"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
/**
 *  Copyright 2024  VideoDB 
 *  @license MIT
**/
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const vue = require("vue");
function useChatInterface() {
  const messageHandlers = {};
  const chatInput = vue.ref("");
  const registerMessageHandler = (contentType, handler) => {
    messageHandlers[contentType] = handler;
  };
  const setChatInput = (input) => {
    chatInput.value = input;
  };
  return {
    chatInput,
    setChatInput,
    messageHandlers,
    registerMessageHandler
  };
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup$1[chars.charCodeAt(i)] = i;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i)];
    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$2 = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event2, fn2) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event2] = this._callbacks["$" + event2] || []).push(fn2);
  return this;
};
Emitter.prototype.once = function(event2, fn2) {
  function on2() {
    this.off(event2, on2);
    fn2.apply(this, arguments);
  }
  on2.fn = fn2;
  this.on(event2, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event2, fn2) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event2];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event2];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn2 || cb.fn === fn2) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event2];
  }
  return this;
};
Emitter.prototype.emit = function(event2) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event2];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event2) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event2] || [];
};
Emitter.prototype.hasListeners = function(event2) {
  return !!this.listeners(event2).length;
};
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length2 = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length2 += 1;
    } else if (c < 2048) {
      length2 += 2;
    } else if (c < 55296 || c >= 57344) {
      length2 += 3;
    } else {
      i++;
      length2 += 4;
    }
  }
  return length2;
}
function encode$1(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode$1(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i$2 = 0, prev;
function encode(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now2 = encode(+/* @__PURE__ */ new Date());
  if (now2 !== prev)
    return seed = 0, prev = now2;
  return now2 + "." + encode(seed++);
}
for (; i$2 < length; i$2++)
  map[alphabet[i$2]] = i$2;
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function XHR$1(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function createCookieJar() {
}
function empty() {
}
const hasXHR2 = function() {
  const xhr = new XHR$1({
    xdomain: false
  });
  return null != xhr.responseType;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close2 = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close2();
    } else {
      this.once("open", close2);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn2) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn2);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr = this.xhr = new XHR$1(opts);
    try {
      xhr.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(xhr);
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
const nextTick$1 = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick$1(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this.writer = encoderStream.writable.getWriter();
        const read2 = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read2();
          }).catch((err) => {
          });
        };
        read2();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick$1(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$2(str) {
  if (str.length > 2e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
let Socket$1 = class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse$2(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse$2(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$2;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i = 0;
      const l = this.upgrades.length;
      for (; i < l; i++) {
        this.probe(this.upgrades[i]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  send(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type, data, options, fn2) {
    if ("function" === typeof data) {
      fn2 = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn2 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn2)
      this.once("flush", fn2);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close2 = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close2();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close2();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close2();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i = 0;
    const j = upgrades.length;
    for (; i < j; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
};
Socket$1.protocol = protocol$2;
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$2(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString$2 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$2.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$2.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol$1 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject$6(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start2 = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start2, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start2 = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if ("," === c)
          break;
        if (i === str.length)
          break;
      }
      p.nsp = str.substring(start2, i);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start2 = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p.id = Number(str.substring(start2, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject$6(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject$6(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol: protocol$1
}, Symbol.toStringTag, { value: "Module" }));
function on$1(obj, ev, fn2) {
  obj.on(ev, fn2);
  return function subDestroy() {
    obj.off(ev, fn2);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on$1(io, "open", this.onopen.bind(this)),
      on$1(io, "packet", this.onpacket.bind(this)),
      on$1(io, "error", this.onerror.bind(this)),
      on$1(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn2 = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn2.withError = true;
    this.acks[id] = fn2;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn2 = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn2.withError = true;
      args.push(fn2);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn2) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on$1(socket, "open", function() {
      self2.onopen();
      fn2 && fn2();
    });
    const onError2 = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn2) {
        fn2(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on$1(socket, "error", onError2);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError2(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn2) {
    return this.open(fn2);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on$1(socket, "ping", this.onping.bind(this)), on$1(socket, "data", this.ondata.bind(this)), on$1(socket, "error", this.onerror.bind(this)), on$1(socket, "close", this.onclose.bind(this)), on$1(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick$1(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache[id] && path2 in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex.push((i$1 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset2) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
const fetchData = async (rootUrl, endpoint) => {
  const res = {};
  try {
    const response = await fetch(`${rootUrl}${endpoint}`);
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    const data = await response.json();
    res.status = "success";
    res.data = data;
  } catch (error) {
    res.status = "error";
    res.error = error;
  }
  return res;
};
function useVideoDBAgent(config) {
  const { debug = false, socketUrl, httpUrl } = config;
  if (debug)
    console.log("debug :videodb-chat config", config);
  const socket = lookup(socketUrl);
  const session = vue.reactive({
    isConnected: false,
    sessionId: null,
    videoId: null,
    collectionId: "default"
  });
  const configStatus = vue.ref(null);
  const collections = vue.ref([]);
  const sessions = vue.ref([]);
  const sessionsSorted = vue.computed(() => {
    return [...sessions.value].sort((a, b) => b.created_at - a.created_at);
  });
  const agents = vue.ref([]);
  const conversations = vue.reactive({});
  const activeCollectionData = vue.ref(null);
  const activeCollectionVideos = vue.ref(null);
  const activeVideoData = vue.ref(null);
  const fetchSession = async (sessionId) => fetchData(httpUrl, `/session/${sessionId}`);
  const fetchSessions = async () => fetchData(httpUrl, "/session");
  const fetchCollections = async () => fetchData(httpUrl, "/videodb/collection");
  const fetchCollection = async (collectionId) => fetchData(httpUrl, `/videodb/collection/${collectionId}`);
  const fetchCollectionVideo = async (collectionId, videoId) => fetchData(httpUrl, `/videodb/collection/${collectionId}/video/${videoId}`);
  const fetchCollectionVideos = async (collectionId) => fetchData(httpUrl, `/videodb/collection/${collectionId}/video`);
  const fetchAllAgents = async () => fetchData(httpUrl, "/agent");
  const fetchConfigStatus = async () => fetchData(httpUrl, "/config/check");
  const uploadMedia = async (uploadData) => {
    const { source, sourceType, collectionId } = uploadData;
    if (sourceType === "file") {
      const formData = new FormData();
      formData.append("file", source);
      return fetch(`${httpUrl}/videodb/collection/${collectionId}/upload`, {
        method: "POST",
        body: formData
      });
    } else if (sourceType === "url") {
      return fetch(`${httpUrl}/videodb/collection/${collectionId}/upload`, {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ source: source.url, source_type: sourceType })
      });
    }
  };
  const refetchCollectionVideos = async () => {
    fetchCollectionVideos(session.collectionId).then((res) => {
      activeCollectionVideos.value = res.data;
    });
  };
  vue.onBeforeMount(() => {
    fetchConfigStatus().then((res) => {
      if (debug)
        console.log("debug :videodb-chat config status", res);
      configStatus.value = res.data;
    });
  });
  vue.watch(configStatus, (val) => {
    if (typeof val === "object" && val !== null && Object.values(val).every((value2) => value2 === true)) {
      Promise.all([
        fetchCollections().then((res) => {
          const defaultCollection = res.data[0];
          defaultCollection.name = "VideoDB Default Collection";
          activeCollectionData.value = defaultCollection;
          collections.value = [defaultCollection, ...res.data.slice(1)];
        }),
        fetchCollectionVideos(session.collectionId).then((res) => {
          activeCollectionVideos.value = res.data;
        })
      ]);
      fetchSessions().then((res) => {
        sessions.value = res.data;
      });
      fetchAllAgents().then((res) => {
        agents.value = res.data;
      });
    }
  });
  vue.watch(
    () => session.isConnected,
    (val) => {
      if (debug)
        console.log("debug :videodb-chat session.isConnected :", val);
    }
  );
  vue.watch(
    () => conversations,
    (val) => {
      if (debug)
        console.log("debug :videodb-chat conversations updated:", JSON.parse(JSON.stringify(val)));
    },
    { deep: true }
  );
  vue.watch(
    () => session.collectionId,
    (val) => {
      activeCollectionData.value = null;
      activeCollectionVideos.value = null;
      if (val) {
        const collection = collections.value.find((c) => c.id === val);
        if (collection) {
          activeCollectionData.value = collection;
        } else {
          fetchCollection(val).then((res) => {
            activeCollectionData.value = res.data;
          });
        }
        fetchCollectionVideos(val).then((res) => {
          activeCollectionVideos.value = res.data;
        });
      }
    }
  );
  vue.watch(
    () => session.videoId,
    (val) => {
      activeVideoData.value = null;
      if (val) {
        fetchCollectionVideo(session.collectionId, val).then((res) => {
          activeVideoData.value = res.data;
        });
      }
    }
  );
  const loadSession = (sessionId) => {
    let fetchPastMessages = true;
    if (!sessionId) {
      sessionId = v4();
      fetchPastMessages = false;
    }
    if (debug)
      console.log("debug :videodb-chat session loading", sessionId);
    session.sessionId = sessionId;
    if (!fetchPastMessages) {
      Object.keys(conversations).forEach((key) => delete conversations[key]);
    } else {
      fetchSession(sessionId).then((res) => {
        if (debug)
          console.log("debug :videodb-chat session loaded", res);
        if (res.status === "success") {
          session.videoId = res.data.video_id || null;
          session.collectionId = res.data.collection_id || session.collectionId || null;
          Object.keys(conversations).forEach(
            (key) => delete conversations[key]
          );
          if (res.data.conversation) {
            res.data.conversation.forEach((message) => {
              const { conv_id, msg_id } = message;
              if (!conversations[conv_id]) {
                conversations[conv_id] = {};
              }
              conversations[String(conv_id)][String(msg_id)] = {
                sender: message.msg_type === "input" ? "user" : "assistant",
                ...message
              };
            });
          }
        }
      });
    }
  };
  const deleteSession = (sessionId) => {
    fetch(`${httpUrl}/session/${sessionId}`, {
      method: "DELETE"
    }).then((response) => response.json()).then((res) => {
      if (debug)
        console.log("debug :videodb-chat session deleted", res);
      sessions.value = sessions.value.filter(
        (s) => s.session_id !== sessionId
      );
    }).catch((error) => {
      if (debug)
        console.error("debug :videodb-chat error deleting session", error);
    });
  };
  const addClientLoadingMessage = (convId) => {
    const messages = Object.values(conversations[convId]);
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage || !lastMessage.clientLoading) {
      const loadingMsgId = Date.now() + 2;
      conversations[convId][loadingMsgId] = {
        conv_id: String(convId),
        msg_id: String(loadingMsgId),
        session_id: String(session.sessionId),
        msg_type: "output",
        sender: "assistant",
        clientLoading: true
      };
    }
  };
  const removeClientLoadingMessage = (convId) => {
    const clientLoadingMessage = Object.values(conversations[convId]).find(
      (msg) => msg.clientLoading
    );
    if (clientLoadingMessage) {
      delete conversations[convId][clientLoadingMessage.msg_id];
    }
  };
  const addMessage = (message) => {
    if (debug)
      console.log("debug :videodb-chat addMessage", message);
    if (session.isConnected) {
      if (!sessions.value.some((s) => s.session_id === session.sessionId)) {
        sessions.value.push({
          session_id: session.sessionId,
          created_at: Date.now() / 1e3
        });
      }
      const convId = Date.now();
      const msgId = convId + 1;
      const _message = {
        agents: [],
        msg_type: "input",
        sender: "user",
        conv_id: String(convId),
        msg_id: String(msgId),
        session_id: String(session.sessionId),
        collection_id: session.collectionId ? String(session.collectionId) : null,
        video_id: session.videoId ? String(session.videoId) : null,
        ...message
      };
      conversations[convId] = { [msgId]: _message };
      socket.emit("chat", _message);
      addClientLoadingMessage(convId);
    }
  };
  socket.on("connect", () => {
    if (debug)
      console.log("debug :videodb-chat socket emmited connect");
    session.isConnected = true;
  });
  socket.on("chat", (event2) => {
    if (debug)
      console.log("debug :videodb-chat socket emmited chat", event2);
    if (session.sessionId !== event2.session_id)
      return;
    if (session.isConnected) {
      const { conv_id: convId, msg_id: msgId } = event2;
      if (!conversations[convId]) {
        conversations[convId] = {};
      }
      conversations[convId][msgId] = { sender: "assistant", ...event2 };
      removeClientLoadingMessage(convId);
    }
  });
  return {
    ...vue.toRefs(session),
    configStatus,
    collections,
    sessions: sessionsSorted,
    agents,
    activeCollectionData,
    activeCollectionVideos,
    activeVideoData,
    conversations,
    addMessage,
    loadSession,
    deleteSession,
    uploadMedia,
    refetchCollectionVideos
  };
}
const useVideoDBChat = () => vue.inject("videodb-chat");
const _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$P = {
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    class: vue.normalizeClass($props.className),
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none"
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      d: "M19.0028 6C18.7376 6 18.4833 6.10536 18.2957 6.29289C18.1082 6.48043 18.0028 6.73478 18.0028 7V11C18.0028 11.2652 17.8975 11.5196 17.7099 11.7071C17.5224 11.8946 17.268 12 17.0028 12H7.41283L8.71283 10.71C8.90113 10.5217 9.00692 10.2663 9.00692 10C9.00692 9.7337 8.90113 9.4783 8.71283 9.29C8.52452 9.1017 8.26913 8.99591 8.00283 8.99591C7.73652 8.99591 7.48113 9.1017 7.29283 9.29L4.29283 12.29C4.20179 12.3851 4.13042 12.4972 4.08283 12.62C3.98281 12.8635 3.98281 13.1365 4.08283 13.38C4.13042 13.5028 4.20179 13.6149 4.29283 13.71L7.29283 16.71C7.38579 16.8037 7.49639 16.8781 7.61825 16.9289C7.74011 16.9797 7.87081 17.0058 8.00283 17.0058C8.13484 17.0058 8.26554 16.9797 8.3874 16.9289C8.50926 16.8781 8.61986 16.8037 8.71283 16.71C8.80655 16.617 8.88095 16.5064 8.93172 16.3846C8.98249 16.2627 9.00862 16.132 9.00862 16C9.00862 15.868 8.98249 15.7373 8.93172 15.6154C8.88095 15.4936 8.80655 15.383 8.71283 15.29L7.41283 14H17.0028C17.7985 14 18.5615 13.6839 19.1241 13.1213C19.6868 12.5587 20.0028 11.7956 20.0028 11V7C20.0028 6.73478 19.8975 6.48043 19.7099 6.29289C19.5224 6.10536 19.268 6 19.0028 6Z",
      fill: "white"
    }, null, -1)
  ]), 2);
}
const ChatEnterIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$r]]);
const Send_vue_vue_type_style_index_0_scoped_fbc8bc1e_lang = "";
const _sfc_main$O = {
  props: {
    className: {
      type: String,
      default: () => {
      }
    }
  }
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    class: vue.normalizeClass($props.className),
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none"
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      d: "M3.66667 16.1875C3.38889 16.2986 3.125 16.2743 2.875 16.1146C2.625 15.9549 2.5 15.7222 2.5 15.4167V11.6667L9.16667 10L2.5 8.33335V4.58335C2.5 4.27779 2.625 4.04516 2.875 3.88543C3.125 3.72571 3.38889 3.70141 3.66667 3.81252L16.5 9.22918C16.8472 9.38196 17.0208 9.63891 17.0208 10C17.0208 10.3611 16.8472 10.6181 16.5 10.7708L3.66667 16.1875Z",
      fill: "#D1D5DB"
    }, null, -1)
  ]), 2);
}
const SendIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["render", _sfc_render$q], ["__scopeId", "data-v-fbc8bc1e"]]);
const EllipsesLoading_vue_vue_type_style_index_0_scoped_8ed08ce7_lang = "";
const _sfc_main$N = {
  props: {
    baseClass: {
      type: String,
      default: ""
    }
  }
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["vdb-c-flex vdb-c-gap-4 vdb-c-items-center vdb-c-px-4", $props.baseClass])
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("div", { class: "vdb-c-w-6 vdb-c-h-6 vdb-c-bg-white vdb-c-rounded-full dot" }, null, -1),
    vue.createElementVNode("div", { class: "vdb-c-w-6 vdb-c-h-6 vdb-c-bg-white vdb-c-rounded-full dot" }, null, -1),
    vue.createElementVNode("div", { class: "vdb-c-w-6 vdb-c-h-6 vdb-c-bg-white vdb-c-rounded-full dot" }, null, -1)
  ]), 2);
}
const EllipsesLoading = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["render", _sfc_render$p], ["__scopeId", "data-v-8ed08ce7"]]);
const ChatInput_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$F = {
  key: 0,
  class: "vdb-c-absolute vdb-c-z-50 vdb-c-w-full vdb-c--translate-y-full vdb-c-transform vdb-c-px-18"
};
const _hoisted_2$o = { class: "vdb-c-max-h-[160px] vdb-c-overflow-y-auto vdb-c-rounded-lg vdb-c-border-2 vdb-c-border-roy vdb-c-bg-white vdb-c-px-8 vdb-c-py-4 vdb-c-shadow-lg" };
const _hoisted_3$k = ["onClick"];
const _hoisted_4$h = { class: "vdb-c-absolute vdb-c-left-0 vdb-c-top-0 vdb-c-h-full vdb-c-w-full vdb-c-px-10 vdb-c-py-8 md:vdb-c-p-18" };
const _hoisted_5$c = { class: "vdb-c-br-50 vdb-c-relative vdb-c-h-full vdb-c-w-full" };
const _hoisted_6$9 = { class: "vdb-c-max-w-[160px] vdb-c-truncate vdb-c-text-sm vdb-c-font-bold" };
const _hoisted_7$7 = { class: "vdb-c-relative vdb-c-h-full vdb-c-flex-grow" };
const _hoisted_8$6 = ["placeholder", "value"];
const _hoisted_9$5 = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-end" };
const _hoisted_10$4 = ["disabled"];
const _hoisted_11$3 = {
  key: 1,
  class: "vdb-c-flex vdb-c-items-center vdb-c-pl-4"
};
const _sfc_main$M = {
  __name: "ChatInput",
  props: {
    placeholder: {
      type: String,
      default: "Ask a question"
    },
    agents: {
      type: Array,
      default: () => []
    },
    contextData: {
      type: Object,
      default: null
    }
  },
  emits: ["on-submit", "on-change", "tag-agent"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const { chatInput, chatLoading } = useVideoDBChat();
    const emit = __emit;
    const charCount = vue.ref(0);
    const inputFocused = vue.ref(false);
    const inputRef = vue.ref(null);
    const showAgentList = vue.ref(false);
    const agentStartIndex = vue.ref(-1);
    const agentQuery = vue.ref("");
    const selectedAgentIndex = vue.ref(0);
    const focus = () => {
      inputRef.value.focus();
    };
    const filteredAgents = vue.computed(() => {
      if (!agentQuery.value)
        return props.agents;
      return props.agents.filter(
        (agent) => agent.name.toLowerCase().includes(agentQuery.value.toLowerCase())
      );
    });
    vue.watch(filteredAgents, () => {
      selectedAgentIndex.value = 0;
    });
    const isInputDisabled = vue.computed(() => {
      return chatLoading.value || charCount.value < 1;
    });
    const handleInput = (e) => {
      const newValue = e.target.value;
      chatInput.value = newValue;
      const lastAtIndex = newValue.lastIndexOf("@");
      const lastSpaceIndex = newValue.lastIndexOf(" ");
      if (lastAtIndex !== -1 && lastAtIndex > lastSpaceIndex) {
        agentStartIndex.value = lastAtIndex;
        agentQuery.value = newValue.slice(lastAtIndex + 1);
        showAgentList.value = true;
      } else {
        showAgentList.value = false;
      }
    };
    const resetTag = () => {
      showAgentList.value = false;
      agentStartIndex.value = -1;
      agentQuery.value = "";
      selectedAgentIndex.value = 0;
    };
    const handleBlur = () => {
      inputFocused.value = false;
      setTimeout(() => {
        showAgentList.value = false;
      }, 200);
    };
    const handleKeyDown = (e) => {
      if (showAgentList.value) {
        if (e.key === "ArrowUp") {
          e.preventDefault();
          selectedAgentIndex.value = Math.max(0, selectedAgentIndex.value - 1);
        } else if (e.key === "ArrowDown") {
          e.preventDefault();
          selectedAgentIndex.value = Math.min(
            filteredAgents.value.length - 1,
            selectedAgentIndex.value + 1
          );
        } else if (e.key === "Enter") {
          e.preventDefault();
          selectAgent(filteredAgents.value[selectedAgentIndex.value]);
        } else if (e.key === "Escape") {
          resetTag();
        }
      } else if (e.key === "@") {
        agentStartIndex.value = e.target.selectionStart;
        showAgentList.value = true;
      } else if (e.key === "Enter" && !e.shiftKey) {
        if (chatInput.value.trim() !== "") {
          handleSubmit(e);
        } else {
          e.preventDefault();
        }
      } else if (e.shiftKey && e.key === "Enter") {
        return;
      }
    };
    const selectAgent = (agent) => {
      const beforeAgent = chatInput.value.slice(0, agentStartIndex.value);
      const afterAgent = chatInput.value.slice(
        agentStartIndex.value + agentQuery.value.length + 1
      );
      chatInput.value = `${beforeAgent}@${agent.name} ${afterAgent}`;
      inputRef.value.focus();
      resetTag();
      emit("tag-agent", agent);
    };
    vue.watch(
      chatInput,
      (newValue) => {
        charCount.value = newValue.length;
      },
      { immediate: true }
    );
    const handleSubmit = (e) => {
      e.preventDefault();
      if (!showAgentList.value && chatInput.value.trim() !== "") {
        emit("on-submit", chatInput.value);
        chatInput.value = "";
        charCount.value = 0;
        resetTag();
      }
    };
    __expose({
      focus
    });
    return (_ctx, _cache) => {
      var _a, _b;
      return vue.openBlock(), vue.createElementBlock("div", null, [
        showAgentList.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$F, [
          vue.createElementVNode("div", _hoisted_2$o, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(filteredAgents.value, (agent, index) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: index,
                class: vue.normalizeClass([
                  "vdb-c-my-2 vdb-c-cursor-pointer vdb-c-truncate vdb-c-rounded-lg vdb-c-p-8 vdb-c-pr-32 vdb-c-text-sm vdb-c-font-normal vdb-c-text-black vdb-c-transition-all vdb-c-duration-300 hover:vdb-c-bg-roy",
                  { "vdb-c-bg-roy": index === selectedAgentIndex.value }
                ]),
                onClick: ($event) => selectAgent(agent)
              }, [
                _cache[1] || (_cache[1] = vue.createElementVNode("span", { class: "vdb-c-text-orange" }, " @ ", -1)),
                vue.createElementVNode("span", null, vue.toDisplayString(agent.name), 1)
              ], 10, _hoisted_3$k);
            }), 128))
          ])
        ])) : vue.createCommentVNode("", true),
        vue.createElementVNode("div", _hoisted_4$h, [
          vue.createElementVNode("div", _hoisted_5$c, [
            vue.createElementVNode("form", {
              class: vue.normalizeClass(["vdb-c-br-50 vdb-c-flex vdb-c-h-full vdb-c-w-full vdb-c-items-center vdb-c-justify-between vdb-c-overflow-hidden vdb-c-border vdb-c-border-solid vdb-c-bg-white", {
                "vdb-c-border-kilvish-600": inputFocused.value,
                "vdb-c-border-kilvish-400": !inputFocused.value
              }]),
              autocomplete: "off",
              onSubmit: handleSubmit
            }, [
              vue.createElementVNode("div", null, [
                vue.createElementVNode("div", {
                  class: vue.normalizeClass([
                    "vdb-c-ml-6 vdb-c-hidden vdb-c-items-center vdb-c-gap-24 vdb-c-rounded-[42px] vdb-c-border vdb-c-border-orange-200 vdb-c-bg-orange-50 vdb-c-px-12 vdb-c-py-12 vdb-c-pr-16 vdb-c-text-black md:vdb-c-flex",
                    { "vdb-c-animate-pulse": !((_a = __props.contextData) == null ? void 0 : _a.name) }
                  ])
                }, [
                  _cache[2] || (_cache[2] = vue.createElementVNode("span", { class: "context-icon vdb-c-ml-12 vdb-c-h-8 vdb-c-w-8 vdb-c-rounded-full vdb-c-border vdb-c-border-white" }, null, -1)),
                  vue.createElementVNode("span", _hoisted_6$9, vue.toDisplayString(((_b = __props.contextData) == null ? void 0 : _b.name) || "Loading..."), 1)
                ], 2)
              ]),
              vue.createElementVNode("div", _hoisted_7$7, [
                vue.createElementVNode("textarea", {
                  ref_key: "inputRef",
                  ref: inputRef,
                  type: "text",
                  class: "vdb-c-chat-input vdb-c-h-full vdb-c-w-full vdb-c-bg-white vdb-c-pl-16 vdb-c-pr-8 vdb-c-font-medium vdb-c-text-[#1D2736] vdb-c-placeholder-kilvish-500 focus:vdb-c-outline-none",
                  name: "prompt",
                  placeholder: __props.placeholder,
                  autocomplete: "off",
                  value: vue.unref(chatInput),
                  onInput: handleInput,
                  onFocus: _cache[0] || (_cache[0] = ($event) => inputFocused.value = true),
                  onBlur: handleBlur,
                  onKeydown: handleKeyDown,
                  style: { "resize": "none", "min-height": "40px", "max-height": "25vh", "box-sizing": "border-box", "padding-top": "13px" }
                }, null, 40, _hoisted_8$6)
              ]),
              vue.createElementVNode("div", _hoisted_9$5, [
                vue.createElementVNode("button", {
                  disabled: isInputDisabled.value,
                  class: vue.normalizeClass(["vdb-c-font-sans vdb-c-mx-8 vdb-c-hidden vdb-c-h-40 vdb-c-cursor-pointer vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full vdb-c-bg-orange vdb-c-px-12 vdb-c-py-8 vdb-c-text-sm vdb-c-font-bold vdb-c-uppercase vdb-c-text-white vdb-c-transition hover:vdb-c-bg-orange-400 md:vdb-c-flex", {
                    "vdb-c-cursor-not-allowed vdb-c-bg-kilvish-400 hover:vdb-c-bg-kilvish-400": charCount.value < 1
                  }]),
                  type: "submit"
                }, [
                  vue.unref(chatLoading) ? (vue.openBlock(), vue.createBlock(EllipsesLoading, { key: 0 })) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_11$3, [
                    _cache[3] || (_cache[3] = vue.createElementVNode("span", { class: "vdb-c-inline" }, "Send", -1)),
                    vue.createVNode(ChatEnterIcon, { "class-name": "vdb-c-ml-4" })
                  ]))
                ], 10, _hoisted_10$4),
                vue.createElementVNode("button", {
                  class: vue.normalizeClass(["vdb-c-mobile-send vdb-c-flex vdb-c-border-none vdb-c-bg-transparent vdb-c-p-8 vdb-c-pr-12 md:vdb-c-hidden", {
                    "vdb-c-text-kilvish-400": isInputDisabled.value,
                    "vdb-c-mobile-send vdb-c-text-others-nightwing": !isInputDisabled.value
                  }]),
                  type: "submit"
                }, [
                  vue.createVNode(SendIcon, { "class-name": "vdb-c-w-24 vdb-c-h-24" })
                ], 2)
              ])
            ], 34)
          ])
        ])
      ]);
    };
  }
};
function getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
let defaults$3 = getDefaults();
function changeDefaults(newDefaults) {
  defaults$3 = newDefaults;
}
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, "g");
const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
const escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape$2(html, encode2) {
  if (encode2) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape$1(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
const noopTest = { exec: function noopTest2() {
} };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset2, str) => {
    let escaped = false, curr = offset2;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer) {
  const href = link.href;
  const title = link.title ? escape$2(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer.inlineTokens(text2)
    };
    lexer.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape$2(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
class Tokenizer {
  constructor(options) {
    this.options = options || defaults$3;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top2 = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top2;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      while (src) {
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        nextLine = src.split("\n", 1)[0];
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimLeft();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();
      const l = list.items.length;
      for (i = 0; i < l; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (i = 0; i < l; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        raw: cap[0],
        pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
        text: cap[0]
      };
      if (this.options.sanitize) {
        const text2 = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0]);
        token.type = "paragraph";
        token.text = text2;
        token.tokens = this.lexer.inline(text2);
      }
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: "table",
        header: splitCells(cap[1]).map((c) => {
          return { text: c };
        }),
        align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        item.raw = cap[0];
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = "right";
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = "center";
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = "left";
          } else {
            item.align[i] = null;
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape$2(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: this.options.sanitize ? "text" : "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0]) : cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start2 + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = rDelim.length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape$2(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src, mangle2) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$2(this.options.mangle ? mangle2(cap[1]) : cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape$2(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src, mangle2) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape$2(this.options.mangle ? mangle2(cap[0]) : cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape$2(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src, smartypants2) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0]) : cap[0];
      } else {
        text2 = escape$2(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
}
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};
inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
function smartypants(text2) {
  return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
}
function mangle(text2) {
  let out = "", i, ch;
  const l = text2.length;
  for (i = 0; i < l; i++) {
    ch = text2.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
let Lexer$1 = class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options || defaults$3;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  /**
   * Lexing
   */
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token, lastToken, cutSrc, lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
class Renderer {
  constructor(options) {
    this.options = options || defaults$3;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape$2(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="' + this.options.langPrefix + escape$2(lang) + '">' + (escaped ? code : escape$2(code, true)) + "</code></pre>\n";
  }
  /**
   * @param {string} quote
   */
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html) {
    return html;
  }
  /**
   * @param {string} text
   * @param {string} level
   * @param {string} raw
   * @param {any} slugger
   */
  heading(text2, level, raw, slugger) {
    if (this.options.headerIds) {
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h${level} id="${id}">${text2}</h${level}>
`;
    }
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
  }
  list(body, ordered, start2) {
    const type = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  /**
   * @param {string} text
   */
  listitem(text2) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
  }
  /**
   * @param {string} text
   */
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  /**
   * @param {string} header
   * @param {string} body
   */
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  /**
   * @param {string} content
   */
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   * @param {string} text
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  /**
   * @param {string} text
   */
  em(text2) {
    return `<em>${text2}</em>`;
  }
  /**
   * @param {string} text
   */
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return this.options.xhtml ? "<br/>" : "<br>";
  }
  /**
   * @param {string} text
   */
  del(text2) {
    return `<del>${text2}</del>`;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  link(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  /**
   * @param {string} href
   * @param {string} title
   * @param {string} text
   */
  image(href, title, text2) {
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text2;
    }
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += this.options.xhtml ? "/>" : ">";
    return out;
  }
  text(text2) {
    return text2;
  }
}
class TextRenderer {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
}
class Slugger {
  constructor() {
    this.seen = {};
  }
  /**
   * @param {string} value
   */
  serialize(value2) {
    return value2.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
  }
  /**
   * Finds the next safe (unique) slug to use
   * @param {string} originalSlug
   * @param {boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + "-" + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }
  /**
   * Convert string to unique id
   * @param {object} [options]
   * @param {boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value2, options = {}) {
    const slug = this.serialize(value2);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
}
let Parser$2 = class Parser {
  constructor(options) {
    this.options = options || defaults$3;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser2 = new Parser(options);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser2 = new Parser(options);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top2 = true) {
    let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start2, loose, itemBody, item, checked, task, checkbox, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape$1(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger
          );
          continue;
        }
        case "code": {
          out += this.renderer.code(
            token.text,
            token.lang,
            token.escaped
          );
          continue;
        }
        case "table": {
          header = "";
          cell = "";
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);
          body = "";
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) {
            row = token.rows[j];
            cell = "";
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                { header: false, align: token.align[k] }
              );
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          ordered = token.ordered;
          start2 = token.start;
          loose = token.loose;
          l2 = token.items.length;
          body = "";
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;
            itemBody = "";
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }
          out += this.renderer.list(body, ordered, start2);
          continue;
        }
        case "html": {
          out += this.renderer.html(token.text);
          continue;
        }
        case "paragraph": {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case "text": {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === "text") {
            token = tokens[++i];
            body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top2 ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "", i, token, ret;
    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          out += renderer.text(token.text);
          break;
        }
        case "html": {
          out += renderer.html(token.text);
          break;
        }
        case "link": {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case "image": {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case "strong": {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case "em": {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case "codespan": {
          out += renderer.codespan(token.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case "text": {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
class Hooks {
  constructor(options) {
    this.options = options || defaults$3;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
}
__publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
function onError$1(silent, async, callback) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape$2(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      if (callback) {
        callback(null, msg);
        return;
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    if (callback) {
      callback(e);
      return;
    }
    throw e;
  };
}
function parseMarkdown(lexer, parser2) {
  return (src, opt, callback) => {
    if (typeof opt === "function") {
      callback = opt;
      opt = null;
    }
    const origOpt = { ...opt };
    opt = { ...marked.defaults, ...origOpt };
    const throwError = onError$1(opt.silent, opt.async, callback);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    checkSanitizeDeprecation(opt);
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (callback) {
      const highlight = opt.highlight;
      let tokens;
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        tokens = lexer(src, opt);
      } catch (e) {
        return throwError(e);
      }
      const done = function(err) {
        let out;
        if (!err) {
          try {
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            out = parser2(tokens, opt);
            if (opt.hooks) {
              out = opt.hooks.postprocess(out);
            }
          } catch (e) {
            err = e;
          }
        }
        opt.highlight = highlight;
        return err ? throwError(err) : callback(null, out);
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!tokens.length)
        return done();
      let pending = 0;
      marked.walkTokens(tokens, function(token) {
        if (token.type === "code") {
          pending++;
          setTimeout(() => {
            highlight(token.text, token.lang, function(err, code) {
              if (err) {
                return done(err);
              }
              if (code != null && code !== token.text) {
                token.text = code;
                token.escaped = true;
              }
              pending--;
              if (pending === 0) {
                done();
              }
            });
          }, 0);
        }
      });
      if (pending === 0) {
        done();
      }
      return;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer(src, opt);
      if (opt.walkTokens) {
        marked.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser2(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e) {
      return throwError(e);
    }
  };
}
function marked(src, opt, callback) {
  return parseMarkdown(Lexer$1.lex, Parser$2.parse)(src, opt, callback);
}
marked.options = marked.setOptions = function(opt) {
  marked.defaults = { ...marked.defaults, ...opt };
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = getDefaults;
marked.defaults = defaults$3;
marked.use = function(...args) {
  const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
  args.forEach((pack) => {
    const opts = { ...pack };
    opts.async = marked.defaults.async || opts.async || false;
    if (pack.extensions) {
      pack.extensions.forEach((ext) => {
        if (!ext.name) {
          throw new Error("extension name required");
        }
        if (ext.renderer) {
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) {
            extensions.renderers[ext.name] = function(...args2) {
              let ret = ext.renderer.apply(this, args2);
              if (ret === false) {
                ret = prevRenderer.apply(this, args2);
              }
              return ret;
            };
          } else {
            extensions.renderers[ext.name] = ext.renderer;
          }
        }
        if (ext.tokenizer) {
          if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
            throw new Error("extension level must be 'block' or 'inline'");
          }
          if (extensions[ext.level]) {
            extensions[ext.level].unshift(ext.tokenizer);
          } else {
            extensions[ext.level] = [ext.tokenizer];
          }
          if (ext.start) {
            if (ext.level === "block") {
              if (extensions.startBlock) {
                extensions.startBlock.push(ext.start);
              } else {
                extensions.startBlock = [ext.start];
              }
            } else if (ext.level === "inline") {
              if (extensions.startInline) {
                extensions.startInline.push(ext.start);
              } else {
                extensions.startInline = [ext.start];
              }
            }
          }
        }
        if (ext.childTokens) {
          extensions.childTokens[ext.name] = ext.childTokens;
        }
      });
      opts.extensions = extensions;
    }
    if (pack.renderer) {
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) {
        const prevRenderer = renderer[prop];
        renderer[prop] = (...args2) => {
          let ret = pack.renderer[prop].apply(renderer, args2);
          if (ret === false) {
            ret = prevRenderer.apply(renderer, args2);
          }
          return ret;
        };
      }
      opts.renderer = renderer;
    }
    if (pack.tokenizer) {
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) {
        const prevTokenizer = tokenizer[prop];
        tokenizer[prop] = (...args2) => {
          let ret = pack.tokenizer[prop].apply(tokenizer, args2);
          if (ret === false) {
            ret = prevTokenizer.apply(tokenizer, args2);
          }
          return ret;
        };
      }
      opts.tokenizer = tokenizer;
    }
    if (pack.hooks) {
      const hooks2 = marked.defaults.hooks || new Hooks();
      for (const prop in pack.hooks) {
        const prevHook = hooks2[prop];
        if (Hooks.passThroughHooks.has(prop)) {
          hooks2[prop] = (arg) => {
            if (marked.defaults.async) {
              return Promise.resolve(pack.hooks[prop].call(hooks2, arg)).then((ret2) => {
                return prevHook.call(hooks2, ret2);
              });
            }
            const ret = pack.hooks[prop].call(hooks2, arg);
            return prevHook.call(hooks2, ret);
          };
        } else {
          hooks2[prop] = (...args2) => {
            let ret = pack.hooks[prop].apply(hooks2, args2);
            if (ret === false) {
              ret = prevHook.apply(hooks2, args2);
            }
            return ret;
          };
        }
      }
      opts.hooks = hooks2;
    }
    if (pack.walkTokens) {
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) {
        let values2 = [];
        values2.push(pack.walkTokens.call(this, token));
        if (walkTokens) {
          values2 = values2.concat(walkTokens.call(this, token));
        }
        return values2;
      };
    }
    marked.setOptions(opts);
  });
};
marked.walkTokens = function(tokens, callback) {
  let values2 = [];
  for (const token of tokens) {
    values2 = values2.concat(callback.call(marked, token));
    switch (token.type) {
      case "table": {
        for (const cell of token.header) {
          values2 = values2.concat(marked.walkTokens(cell.tokens, callback));
        }
        for (const row of token.rows) {
          for (const cell of row) {
            values2 = values2.concat(marked.walkTokens(cell.tokens, callback));
          }
        }
        break;
      }
      case "list": {
        values2 = values2.concat(marked.walkTokens(token.items, callback));
        break;
      }
      default: {
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
            values2 = values2.concat(marked.walkTokens(token[childTokens], callback));
          });
        } else if (token.tokens) {
          values2 = values2.concat(marked.walkTokens(token.tokens, callback));
        }
      }
    }
  }
  return values2;
};
marked.parseInline = parseMarkdown(Lexer$1.lexInline, Parser$2.parseInline);
marked.Parser = Parser$2;
marked.parser = Parser$2.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer$1;
marked.lexer = Lexer$1.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.Hooks = Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
Parser$2.parse;
Lexer$1.lex;
class SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start2, end2) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start2;
    this.end = end2;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}
class Token {
  // don't expand the token
  // used in \noexpand
  constructor(text2, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text2;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text2) {
    return new Token(text2, SourceLocation.range(this, endToken));
  }
}
let ParseError$2 = class ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error = "KaTeX parse error: " + message;
    var start2;
    var end2;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start2 = loc.start;
      end2 = loc.end;
      if (start2 === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start2 + 1) + ": ";
      }
      var underlined = input.slice(start2, end2).replace(/[^]/g, "$&̲");
      var left2;
      if (start2 > 15) {
        left2 = "…" + input.slice(start2 - 15, start2);
      } else {
        left2 = input.slice(0, start2);
      }
      var right2;
      if (end2 + 15 < input.length) {
        right2 = input.slice(end2, end2 + 15) + "…";
      } else {
        right2 = input.slice(end2);
      }
      error += left2 + underlined + right2;
    }
    var self2 = new Error(error);
    self2.name = "ParseError";
    self2.__proto__ = ParseError.prototype;
    self2.position = start2;
    if (start2 != null && end2 != null) {
      self2.length = end2 - start2;
    }
    self2.rawMessage = message;
    return self2;
  }
};
ParseError$2.prototype.__proto__ = Error.prototype;
var contains$1 = function contains(list, elem) {
  return list.indexOf(elem) !== -1;
};
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape$1(text2) {
  return String(text2).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert = function assert2(value2) {
  if (!value2) {
    throw new Error("Expected non-null, but got " + String(value2));
  }
  return value2;
};
var protocolFromUrl = function protocolFromUrl2(url2) {
  var protocol2 = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url2);
  if (!protocol2) {
    return "_relative";
  }
  if (protocol2[2] !== ":") {
    return null;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol2[1])) {
    return null;
  }
  return protocol2[1].toLowerCase();
};
var utils$1 = {
  contains: contains$1,
  deflt,
  escape: escape$1,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color) => "#" + color
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t) => Math.max(0, t),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s) => Math.max(0, s),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? Infinity : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
let Settings$1 = class Settings {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options = options || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError$2("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      var protocol2 = utils$1.protocolFromUrl(context.url);
      if (protocol2 == null) {
        return false;
      }
      context.protocol = protocol2;
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
};
class Style {
  constructor(id, size, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D, Dc, T, Tc, T, Tc, T, Tc];
var Style$1 = {
  DISPLAY: styles[D],
  TEXT: styles[T],
  SCRIPT: styles[S],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i = 0; i < scriptData.length; i++) {
    var script2 = scriptData[i];
    for (var _i = 0; _i < script2.blocks.length; _i++) {
      var block2 = script2.blocks[_i];
      if (codepoint >= block2[0] && codepoint <= block2[1]) {
        return script2.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s) => s.blocks.forEach((b) => allBlocks.push(...b)));
function supportedCodepoint(codepoint) {
  for (var i = 0; i < allBlocks.length; i += 2) {
    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y) {
  var x = y / 2;
  return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path2 = "";
  switch (size) {
    case "sqrtMain":
      path2 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path2 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path2 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path2 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path2 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path2 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path2;
};
var innerPath = function innerPath2(name, height) {
  switch (name) {
    case "⎜":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "∣":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "∥":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "⎟":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "⎢":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "⎥":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "⎪":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "⏐":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "‖":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
let DocumentFragment$1 = class DocumentFragment {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return utils$1.contains(this.classes, className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
};
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "Å": "A",
  "Ð": "D",
  "Þ": "o",
  "å": "a",
  "ð": "d",
  "þ": "o",
  // Cyrillic
  "А": "A",
  "Б": "B",
  "В": "B",
  "Г": "F",
  "Д": "A",
  "Е": "E",
  "Ж": "K",
  "З": "3",
  "И": "N",
  "Й": "N",
  "К": "K",
  "Л": "N",
  "М": "M",
  "Н": "H",
  "О": "O",
  "П": "N",
  "Р": "P",
  "С": "C",
  "Т": "T",
  "У": "y",
  "Ф": "O",
  "Х": "X",
  "Ц": "U",
  "Ч": "h",
  "Ш": "W",
  "Щ": "W",
  "Ъ": "B",
  "Ы": "X",
  "Ь": "B",
  "Э": "3",
  "Ю": "X",
  "Я": "R",
  "а": "a",
  "б": "b",
  "в": "a",
  "г": "r",
  "д": "y",
  "е": "e",
  "ж": "m",
  "з": "e",
  "и": "n",
  "й": "n",
  "к": "n",
  "л": "n",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "n",
  "р": "p",
  "с": "c",
  "т": "o",
  "у": "y",
  "ф": "b",
  "х": "x",
  "ц": "n",
  "ч": "n",
  "ш": "w",
  "щ": "w",
  "ъ": "a",
  "ы": "m",
  "ь": "a",
  "э": "e",
  "ю": "m",
  "я": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size) {
  var sizeIndex;
  if (size >= 5) {
    sizeIndex = 0;
  } else if (size >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size, style2) {
  return style2.size < 2 ? size : sizeStyleMap[size - 1][style2.size - 1];
};
class Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension) {
      if (extension.hasOwnProperty(key)) {
        data[key] = extension[key];
      }
    }
    return new Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style2) {
    if (this.style === style2) {
      return this;
    } else {
      return this.extend({
        style: style2,
        size: sizeAtStyle(this.textSize, style2)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size) {
    if (this.size === size && this.textSize === size) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size,
        textSize: size,
        sizeMultiplier: sizeMultipliers[size - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style2) {
    style2 = style2 || this.style.text();
    var wantSize = sizeAtStyle(Options.BASESIZE, style2);
    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style2) {
      return this;
    } else {
      return this.extend({
        style: style2,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size;
    switch (this.style.id) {
      case 4:
      case 5:
        size = 3;
        break;
      case 6:
      case 7:
        size = 1;
        break;
      default:
        size = 6;
    }
    return this.extend({
      style: this.style.text(),
      size
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color) {
    return this.extend({
      color
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
}
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options.style.isTight()) {
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError$2("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options.maxSize);
};
var makeEm = function makeEm2(n) {
  return +n.toFixed(4) + "em";
};
var createClass = function createClass2(classes2) {
  return classes2.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes2, options, style2) {
  this.classes = classes2 || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style2 || {};
  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }
    var color = options.getColor();
    if (color) {
      this.style.color = color;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node = document.createElement(tagName);
  node.className = createClass(this.classes);
  for (var style2 in this.style) {
    if (this.style.hasOwnProperty(style2)) {
      node.style[style2] = this.style[style2];
    }
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }
  for (var i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }
  return node;
};
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils$1.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style2 in this.style) {
    if (this.style.hasOwnProperty(style2)) {
      styles2 += utils$1.hyphenate(style2) + ":" + this.style[style2] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils$1.escape(styles2) + '"';
  }
  for (var attr in this.attributes) {
    if (this.attributes.hasOwnProperty(attr)) {
      markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
    }
  }
  markup += ">";
  for (var i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
class Span {
  constructor(classes2, children, options, style2) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes2, options, style2);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute, value2) {
    this.attributes[attribute] = value2;
  }
  hasClass(className) {
    return utils$1.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
}
class Anchor {
  constructor(href, classes2, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes2, options);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value2) {
    this.attributes[attribute] = value2;
  }
  hasClass(className) {
    return utils$1.contains(this.classes, className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
}
class Img {
  constructor(src, alt, style2) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style2;
  }
  hasClass(className) {
    return utils$1.contains(this.classes, className);
  }
  toNode() {
    var node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        node.style[style2] = this.style[style2];
      }
    }
    return node;
  }
  toMarkup() {
    var markup = '<img src="' + utils$1.escape(this.src) + '"' + (' alt="' + utils$1.escape(this.alt) + '"');
    var styles2 = "";
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        styles2 += utils$1.hyphenate(style2) + ":" + this.style[style2] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils$1.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
}
var iCombinations = {
  "î": "ı̂",
  "ï": "ı̈",
  "í": "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  "ì": "ı̀"
};
class SymbolNode {
  constructor(text2, height, depth, italic, skew, width, classes2, style2) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text2;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes2 || [];
    this.style = style2 || {};
    this.maxFontSize = 0;
    var script2 = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script2) {
      this.classes.push(script2 + "_fallback");
    }
    if (/[îïíì]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return utils$1.contains(this.classes, className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        span = span || document.createElement("span");
        span.style[style2] = this.style[style2];
      }
    }
    if (span) {
      span.appendChild(node);
      return span;
    } else {
      return node;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils$1.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        styles2 += utils$1.hyphenate(style2) + ":" + this.style[style2] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils$1.escape(styles2) + '"';
    }
    var escaped = utils$1.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
}
class SvgNode {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "svg");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
      }
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
}
class PathNode {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node.setAttribute("d", this.alternate);
    } else {
      node.setAttribute("d", path[this.pathName]);
    }
    return node;
  }
  toMarkup() {
    if (this.alternate) {
      return '<path d="' + utils$1.escape(this.alternate) + '"/>';
    } else {
      return '<path d="' + utils$1.escape(path[this.pathName]) + '"/>';
    }
  }
}
class LineNode {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node = document.createElementNS(svgNS, "line");
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    return node;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="' + utils$1.escape(this.attributes[attr]) + '"';
      }
    }
    markup += "/>";
    return markup;
  }
}
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = {
    font,
    group,
    replace
  };
  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}
var math = "math";
var text = "text";
var main$1 = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math, main$1, rel, "≡", "\\equiv", true);
defineSymbol(math, main$1, rel, "≺", "\\prec", true);
defineSymbol(math, main$1, rel, "≻", "\\succ", true);
defineSymbol(math, main$1, rel, "∼", "\\sim", true);
defineSymbol(math, main$1, rel, "⊥", "\\perp");
defineSymbol(math, main$1, rel, "⪯", "\\preceq", true);
defineSymbol(math, main$1, rel, "⪰", "\\succeq", true);
defineSymbol(math, main$1, rel, "≃", "\\simeq", true);
defineSymbol(math, main$1, rel, "∣", "\\mid", true);
defineSymbol(math, main$1, rel, "≪", "\\ll", true);
defineSymbol(math, main$1, rel, "≫", "\\gg", true);
defineSymbol(math, main$1, rel, "≍", "\\asymp", true);
defineSymbol(math, main$1, rel, "∥", "\\parallel");
defineSymbol(math, main$1, rel, "⋈", "\\bowtie", true);
defineSymbol(math, main$1, rel, "⌣", "\\smile", true);
defineSymbol(math, main$1, rel, "⊑", "\\sqsubseteq", true);
defineSymbol(math, main$1, rel, "⊒", "\\sqsupseteq", true);
defineSymbol(math, main$1, rel, "≐", "\\doteq", true);
defineSymbol(math, main$1, rel, "⌢", "\\frown", true);
defineSymbol(math, main$1, rel, "∋", "\\ni", true);
defineSymbol(math, main$1, rel, "∝", "\\propto", true);
defineSymbol(math, main$1, rel, "⊢", "\\vdash", true);
defineSymbol(math, main$1, rel, "⊣", "\\dashv", true);
defineSymbol(math, main$1, rel, "∋", "\\owns");
defineSymbol(math, main$1, punct, ".", "\\ldotp");
defineSymbol(math, main$1, punct, "⋅", "\\cdotp");
defineSymbol(math, main$1, textord, "#", "\\#");
defineSymbol(text, main$1, textord, "#", "\\#");
defineSymbol(math, main$1, textord, "&", "\\&");
defineSymbol(text, main$1, textord, "&", "\\&");
defineSymbol(math, main$1, textord, "ℵ", "\\aleph", true);
defineSymbol(math, main$1, textord, "∀", "\\forall", true);
defineSymbol(math, main$1, textord, "ℏ", "\\hbar", true);
defineSymbol(math, main$1, textord, "∃", "\\exists", true);
defineSymbol(math, main$1, textord, "∇", "\\nabla", true);
defineSymbol(math, main$1, textord, "♭", "\\flat", true);
defineSymbol(math, main$1, textord, "ℓ", "\\ell", true);
defineSymbol(math, main$1, textord, "♮", "\\natural", true);
defineSymbol(math, main$1, textord, "♣", "\\clubsuit", true);
defineSymbol(math, main$1, textord, "℘", "\\wp", true);
defineSymbol(math, main$1, textord, "♯", "\\sharp", true);
defineSymbol(math, main$1, textord, "♢", "\\diamondsuit", true);
defineSymbol(math, main$1, textord, "ℜ", "\\Re", true);
defineSymbol(math, main$1, textord, "♡", "\\heartsuit", true);
defineSymbol(math, main$1, textord, "ℑ", "\\Im", true);
defineSymbol(math, main$1, textord, "♠", "\\spadesuit", true);
defineSymbol(math, main$1, textord, "§", "\\S", true);
defineSymbol(text, main$1, textord, "§", "\\S");
defineSymbol(math, main$1, textord, "¶", "\\P", true);
defineSymbol(text, main$1, textord, "¶", "\\P");
defineSymbol(math, main$1, textord, "†", "\\dag");
defineSymbol(text, main$1, textord, "†", "\\dag");
defineSymbol(text, main$1, textord, "†", "\\textdagger");
defineSymbol(math, main$1, textord, "‡", "\\ddag");
defineSymbol(text, main$1, textord, "‡", "\\ddag");
defineSymbol(text, main$1, textord, "‡", "\\textdaggerdbl");
defineSymbol(math, main$1, close, "⎱", "\\rmoustache", true);
defineSymbol(math, main$1, open, "⎰", "\\lmoustache", true);
defineSymbol(math, main$1, close, "⟯", "\\rgroup", true);
defineSymbol(math, main$1, open, "⟮", "\\lgroup", true);
defineSymbol(math, main$1, bin, "∓", "\\mp", true);
defineSymbol(math, main$1, bin, "⊖", "\\ominus", true);
defineSymbol(math, main$1, bin, "⊎", "\\uplus", true);
defineSymbol(math, main$1, bin, "⊓", "\\sqcap", true);
defineSymbol(math, main$1, bin, "∗", "\\ast");
defineSymbol(math, main$1, bin, "⊔", "\\sqcup", true);
defineSymbol(math, main$1, bin, "◯", "\\bigcirc", true);
defineSymbol(math, main$1, bin, "∙", "\\bullet", true);
defineSymbol(math, main$1, bin, "‡", "\\ddagger");
defineSymbol(math, main$1, bin, "≀", "\\wr", true);
defineSymbol(math, main$1, bin, "⨿", "\\amalg");
defineSymbol(math, main$1, bin, "&", "\\And");
defineSymbol(math, main$1, rel, "⟵", "\\longleftarrow", true);
defineSymbol(math, main$1, rel, "⇐", "\\Leftarrow", true);
defineSymbol(math, main$1, rel, "⟸", "\\Longleftarrow", true);
defineSymbol(math, main$1, rel, "⟶", "\\longrightarrow", true);
defineSymbol(math, main$1, rel, "⇒", "\\Rightarrow", true);
defineSymbol(math, main$1, rel, "⟹", "\\Longrightarrow", true);
defineSymbol(math, main$1, rel, "↔", "\\leftrightarrow", true);
defineSymbol(math, main$1, rel, "⟷", "\\longleftrightarrow", true);
defineSymbol(math, main$1, rel, "⇔", "\\Leftrightarrow", true);
defineSymbol(math, main$1, rel, "⟺", "\\Longleftrightarrow", true);
defineSymbol(math, main$1, rel, "↦", "\\mapsto", true);
defineSymbol(math, main$1, rel, "⟼", "\\longmapsto", true);
defineSymbol(math, main$1, rel, "↗", "\\nearrow", true);
defineSymbol(math, main$1, rel, "↩", "\\hookleftarrow", true);
defineSymbol(math, main$1, rel, "↪", "\\hookrightarrow", true);
defineSymbol(math, main$1, rel, "↘", "\\searrow", true);
defineSymbol(math, main$1, rel, "↼", "\\leftharpoonup", true);
defineSymbol(math, main$1, rel, "⇀", "\\rightharpoonup", true);
defineSymbol(math, main$1, rel, "↙", "\\swarrow", true);
defineSymbol(math, main$1, rel, "↽", "\\leftharpoondown", true);
defineSymbol(math, main$1, rel, "⇁", "\\rightharpoondown", true);
defineSymbol(math, main$1, rel, "↖", "\\nwarrow", true);
defineSymbol(math, main$1, rel, "⇌", "\\rightleftharpoons", true);
defineSymbol(math, ams, rel, "≮", "\\nless", true);
defineSymbol(math, ams, rel, "", "\\@nleqslant");
defineSymbol(math, ams, rel, "", "\\@nleqq");
defineSymbol(math, ams, rel, "⪇", "\\lneq", true);
defineSymbol(math, ams, rel, "≨", "\\lneqq", true);
defineSymbol(math, ams, rel, "", "\\@lvertneqq");
defineSymbol(math, ams, rel, "⋦", "\\lnsim", true);
defineSymbol(math, ams, rel, "⪉", "\\lnapprox", true);
defineSymbol(math, ams, rel, "⊀", "\\nprec", true);
defineSymbol(math, ams, rel, "⋠", "\\npreceq", true);
defineSymbol(math, ams, rel, "⋨", "\\precnsim", true);
defineSymbol(math, ams, rel, "⪹", "\\precnapprox", true);
defineSymbol(math, ams, rel, "≁", "\\nsim", true);
defineSymbol(math, ams, rel, "", "\\@nshortmid");
defineSymbol(math, ams, rel, "∤", "\\nmid", true);
defineSymbol(math, ams, rel, "⊬", "\\nvdash", true);
defineSymbol(math, ams, rel, "⊭", "\\nvDash", true);
defineSymbol(math, ams, rel, "⋪", "\\ntriangleleft");
defineSymbol(math, ams, rel, "⋬", "\\ntrianglelefteq", true);
defineSymbol(math, ams, rel, "⊊", "\\subsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math, ams, rel, "⫋", "\\subsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math, ams, rel, "≯", "\\ngtr", true);
defineSymbol(math, ams, rel, "", "\\@ngeqslant");
defineSymbol(math, ams, rel, "", "\\@ngeqq");
defineSymbol(math, ams, rel, "⪈", "\\gneq", true);
defineSymbol(math, ams, rel, "≩", "\\gneqq", true);
defineSymbol(math, ams, rel, "", "\\@gvertneqq");
defineSymbol(math, ams, rel, "⋧", "\\gnsim", true);
defineSymbol(math, ams, rel, "⪊", "\\gnapprox", true);
defineSymbol(math, ams, rel, "⊁", "\\nsucc", true);
defineSymbol(math, ams, rel, "⋡", "\\nsucceq", true);
defineSymbol(math, ams, rel, "⋩", "\\succnsim", true);
defineSymbol(math, ams, rel, "⪺", "\\succnapprox", true);
defineSymbol(math, ams, rel, "≆", "\\ncong", true);
defineSymbol(math, ams, rel, "", "\\@nshortparallel");
defineSymbol(math, ams, rel, "∦", "\\nparallel", true);
defineSymbol(math, ams, rel, "⊯", "\\nVDash", true);
defineSymbol(math, ams, rel, "⋫", "\\ntriangleright");
defineSymbol(math, ams, rel, "⋭", "\\ntrianglerighteq", true);
defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math, ams, rel, "⊋", "\\supsetneq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math, ams, rel, "⫌", "\\supsetneqq", true);
defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math, ams, rel, "⊮", "\\nVdash", true);
defineSymbol(math, ams, rel, "⪵", "\\precneqq", true);
defineSymbol(math, ams, rel, "⪶", "\\succneqq", true);
defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math, ams, bin, "⊴", "\\unlhd");
defineSymbol(math, ams, bin, "⊵", "\\unrhd");
defineSymbol(math, ams, rel, "↚", "\\nleftarrow", true);
defineSymbol(math, ams, rel, "↛", "\\nrightarrow", true);
defineSymbol(math, ams, rel, "⇍", "\\nLeftarrow", true);
defineSymbol(math, ams, rel, "⇏", "\\nRightarrow", true);
defineSymbol(math, ams, rel, "↮", "\\nleftrightarrow", true);
defineSymbol(math, ams, rel, "⇎", "\\nLeftrightarrow", true);
defineSymbol(math, ams, rel, "△", "\\vartriangle");
defineSymbol(math, ams, textord, "ℏ", "\\hslash");
defineSymbol(math, ams, textord, "▽", "\\triangledown");
defineSymbol(math, ams, textord, "◊", "\\lozenge");
defineSymbol(math, ams, textord, "Ⓢ", "\\circledS");
defineSymbol(math, ams, textord, "®", "\\circledR");
defineSymbol(text, ams, textord, "®", "\\circledR");
defineSymbol(math, ams, textord, "∡", "\\measuredangle", true);
defineSymbol(math, ams, textord, "∄", "\\nexists");
defineSymbol(math, ams, textord, "℧", "\\mho");
defineSymbol(math, ams, textord, "Ⅎ", "\\Finv", true);
defineSymbol(math, ams, textord, "⅁", "\\Game", true);
defineSymbol(math, ams, textord, "‵", "\\backprime");
defineSymbol(math, ams, textord, "▲", "\\blacktriangle");
defineSymbol(math, ams, textord, "▼", "\\blacktriangledown");
defineSymbol(math, ams, textord, "■", "\\blacksquare");
defineSymbol(math, ams, textord, "⧫", "\\blacklozenge");
defineSymbol(math, ams, textord, "★", "\\bigstar");
defineSymbol(math, ams, textord, "∢", "\\sphericalangle", true);
defineSymbol(math, ams, textord, "∁", "\\complement", true);
defineSymbol(math, ams, textord, "ð", "\\eth", true);
defineSymbol(text, main$1, textord, "ð", "ð");
defineSymbol(math, ams, textord, "╱", "\\diagup");
defineSymbol(math, ams, textord, "╲", "\\diagdown");
defineSymbol(math, ams, textord, "□", "\\square");
defineSymbol(math, ams, textord, "□", "\\Box");
defineSymbol(math, ams, textord, "◊", "\\Diamond");
defineSymbol(math, ams, textord, "¥", "\\yen", true);
defineSymbol(text, ams, textord, "¥", "\\yen", true);
defineSymbol(math, ams, textord, "✓", "\\checkmark", true);
defineSymbol(text, ams, textord, "✓", "\\checkmark");
defineSymbol(math, ams, textord, "ℶ", "\\beth", true);
defineSymbol(math, ams, textord, "ℸ", "\\daleth", true);
defineSymbol(math, ams, textord, "ℷ", "\\gimel", true);
defineSymbol(math, ams, textord, "ϝ", "\\digamma", true);
defineSymbol(math, ams, textord, "ϰ", "\\varkappa");
defineSymbol(math, ams, open, "┌", "\\@ulcorner", true);
defineSymbol(math, ams, close, "┐", "\\@urcorner", true);
defineSymbol(math, ams, open, "└", "\\@llcorner", true);
defineSymbol(math, ams, close, "┘", "\\@lrcorner", true);
defineSymbol(math, ams, rel, "≦", "\\leqq", true);
defineSymbol(math, ams, rel, "⩽", "\\leqslant", true);
defineSymbol(math, ams, rel, "⪕", "\\eqslantless", true);
defineSymbol(math, ams, rel, "≲", "\\lesssim", true);
defineSymbol(math, ams, rel, "⪅", "\\lessapprox", true);
defineSymbol(math, ams, rel, "≊", "\\approxeq", true);
defineSymbol(math, ams, bin, "⋖", "\\lessdot");
defineSymbol(math, ams, rel, "⋘", "\\lll", true);
defineSymbol(math, ams, rel, "≶", "\\lessgtr", true);
defineSymbol(math, ams, rel, "⋚", "\\lesseqgtr", true);
defineSymbol(math, ams, rel, "⪋", "\\lesseqqgtr", true);
defineSymbol(math, ams, rel, "≑", "\\doteqdot");
defineSymbol(math, ams, rel, "≓", "\\risingdotseq", true);
defineSymbol(math, ams, rel, "≒", "\\fallingdotseq", true);
defineSymbol(math, ams, rel, "∽", "\\backsim", true);
defineSymbol(math, ams, rel, "⋍", "\\backsimeq", true);
defineSymbol(math, ams, rel, "⫅", "\\subseteqq", true);
defineSymbol(math, ams, rel, "⋐", "\\Subset", true);
defineSymbol(math, ams, rel, "⊏", "\\sqsubset", true);
defineSymbol(math, ams, rel, "≼", "\\preccurlyeq", true);
defineSymbol(math, ams, rel, "⋞", "\\curlyeqprec", true);
defineSymbol(math, ams, rel, "≾", "\\precsim", true);
defineSymbol(math, ams, rel, "⪷", "\\precapprox", true);
defineSymbol(math, ams, rel, "⊲", "\\vartriangleleft");
defineSymbol(math, ams, rel, "⊴", "\\trianglelefteq");
defineSymbol(math, ams, rel, "⊨", "\\vDash", true);
defineSymbol(math, ams, rel, "⊪", "\\Vvdash", true);
defineSymbol(math, ams, rel, "⌣", "\\smallsmile");
defineSymbol(math, ams, rel, "⌢", "\\smallfrown");
defineSymbol(math, ams, rel, "≏", "\\bumpeq", true);
defineSymbol(math, ams, rel, "≎", "\\Bumpeq", true);
defineSymbol(math, ams, rel, "≧", "\\geqq", true);
defineSymbol(math, ams, rel, "⩾", "\\geqslant", true);
defineSymbol(math, ams, rel, "⪖", "\\eqslantgtr", true);
defineSymbol(math, ams, rel, "≳", "\\gtrsim", true);
defineSymbol(math, ams, rel, "⪆", "\\gtrapprox", true);
defineSymbol(math, ams, bin, "⋗", "\\gtrdot");
defineSymbol(math, ams, rel, "⋙", "\\ggg", true);
defineSymbol(math, ams, rel, "≷", "\\gtrless", true);
defineSymbol(math, ams, rel, "⋛", "\\gtreqless", true);
defineSymbol(math, ams, rel, "⪌", "\\gtreqqless", true);
defineSymbol(math, ams, rel, "≖", "\\eqcirc", true);
defineSymbol(math, ams, rel, "≗", "\\circeq", true);
defineSymbol(math, ams, rel, "≜", "\\triangleq", true);
defineSymbol(math, ams, rel, "∼", "\\thicksim");
defineSymbol(math, ams, rel, "≈", "\\thickapprox");
defineSymbol(math, ams, rel, "⫆", "\\supseteqq", true);
defineSymbol(math, ams, rel, "⋑", "\\Supset", true);
defineSymbol(math, ams, rel, "⊐", "\\sqsupset", true);
defineSymbol(math, ams, rel, "≽", "\\succcurlyeq", true);
defineSymbol(math, ams, rel, "⋟", "\\curlyeqsucc", true);
defineSymbol(math, ams, rel, "≿", "\\succsim", true);
defineSymbol(math, ams, rel, "⪸", "\\succapprox", true);
defineSymbol(math, ams, rel, "⊳", "\\vartriangleright");
defineSymbol(math, ams, rel, "⊵", "\\trianglerighteq");
defineSymbol(math, ams, rel, "⊩", "\\Vdash", true);
defineSymbol(math, ams, rel, "∣", "\\shortmid");
defineSymbol(math, ams, rel, "∥", "\\shortparallel");
defineSymbol(math, ams, rel, "≬", "\\between", true);
defineSymbol(math, ams, rel, "⋔", "\\pitchfork", true);
defineSymbol(math, ams, rel, "∝", "\\varpropto");
defineSymbol(math, ams, rel, "◀", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "∴", "\\therefore", true);
defineSymbol(math, ams, rel, "∍", "\\backepsilon");
defineSymbol(math, ams, rel, "▶", "\\blacktriangleright");
defineSymbol(math, ams, rel, "∵", "\\because", true);
defineSymbol(math, ams, rel, "⋘", "\\llless");
defineSymbol(math, ams, rel, "⋙", "\\gggtr");
defineSymbol(math, ams, bin, "⊲", "\\lhd");
defineSymbol(math, ams, bin, "⊳", "\\rhd");
defineSymbol(math, ams, rel, "≂", "\\eqsim", true);
defineSymbol(math, main$1, rel, "⋈", "\\Join");
defineSymbol(math, ams, rel, "≑", "\\Doteq", true);
defineSymbol(math, ams, bin, "∔", "\\dotplus", true);
defineSymbol(math, ams, bin, "∖", "\\smallsetminus");
defineSymbol(math, ams, bin, "⋒", "\\Cap", true);
defineSymbol(math, ams, bin, "⋓", "\\Cup", true);
defineSymbol(math, ams, bin, "⩞", "\\doublebarwedge", true);
defineSymbol(math, ams, bin, "⊟", "\\boxminus", true);
defineSymbol(math, ams, bin, "⊞", "\\boxplus", true);
defineSymbol(math, ams, bin, "⋇", "\\divideontimes", true);
defineSymbol(math, ams, bin, "⋉", "\\ltimes", true);
defineSymbol(math, ams, bin, "⋊", "\\rtimes", true);
defineSymbol(math, ams, bin, "⋋", "\\leftthreetimes", true);
defineSymbol(math, ams, bin, "⋌", "\\rightthreetimes", true);
defineSymbol(math, ams, bin, "⋏", "\\curlywedge", true);
defineSymbol(math, ams, bin, "⋎", "\\curlyvee", true);
defineSymbol(math, ams, bin, "⊝", "\\circleddash", true);
defineSymbol(math, ams, bin, "⊛", "\\circledast", true);
defineSymbol(math, ams, bin, "⋅", "\\centerdot");
defineSymbol(math, ams, bin, "⊺", "\\intercal", true);
defineSymbol(math, ams, bin, "⋒", "\\doublecap");
defineSymbol(math, ams, bin, "⋓", "\\doublecup");
defineSymbol(math, ams, bin, "⊠", "\\boxtimes", true);
defineSymbol(math, ams, rel, "⇢", "\\dashrightarrow", true);
defineSymbol(math, ams, rel, "⇠", "\\dashleftarrow", true);
defineSymbol(math, ams, rel, "⇇", "\\leftleftarrows", true);
defineSymbol(math, ams, rel, "⇆", "\\leftrightarrows", true);
defineSymbol(math, ams, rel, "⇚", "\\Lleftarrow", true);
defineSymbol(math, ams, rel, "↞", "\\twoheadleftarrow", true);
defineSymbol(math, ams, rel, "↢", "\\leftarrowtail", true);
defineSymbol(math, ams, rel, "↫", "\\looparrowleft", true);
defineSymbol(math, ams, rel, "⇋", "\\leftrightharpoons", true);
defineSymbol(math, ams, rel, "↶", "\\curvearrowleft", true);
defineSymbol(math, ams, rel, "↺", "\\circlearrowleft", true);
defineSymbol(math, ams, rel, "↰", "\\Lsh", true);
defineSymbol(math, ams, rel, "⇈", "\\upuparrows", true);
defineSymbol(math, ams, rel, "↿", "\\upharpoonleft", true);
defineSymbol(math, ams, rel, "⇃", "\\downharpoonleft", true);
defineSymbol(math, main$1, rel, "⊶", "\\origof", true);
defineSymbol(math, main$1, rel, "⊷", "\\imageof", true);
defineSymbol(math, ams, rel, "⊸", "\\multimap", true);
defineSymbol(math, ams, rel, "↭", "\\leftrightsquigarrow", true);
defineSymbol(math, ams, rel, "⇉", "\\rightrightarrows", true);
defineSymbol(math, ams, rel, "⇄", "\\rightleftarrows", true);
defineSymbol(math, ams, rel, "↠", "\\twoheadrightarrow", true);
defineSymbol(math, ams, rel, "↣", "\\rightarrowtail", true);
defineSymbol(math, ams, rel, "↬", "\\looparrowright", true);
defineSymbol(math, ams, rel, "↷", "\\curvearrowright", true);
defineSymbol(math, ams, rel, "↻", "\\circlearrowright", true);
defineSymbol(math, ams, rel, "↱", "\\Rsh", true);
defineSymbol(math, ams, rel, "⇊", "\\downdownarrows", true);
defineSymbol(math, ams, rel, "↾", "\\upharpoonright", true);
defineSymbol(math, ams, rel, "⇂", "\\downharpoonright", true);
defineSymbol(math, ams, rel, "⇝", "\\rightsquigarrow", true);
defineSymbol(math, ams, rel, "⇝", "\\leadsto");
defineSymbol(math, ams, rel, "⇛", "\\Rrightarrow", true);
defineSymbol(math, ams, rel, "↾", "\\restriction");
defineSymbol(math, main$1, textord, "‘", "`");
defineSymbol(math, main$1, textord, "$", "\\$");
defineSymbol(text, main$1, textord, "$", "\\$");
defineSymbol(text, main$1, textord, "$", "\\textdollar");
defineSymbol(math, main$1, textord, "%", "\\%");
defineSymbol(text, main$1, textord, "%", "\\%");
defineSymbol(math, main$1, textord, "_", "\\_");
defineSymbol(text, main$1, textord, "_", "\\_");
defineSymbol(text, main$1, textord, "_", "\\textunderscore");
defineSymbol(math, main$1, textord, "∠", "\\angle", true);
defineSymbol(math, main$1, textord, "∞", "\\infty", true);
defineSymbol(math, main$1, textord, "′", "\\prime");
defineSymbol(math, main$1, textord, "△", "\\triangle");
defineSymbol(math, main$1, textord, "Γ", "\\Gamma", true);
defineSymbol(math, main$1, textord, "Δ", "\\Delta", true);
defineSymbol(math, main$1, textord, "Θ", "\\Theta", true);
defineSymbol(math, main$1, textord, "Λ", "\\Lambda", true);
defineSymbol(math, main$1, textord, "Ξ", "\\Xi", true);
defineSymbol(math, main$1, textord, "Π", "\\Pi", true);
defineSymbol(math, main$1, textord, "Σ", "\\Sigma", true);
defineSymbol(math, main$1, textord, "Υ", "\\Upsilon", true);
defineSymbol(math, main$1, textord, "Φ", "\\Phi", true);
defineSymbol(math, main$1, textord, "Ψ", "\\Psi", true);
defineSymbol(math, main$1, textord, "Ω", "\\Omega", true);
defineSymbol(math, main$1, textord, "A", "Α");
defineSymbol(math, main$1, textord, "B", "Β");
defineSymbol(math, main$1, textord, "E", "Ε");
defineSymbol(math, main$1, textord, "Z", "Ζ");
defineSymbol(math, main$1, textord, "H", "Η");
defineSymbol(math, main$1, textord, "I", "Ι");
defineSymbol(math, main$1, textord, "K", "Κ");
defineSymbol(math, main$1, textord, "M", "Μ");
defineSymbol(math, main$1, textord, "N", "Ν");
defineSymbol(math, main$1, textord, "O", "Ο");
defineSymbol(math, main$1, textord, "P", "Ρ");
defineSymbol(math, main$1, textord, "T", "Τ");
defineSymbol(math, main$1, textord, "X", "Χ");
defineSymbol(math, main$1, textord, "¬", "\\neg", true);
defineSymbol(math, main$1, textord, "¬", "\\lnot");
defineSymbol(math, main$1, textord, "⊤", "\\top");
defineSymbol(math, main$1, textord, "⊥", "\\bot");
defineSymbol(math, main$1, textord, "∅", "\\emptyset");
defineSymbol(math, ams, textord, "∅", "\\varnothing");
defineSymbol(math, main$1, mathord, "α", "\\alpha", true);
defineSymbol(math, main$1, mathord, "β", "\\beta", true);
defineSymbol(math, main$1, mathord, "γ", "\\gamma", true);
defineSymbol(math, main$1, mathord, "δ", "\\delta", true);
defineSymbol(math, main$1, mathord, "ϵ", "\\epsilon", true);
defineSymbol(math, main$1, mathord, "ζ", "\\zeta", true);
defineSymbol(math, main$1, mathord, "η", "\\eta", true);
defineSymbol(math, main$1, mathord, "θ", "\\theta", true);
defineSymbol(math, main$1, mathord, "ι", "\\iota", true);
defineSymbol(math, main$1, mathord, "κ", "\\kappa", true);
defineSymbol(math, main$1, mathord, "λ", "\\lambda", true);
defineSymbol(math, main$1, mathord, "μ", "\\mu", true);
defineSymbol(math, main$1, mathord, "ν", "\\nu", true);
defineSymbol(math, main$1, mathord, "ξ", "\\xi", true);
defineSymbol(math, main$1, mathord, "ο", "\\omicron", true);
defineSymbol(math, main$1, mathord, "π", "\\pi", true);
defineSymbol(math, main$1, mathord, "ρ", "\\rho", true);
defineSymbol(math, main$1, mathord, "σ", "\\sigma", true);
defineSymbol(math, main$1, mathord, "τ", "\\tau", true);
defineSymbol(math, main$1, mathord, "υ", "\\upsilon", true);
defineSymbol(math, main$1, mathord, "ϕ", "\\phi", true);
defineSymbol(math, main$1, mathord, "χ", "\\chi", true);
defineSymbol(math, main$1, mathord, "ψ", "\\psi", true);
defineSymbol(math, main$1, mathord, "ω", "\\omega", true);
defineSymbol(math, main$1, mathord, "ε", "\\varepsilon", true);
defineSymbol(math, main$1, mathord, "ϑ", "\\vartheta", true);
defineSymbol(math, main$1, mathord, "ϖ", "\\varpi", true);
defineSymbol(math, main$1, mathord, "ϱ", "\\varrho", true);
defineSymbol(math, main$1, mathord, "ς", "\\varsigma", true);
defineSymbol(math, main$1, mathord, "φ", "\\varphi", true);
defineSymbol(math, main$1, bin, "∗", "*", true);
defineSymbol(math, main$1, bin, "+", "+");
defineSymbol(math, main$1, bin, "−", "-", true);
defineSymbol(math, main$1, bin, "⋅", "\\cdot", true);
defineSymbol(math, main$1, bin, "∘", "\\circ", true);
defineSymbol(math, main$1, bin, "÷", "\\div", true);
defineSymbol(math, main$1, bin, "±", "\\pm", true);
defineSymbol(math, main$1, bin, "×", "\\times", true);
defineSymbol(math, main$1, bin, "∩", "\\cap", true);
defineSymbol(math, main$1, bin, "∪", "\\cup", true);
defineSymbol(math, main$1, bin, "∖", "\\setminus", true);
defineSymbol(math, main$1, bin, "∧", "\\land");
defineSymbol(math, main$1, bin, "∨", "\\lor");
defineSymbol(math, main$1, bin, "∧", "\\wedge", true);
defineSymbol(math, main$1, bin, "∨", "\\vee", true);
defineSymbol(math, main$1, textord, "√", "\\surd");
defineSymbol(math, main$1, open, "⟨", "\\langle", true);
defineSymbol(math, main$1, open, "∣", "\\lvert");
defineSymbol(math, main$1, open, "∥", "\\lVert");
defineSymbol(math, main$1, close, "?", "?");
defineSymbol(math, main$1, close, "!", "!");
defineSymbol(math, main$1, close, "⟩", "\\rangle", true);
defineSymbol(math, main$1, close, "∣", "\\rvert");
defineSymbol(math, main$1, close, "∥", "\\rVert");
defineSymbol(math, main$1, rel, "=", "=");
defineSymbol(math, main$1, rel, ":", ":");
defineSymbol(math, main$1, rel, "≈", "\\approx", true);
defineSymbol(math, main$1, rel, "≅", "\\cong", true);
defineSymbol(math, main$1, rel, "≥", "\\ge");
defineSymbol(math, main$1, rel, "≥", "\\geq", true);
defineSymbol(math, main$1, rel, "←", "\\gets");
defineSymbol(math, main$1, rel, ">", "\\gt", true);
defineSymbol(math, main$1, rel, "∈", "\\in", true);
defineSymbol(math, main$1, rel, "", "\\@not");
defineSymbol(math, main$1, rel, "⊂", "\\subset", true);
defineSymbol(math, main$1, rel, "⊃", "\\supset", true);
defineSymbol(math, main$1, rel, "⊆", "\\subseteq", true);
defineSymbol(math, main$1, rel, "⊇", "\\supseteq", true);
defineSymbol(math, ams, rel, "⊈", "\\nsubseteq", true);
defineSymbol(math, ams, rel, "⊉", "\\nsupseteq", true);
defineSymbol(math, main$1, rel, "⊨", "\\models");
defineSymbol(math, main$1, rel, "←", "\\leftarrow", true);
defineSymbol(math, main$1, rel, "≤", "\\le");
defineSymbol(math, main$1, rel, "≤", "\\leq", true);
defineSymbol(math, main$1, rel, "<", "\\lt", true);
defineSymbol(math, main$1, rel, "→", "\\rightarrow", true);
defineSymbol(math, main$1, rel, "→", "\\to");
defineSymbol(math, ams, rel, "≱", "\\ngeq", true);
defineSymbol(math, ams, rel, "≰", "\\nleq", true);
defineSymbol(math, main$1, spacing, " ", "\\ ");
defineSymbol(math, main$1, spacing, " ", "\\space");
defineSymbol(math, main$1, spacing, " ", "\\nobreakspace");
defineSymbol(text, main$1, spacing, " ", "\\ ");
defineSymbol(text, main$1, spacing, " ", " ");
defineSymbol(text, main$1, spacing, " ", "\\space");
defineSymbol(text, main$1, spacing, " ", "\\nobreakspace");
defineSymbol(math, main$1, spacing, null, "\\nobreak");
defineSymbol(math, main$1, spacing, null, "\\allowbreak");
defineSymbol(math, main$1, punct, ",", ",");
defineSymbol(math, main$1, punct, ";", ";");
defineSymbol(math, ams, bin, "⊼", "\\barwedge", true);
defineSymbol(math, ams, bin, "⊻", "\\veebar", true);
defineSymbol(math, main$1, bin, "⊙", "\\odot", true);
defineSymbol(math, main$1, bin, "⊕", "\\oplus", true);
defineSymbol(math, main$1, bin, "⊗", "\\otimes", true);
defineSymbol(math, main$1, textord, "∂", "\\partial", true);
defineSymbol(math, main$1, bin, "⊘", "\\oslash", true);
defineSymbol(math, ams, bin, "⊚", "\\circledcirc", true);
defineSymbol(math, ams, bin, "⊡", "\\boxdot", true);
defineSymbol(math, main$1, bin, "△", "\\bigtriangleup");
defineSymbol(math, main$1, bin, "▽", "\\bigtriangledown");
defineSymbol(math, main$1, bin, "†", "\\dagger");
defineSymbol(math, main$1, bin, "⋄", "\\diamond");
defineSymbol(math, main$1, bin, "⋆", "\\star");
defineSymbol(math, main$1, bin, "◃", "\\triangleleft");
defineSymbol(math, main$1, bin, "▹", "\\triangleright");
defineSymbol(math, main$1, open, "{", "\\{");
defineSymbol(text, main$1, textord, "{", "\\{");
defineSymbol(text, main$1, textord, "{", "\\textbraceleft");
defineSymbol(math, main$1, close, "}", "\\}");
defineSymbol(text, main$1, textord, "}", "\\}");
defineSymbol(text, main$1, textord, "}", "\\textbraceright");
defineSymbol(math, main$1, open, "{", "\\lbrace");
defineSymbol(math, main$1, close, "}", "\\rbrace");
defineSymbol(math, main$1, open, "[", "\\lbrack", true);
defineSymbol(text, main$1, textord, "[", "\\lbrack", true);
defineSymbol(math, main$1, close, "]", "\\rbrack", true);
defineSymbol(text, main$1, textord, "]", "\\rbrack", true);
defineSymbol(math, main$1, open, "(", "\\lparen", true);
defineSymbol(math, main$1, close, ")", "\\rparen", true);
defineSymbol(text, main$1, textord, "<", "\\textless", true);
defineSymbol(text, main$1, textord, ">", "\\textgreater", true);
defineSymbol(math, main$1, open, "⌊", "\\lfloor", true);
defineSymbol(math, main$1, close, "⌋", "\\rfloor", true);
defineSymbol(math, main$1, open, "⌈", "\\lceil", true);
defineSymbol(math, main$1, close, "⌉", "\\rceil", true);
defineSymbol(math, main$1, textord, "\\", "\\backslash");
defineSymbol(math, main$1, textord, "∣", "|");
defineSymbol(math, main$1, textord, "∣", "\\vert");
defineSymbol(text, main$1, textord, "|", "\\textbar", true);
defineSymbol(math, main$1, textord, "∥", "\\|");
defineSymbol(math, main$1, textord, "∥", "\\Vert");
defineSymbol(text, main$1, textord, "∥", "\\textbardbl");
defineSymbol(text, main$1, textord, "~", "\\textasciitilde");
defineSymbol(text, main$1, textord, "\\", "\\textbackslash");
defineSymbol(text, main$1, textord, "^", "\\textasciicircum");
defineSymbol(math, main$1, rel, "↑", "\\uparrow", true);
defineSymbol(math, main$1, rel, "⇑", "\\Uparrow", true);
defineSymbol(math, main$1, rel, "↓", "\\downarrow", true);
defineSymbol(math, main$1, rel, "⇓", "\\Downarrow", true);
defineSymbol(math, main$1, rel, "↕", "\\updownarrow", true);
defineSymbol(math, main$1, rel, "⇕", "\\Updownarrow", true);
defineSymbol(math, main$1, op, "∐", "\\coprod");
defineSymbol(math, main$1, op, "⋁", "\\bigvee");
defineSymbol(math, main$1, op, "⋀", "\\bigwedge");
defineSymbol(math, main$1, op, "⨄", "\\biguplus");
defineSymbol(math, main$1, op, "⋂", "\\bigcap");
defineSymbol(math, main$1, op, "⋃", "\\bigcup");
defineSymbol(math, main$1, op, "∫", "\\int");
defineSymbol(math, main$1, op, "∫", "\\intop");
defineSymbol(math, main$1, op, "∬", "\\iint");
defineSymbol(math, main$1, op, "∭", "\\iiint");
defineSymbol(math, main$1, op, "∏", "\\prod");
defineSymbol(math, main$1, op, "∑", "\\sum");
defineSymbol(math, main$1, op, "⨂", "\\bigotimes");
defineSymbol(math, main$1, op, "⨁", "\\bigoplus");
defineSymbol(math, main$1, op, "⨀", "\\bigodot");
defineSymbol(math, main$1, op, "∮", "\\oint");
defineSymbol(math, main$1, op, "∯", "\\oiint");
defineSymbol(math, main$1, op, "∰", "\\oiiint");
defineSymbol(math, main$1, op, "⨆", "\\bigsqcup");
defineSymbol(math, main$1, op, "∫", "\\smallint");
defineSymbol(text, main$1, inner, "…", "\\textellipsis");
defineSymbol(math, main$1, inner, "…", "\\mathellipsis");
defineSymbol(text, main$1, inner, "…", "\\ldots", true);
defineSymbol(math, main$1, inner, "…", "\\ldots", true);
defineSymbol(math, main$1, inner, "⋯", "\\@cdots", true);
defineSymbol(math, main$1, inner, "⋱", "\\ddots", true);
defineSymbol(math, main$1, textord, "⋮", "\\varvdots");
defineSymbol(math, main$1, accent, "ˊ", "\\acute");
defineSymbol(math, main$1, accent, "ˋ", "\\grave");
defineSymbol(math, main$1, accent, "¨", "\\ddot");
defineSymbol(math, main$1, accent, "~", "\\tilde");
defineSymbol(math, main$1, accent, "ˉ", "\\bar");
defineSymbol(math, main$1, accent, "˘", "\\breve");
defineSymbol(math, main$1, accent, "ˇ", "\\check");
defineSymbol(math, main$1, accent, "^", "\\hat");
defineSymbol(math, main$1, accent, "⃗", "\\vec");
defineSymbol(math, main$1, accent, "˙", "\\dot");
defineSymbol(math, main$1, accent, "˚", "\\mathring");
defineSymbol(math, main$1, mathord, "", "\\@imath");
defineSymbol(math, main$1, mathord, "", "\\@jmath");
defineSymbol(math, main$1, textord, "ı", "ı");
defineSymbol(math, main$1, textord, "ȷ", "ȷ");
defineSymbol(text, main$1, textord, "ı", "\\i", true);
defineSymbol(text, main$1, textord, "ȷ", "\\j", true);
defineSymbol(text, main$1, textord, "ß", "\\ss", true);
defineSymbol(text, main$1, textord, "æ", "\\ae", true);
defineSymbol(text, main$1, textord, "œ", "\\oe", true);
defineSymbol(text, main$1, textord, "ø", "\\o", true);
defineSymbol(text, main$1, textord, "Æ", "\\AE", true);
defineSymbol(text, main$1, textord, "Œ", "\\OE", true);
defineSymbol(text, main$1, textord, "Ø", "\\O", true);
defineSymbol(text, main$1, accent, "ˊ", "\\'");
defineSymbol(text, main$1, accent, "ˋ", "\\`");
defineSymbol(text, main$1, accent, "ˆ", "\\^");
defineSymbol(text, main$1, accent, "˜", "\\~");
defineSymbol(text, main$1, accent, "ˉ", "\\=");
defineSymbol(text, main$1, accent, "˘", "\\u");
defineSymbol(text, main$1, accent, "˙", "\\.");
defineSymbol(text, main$1, accent, "¸", "\\c");
defineSymbol(text, main$1, accent, "˚", "\\r");
defineSymbol(text, main$1, accent, "ˇ", "\\v");
defineSymbol(text, main$1, accent, "¨", '\\"');
defineSymbol(text, main$1, accent, "˝", "\\H");
defineSymbol(text, main$1, accent, "◯", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text, main$1, textord, "–", "--", true);
defineSymbol(text, main$1, textord, "–", "\\textendash");
defineSymbol(text, main$1, textord, "—", "---", true);
defineSymbol(text, main$1, textord, "—", "\\textemdash");
defineSymbol(text, main$1, textord, "‘", "`", true);
defineSymbol(text, main$1, textord, "‘", "\\textquoteleft");
defineSymbol(text, main$1, textord, "’", "'", true);
defineSymbol(text, main$1, textord, "’", "\\textquoteright");
defineSymbol(text, main$1, textord, "“", "``", true);
defineSymbol(text, main$1, textord, "“", "\\textquotedblleft");
defineSymbol(text, main$1, textord, "”", "''", true);
defineSymbol(text, main$1, textord, "”", "\\textquotedblright");
defineSymbol(math, main$1, textord, "°", "\\degree", true);
defineSymbol(text, main$1, textord, "°", "\\degree");
defineSymbol(text, main$1, textord, "°", "\\textdegree", true);
defineSymbol(math, main$1, textord, "£", "\\pounds");
defineSymbol(math, main$1, textord, "£", "\\mathsterling", true);
defineSymbol(text, main$1, textord, "£", "\\pounds");
defineSymbol(text, main$1, textord, "£", "\\textsterling", true);
defineSymbol(math, ams, textord, "✠", "\\maltese");
defineSymbol(text, ams, textord, "✠", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (var i = 0; i < mathTextSymbols.length; i++) {
  var ch = mathTextSymbols.charAt(i);
  defineSymbol(math, main$1, textord, ch, ch);
}
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (var _i = 0; _i < textSymbols.length; _i++) {
  var _ch = textSymbols.charAt(_i);
  defineSymbol(text, main$1, textord, _ch, _ch);
}
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var _i2 = 0; _i2 < letters.length; _i2++) {
  var _ch2 = letters.charAt(_i2);
  defineSymbol(math, main$1, mathord, _ch2, _ch2);
  defineSymbol(text, main$1, textord, _ch2, _ch2);
}
defineSymbol(math, ams, textord, "C", "ℂ");
defineSymbol(text, ams, textord, "C", "ℂ");
defineSymbol(math, ams, textord, "H", "ℍ");
defineSymbol(text, ams, textord, "H", "ℍ");
defineSymbol(math, ams, textord, "N", "ℕ");
defineSymbol(text, ams, textord, "N", "ℕ");
defineSymbol(math, ams, textord, "P", "ℙ");
defineSymbol(text, ams, textord, "P", "ℙ");
defineSymbol(math, ams, textord, "Q", "ℚ");
defineSymbol(text, ams, textord, "Q", "ℚ");
defineSymbol(math, ams, textord, "R", "ℝ");
defineSymbol(text, ams, textord, "R", "ℝ");
defineSymbol(math, ams, textord, "Z", "ℤ");
defineSymbol(text, ams, textord, "Z", "ℤ");
defineSymbol(math, main$1, mathord, "h", "ℎ");
defineSymbol(text, main$1, mathord, "h", "ℎ");
var wideChar = "";
for (var _i3 = 0; _i3 < letters.length; _i3++) {
  var _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56684 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math, main$1, mathord, _ch3, wideChar);
  defineSymbol(text, main$1, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math, main$1, mathord, _ch3, wideChar);
    defineSymbol(text, main$1, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math, main$1, mathord, _ch3, wideChar);
    defineSymbol(text, main$1, textord, _ch3, wideChar);
  }
}
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math, main$1, mathord, "k", wideChar);
defineSymbol(text, main$1, textord, "k", wideChar);
for (var _i4 = 0; _i4 < 10; _i4++) {
  var _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text, main$1, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math, main$1, mathord, _ch4, wideChar);
  defineSymbol(text, main$1, textord, _ch4, wideChar);
}
var extraLatin = "ÐÞþ";
for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
  var _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math, main$1, mathord, _ch5, _ch5);
  defineSymbol(text, main$1, textord, _ch5, _ch5);
}
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H = wideChar2.charCodeAt(0);
  var L = wideChar2.charCodeAt(1);
  var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
  var j = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError$2("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value2, fontName, mode) {
  if (symbols[mode][value2] && symbols[mode][value2].replace) {
    value2 = symbols[mode][value2].replace;
  }
  return {
    value: value2,
    metrics: getCharacterMetrics(value2, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value2, fontName, mode, options, classes2) {
  var lookup2 = lookupSymbol(value2, fontName, mode);
  var metrics = lookup2.metrics;
  value2 = lookup2.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value2, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes2);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value2 + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value2, 0, 0, 0, 0, 0, classes2);
  }
  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;
    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color = options.getColor();
    if (color) {
      symbolNode.style.color = color;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value2, mode, options, classes2) {
  if (classes2 === void 0) {
    classes2 = [];
  }
  if (options.font === "boldsymbol" && lookupSymbol(value2, "Main-Bold", mode).metrics) {
    return makeSymbol(value2, "Main-Bold", mode, options, classes2.concat(["mathbf"]));
  } else if (value2 === "\\" || symbols[mode][value2].font === "main") {
    return makeSymbol(value2, "Main-Regular", mode, options, classes2);
  } else {
    return makeSymbol(value2, "AMS-Regular", mode, options, classes2.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value2, mode, options, classes2, type) {
  if (type !== "textord" && lookupSymbol(value2, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options, type) {
  var mode = group.mode;
  var text2 = group.text;
  var classes2 = ["mord"];
  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;
  var wideFontName = "";
  var wideFontClass = "";
  if (text2.charCodeAt(0) === 55349) {
    [wideFontName, wideFontClass] = wideCharacterFont(text2, mode);
  }
  if (wideFontName.length > 0) {
    return makeSymbol(text2, wideFontName, mode, options, classes2.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text2, mode, options, classes2, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap$1[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }
    if (lookupSymbol(text2, fontName, mode).metrics) {
      return makeSymbol(text2, fontName, mode, options, classes2.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text2) && fontName.slice(0, 10) === "Typewriter") {
      var parts2 = [];
      for (var i = 0; i < text2.length; i++) {
        parts2.push(makeSymbol(text2[i], fontName, mode, options, classes2.concat(fontClasses)));
      }
      return makeFragment(parts2);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text2, "Math-Italic", mode, options, classes2.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text2] && symbols[mode][text2].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName, mode, options, classes2.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName2, mode, options, classes2.concat(options.fontWeight, options.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
      return makeSymbol(text2, _fontName3, mode, options, classes2.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev2, next) => {
  if (createClass(prev2.classes) !== createClass(next.classes) || prev2.skew !== next.skew || prev2.maxFontSize !== next.maxFontSize) {
    return false;
  }
  if (prev2.classes.length === 1) {
    var cls = prev2.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style2 in prev2.style) {
    if (prev2.style.hasOwnProperty(style2) && prev2.style[style2] !== next.style[style2]) {
      return false;
    }
  }
  for (var _style in next.style) {
    if (next.style.hasOwnProperty(_style) && prev2.style[_style] !== next.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars2) => {
  for (var i = 0; i < chars2.length - 1; i++) {
    var prev2 = chars2[i];
    var next = chars2[i + 1];
    if (prev2 instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev2, next)) {
      prev2.text += next.text;
      prev2.height = Math.max(prev2.height, next.height);
      prev2.depth = Math.max(prev2.depth, next.depth);
      prev2.italic = next.italic;
      chars2.splice(i + 1, 1);
      i--;
    }
  }
  return chars2;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i = 0; i < elem.children.length; i++) {
    var child = elem.children[i];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes2, children, options, style2) {
  var span = new Span(classes2, children, options, style2);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes2, children, options, style2) => new Span(classes2, children, options, style2);
var makeLineSpan = function makeLineSpan2(className, options, thickness) {
  var line = makeSpan$2([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes2, children, options) {
  var anchor = new Anchor(href, classes2, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment = new DocumentFragment$1(children);
  sizeElementFromChildren(fragment);
  return fragment;
};
var wrapFragment = function wrapFragment2(group, options) {
  if (group instanceof DocumentFragment$1) {
    return makeSpan$2([], [group], options);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i = 1; i < oldChildren.length; i++) {
      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size
      });
      children.push(oldChildren[i]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom2 = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom2 -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom2;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes2 = _child.wrapperClasses || [];
      var style2 = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes2, [pstrut, _elem], void 0, style2);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("​")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options) => {
  var rule = makeSpan$2(["mspace"], [], options);
  var size = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap$1 = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value2, options) {
  var [pathName, width, height] = svgData[value2];
  var path2 = new PathNode(pathName);
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap: fontMap$1,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i = 0; i < expression.length; i++) {
    var output = buildGroup$1(expression[i], options);
    if (output instanceof DocumentFragment$1) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options;
  if (expression.length === 1) {
    var node = expression[0];
    if (node.type === "sizing") {
      glueOptions = options.havingSize(node.size);
    } else if (node.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node2, prev2) => {
    var prevType = prev2.classes[0];
    var type = node2.classes[0];
    if (prevType === "mbin" && utils$1.contains(binRightCanceller, type)) {
      prev2.classes[0] = "mord";
    } else if (type === "mbin" && utils$1.contains(binLeftCanceller, prevType)) {
      node2.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node2, prev2) => {
    var prevType = getTypeOfDomTree(prev2);
    var type = getTypeOfDomTree(node2);
    var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev2, next, isRoot) {
  if (next) {
    nodes.push(next);
  }
  var i = 0;
  for (; i < nodes.length; i++) {
    var node = nodes[i];
    var partialGroup = checkPartialGroup(node);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev2, null, isRoot);
      continue;
    }
    var nonspace = !node.hasClass("mspace");
    if (nonspace) {
      var result = callback(node, prev2.node);
      if (result) {
        if (prev2.insertAfter) {
          prev2.insertAfter(result);
        } else {
          nodes.unshift(result);
          i++;
        }
      }
    }
    if (nonspace) {
      prev2.node = node;
    } else if (isRoot && node.hasClass("newline")) {
      prev2.node = makeSpan$1(["leftmost"]);
    }
    prev2.insertAfter = ((index) => (n) => {
      nodes.splice(index + 1, 0, n);
      i++;
    })(i);
  }
  if (next) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node) {
  if (node instanceof DocumentFragment$1 || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
    return node;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node, side) {
  var partialGroup = checkPartialGroup(node);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
  if (!node) {
    return null;
  }
  if (side) {
    node = getOutermostNode(node, side);
  }
  return DomEnum[node.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options, classes2) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes2.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options);
    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError$2("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options) {
  var body = makeSpan$1(["base"], children, options);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options) {
  var tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts2 = [];
  for (var i = 0; i < expression.length; i++) {
    parts2.push(expression[i]);
    if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
      var nobreak = false;
      while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
        i++;
        parts2.push(expression[i]);
        if (expression[i].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts2, options));
        parts2 = [];
      }
    } else if (expression[i].hasClass("newline")) {
      parts2.pop();
      if (parts2.length > 0) {
        children.push(buildHTMLUnbreakable(parts2, options));
        parts2 = [];
      }
      children.push(expression[i]);
    }
  }
  if (parts2.length > 0) {
    children.push(buildHTMLUnbreakable(parts2, options));
  }
  var tagChild;
  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment$1(children);
}
class MathNode {
  constructor(type, children, classes2) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes2 || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value2) {
    this.attributes[name] = value2;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (var i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils$1.escape(this.attributes[attr]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils$1.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}
class TextNode {
  constructor(text2) {
    this.text = void 0;
    this.text = text2;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils$1.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class SpaceNode {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = " ";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = " ";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = " ";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "  ";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = " ⁣";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = " ⁣";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = " ⁣";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = " ⁣";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node.setAttribute("width", makeEm(this.width));
      return node;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
}
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text2, mode, options) {
  if (symbols[mode][text2] && symbols[mode][text2].replace && text2.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text2) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text2 = symbols[mode][text2].replace;
  }
  return new mathMLTree.TextNode(text2);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options) {
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }
  var font = options.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text2 = group.text;
  if (utils$1.contains(["\\imath", "\\jmath"], text2)) {
    return null;
  }
  if (symbols[mode][text2] && symbols[mode][text2].replace) {
    text2 = symbols[mode][text2].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text2, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i = 0; i < expression.length; i++) {
    var _group = buildGroup2(expression[i], options);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
        var child = _group.children[0];
        if (child instanceof TextNode && child.text === ".") {
          lastGroup.children.push(..._group.children);
          continue;
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "̸" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var _child = _group.children[0];
          if (_child instanceof TextNode && _child.text.length > 0) {
            _child.text = _child.text.slice(0, 1) + "̸" + _child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
  return makeRow(buildExpression2(expression, options, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new ParseError$2("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && utils$1.contains(["mrow", "mtable"], expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math2 = new mathMLTree.MathNode("math", [semantics]);
  math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math2.setAttribute("display", "block");
  }
  var wrapperClass2 = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass2], [math2]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node, settings) {
  if (settings.displayMode) {
    var classes2 = ["katex-display"];
    if (settings.leqno) {
      classes2.push("leqno");
    }
    if (settings.fleqn) {
      classes2.push("fleqn");
    }
    node = buildCommon.makeSpan(classes2, [node]);
  }
  return node;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node.setAttribute("stretchy", "true");
  return node;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.slice(1);
    if (utils$1.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path2 = new PathNode(pathName);
      var svgNode = new SvgNode([path2], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i = 0; i < numSvgChildren; i++) {
        var _path = new PathNode(paths[i]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
  var img;
  var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);
    if (label === "fbox") {
      var color = options.color && options.getColor();
      if (color) {
        img.style.borderColor = color;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
  }
  return node;
}
function assertSymbolNodeType(node) {
  var typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
  }
  return typedNode;
}
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
    return node;
  }
  return null;
}
var htmlBuilder$a = (grp, options) => {
  var base;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base = group.base;
    grp.base = base;
    supSubGroup = assertSpan(buildGroup$1(grp, options));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  }
  var body = buildGroup$1(base, options.havingCrampedStyle());
  var mustShift = group.isShifty && utils$1.isCharacterBox(base);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils$1.getBaseElem(base);
    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left2 = skew;
    if (!accentFull) {
      left2 -= width / 2;
    }
    accentBody.style.left = makeEm(left2);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
  node.setAttribute("accent", "true");
  return node;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser2.mode,
      label: funcName,
      base
    };
  },
  htmlBuilder: (group, options) => {
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
var paddedNode = (group) => {
  var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node.setAttribute("width", "+0.6em");
  node.setAttribute("lspace", "0.3em");
  return node;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser2.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style2 = options.style;
    var newOptions = options.havingStyle(style2.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options.havingStyle(style2.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options);
    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options));
        node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options));
      node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node = paddedNode();
      node = new mathMLTree.MathNode("mover", [arrowNode, node]);
    }
    return node;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options) {
  var elements = buildExpression$1(group.body, options, true);
  return makeSpan2([group.mclass], elements, options);
}
function mathmlBuilder$8(group, options) {
  var node;
  var inner2 = buildExpression2(group.body, options);
  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner2);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mi";
    } else {
      node = new mathMLTree.MathNode("mi", inner2);
    }
  } else {
    if (group.isCharacterBox) {
      node = inner2[0];
      node.type = "mo";
    } else {
      node = new mathMLTree.MathNode("mo", inner2);
    }
    if (group.mclass === "mbin") {
      node.attributes.lspace = "0.22em";
      node.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.attributes.lspace = "0em";
      node.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node.attributes.lspace = "0.0556em";
      node.attributes.width = "+0.1111em";
    }
  }
  return node;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils$1.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser: parser2
    } = _ref2;
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils$1.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils$1.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "pmb",
      mode: parser2.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    var node = buildCommon.makeSpan([group.mclass], elements, options);
    node.style.textShadow = "0.02em 0.01em 0.04px";
    return node;
  },
  mathmlBuilder(group, style2) {
    var inner2 = buildExpression2(group.body, style2);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};
var isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};
function cdArrow(arrowChar, labels, parser2) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser2.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow2 = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser2.callFunction("\\Big", [arrow2], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser2) {
  var parsedRows = [];
  parser2.gullet.beginGroup();
  parser2.gullet.macros.set("\\cr", "\\\\\\relax");
  parser2.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser2.parseExpression(false, "\\\\"));
    parser2.gullet.endGroup();
    parser2.gullet.beginGroup();
    var next = parser2.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser2.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError$2("Expected \\\\ or \\cr or \\end", parser2.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i = 0; i < parsedRows.length; i++) {
    var rowNodes = parsedRows[i];
    var cell = newCell();
    for (var j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        cell.body.push(rowNodes[j]);
      } else {
        row.push(cell);
        j += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1)
          ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError$2("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
              }
              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              throw new ParseError$2("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
            }
          }
        } else {
          throw new ParseError$2('Expected one of "<>AV=|." after @', rowNodes[j]);
        }
        var arrow2 = cdArrow(arrowChar, labels, parser2);
        var wrappedArrow = {
          type: "styling",
          body: [arrow2],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser2.gullet.endGroup();
  parser2.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser2.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser: parser2
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser2.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number = "";
    for (var i = 0; i < group.length; i++) {
      var node = assertNodeType(group[i], "textord");
      number += node.text;
    }
    var code = parseInt(number);
    var text2;
    if (isNaN(code)) {
      throw new ParseError$2("\\@char has non-numeric argument " + number);
    } else if (code < 0 || code >= 1114111) {
      throw new ParseError$2("\\@char with invalid code point " + number);
    } else if (code <= 65535) {
      text2 = String.fromCharCode(code);
    } else {
      code -= 65536;
      text2 = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser2.mode,
      text: text2
    };
  }
});
var htmlBuilder$8 = (group, options) => {
  var elements = buildExpression$1(group.body, options.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$7 = (group, options) => {
  var inner2 = buildExpression2(group.body, options.withColor(group.color));
  var node = new mathMLTree.MathNode("mstyle", inner2);
  node.setAttribute("mathcolor", group.color);
  return node;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser2.mode,
      color,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser: parser2,
      breakOnTokenText
    } = _ref2;
    var color = assertNodeType(args[0], "color-token").color;
    parser2.gullet.macros.set("\\current@color", color);
    var body = parser2.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser2.mode,
      color,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var size = parser2.gullet.future().text === "[" ? parser2.parseSizeGroup(true) : null;
    var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser2.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }
    return span;
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        node.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }
    return node;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError$2("Expected a control sequence", tok);
  }
  return name;
};
var getRHS = (parser2) => {
  var tok = parser2.gullet.popToken();
  if (tok.text === "=") {
    tok = parser2.gullet.popToken();
    if (tok.text === " ") {
      tok = parser2.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser2, name, tok, global2) => {
  var macro = parser2.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser2.gullet.isExpandable(tok.text)
    };
  }
  parser2.gullet.macros.set(name, macro, global2);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    parser2.consumeSpaces();
    var token = parser2.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser2.parseFunction(), "internal");
    }
    throw new ParseError$2("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var tok = parser2.gullet.popToken();
    var name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError$2("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser2.gullet.future().text !== "{") {
      tok = parser2.gullet.popToken();
      if (tok.text === "#") {
        if (parser2.gullet.future().text === "{") {
          insert = parser2.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser2.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError$2('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError$2('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError$2("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser2.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser2.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser2.gullet.macros.set(name, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    var name = checkControlSequence(parser2.gullet.popToken());
    parser2.gullet.consumeSpaces();
    var tok = getRHS(parser2);
    letCommand(parser2, name, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    var name = checkControlSequence(parser2.gullet.popToken());
    var middle = parser2.gullet.popToken();
    var tok = parser2.gullet.popToken();
    letCommand(parser2, name, tok, funcName === "\\\\globalfuture");
    parser2.gullet.pushToken(tok);
    parser2.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options, classes2) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes2.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options, style2) {
  var newOptions = options.havingBaseStyle(style2);
  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift);
  span.height -= shift;
  span.depth += shift;
};
var makeSmallDelim = function makeSmallDelim2(delim, style2, center, options, mode, classes2) {
  var text2 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text2, style2, options, classes2);
  if (center) {
    centerSpan(span, options, style2);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value2, size, mode, options) {
  return buildCommon.makeSymbol(value2, "Size" + size + "-Regular", mode, options);
};
var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes2) {
  var inner2 = mathrmSize(delim, size, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), Style$1.TEXT, options, classes2);
  if (center) {
    centerSpan(span, options, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height, options) {
  var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path2 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path2], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes2) {
  var top2;
  var middle;
  var repeat;
  var bottom2;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top2 = repeat = bottom2 = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom2 = "⏐";
  } else if (delim === "\\Uparrow") {
    repeat = bottom2 = "‖";
  } else if (delim === "\\downarrow") {
    top2 = repeat = "⏐";
  } else if (delim === "\\Downarrow") {
    top2 = repeat = "‖";
  } else if (delim === "\\updownarrow") {
    top2 = "\\uparrow";
    repeat = "⏐";
    bottom2 = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top2 = "\\Uparrow";
    repeat = "‖";
    bottom2 = "\\Downarrow";
  } else if (utils$1.contains(verts, delim)) {
    repeat = "∣";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (utils$1.contains(doubleVerts, delim)) {
    repeat = "∥";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top2 = "⎡";
    repeat = "⎢";
    bottom2 = "⎣";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top2 = "⎤";
    repeat = "⎥";
    bottom2 = "⎦";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "⌊") {
    repeat = top2 = "⎢";
    bottom2 = "⎣";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "⌈") {
    top2 = "⎡";
    repeat = bottom2 = "⎢";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "⌋") {
    repeat = top2 = "⎥";
    bottom2 = "⎦";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "⌉") {
    top2 = "⎤";
    repeat = bottom2 = "⎥";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top2 = "⎛";
    repeat = "⎜";
    bottom2 = "⎝";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top2 = "⎞";
    repeat = "⎟";
    bottom2 = "⎠";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top2 = "⎧";
    middle = "⎨";
    bottom2 = "⎩";
    repeat = "⎪";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top2 = "⎫";
    middle = "⎬";
    bottom2 = "⎭";
    repeat = "⎪";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "⟮") {
    top2 = "⎧";
    bottom2 = "⎩";
    repeat = "⎪";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "⟯") {
    top2 = "⎫";
    bottom2 = "⎭";
    repeat = "⎪";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "⎰") {
    top2 = "⎧";
    bottom2 = "⎭";
    repeat = "⎪";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "⎱") {
    top2 = "⎫";
    bottom2 = "⎩";
    repeat = "⎪";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top2, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom2, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path2 = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg = new SvgNode([path2], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg], options);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom2, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, _innerHeight, options));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top2, font, mode));
  }
  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner2 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), Style$1.TEXT, options, classes2);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
  var path2 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path2);
  var svg = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
};
var makeSqrtImage = function makeSqrtImage2(height, options) {
  var newOptions = options.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes2) {
  if (delim === "<" || delim === "\\lt" || delim === "⟨") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
    delim = "\\rangle";
  }
  if (utils$1.contains(stackLargeDelimiters, delim) || utils$1.contains(stackNeverDelimiters, delim)) {
    return makeLargeDelim(delim, size, false, options, mode, classes2);
  } else if (utils$1.contains(stackAlwaysDelimiters, delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes2);
  } else {
    throw new ParseError$2("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
  var start2 = Math.min(2, 3 - options.style.size);
  for (var i = start2; i < sequence.length; i++) {
    if (sequence[i].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes2) {
  if (delim === "<" || delim === "\\lt" || delim === "⟨") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
    delim = "\\rangle";
  }
  var sequence;
  if (utils$1.contains(stackNeverDelimiters, delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (utils$1.contains(stackLargeDelimiters, delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes2);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes2);
  } else {
    return makeStackedDelim(delim, height, center, options, mode, classes2);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes2) {
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes2);
};
var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && utils$1.contains(delimiters, symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError$2("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError$2("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node.setAttribute("fence", "true");
    } else {
      node.setAttribute("fence", "false");
    }
    node.setAttribute("stretchy", "true");
    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node.setAttribute("minsize", size);
    node.setAttribute("maxsize", size);
    return node;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color = context.parser.gullet.macros.get("\\current@color");
    if (color && typeof color !== "string") {
      throw new ParseError$2("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser2 = context.parser;
    ++parser2.leftrightDepth;
    var body = parser2.parseExpression(false);
    --parser2.leftrightDepth;
    parser2.expect("\\right", false);
    var right2 = assertNodeType(parser2.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser2.mode,
      body,
      left: delim.text,
      right: right2.delim,
      rightColor: right2.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i = 0; i < inner2.length; i++) {
      if (inner2[i].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner2[i].height, innerHeight);
        innerDepth = Math.max(inner2[i].depth, innerDepth);
      }
    }
    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    }
    inner2.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner2.length; _i++) {
        var middleDelim = inner2[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner2[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner2.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner2, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner2 = buildExpression2(group.body, options);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner2.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner2.push(rightNode);
    }
    return makeRow(inner2);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError$2("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options) => {
  var inner2 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils$1.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options);
    var newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
    inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path2 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path2)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner2.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner2.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner2.classes.push("anglpad");
    } else {
      inner2.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(
        options.fontMetrics().fboxrule,
        // default
        options.minRuleThickness
        // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner2.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner2.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner2,
          shift: 0
        }
      ]
    }, options);
  } else {
    var classes2 = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner2,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes2
        }
      ]
    }, options);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner2.height;
    vlist.depth = inner2.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};
var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
  switch (group.label) {
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node.setAttribute("notation", "box");
      break;
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node.setAttribute("lspace", fboxsep + "pt");
      node.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // user override
        );
        node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var color = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser: parser2
    } = _ref3;
    return {
      type: "enclose",
      mode: parser2.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser2.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser: parser2
    } = _ref5;
    return {
      type: "enclose",
      mode: parser2.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name, body) {
  _macros[name] = body;
}
function getHLines(parser2) {
  var hlineInfo = [];
  parser2.consumeSpaces();
  var nxt = parser2.fetch().text;
  if (nxt === "\\relax") {
    parser2.consume();
    parser2.consumeSpaces();
    nxt = parser2.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser2.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser2.consumeSpaces();
    nxt = parser2.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError$2("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
}
function parseArray(parser2, _ref, style2) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser2.gullet.beginGroup();
  if (!singleRow) {
    parser2.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError$2("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser2.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser2.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser2.gullet.macros.get("\\df@tag")) {
        tags.push(parser2.subparse([new Token("\\df@tag")]));
        parser2.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser2.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser2));
  while (true) {
    var cell = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser2.gullet.endGroup();
    parser2.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser2.mode,
      body: cell
    };
    if (style2) {
      cell = {
        type: "styling",
        mode: parser2.mode,
        style: style2,
        body: [cell]
      };
    }
    row.push(cell);
    var next = parser2.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError$2("Too many tab characters: &", parser2.nextToken);
        } else {
          parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser2.consume();
    } else if (next === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser2.consume();
      var size = void 0;
      if (parser2.gullet.future().text !== " ") {
        size = parser2.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser2));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError$2("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
    }
  }
  parser2.gullet.endGroup();
  parser2.gullet.endGroup();
  return {
    type: "array",
    mode: parser2.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r;
  var c;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,
    options.minRuleThickness
    // User override.
  );
  var pt = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt;
  var jot = 3 * pt;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i = 0; i < hlinesInGap.length; ++i) {
      if (i > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r = 0; r < group.body.length; ++r) {
    var inrow = group.body[r];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c = 0; c < inrow.length; ++c) {
      var elt = buildGroup$1(inrow[c], options);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c] = elt;
    }
    var rowGap = group.rowGaps[r];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r] = outrow;
    setHLinePos(hLinesBeforeRow[r + 1]);
  }
  var offset2 = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag2) => tag2)) {
    for (r = 0; r < nr; ++r) {
      var rw = body[r];
      var shift = rw.pos - offset2;
      var tag = group.tags[r];
      var tagSpan = void 0;
      if (tag === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift
      });
    }
  }
  for (
    c = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c < nc || colDescrNum < colDescriptions.length;
    ++c, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset2;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError$2("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils$1.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r = 0; r < nr; ++r) {
      var row = body[r];
      var elem = row[c];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset2;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils$1.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset2;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i = 0; i < group.body.length; i++) {
    var rw = group.body[i];
    var row = [];
    for (var j = 0; j < rw.length; j++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j], options)]));
    }
    if (group.tags && group.tags[i]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table.setAttribute("columnspacing", "0.5em");
  } else {
    table.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table = new mathMLTree.MathNode("menclose", [table]);
    table.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }
  return table;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i = 0; i < args[0].body.length; i++) {
      var textord2 = assertNodeType(args[0].body[i], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError$2("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError$2("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser2 = context.parser;
      parser2.consumeSpaces();
      if (parser2.fetch().text === "[") {
        parser2.consume();
        parser2.consumeSpaces();
        colAlign = parser2.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError$2("Expected l or c or r", parser2.nextToken);
        }
        parser2.consume();
        parser2.consumeSpaces();
        parser2.expect("]");
        parser2.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node = assertSymbolNodeType(nde);
      var ca = node.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError$2("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError$2("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError$2("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (utils$1.contains(["gather", "gather*"], context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError$2(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError$2("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError$2("No such environment: " + envName, nameGroup);
      }
      var env = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser2.parseArguments("\\begin{" + envName + "}", env);
      var context = {
        mode: parser2.mode,
        envName,
        parser: parser2
      };
      var result = env.handler(context, _args, optArgs);
      parser2.expect("\\end", false);
      var endNameToken = parser2.nextToken;
      var end2 = assertNodeType(parser2.parseFunction(), "environment");
      if (end2.name !== envName) {
        throw new ParseError$2("Mismatch: \\begin{" + envName + "} matched by \\end{" + end2.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser2.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser2.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils$1.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser2.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser2.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser: parser2,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser2;
    var body = parser2.parseExpression(true, breakOnTokenText);
    var style2 = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style2,
      body: {
        type: "ordgroup",
        mode: parser2.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size, originalStyle) => {
  var style2 = originalStyle;
  if (size === "display") {
    style2 = style2.id >= Style$1.SCRIPT.id ? style2.text() : Style$1.DISPLAY;
  } else if (size === "text" && style2.size === Style$1.DISPLAY.size) {
    style2 = Style$1.TEXT;
  } else if (size === "script") {
    style2 = Style$1.SCRIPT;
  } else if (size === "scriptscript") {
    style2 = Style$1.SCRIPTSCRIPT;
  }
  return style2;
};
var htmlBuilder$4 = (group, options) => {
  var style2 = adjustStyle(group.size, options.style);
  var nstyle = style2.fracNum();
  var dstyle = style2.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);
  if (group.continued) {
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style2.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    var axisHeight = options.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  }
  newOptions = options.havingStyle(style2);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
  var delimSize;
  if (style2.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style2.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};
var mathmlBuilder$3 = (group, options) => {
  var node = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style2 = adjustStyle(group.size, options.style);
  if (style2.size !== options.style.size) {
    node = new mathMLTree.MathNode("mstyle", [node]);
    var isDisplay = style2.size === Style$1.DISPLAY.size ? "true" : "false";
    node.setAttribute("displaystyle", isDisplay);
    node.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser2.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser2.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser2.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser: parser2
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser2.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser2.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser2.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options) => {
  var style2 = options.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style2.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style2.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};
var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser2.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser2.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser2.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser2.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    var math2 = buildExpressionRow(group.body, options);
    if (!(math2 instanceof MathNode)) {
      math2 = new MathNode("mrow", [math2]);
    }
    math2.setAttribute("href", group.href);
    return math2;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser2.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser2.formatUnsupportedCmd("\\url");
    }
    var chars2 = [];
    for (var i = 0; i < href.length; i++) {
      var c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars2.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    var body = {
      type: "text",
      mode: parser2.mode,
      font: "\\texttt",
      body: chars2
    };
    return {
      type: "href",
      mode: parser2.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "hbox",
      mode: parser2.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName,
      token
    } = _ref;
    var value2 = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser2.settings.strict) {
      parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value2;
        trustContext = {
          command: "\\htmlClass",
          class: value2
        };
        break;
      case "\\htmlId":
        attributes.id = value2;
        trustContext = {
          command: "\\htmlId",
          id: value2
        };
        break;
      case "\\htmlStyle":
        attributes.style = value2;
        trustContext = {
          command: "\\htmlStyle",
          style: value2
        };
        break;
      case "\\htmlData": {
        var data = value2.split(",");
        for (var i = 0; i < data.length; i++) {
          var keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError$2("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser2.settings.isTrusted(trustContext)) {
      return parser2.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser2.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    var classes2 = ["enclosing"];
    if (group.attributes.class) {
      classes2.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes2, elements, options);
    for (var attr in group.attributes) {
      if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
        span.setAttribute(attr, group.attributes[attr]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser2.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError$2("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError$2("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser: parser2
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i = 0; i < attributes.length; i++) {
        var keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width = sizeData(str);
              break;
            case "height":
              height = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError$2("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser2.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser2.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser2.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options) => {
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }
    var style2 = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style2.width = makeEm(width);
    }
    if (depth > 0) {
      style2.verticalAlign = makeEm(-depth);
    }
    var node = new Img(group.src, group.alt, style2);
    node.height = height;
    node.depth = depth;
    return node;
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mglyph", []);
    node.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node.setAttribute("valign", makeEm(-depth));
    }
    node.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options);
      node.setAttribute("width", makeEm(width));
    }
    node.setAttribute("src", group.src);
    return node;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var size = assertNodeType(args[0], "size");
    if (parser2.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
        }
        if (parser2.mode !== "math") {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser2.mode,
      dimension: size.value
    };
  },
  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser2.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2;
    if (group.alignment === "clap") {
      inner2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
    } else {
      inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node.height + node.depth);
    if (node.depth) {
      strut.style.verticalAlign = makeEm(-node.depth);
    }
    node.children.unshift(strut);
    node = buildCommon.makeSpan(["thinbox"], [node], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.alignment !== "rlap") {
      var offset2 = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset2 + "width");
    }
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser: parser2
    } = _ref;
    var outerMode = parser2.mode;
    parser2.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser2.parseExpression(false, close2);
    parser2.expect(close2);
    parser2.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser2.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError$2("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser2.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
var assembleSupSub = (base, supGroup, subGroup, options, style2, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils$1.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style2.sup()), options);
    sup2 = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style2.sub()), options);
    sub2 = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom2 = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom2,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub2) {
    var top2 = base.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top2,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup2) {
    var _bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    return base;
  }
  var parts2 = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts2.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts2, options);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style2 = options.style;
  var large = false;
  if (style2.size === Style$1.DISPLAY.size && group.symbol && !utils$1.contains(noSuccessor, group.name)) {
    large = true;
  }
  var base;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop");
      base.italic = italic;
    }
  } else if (group.body) {
    var inner2 = buildExpression$1(group.body, options, true);
    if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
      base = inner2[0];
      base.classes[0] = "mop";
    } else {
      base = buildCommon.makeSpan(["mop"], inner2, options);
    }
  } else {
    var output = [];
    for (var i = 1; i < group.name.length; i++) {
      output.push(buildCommon.mathsym(group.name[i], group.mode, options));
    }
    base = buildCommon.makeSpan(["mop"], output, options);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
    slant = base.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style2, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }
    return base;
  }
};
var mathmlBuilder$1 = (group, options) => {
  var node;
  if (group.symbol) {
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (utils$1.contains(noSuccessor, group.name)) {
      node.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node = new MathNode("mo", buildExpression2(group.body, options));
  } else {
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("⁡", "text")]);
    if (group.parentIsSupSub) {
      node = new MathNode("mrow", [node, operator]);
    } else {
      node = newDocumentFragment([node, operator]);
    }
  }
  return node;
};
var singleCharBigOps = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser2.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser: parser2,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser: parser2,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser2.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser: parser2,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser2.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options.withFont("mathrm"), true);
    for (var i = 0; i < expression.length; i++) {
      var child = expression[i];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};
var mathmlBuilder2 = (group, options) => {
  var expression = buildExpression2(group.body, options.withFont("mathrm"));
  var isAllString = true;
  for (var i = 0; i < expression.length; i++) {
    var node = expression[i];
    if (node instanceof mathMLTree.SpaceNode)
      ;
    else if (node instanceof mathMLTree.MathNode) {
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node2) => node2.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser2.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },
  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
    node.setAttribute("accent", "true");
    return node;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser: parser2
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser2.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner2);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser: parser2
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node.height = 0;
    node.depth = 0;
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        node.children[i].height = 0;
        node.children[i].depth = 0;
      }
    }
    node = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [node], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser: parser2
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser2.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner2 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner2 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner2);
    var node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser2.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node.setAttribute("voffset", dy);
    return node;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "internal",
      mode: parser2.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var shift = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser2.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift);
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;
    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options) {
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift = group.shift ? calculateSize(group.shift, options) : 0;
    var color = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift >= 0) {
      wrapper.setAttribute("height", makeEm(shift));
    } else {
      wrapper.setAttribute("height", makeEm(shift));
      wrapper.setAttribute("depth", makeEm(-shift));
    }
    wrapper.setAttribute("voffset", makeEm(shift));
    return wrapper;
  }
});
function sizingGroup(value2, options, baseOptions) {
  var inner2 = buildExpression$1(value2, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i = 0; i < inner2.length; i++) {
    var pos = inner2[i].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner2[i].classes, options.sizingClasses(baseOptions));
    } else if (inner2[i].classes[pos + 1] === "reset-size" + options.size) {
      inner2[i].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner2[i].height *= multiplier;
    inner2[i].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner2);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options) => {
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser: parser2
    } = _ref;
    var body = parser2.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser2.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser: parser2
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i = 0; i < tbArg.body.length; ++i) {
        var node = tbArg.body[i];
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser2.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node;
    }
    if (group.smashHeight) {
      node.height = 0;
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          node.children[i].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node.depth = 0;
      if (node.children) {
        for (var _i = 0; _i < node.children.length; _i++) {
          node.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }
    return node;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser: parser2
    } = _ref;
    var index = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser2.mode,
      body,
      index
    };
  },
  htmlBuilder(group, options) {
    var inner2 = buildGroup$1(group.body, options.havingCrampedStyle());
    if (inner2.height === 0) {
      inner2.height = options.fontMetrics().xHeight;
    }
    inner2 = buildCommon.wrapFragment(inner2, options);
    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner2.height + inner2.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
    }
    var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
    inner2.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner2,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner2.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder(group, options) {
    var {
      body,
      index
    } = group;
    return index ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser: parser2
    } = _ref;
    var body = parser2.parseExpression(true, breakOnTokenText);
    var style2 = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser2.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: style2,
      body
    };
  },
  htmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner2 = buildExpression2(group.body, newOptions);
    var node = new mathMLTree.MathNode("mstyle", inner2);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr = styleAttributes[group.style];
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);
    return node;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
  var base = group.base;
  if (!base) {
    return null;
  } else if (base.type === "op") {
    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils$1.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options) {
    var builderDelegate = htmlBuilderDelegate(group, options);
    if (builderDelegate) {
      return builderDelegate(group, options);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils$1.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);
      if (!isCharacterBox3) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options);
      if (!isCharacterBox3) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder(group, options) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup2(group.base, options)];
    if (group.sub) {
      children.push(buildGroup2(group.sub, options));
    }
    if (group.sup) {
      children.push(buildGroup2(group.sup, options));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;
      if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options);
      if (variant === "bold-italic") {
        node.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node.setAttribute("stretchy", "false");
    }
    return node;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder(group, options) {
    var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder(group, options) {
    var text2 = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node;
    if (group.mode === "text") {
      node = new mathMLTree.MathNode("mtext", [text2]);
    } else if (/[0-9]/.test(group.text)) {
      node = new mathMLTree.MathNode("mn", [text2]);
    } else if (group.text === "\\prime") {
      node = new mathMLTree.MathNode("mo", [text2]);
    } else {
      node = new mathMLTree.MathNode("mi", [text2]);
    }
    if (variant !== defaultVariant[node.type]) {
      node.setAttribute("mathvariant", variant);
    }
    return node;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError$2('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options) {
    var node;
    if (regularSpace.hasOwnProperty(group.text)) {
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError$2('Unknown type of space "' + group.text + '"');
    }
    return node;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options) {
    var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table.setAttribute("width", "100%");
    return table;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options) => {
  var font = group.font;
  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
  }
  return options.withTextFontShape(textFontShapes[font]);
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser2.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner2 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
  },
  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "underline",
      mode: parser2.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options);
    var line = buildCommon.makeLineSpan("underline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
    operator.setAttribute("stretchy", "true");
    var node = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
    node.setAttribute("accentunder", "true");
    return node;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser: parser2
    } = _ref;
    return {
      type: "vcenter",
      mode: parser2.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError$2("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options) {
    var text2 = makeVerb(group);
    var body = [];
    var newOptions = options.havingStyle(options.style.text());
    for (var i = 0; i < text2.length; i++) {
      var c = text2[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options) {
    var text2 = new mathMLTree.TextNode(makeVerb(group));
    var node = new mathMLTree.MathNode("mtext", [text2]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "␣" : " ");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[̀-ͯ]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
class Lexer2 {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char, code) {
    this.catcodes[char] = code;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError$2("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text2 = match[6] || match[3] || (match[2] ? "\\ " : " ");
    if (this.catcodes[text2] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text2, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}
class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError$2("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (this.current.hasOwnProperty(name)) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name, value2, global2) {
    if (global2 === void 0) {
      global2 = false;
    }
    if (global2) {
      for (var i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value2;
      }
    } else {
      var top2 = this.undefStack[this.undefStack.length - 1];
      if (top2 && !top2.hasOwnProperty(name)) {
        top2[name] = this.current[name];
      }
    }
    if (value2 == null) {
      delete this.current[name];
    } else {
      this.current[name] = value2;
    }
  }
}
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token = context.popToken();
  var base;
  var number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError$2("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    number = digitToNumber[token.text];
    if (number == null || number >= base) {
      throw new ParseError$2("Invalid base-" + base + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number *= base;
      number += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number + "}";
});
var newcommand = (context, existsOK, nonexistsOK) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError$2("\\newcommand's first argument must be a macro name");
  }
  var name = arg[0].text;
  var exists = context.isDefined(name);
  if (exists && !existsOK) {
    throw new ParseError$2("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError$2("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError$2("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  context.macros.set(name, {
    tokens: arg,
    numArgs
  });
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name = tok.text;
  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
defineMacro("ℬ", "\\mathscr{B}");
defineMacro("ℰ", "\\mathscr{E}");
defineMacro("ℱ", "\\mathscr{F}");
defineMacro("ℋ", "\\mathscr{H}");
defineMacro("ℐ", "\\mathscr{I}");
defineMacro("ℒ", "\\mathscr{L}");
defineMacro("ℳ", "\\mathscr{M}");
defineMacro("ℛ", "\\mathscr{R}");
defineMacro("ℭ", "\\mathfrak{C}");
defineMacro("ℌ", "\\mathfrak{H}");
defineMacro("ℨ", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("·", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
defineMacro("\\ne", "\\neq");
defineMacro("≠", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
defineMacro("∉", "\\notin");
defineMacro("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
defineMacro("⟂", "\\perp");
defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("∌", "\\notni");
defineMacro("⌜", "\\ulcorner");
defineMacro("⌝", "\\urcorner");
defineMacro("⌞", "\\llcorner");
defineMacro("⌟", "\\lrcorner");
defineMacro("©", "\\copyright");
defineMacro("®", "\\textregistered");
defineMacro("️", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("⋮", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (utils$1.contains(["bin", "rel"], symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError$2("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("∷", "\\dblcolon");
defineMacro("∹", "\\eqcolon");
defineMacro("≔", "\\coloneqq");
defineMacro("≕", "\\eqqcolon");
defineMacro("⩴", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
defineMacro("⟦", "\\llbracket");
defineMacro("⟧", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
defineMacro("⦃", "\\lBrace");
defineMacro("⦄", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
defineMacro("⦵", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one2) => (context) => {
  var left2 = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right2 = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one2) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right2,
    ...arg,
    ...left2
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer2(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start2;
    var end2;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start2 = this.popToken();
      ({
        tokens,
        end: end2
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start: start2,
        end: end2
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end2.loc));
    this.pushTokens(tokens);
    return start2.range(end2, "");
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    var tokens = [];
    var isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start2 = this.future();
    var tok;
    var depth = 0;
    var match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError$2("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError$2("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }
      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start2.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start: start2,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError$2("The length of delimiters doesn't match the number of args!");
      }
      var delims = delimiters2[0];
      for (var i = 0; i < delims.length; i++) {
        var tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError$2("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(amount) {
    this.expansionCount += amount;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError$2("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError$2("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.countExpansion(1);
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i = tokens.length - 1; i >= 0; --i) {
        var tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError$2("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i];
          if (tok.text === "#") {
            tokens.splice(i + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError$2("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    var tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    var definition = this.macros.get(name);
    if (definition == null) {
      return definition;
    }
    if (name.length === 1) {
      var catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer2(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    var macro = this.macros.get(name);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;
  }
}
var unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
var uSubsAndSups = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  "ʰ": "h",
  "ⁱ": "i",
  "ʲ": "j",
  "ᵏ": "k",
  "ˡ": "l",
  "ᵐ": "m",
  "ⁿ": "n",
  "ᵒ": "o",
  "ᵖ": "p",
  "ʳ": "r",
  "ˢ": "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  "ʷ": "w",
  "ˣ": "x",
  "ʸ": "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
});
var unicodeAccents = {
  "́": {
    "text": "\\'",
    "math": "\\acute"
  },
  "̀": {
    "text": "\\`",
    "math": "\\grave"
  },
  "̈": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "̃": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "̄": {
    "text": "\\=",
    "math": "\\bar"
  },
  "̆": {
    "text": "\\u",
    "math": "\\breve"
  },
  "̌": {
    "text": "\\v",
    "math": "\\check"
  },
  "̂": {
    "text": "\\^",
    "math": "\\hat"
  },
  "̇": {
    "text": "\\.",
    "math": "\\dot"
  },
  "̊": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "̋": {
    "text": "\\H"
  },
  "̧": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "ḉ": "ḉ",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ç": "ç",
  "ď": "ď",
  "ḋ": "ḋ",
  "ḑ": "ḑ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ḝ": "ḝ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ȩ": "ȩ",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ģ": "ģ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "ḩ": "ḩ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ķ": "ķ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ļ": "ļ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ņ": "ņ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ŗ": "ŗ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ş": "ş",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ţ": "ţ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Ḉ": "Ḉ",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ç": "Ç",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "Ḑ": "Ḑ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ḝ": "Ḝ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ȩ": "Ȩ",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ģ": "Ģ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Ḩ": "Ḩ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ķ": "Ķ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ļ": "Ļ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ņ": "Ņ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ŗ": "Ŗ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ş": "Ş",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ţ": "Ţ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};
let Parser$1 = class Parser2 {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text2, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text2) {
      throw new ParseError$2("Expected '" + text2 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse2 = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse2;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse2 = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse2;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (Parser2.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError$2("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group = this.parseGroup(name);
    if (!group) {
      throw new ParseError$2("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text2) {
    var textordArray = [];
    for (var i = 0; i < text2.length; i++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text2[i]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base = this.parseGroup("atom", breakOnTokenText);
    if (this.mode === "text") {
      return base;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError$2("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError$2("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError$2("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError$2("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var isSub = unicodeSubRegEx.test(lex.text);
        var subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        while (true) {
          var token = this.fetch().text;
          if (!uSubsAndSups[token]) {
            break;
          }
          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        var body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError$2("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError$2("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError$2("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError$2("No function handler for " + name);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i = 0; i < totalArgs; i++) {
      var argType = funcData.argTypes && funcData.argTypes[i];
      var isOptional = i < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError$2("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError$2("A primitive argument cannot be optional");
        }
        var _group = this.parseGroup(name);
        if (_group == null) {
          throw new ParseError$2("Expected group as " + name, this.fetch());
        }
        return _group;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError$2("Unknown group type as " + name, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError$2("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match) {
      throw new ParseError$2("Invalid color: '" + res.text + "'", res);
    }
    var color = match[0];
    if (/^[0-9a-f]{6}$/i.test(color)) {
      color = "#" + color;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match) {
      throw new ParseError$2("Invalid size: '" + res.text + "'", res);
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError$2("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url2 = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: url2
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name, breakOnTokenText) {
    var firstToken = this.fetch();
    var text2 = firstToken.text;
    var result;
    if (text2 === "{" || text2 === "\\begingroup") {
      this.consume();
      var groupEnd = text2 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text2 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text2[0] === "\\" && !implicitCommands.hasOwnProperty(text2)) {
        if (this.settings.throwOnError) {
          throw new ParseError$2("Undefined control sequence: " + text2, firstToken);
        }
        result = this.formatUnsupportedCmd(text2);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n = group.length - 1;
    for (var i = 0; i < n; ++i) {
      var a = group[i];
      var v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text2 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text2)) {
      this.consume();
      var arg = text2.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError$2("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text2[0]) && !symbols[this.mode][text2[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      text2 = unicodeSymbols[text2[0]] + text2.slice(1);
    }
    var match = combiningDiacriticalMarksEndRegex.exec(text2);
    if (match) {
      text2 = text2.substring(0, match.index);
      if (text2 === "i") {
        text2 = "ı";
      } else if (text2 === "j") {
        text2 = "ȷ";
      }
    }
    var symbol;
    if (symbols[this.mode][text2]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text2) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text2[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text2].group;
      var loc = SourceLocation.range(nucleus);
      var s;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text2
        };
      } else {
        s = {
          type: group,
          mode: this.mode,
          loc,
          text: text2
        };
      }
      symbol = s;
    } else if (text2.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text2.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text2[0] + '"' + (" (" + text2.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text2[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text2
      };
    } else {
      return null;
    }
    this.consume();
    if (match) {
      for (var i = 0; i < match[0].length; i++) {
        var accent2 = match[0][i];
        if (!unicodeAccents[accent2]) {
          throw new ParseError$2("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError$2("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
};
Parser$1.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser2 = new Parser$1(toParse, settings);
  delete parser2.gullet.macros.current["\\df@tag"];
  var tree = parser2.parse();
  delete parser2.gullet.macros.current["\\current@color"];
  delete parser2.gullet.macros.current["\\color"];
  if (parser2.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError$2("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser2.subparse([new Token("\\df@tag")])
    }];
  }
  return tree;
};
var render$1 = function render(expression, baseNode, options) {
  baseNode.textContent = "";
  var node = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render$1 = function render3() {
      throw new ParseError$2("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options) {
  var settings = new Settings$1(options);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError$2)) {
    throw error;
  }
  var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node.setAttribute("title", error.toString());
  node.setAttribute("style", "color:" + options.errorColor);
  return node;
};
var renderToDomTree = function renderToDomTree2(expression, options) {
  var settings = new Settings$1(options);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
  var settings = new Settings$1(options);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};
var katex = {
  /**
   * Current KaTeX version
   */
  version: "0.16.11",
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: render$1,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: ParseError$2,
  /**
   * The shema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: {
    Span,
    Anchor,
    SymbolNode,
    SvgNode,
    PathNode,
    LineNode
  }
};
const inlineRule = /^(\${1,2})(?!\$)((?:\\.|[^\\\n])*?(?:\\.|[^\\\n\$]))\1(?=[\s?!\.,:？！。，：]|$)/;
const inlineRuleNonStandard = /^(\${1,2})(?!\$)((?:\\.|[^\\\n])*?(?:\\.|[^\\\n\$]))\1/;
const blockRule = /^(\${1,2})\n((?:\\[^]|[^\\])+?)\n\1(?:\n|$)/;
function markedKatex(options = {}) {
  return {
    extensions: [
      inlineKatex(options, createRenderer(options, false)),
      blockKatex(options, createRenderer(options, true))
    ]
  };
}
function createRenderer(options, newlineAfter) {
  return (token) => katex.renderToString(token.text, { ...options, displayMode: token.displayMode }) + (newlineAfter ? "\n" : "");
}
function inlineKatex(options, renderer) {
  const nonStandard = options && options.nonStandard;
  const ruleReg = nonStandard ? inlineRuleNonStandard : inlineRule;
  return {
    name: "inlineKatex",
    level: "inline",
    start(src) {
      let index;
      let indexSrc = src;
      while (indexSrc) {
        index = indexSrc.indexOf("$");
        if (index === -1) {
          return;
        }
        const f = nonStandard ? index > -1 : index === 0 || indexSrc.charAt(index - 1) === " ";
        if (f) {
          const possibleKatex = indexSrc.substring(index);
          if (possibleKatex.match(ruleReg)) {
            return index;
          }
        }
        indexSrc = indexSrc.substring(index + 1).replace(/^\$+/, "");
      }
    },
    tokenizer(src, tokens) {
      const match = src.match(ruleReg);
      if (match) {
        return {
          type: "inlineKatex",
          raw: match[0],
          text: match[2].trim(),
          displayMode: match[1].length === 2
        };
      }
    },
    renderer
  };
}
function blockKatex(options, renderer) {
  return {
    name: "blockKatex",
    level: "block",
    tokenizer(src, tokens) {
      const match = src.match(blockRule);
      if (match) {
        return {
          type: "blockKatex",
          raw: match[0],
          text: match[2].trim(),
          displayMode: match[1].length === 2
        };
      }
    },
    renderer
  };
}
const _sfc_main$L = {
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#53B745"
    }
  }
};
const _hoisted_1$E = ["fill"];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "18",
    height: "18",
    viewBox: "0 0 18 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M0.666626 9.00033C0.666626 4.39795 4.39759 0.666992 8.99996 0.666992C13.6023 0.666992 17.3333 4.39795 17.3333 9.00033C17.3333 13.6027 13.6023 17.3337 8.99996 17.3337C4.39759 17.3337 0.666626 13.6027 0.666626 9.00033ZM12.0892 7.92291C12.4147 7.59748 12.4147 7.06984 12.0892 6.7444C11.7638 6.41897 11.2361 6.41897 10.9107 6.7444L8.16663 9.48848L7.08922 8.41107C6.76378 8.08563 6.23614 8.08563 5.9107 8.41107C5.58527 8.73651 5.58527 9.26414 5.9107 9.58958L7.57737 11.2562C7.90281 11.5817 8.43045 11.5817 8.75588 11.2562L12.0892 7.92291Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$E)
  ], 2);
}
const CheckIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["render", _sfc_render$o]]);
const _sfc_main$K = {
  name: "InfoIcon",
  props: {
    fill: {
      type: String,
      default: "#282828"
    }
  }
};
const _hoisted_1$D = {
  width: "18",
  height: "18",
  viewBox: "0 0 18 18",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$D, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M9.00033 17.3327C13.6027 17.3327 17.3337 13.6017 17.3337 8.99935C17.3337 4.39698 13.6027 0.666016 9.00033 0.666016C4.39795 0.666016 0.666992 4.39698 0.666992 8.99935C0.666992 13.6017 4.39795 17.3327 9.00033 17.3327ZM9.00033 12.3327C10.8413 12.3327 12.3337 10.8403 12.3337 8.99935C12.3337 7.1584 10.8413 5.66602 9.00033 5.66602C7.15938 5.66602 5.66699 7.1584 5.66699 8.99935C5.66699 10.8403 7.15938 12.3327 9.00033 12.3327Z",
      fill: "#0075FF"
    }, null, -1)
  ]));
}
const Shape1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["render", _sfc_render$n]]);
const RedExclamation_vue_vue_type_style_index_0_scoped_c6596ad5_lang = "";
const _sfc_main$J = {
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
const _hoisted_1$C = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none"
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$C, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      d: "M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z",
      stroke: "#E2462C",
      "stroke-width": "1.8",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1),
    vue.createElementVNode("path", {
      d: "M12 7.5V12.75",
      stroke: "#E2462C",
      "stroke-width": "1.8",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1),
    vue.createElementVNode("path", {
      d: "M12 17.0625C12.5178 17.0625 12.9375 16.6428 12.9375 16.125C12.9375 15.6072 12.5178 15.1875 12 15.1875C11.4822 15.1875 11.0625 15.6072 11.0625 16.125C11.0625 16.6428 11.4822 17.0625 12 17.0625Z",
      fill: "#E2462C"
    }, null, -1)
  ]));
}
const RedExclamation = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["render", _sfc_render$m], ["__scopeId", "data-v-c6596ad5"]]);
const LoadingMessage_vue_vue_type_style_index_0_scoped_63042916_lang = "";
const _hoisted_1$B = { class: "vdb-c-flex vdb-c-items-center vdb-c-space-x-2" };
const _hoisted_2$n = {
  class: "vdb-c-text-gray-500",
  key: "progress"
};
const _hoisted_3$j = { key: 3 };
const _hoisted_4$g = { class: "vdb-c-font-semibold" };
const _sfc_main$I = {
  __name: "LoadingMessage",
  props: {
    status: {
      type: String,
      required: true,
      validator: (value2) => ["progress", "success", "error"].includes(value2)
    },
    message: {
      type: String
    },
    isFocused: {
      type: Boolean,
      default: false
    },
    isLastConv: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const messageKey = vue.ref(0);
    vue.watch(
      () => props.message,
      () => {
        if (props.status === "progress") {
          messageKey.value++;
        }
      }
    );
    vue.watch(
      () => props.status,
      (newStatus) => {
        console.log("Status changed:", newStatus, "Message:", props.message);
      },
      { immediate: true }
    );
    vue.watch(
      () => props.isFocused,
      (newFocused) => {
        console.log("Focus changed:", newFocused, "Message:", props.message);
      },
      { immediate: true }
    );
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$B, [
        vue.createVNode(vue.Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: vue.withCtx(() => [
            __props.status === "progress" ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$n, [
              vue.createVNode(vue.Transition, {
                name: "fade",
                mode: "out-in"
              }, {
                default: vue.withCtx(() => [
                  (vue.openBlock(), vue.createElementBlock("span", { key: __props.message }, vue.toDisplayString(__props.message || "Thinking..."), 1))
                ]),
                _: 1
              })
            ])) : __props.status === "success" ? (vue.openBlock(), vue.createElementBlock("span", {
              class: vue.normalizeClass([
                "vdb-c-flex vdb-c-items-center vdb-c-gap-8 vdb-c-font-semibold vdb-c-text-[#333]",
                { "vdb-c-text-vdb-green": __props.isFocused }
              ]),
              key: "success"
            }, [
              vue.createVNode(CheckIcon, {
                class: vue.normalizeClass({ bounce: __props.isLastConv }),
                fill: __props.isFocused ? "#53B745" : "#EC5B16"
              }, null, 8, ["class", "fill"]),
              vue.createElementVNode("span", null, vue.toDisplayString(__props.message || "Here is your response"), 1)
            ], 2)) : __props.status === "error" ? (vue.openBlock(), vue.createElementBlock("span", {
              class: vue.normalizeClass([
                "vdb-c-flex vdb-c-items-center vdb-c-gap-8 vdb-c-text-primary",
                {
                  "vdb-c-font-semibold": __props.isFocused
                }
              ]),
              key: "error"
            }, [
              vue.createElementVNode("span", null, vue.toDisplayString(__props.message || "An error occurred"), 1)
            ], 2)) : __props.status === "unknown" ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3$j, [
              vue.createVNode(Shape1),
              vue.createElementVNode("span", _hoisted_4$g, vue.toDisplayString(__props.message || "Here is your response"), 1)
            ])) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const LoadingMessage = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__scopeId", "data-v-63042916"]]);
const TextResponse_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$A = { class: "vdb-c-relative vdb-c-flex vdb-c-w-full vdb-c-flex-col vdb-c-gap-8 vdb-c-bg-white vdb-c-py-14 vdb-c-text-left" };
const _hoisted_2$m = {
  key: 0,
  class: "vdb-c-flex vdb-c-flex-col"
};
const _hoisted_3$i = ["innerHTML"];
const _hoisted_4$f = {
  key: 1,
  class: "vdb-c-flex-start vdb-c-flex vdb-c-flex-col"
};
const _sfc_main$H = {
  __name: "TextResponse",
  props: {
    content: {
      type: Object,
      required: true
    },
    isUser: {
      type: Boolean,
      default: false
    },
    mediaTypesObject: {
      type: Object,
      default: () => ({})
    },
    isLastConv: {
      type: Boolean,
      default: false
    },
    convId: {
      type: String,
      default: ""
    },
    msgId: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const options = {
      nonStandard: true
    };
    const props = __props;
    const text2 = vue.computed(() => {
      var _a;
      return ((_a = props.content) == null ? void 0 : _a.text) || "";
    });
    const { conversations } = useVideoDBChat();
    const getMarkedMsg = (msg) => {
      marked.use(markedKatex(options));
      return marked.parse(msg);
    };
    const isMainReponse = vue.computed(() => props.content.agent_name === "assistant");
    const message = vue.computed(() => {
      var _a;
      return (_a = conversations == null ? void 0 : conversations[props.convId]) == null ? void 0 : _a[props.msgId];
    });
    return (_ctx, _cache) => {
      var _a;
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$A, [
        !__props.isUser ? (vue.openBlock(), vue.createBlock(LoadingMessage, {
          key: 0,
          status: isMainReponse.value && message.value.status === "error" ? "error" : __props.content.status,
          message: (_a = __props.content) == null ? void 0 : _a.status_message,
          "is-focused": isMainReponse.value,
          "is-last-conv": __props.isLastConv
        }, null, 8, ["status", "message", "is-focused", "is-last-conv"])) : vue.createCommentVNode("", true),
        vue.createVNode(vue.Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: vue.withCtx(() => [
            __props.content.status === "success" || __props.content.status === "error" || __props.isUser ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$m, [
              vue.createElementVNode("p", {
                class: vue.normalizeClass([
                  "markdown-body vdb-c-overflow-hidden vdb-c-text-kilvish-900",
                  __props.isUser ? "vdb-c-font-semibold" : "vdb-c-font-normal"
                ]),
                innerHTML: getMarkedMsg(text2.value)
              }, null, 10, _hoisted_3$i)
            ])) : __props.content.status === "progress" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$f, _cache[0] || (_cache[0] = [
              vue.createElementVNode("div", { class: "vdb-c-mb-2 vdb-c-h-16 vdb-c-w-3/4 vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-gray-200" }, null, -1),
              vue.createElementVNode("div", { class: "vdb-c-mb-2 vdb-c-h-16 vdb-c-w-1/2 vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-gray-200" }, null, -1),
              vue.createElementVNode("div", { class: "vdb-c-h-16 vdb-c-w-2/3 vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-gray-200" }, null, -1)
            ]))) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const _sfc_main$G = {
  props: {
    className: {
      type: String,
      default: ""
    },
    strokeWidth: {
      type: Number,
      default: 1.5
    },
    strokeColor: {
      type: String,
      default: "#20557D"
    }
  }
};
const _hoisted_1$z = { id: "Chevron down" };
const _hoisted_2$l = ["stroke", "stroke-width"];
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", null, [
    (vue.openBlock(), vue.createElementBlock("svg", {
      class: vue.normalizeClass($props.className),
      width: "16",
      height: "16",
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      vue.createElementVNode("g", _hoisted_1$z, [
        vue.createElementVNode("path", {
          id: "Icon",
          d: "M12.6668 6L8.00016 10.6667L3.3335 6",
          stroke: $props.strokeColor,
          "stroke-width": $props.strokeWidth,
          "stroke-linecap": "round",
          "stroke-linejoin": "round"
        }, null, 8, _hoisted_2$l)
      ])
    ], 2))
  ]);
}
const ChevronDown = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["render", _sfc_render$l]]);
const ChatMessageSteps_vue_vue_type_style_index_0_scoped_8e73daeb_lang = "";
const _hoisted_1$y = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-16" };
const _hoisted_2$k = {
  key: 0,
  class: "vdb-c-shadow-sm vdb-c-overflow-hidden vdb-c-rounded-md vdb-c-bg-white"
};
const _hoisted_3$h = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-12 vdb-c-overflow-y-auto" };
const _hoisted_4$e = { class: "vdb-c-flex vdb-c-h-20 vdb-c-w-20 vdb-c-items-center vdb-c-justify-center" };
const _hoisted_5$b = {
  key: 0,
  class: "vdb-c-text-[#D9D9D9]"
};
const _hoisted_6$8 = ["innerHTML"];
const _sfc_main$F = {
  __name: "ChatMessageSteps",
  props: {
    steps: {
      type: Array,
      default: () => []
    },
    status: {
      type: String,
      default: "progress"
    },
    expanded: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const isExpanded = vue.ref(props.expanded);
    vue.watch(
      () => props.expanded,
      (newValue) => {
        if (!newValue) {
          isExpanded.value = false;
        }
      }
    );
    const toggleExpand = () => {
      isExpanded.value = !isExpanded.value;
    };
    const displaySteps = vue.computed(() => {
      if (props.steps.length === 0) {
        return ["Thinking"];
      }
      if (props.status === "success") {
        return [...props.steps, "Final cut ready!"];
      }
      return props.steps;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$y, [
        vue.createElementVNode("button", {
          onClick: toggleExpand,
          class: "vdb-c-focus:outline-none vdb-c-flex vdb-c-items-center vdb-c-gap-8"
        }, [
          vue.createVNode(ChevronDown, {
            class: vue.normalizeClass({ "vdb-c-rotate-180 vdb-c-transform": isExpanded.value }),
            "stroke-width": 2,
            "stroke-color": "#343E4F"
          }, null, 8, ["class"]),
          _cache[0] || (_cache[0] = vue.createElementVNode("span", { class: "vdb-c-font-medium vdb-c-text-black" }, "Agent's Log", -1))
        ]),
        vue.createVNode(vue.Transition, {
          "enter-active-class": "vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-out",
          "enter-from-class": "vdb-c-transform vdb-c-scale-95 vdb-c-opacity-0",
          "enter-to-class": "vdb-c-transform vdb-c-scale-100 vdb-c-opacity-100",
          "leave-active-class": "vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in",
          "leave-from-class": "vdb-c-transform vdb-c-scale-100 vdb-c-opacity-100",
          "leave-to-class": "vdb-c-transform vdb-c-scale-95 vdb-c-opacity-0"
        }, {
          default: vue.withCtx(() => [
            isExpanded.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$k, [
              vue.createElementVNode("div", _hoisted_3$h, [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(displaySteps.value, (step, index) => {
                  return vue.openBlock(), vue.createElementBlock("div", {
                    key: index,
                    class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8"
                  }, [
                    vue.createElementVNode("span", _hoisted_4$e, [
                      index !== displaySteps.value.length - 1 ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_5$b, "|")) : (vue.openBlock(), vue.createElementBlock("div", {
                        key: 1,
                        class: vue.normalizeClass([
                          "vdb-c-block vdb-c-h-1/2 vdb-c-w-10 vdb-c-rounded-full",
                          __props.status === "progress" ? "vdb-c-animate-pulse vdb-c-bg-orange-500" : __props.status === "success" ? "vdb-c-bg-[#0AA910]" : "vdb-c-bg-[#0075FF]"
                        ])
                      }, null, 2))
                    ]),
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(["vdb-c-flex-grow", {
                        "vdb-c-font-semibold vdb-c-text-[#0075FF]": __props.status !== "success" && index === displaySteps.value.length - 1,
                        "vdb-c-font-semibold vdb-c-text-green": __props.status === "success" && index === displaySteps.value.length - 1,
                        "vdb-c-font-medium vdb-c-text-kilvish-800": !(__props.status === "success" && index === displaySteps.value.length - 1)
                      }]),
                      innerHTML: step.replace(
                        /@(\w+)/g,
                        "<span class='vdb-c-text-orange-500'>@$1</span>"
                      )
                    }, null, 10, _hoisted_6$8)
                  ]);
                }), 128))
              ])
            ])) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const ChatMessageSteps = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__scopeId", "data-v-8e73daeb"]]);
const ChatMessage_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$x = { class: "message-width" };
const _hoisted_2$j = {
  key: 0,
  class: "vdb-c-w-full vdb-c-transform vdb-c-transition-all"
};
const _hoisted_3$g = { key: 1 };
const _hoisted_4$d = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-8" };
const _hoisted_5$a = { class: "vdb-c-py-14" };
const _sfc_main$E = {
  __name: "ChatMessage",
  props: {
    message: {
      type: Object,
      default: () => ({})
    },
    isStaticPage: {
      type: Boolean,
      default: false
    },
    isLastConv: {
      type: Boolean,
      default: false
    },
    messageList: {
      type: Array,
      required: true
    },
    currentIndex: {
      type: Number,
      required: true
    },
    messageLoading: {
      type: Boolean,
      default: false
    },
    searchTerm: {
      type: String,
      default: ""
    },
    isLastConv: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const { messageHandlers } = useVideoDBChat();
    const isUser = vue.computed(() => props.message.msg_type === "input");
    const isAssistant = vue.computed(() => props.message.msg_type === "output");
    const isSystem = vue.computed(() => props.message.msg_type === "system");
    const finalStatus = vue.computed(() => {
      var _a, _b;
      if (props.message.status === "error") {
        return "error";
      }
      const assistantContent = (_b = (_a = props.message) == null ? void 0 : _a.content) == null ? void 0 : _b.find(
        (c) => c.agent_name === "assistant"
      );
      return (assistantContent == null ? void 0 : assistantContent.status) || props.message.status;
    });
    return (_ctx, _cache) => {
      return !isSystem.value ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass([
          "vdb-c-flex vdb-c-h-auto vdb-c-w-full vdb-c-justify-start vdb-c-py-14",
          {
            "vdb-c-border-b vdb-c-border-kilvish-300 vdb-c-bg-white": isUser.value
          }
        ])
      }, [
        vue.createElementVNode("div", _hoisted_1$x, [
          isUser.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$j, [
            vue.createVNode(_sfc_main$H, {
              content: __props.message.content[0],
              "is-user": true,
              "conv-id": __props.message.conv_id,
              "msg-id": __props.message.msg_id
            }, null, 8, ["content", "conv-id", "msg-id"])
          ])) : isAssistant.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$g, [
            vue.createElementVNode("div", _hoisted_4$d, [
              vue.createElementVNode("div", _hoisted_5$a, [
                vue.createVNode(ChatMessageSteps, {
                  steps: __props.message.actions,
                  status: finalStatus.value,
                  expanded: __props.isLastConv && __props.message.status !== "success"
                }, null, 8, ["steps", "status", "expanded"])
              ]),
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.message.content, (content) => {
                return vue.openBlock(), vue.createElementBlock("div", null, [
                  Object.keys(vue.unref(messageHandlers)).includes(content.type) ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(vue.unref(messageHandlers)[content.type]), {
                    key: 0,
                    "is-last-conv": __props.isLastConv,
                    content,
                    "is-user": isUser.value,
                    "search-term": __props.searchTerm,
                    "conv-id": __props.message.conv_id,
                    "msg-id": __props.message.msg_id
                  }, null, 8, ["is-last-conv", "content", "is-user", "search-term", "conv-id", "msg-id"])) : vue.createCommentVNode("", true)
                ]);
              }), 256))
            ])
          ])) : vue.createCommentVNode("", true)
        ])
      ], 2)) : vue.createCommentVNode("", true);
    };
  }
};
const ChatMessageContainer_vue_vue_type_style_index_0_lang = "";
const _sfc_main$D = {
  __name: "ChatMessageContainer",
  props: {
    conversation: {
      type: Object,
      default: () => ({})
    },
    isStaticPage: {
      type: Boolean,
      default: false
    },
    isLastConv: {
      type: Boolean,
      default: false
    },
    searchTerm: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props = __props;
    const messages = vue.computed(() => {
      const vals = Object.values(props.conversation);
      return vals.filter((val) => val.sender !== "system");
    });
    const messageLoading = vue.computed(() => {
      return messages.value.some((msg) => {
        return msg.status === "progress" || msg.loading;
      });
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["vdb-c-relative vdb-c-h-auto vdb-c-w-full vdb-c-px-30", { "vdb-c-pt-16 vdb-c-min-h-full": __props.isLastConv }])
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(messages.value, (message, i) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: message.msg_id,
            class: "vdb-c-w-full"
          }, [
            vue.createVNode(_sfc_main$E, {
              message,
              "is-static-page": __props.isStaticPage,
              "is-last-conv": __props.isLastConv,
              "message-list": messages.value,
              "current-index": i,
              "message-loading": messageLoading.value,
              "search-term": __props.searchTerm
            }, null, 8, ["message", "is-static-page", "is-last-conv", "message-list", "current-index", "message-loading", "search-term"])
          ]);
        }), 128))
      ], 2);
    };
  }
};
const _sfc_main$C = {
  __name: "Button",
  props: {
    variant: {
      type: String,
      default: "primary",
      validator: (value2) => ["primary", "secondary", "tertiary"].includes(value2)
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("button", {
        class: vue.normalizeClass([
          "vdb-c-flex vdb-c-rounded-lg vdb-c-px-16 vdb-c-py-8 vdb-c-transition-colors vdb-c-duration-300 vdb-c-ease-in-out",
          {
            "hover:vdb-c-bg-ota vdb-c-bg-black vdb-c-text-white": __props.variant === "primary",
            "vdb-c-border-pam hover:vdb-c-border-pam hover:vdb-c-bg-pam vdb-c-border vdb-c-bg-white vdb-c-text-black hover:vdb-c-text-white": __props.variant === "secondary",
            "vdb-c-bg-orange vdb-c-text-white hover:vdb-c-bg-orange-400": __props.variant === "tertiary"
          }
        ])
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
};
const play_vue_vue_type_style_index_0_scoped_29661e89_lang = "";
const _sfc_main$B = {
  name: "Play",
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    class: vue.normalizeClass($props.className),
    width: "28",
    height: "28",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      d: "M10.1751 2.97135C7.85552 1.34603 4.66663 3.00538 4.66663 5.83772V22.1626C4.66663 24.995 7.85555 26.6543 10.1751 25.029L21.8513 16.8473C23.8267 15.4631 23.8267 12.537 21.8513 11.1528L10.1751 2.97135Z",
      fill: "white"
    }, null, -1)
  ]), 2);
}
const PlayIcon$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$k], ["__scopeId", "data-v-29661e89"]]);
const _sfc_main$A = {
  name: "DefaultThumnail",
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
const _hoisted_1$w = {
  viewBox: "0 0 189 138",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$w, _cache[0] || (_cache[0] = [
    vue.createStaticVNode('<g clip-path="url(#clip0_611_8889)"><rect x="1.00006" y="1.00195" width="187" height="135.784" rx="8.42162" fill="#C3C3C3"></rect><g style="mix-blend-mode:soft-light;"><rect x="1.00018" y="1.12402" width="187.166" height="136" fill="url(#pattern0_611_8889)"></rect></g></g><rect x="1.00006" y="1.00195" width="187" height="135.784" rx="8.42162" stroke="#D6D6D6" stroke-width="2"></rect><defs><pattern id="pattern0_611_8889" patternContentUnits="objectBoundingBox" width="1" height="1"><use xlink:href="#image0_611_8889" transform="matrix(0.0014192 0 0 0.00195312 -0.226629 0)"></use></pattern><clipPath id="clip0_611_8889"><rect x="1.00006" y="1.00195" width="187" height="135.784" rx="8.42162" fill="white"></rect></clipPath><image id="image0_611_8889" width="1024" height="512" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAIACAYAAAAczR65AAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nOy92Y4k23rf919TjDnW1NXdu/c+Aw8HiaQoSoQFErywQRi+sQG/gV/Az6EXECBAF7oSfGVIFwZsGDJgk4Qp0BJ9DJMyeUSeYe8+PVVXVVZmxhyx1vLFihWVWV1Td2VWZVatH7CxqyuzIiMzI9b6xv9H/uv/7r/XcDgcDofD4XA4HA5Hx+54hN2dUffvk9MznEzObvW3r14cIgwD1E2Dum5ufD6jFL7v3fg8pRSKsgIABJ6Pg70dAEAYBojCACenZzieTAAAP/jmFeq6wWyeYDqfLx3j48kEnDGMRwNQSpdeoywrSKUAAFEYLP0bAALf6/5m6XwWfp/lBQAgzwv82g+//8n7sOdzsLeLg70dTGcJZvNk6Tn9XoSqbpBmOb46fAbhcQCAv/C+LYvv+zpm8wR13SArCmR5fuPzzWcQ4vBgD4Lzpd/XTYPZLMH+3g4C38Og38ew3/vk7//i//2PKNvPCABevTzsfr7qbxY5Oj7F0fEJvv7qOX7vH/zWJ4//5Kc/737eG4+XrlnL4udDXADA4XA4HPeNNYxev3mPvCge+nQuJQyCpU0aMIbM67fv1/pam/yZONaDvR8s7howHOzuQAMoqwqB58HzPeyOR4jDcOl5RVVhNk/QNA0O9nbBGet+/8s373B0cnrla/zub/99BN7lTpc9blGWnzx20VHhjIG1rwsAjWzAGb/4Zx1xFCGOlt9HWVWXvtZVDHo9HB2fQEoJ3/fgex4O9/fBGL30+XXTgBDSfT6/8as/xNHxySfPW3QmrkJwjmG/j14coReHeH/06XEG/R6Ggx7KssLRsfkOhOAY3ODsnEymmM7miKMQo+EAv/0bv7r0+KsXzxGFQXeeZVnh/dEximr5s4vCAK9ePL/SIbqJRYfp9dt3nUO7ePzF3/3RH/4+ooX72HLxb4+OT1FWJV6/Od9LXr08xB/94e/feB7XcZ3j993bd+Y5OyNEQdgd76q/ef32Hf63P/l3+I1f/SHqullytmezxFxvVwQrLnP2v5SL791+94674QIAG8wPvvmq+/ln3/7y2ue+eLaPIPCXfvf2/cfP2ki2mcsM9UVuMqYuRngt/+mnv1jF6d369VZNWVYoq+rSyPPFTdguqlle4HW7UXDGkWbZlYu8VArQGiAEBIBSGlprABoAgdIKWgOcUYAQSClBCYWUEkprUEqglAYhACUUhBAQQqB1exwCUEKgAfz6r/wASioQSsAYQ1GU+O7N2y7SrLVeikITQrrfB76PZ3u7t/rMT04/jezbqPoqsJ9vFITdNZvlBfL8ZmP/LtfMokF3mw108XMoqupSI9Hy9YvnS/++7jwv+3wXsRmBYb9/7fPqplnKZgz7fRwe7F37N8DyZ302m6MXR50xzBhFGARI0gwAMB4O8PLwGQYDc59EYYDd8bi7PywfTyb4k3/3f6GREpwx7C84IIsc7O3gn/yj38Hu2Hw+lxmUV3F0fIq/+/m33d8t4vse/vM/+Cc3ZhDuwmVGYpYX+H/+6q8748wa25dx1TX3+u07vDs6RuBdbkz+2g+/j9dv3+HHf/XX+KM//H385Kc//+T92+fYLEpV1/jw8RgAcLC72x3Xvoe//Jv/1D1usc+z9+fPvn2Numm649+ENVKtU3QR6wj95O9+gbqpP3lO1u5PUWA+o8Gg12WaPsfgLcsKRyfmXj06Pl3KOF3E973OqF/MQNnP+3Ow69l11wBgPqf3x8cgAKq6BuccZVlBKQVKCZpGtvvK7V53f28Hz3Z3u3vUMpslmCbn60NdNZjMZgCAOArx4uDgk7+5jovHu4o0zQFiXqOumi5b+aUMe/1rz3Px+/Z9H8N+D7N5CkpJt85YVumUORyO7Yb8i//hX2u7KCwaI3vjMQ72diGVBPDpBjSdJ/jl23c4Pj1D3dTd722E7yJxFHaRzsUNGVhewAQXODzY6zaR20QhF8/NGgev37yH73t49eI5/t6Pfngrw9m+1l/9zd/i9dv3yLIMO+MRXhwedM/ZG4/xO7/5G0uvN5nOwBmDEByMMbw8fIZfvH4DrRWUMrtYGPgIgwB/9ZO/Rb/XQz+OumO+ODxAGHy6uedFgbfvjwAAP/ze1wCAn/7iO4SBj/Fo2D12kTDw8eLwGQBgcjbF6dkUALAzGuL0bAohODwhUNcNjk5OcDadQcMYu5bLSmsuGl12k1/8/asXz5e+T094OGs33Zu+y6sMiO/evOuc973xGBoaeVHg9Zv3GPR7+M1f/xH+7N//uDNm0syU88RRiKPjU/ieh9/89R+dv057/IvGK2Ai+r/3O7+15ARfx954jN//vX945eP/9k/+DL9ss4WT6RS/8v1vOgeIEIJn+zsQQgC4vATor/7mb7ssw+7OCP/Nf/lf3HhOr9++w5/++V/g1YvnONjbWYqeaqXx7GAPf/rn/6F7/qLT/PLwGX777/1adx5lWcH3PUznCeIoBCUE8yRF3TR4f/QRAMHx6QR1XQMgUEpB6WXLzd779nryPQ8He7vd53uTgXMRTwhwzsAZh1QKge9BKYW/+buf4+evf4myqEAIQd3UEJyjqhvs7+1ACGNocm6yNFVVd/etVArj4RBNU2PQ72M2n6MoK3xs17PL1g+7Flx1nSw6TH/27398afT+D/7x72J3Z3Sr6P7R8QkO9nY/+f3Ftdle1//nf/i/8Qf/+Hfx6uXhtQb5VVy8B6bzBB+PT65c4y2Dfg8vnz8DI3Tpe/1S4/MnP/350rlYB/7Xfvj9a++9q1jc52azBN+9e/dJSd9F7Gd8l8zDT37682uzUDdlmhYDF7cNBL168Rxfv3i+tmDjxev2su948b1c9vjiMe7LQVl8zZscVsd6KcsKZ/M5ZCMRBB7SLAcBOQ8GQ0MpDSkltNao6vrmgz5hKKUIfA+B76Oqarx8/uyhT8nhcGwg5J/+s3+pwzAAZxS/9Ru/1j1w1UZuo8JploOCdFFrAJcaY0fHJygr41xMpjMkSXbtCTHOMBpcn/n5EqzhdpWBYQMHV5Xf/OSnP//EgdVa41e+9w1GgwF2xkPUdb3UH7PI2/cfkBeXZ+MXHfbrWAwIXMfOaIjxaHjpYz/9xXfdz4wxEELgeQKMUmitu6zpbbnolFzlpLx+++6ToMJ1htd1mbGrXuM23GTsfU5G7jbHu4mLQberyrAAfNbrXLxWbzrPJM2QZBk8zsE4x3/8yd9Ca426acAoRSMlpJS3fv2r+Fxn/3OwGZpFx50yCt1WJbw4fIbD/V3s7+6Ac4amfT/HJxO8fH6IXhSirGtQQsAYRVXVYIx1/WH2mrPfmcumOBwOx+ooywpFVaEXRzidnIEx1u07nhDQWsP3PUymM0hpKgZstY7jU4b9PuZpiq+eP7s0yeRwOJ4u5I///Mf6cw3Zsqzw3dt3UFc4u19KP46Xsu2biI1A89Z5rpvmsxzGTSXwfQS+99kBAMf2IJXCbD6HEAKUUMySBEopSKluLYLymLGZE0opfM+D53mghEAIjqIoMRz0IZXCfJ5gnqboxREAAsF517vL6OV9lw6Hw+H4fKRSaNoWNt/3kBcF5kkKITigCcq6AqMUSZohDHxIpZDlxcrt021lf3cHVV1jf3fH7U8Oh6ODvD8+u7UGQJYX8H0P375+0/XGrQpKKX70/W9WesxVopRCVZnSM0IJpFSo6/qTcudthRACRimCwO+CG47txhpO1tHPi7KrxnF8Pr7ngTGKwPc7wSWAwBMCcRTi48kpmkYijsKufTUKjPqvLRuv68YYrg6Hw+H4YqRSYJRCKgUlFUAAJRWkUrDmi5QKSZqirGpUVQ2ln2ZQ4OXhM8ySBC+ebXaCzeFw3B+3DgDYcQmTs+nKnQjf8/D8YP9Woy/uG601pFIoywqe4Gik7PqlHyu+5yHwPWitlxRtHZuLbT1RUuFsNkNRVqjqGs2KA3WOy/E9D4QSeFx0Dj5jFJ4wGSsjjqhQ1TV8z4MQHL7nOyVbx71S1w3KtsTaYh0ph+OxMU/Szoap6xp5UUBrY9cJwZGkGZRSXTuY4Hzlya1NgFKKQS9GHEVL977D4Xi63CoAUNcNPp6eYp6kazmJw4P9taoXfwlaG9GZRspOpfyxO/4XCdtqAH6DQJbj4ZBK4XQyRVVVSDLXC7mJCH4uVui3o6bCIICUEmEQYJ6mGPb7mM7NyKOiLDHo951T5uiym6usGsnyAoJzV4nieLLUdYO03S819JXCphdHvC1CKe3aDOz9VLTTDDaRYb+H8XC4kYk2h8Nx/9wqAPD+6COmF+adrgpKKX7wzauNMXallCirGoxSUEa7jMlThBBT3uwJDg3cqJTtWD+2jz9Jc9R1/SizFU8JaziGQQDOGDzPwzxJ4bcVOGU7xpNzjjgKkRcldkbDbjqDY3uw7R8XnfosL1A3DSgh6Pfi7rlKKcxTE3Q3I9JM+8nR8cnSfW8rSuy4N/uY1bSQUqGsKnDO0TRNF4Syjsp4ZKa/5HkJqSQopfDaySSEGI2LvCjQi2MIzt1153i02HuzrCoIzlFUFThjSLMMw34fXHCkWQ5fCGRFDq01mkbC8zw0jbEVlVJgjMH3vE6kcBN0ouz0HQCu8szhcFwfAKjrBnXT3Goc2pdAKcXXL55vjEGRFyWklGCMoWmarizsqUMI6YxMJRU8Tzz0KT0pTidTUEpQlOXaAnGOzcI6b4JzcM4hhIBSElEQoqgqSNlAKY1hv985lUmaYdjvuZLue+YqXQfrTCil2u/HOPO9OAajFHXToCjPJ8MopZaCzYtOA6UUgvMrg9HrKF22AQNLL45Q10bPQgiOum7Qi2P4vueuN8ejx66rNvgqlUJVVeDM3PuU0U5zJwwClGXZ6hEQMMrQSBMgsFUCixUE98Wz/T3EYeiqfxyOW/KY7alrAwDHpxOcTM7W8sK+52FvZ/zg/Ui2x7+qahBCnON/DYQQcM4gGO9mqTvWQ5JmqOoK01mCqq7v1VhgjIJRBtqOhgSAOApR1TWUUijKCuPhAEmadefVNM2VIzAd66MXR4jCAL7nQymFXhwhSTMUZQnOGDSApmk6Uc/A90HbzcxlgT6PJM1QN033edps33g0xGyedOPKmkZ2s8ofU0+xFcEUQsD3RCt4GaGsTBAjCkLzvA0J6Dsc94Hd96wgYVVVqBsJwRnqRqKqKszmCfq9GL04MgEAKbuRszYgIJXqAgOUUgjGkJdlt4aswgbYHY8QhaFb+x2OSyjLClzwzuF/zM4/cE0AYJ1l/2EQ4Nne7oMbClLK1qCT3Ug//UhU/dcJIQRa60793HF3rOEwS1JUVbXWkkFTmkjBmBl3V7ZljvbKp4SAc47ZPMHLw2coyhKUUjRNg9k8gd/2sld1jcD3kRcFGKXoxXGnwOx5HppWOJQxhiRNIRvZBdeU1t3CWlZVdx6O1cD5+SbGGDUtBpyDAFDajH60hqC91hb7wre1xaBux4XZDPV0PgdgRszawId9j4ube1lWnwSwyqrsyuef4qxx3zP3OSHtlBjGkBfL61JRVmYP0Oae3t8Zb+V143B8CZ871cVO0lLtqEIpJeIwBKUUJ5MJirIC5wx13YAyCikV+nGEeZKuJJAYhQHiKMLOaHjnYzkcm85Fh97+O0kz1HUNTwiT+JUSWZaDMYrhoA/P87rqPcC01dkKuLppwCh9FPvcpQGAo+MTTKaztb3oV88PH9xxTNKsNWpMSddjGed33zBqMkKB74EQ0t0w9BFHzVZJkmaYzueQUn1iXN8VwTk8z0MvjqC1AmMceZ5jNBzgbDoDIbR1Bk3bSy+KkBcFOGcYD4eYTKeIgvCTBdT3vc7wsQ4XZfTSSOllImY205HnBSazGULfb7UNvjzg6AIIn4fN5tI2cKOUhO/5V25stk992O+hLCtQSjGdz9GPY0ymU3DOMR4NkaQZBOdLYw8BLPW+T+dziFZbpChLCC4QhgGaukFRVZjN512Qyh6zrmswRhEFxlimjLbP87vrbpYk0FojCsOusswGN0zlStn9bK8V6+A7LmfQ60Eqk+kfDwefPG6DKPZ7ns0TjEaDS9cCa1MEvoemkZ3egcPxVLGOvmU6m6NpJJRW8IToquviOIKUCh8+Ht/p9Tal8tbhuCvWDrHTPGybsg3k53nRBdaU1tgbjzttD6UUlNZdi1sYBpDS6Gv14giMcQjOMJ3NwTmHlBL9Xg9ZngMwlZRFWSIvSsRtUC0rCkSBsXu2JTjQBQDsQvTh4/Ha1P4BE4E83N9/sB6kNMsRRyFKOybNlfuvBEapEQ30hBFQbP9zfIpUCk3d4MPxyUqcfpu55cwIdIWB3zli/X6vM9Ctk26jmJvWu7uYhc2LAlEYoCgrCMEhGEdZ18jzHGEQwPdMD6ZdkAFTSWBFO/fGYzRKoq5rNI0EY+fv23E1lNLu/lXKBG6s8JuU5xlyIQSklPCE6O7zvCjQi6Ju85vOE9R1jX4cg7f6ITZodFMU3T5n8fsVQnR99FEYQHCBuqk/UfC2182mqnFvIzag4wkBzxNt5U8JQrB0XQDGOLLZEsAEXBa/Z1vtVJQVBu365HA4zm2Dqq5RVRUGgz6SNEVdS/iewCxJ7lwdeLi/ByGEawNwbBVW5Nb3PWR5sWQ/zJIUaZqhrCqEgW8c8jw3bXpagxKylIwASFvBaqrcpJTG9tRA1VYGVHV9p+SADUjsjceoZYMwCDZur+sCAFIpzOcJPp5O1mY4xVGI0WDwINFHpdS5QaLVkxvpd58Izjun1AUBzrGG7/uj43a85JfdZ54Q8D0Po+GgU/UuqwogBINe3DlPj3mDtwGNPC/Qi6MlETyLVAplWWEynUIpjTgMwTlDUZbI8sJlftfIYmvBYu/qTZUaVqF+Hd/NY+rHv298zwNtdSS+/urFpS0i9n4TnC9VBF3VR2kNOps52ZasicNxH5jpATnGw2ErADyHJ8Sdq3NHgz72dnc2zhlxOBaxwTDf95CkGRij8DwPZVlhlpjkAiEEQghQQpBm+aV2g/VBHiohEIUhKKEIQx9h4CMMNscu54D5oF+/ebdWg3g8HHQjSO6bqqpNbz8xPz901t+KxVBCHmXrQSMltNZGiIwbwUDBn24wIMuLdkZwiaaRXYnfbTEibx6iMITveWhk0/Uo2Sz+ovEsxOOf8W3fnw0mMko75z9JM4Rt8MNmsG3LQlXXbWRWdOOdKKWYTGedo/oQ6syPjcUs1WJb0HV7zHUq96vAOf+3R3COndHQGCvECBtKpTBoy/Z938NkOu2y/75njDSz9oilQNxVjoZds5zj73B8Si+OujUrzTJUVX3nUcxRGGA0+LSVx+HYBGybYCMbUEKR5hl4a+tN5wkGvR7maQoljYbGoNfDWRsQs8mDizy0LVeUpTkHopG2tummCHGSv/ybn+kkyzrV4nXwUGX/Nutvna+yWt97vA4rmmf/DxihNSvEZjHjB8+DE5QS4yy2o2Q0AGi9lUEDQgi8dt65VSR/7NjM1+nZtCt5vY2DY0uuCczUhXE7993N4L6eq7KStvR8Opuj14sxm89BKcPJ6QSjYR9xGOFsPgcBoAEURdlNPHA4nhKUUHieUflnjKFuGuzv7tza8fhcUTSHw3E1ts95niaQUuFsNr/TvrQzGqKqarx8/myFZ+lw3I16YXymaAWoB4Me6roxLTBNA9m0I9qlBCXEVJxtaRUnZwyeJzDs99HIBv1e787BvS86j7/+u5/h2f76MvOUUrw4fHbv5UZKKXPRKIkiKe/VabaOPqMUnHPUdQ3OOSg182C11mCcQcpz596cswalBISY/zhjoMTMi1ZKmX+32UnfEyiqCkqqrRi/RtpqhzTLQSmFJ8x888fKPEnhCYFpnuFkMr1x07bOfSMldscjSKmWxNQeYnHYNi4LjjB6Xoo8HPQBAOOhUUC2WUqpFOLIVFdMzqaglOBgbxeqbdlgjEEphcl01n0PVsjwOlwlgWPbMMrjEnVjJoE829/r7p/bOPfO+Xc47k5ZVsiKAuPhAGezOZI0B6XkzvtJGARrTfY5HDdhg1pW/LIsKzBKsTseYTpPQIjpw1/UabPaTo/FpmqkRJNLZHmBYb+HpmkgOL/3sYO8qtcbQVk0IO6LsqqgtUZdN/de7m/7TKMggNIKWmsIwduggDk3xhiINIu5JwSkVEakrJHQGuCctUrVNaIwAGMUeVGaGcyco2jF0hhl0ErD98xYGa11p265SXDGTD9PI03kq/08bLn1Y4QxhqOTk2sFewLfB2MMYeCbsnTOlxT3HfcDoxS9yLQSHOztdlohAIAoglIKx5MJ+nGMRkrEUdiqzop2dKi5Z6uqBqEmcJek2aPYqBxPAxtojIIQuzujS5/jnHuHY31IZSYBzZMUHhdQWuHjyQRaK3DOViLObfWZHI77xDr9izaRrdA+mZwBAMLAb3VkSiitcHR88knb3mO0qabzBNN5gn4vxqDX6yYb3Md9yilZn7Mx7Pe6nsH7QGvdiquZ8Q7rdv5tlh4w5fpSKlBKEAa+yaTU0nyZnHdZfhL4C46vmUFpv+erMuKcc/R7vHt/5wEFaS4SAjBqAg8aWNIWWGw7eCi01ujFEQhaIby6hlJ6qQemrCpQW/mwxRuUHet31dxwzhjCIEDg++214sSvNo3LHJ2Xh8/M1IHMqNIf7O1gnqTQGiAEEFx0QcdK1oijCIIzFFWFoigfTeTa8TighOJgfxeB57n1x+F4QOy+EkUh0ixHFIaQjUSWFdBar6zMedjvYTqfdxVwDse6SNIMdVOjrpsu0RUIjkY2SLO81QirEAU+glbV3wYCnirzJMU8STsB9SgIwDjHqK1cXQfkj//8x2vxDn3Pw6uXz+81m1nVNaRUqOt6bWXxlBCTwW8da0opOGOdqBtvBceUMlFbT4jub1fd+y6lBGl7YWQb7GgaI8Bn9ARMQOAhHQ87Usxmui32nGwlAGsDKUVZti0C4tLjbSplWeFsNsPZbP7JY7QNauyMhtAAQt93RveWY+9xe72WVYV+HMP3Pfzy3ftutAwA9HoxoIE0z0Fggl13HeXkcHwunJvqol4cYTwaukojh+MByfLCtP3VDbKigJSyG0Fm94hV2m57O2MAwO748gofh+NLsRMr6qZB4HmIohCcc2PnaI2qNkLs8zTDoBejKEtUdYPGCfNeSS+KwLjxNXfaoN2qq/DWEgCglOLrF8/vzcmxi2RZ1SjKcqXHto6+4LwV7Gsdf0IWMvG6CzjY5z5EabvWuptyQCntWgKAh1fAPq+EAAATCGHMBE+s5sE2kuUF6qbB8cnpJxUnjDGMBn1orRFH0UaofjpWx6LAoP13mmZgjEFDIwwCNHUDLjiqqsI8ScE5R+D7SNIUQpgN0up4bKugjWNzoZSiH0cIg6DTwHA4HPdPWVaYpyniKMS0TRRIqdDrxZ3Kfz+OUFTVlRWEX0ovjrAzGoIS6pIPjjtRlhW44GjqBkqfC61zxjvttSzPu1HLo+EAnDEURYmsWG1Q6ynQiyNoraGVxmg4QH+FVfVrqbUeDwf3tshYIb2qblYqbkJgjCfrSFN6Xu4PQkCwXF6/CRlrQgh834O/8DvbZ2ODFPqeWwN8zwOlxrkXnHeRQPuZbrMGwGye4Ph00gVXbJm3aEcfPn92YKoftvg9Oq6GXfhuGaUYLIw/A4B8IfA2Hg5N1UBV4WBvF2ezOQLfx3Q2hxBtqRch0ErdemKEw7FIL4666pReHGHY7zuD/5ZM52a2tNHaEZBKGbFa9vjHqjrWQ1lWKOu6a28sygpSSoyHQ1R13Qr8pWbKj+A4nc7W4iAN+33UdfPJ/uRwfA5ZXkBw4/zPkgRVbcr893bGSLM5TiZn7Zjl8/XSjulzfBk2GGhFq8+mMzOeF3cfobuyCgDr6Bzs7XazudeNLZmq62alJf+2t1+2/fYAOqG9NoXdZa63Dds2ULcBk3WJBhIAXHAIZpxhQpad/cVAxLZR1w1++e79eeWHNu9DeBycMvR68dIcbIfDYjfQ6XyO8ciUdVVVhTAIkKSZuT8pRZ7n3cSMOArBOWvL7FzrgOMcSikC34fgZkLMwd76Jvo8Juqmwcfj0y7IdlPywIr7+p6H8WgIrTVC34fSCp7nuSCvA4CpArMGexQE+Hh6isD3EPhBJ9Q8SxIkaYbxcIDpPFl7RrQXRwh835X+O27FdJ6AtRW78zSFlLKbhFRWdadfVZYVNIwIuRU9fuhK41XR78UgIGCMoqprkwxufZimkdDQkFJ1Puh9YfQBBAa9GEma4WB/F9Bf3hqw0haAwPfxzVcvVnW4a1kcEbFqOGPgnHXq/J4wAl+k7f9/jNSN6cepqnolAQHBeTcBIfD97vPbdj58PEZZVShLc9NTSlqRxhjDQd8Zgo7PxpbQXRyzVtcNKKOYzc0YqPFwgDfvPwAwRh0hpJuP+1g2XsfNDPs97I7HLit9DXacklQKs/kcUipM58nKek59z0NZVeCMYTwaoB/3urFWbg94eiRphqIs0Y9Nf3PdNEjzHHEYglKK2TwBYMWOaacZdR8c7u8BhLikhONS6rrBdG6qETU0qnYEZS+OILjAbJ6AcYad4RBv3n+A1hrDQR+UEMzTdCuTElZoz67jtnKOMYZeFOHj6Sl2x6NuDDtgbC6pFJq66ap9szyH1gAIkGZZ5zMWRbXWe9yKicdxhDTLsDsafVE1wEoCAJRQgAA/+ObVvWx+ZVseu6qsP2lL+nnbu2/GrnDQ1mG1rQBPgaZpUNVNWyXweWKKvufBWzBKt1nN/yJ10+DkdAKlNdI0AwiB5wn4wsPueOSMccfKmM4TBJ4HLjjKsuoi64HvdVUBTWPu0SwvUJRlNzJGKtVllGzW0rF9RGHYGmAcvTjqBMOcc7nMdXOT0yzH6ZlRlr4vIzUKA1BK4XvGGLNVPu57e1zUdYOjkxMc7JqKmyRL0TSyq+CC1pjNU6jWlmyaBuPhAJN7Loc+PNhHXdedAKDjaVGWlSmrWUoAACAASURBVEkSKIVhv2eqDJVCU9dIsxy9XgxCAMZ4V/Uc+D5mSYIsz+F7HuqmWdKk2Ea7YtjvQQgBxhj6vRizeQLe/pykGZTWGPTiTt8A+PI124wyrFBVFdI87yrUw8BH2k6RWlXVj60IsC1Gu+PPCwSsrAJgPBzcS/lhWVbIiwJ3PenzkXMmo980EkHgm77ettzlqTj9V6G1buecm0/blLuYMsiiLMEZM+KInHVq/4+R07MzaG2i/HbyQy8K0e/1nOPvWDu2MmA6T1AUBeIoagU0ObKiACWkmy5hK3mOTyfwfQ+B7yMMAszm806w0rEZBIGPOAwRtFNBTGtIAk9wV1Z+C6bzBGmWdeWawHmWJstzIzxVVsjyHEVRrn0s8GVYQWDGKOq6QRSasa+9KHZ7xxZihfyG/T6SLAWlDLP5HIyZiU+TtoffOkm2Nfa+1937FuJ2PAx13aBuzH/Dfg8/+/Y1fvDNq/O9XmuIVp+srEpIqcw6qDXGwyGOJ5NunynKygiJXyhp37YRxpxzeEIg8L2uHT1JMxBCEEchqrp5kGqYsjTtZrYFiHOGRkpU1d1bCELfNzZgEEAIdutRnysJAPieh5eHz9a+oZVtacpdIITAExxKaXDOOofOE2JpHJ3DUZYVkladNy8KY2gSgmG/74w3x4NSlhVmSdKNGgzDEIHnYZ6mXV8zAQHjDJSQTu/D97yu79Rmlhc3dxvE26YNf9OghEBp3ZUXWqIwQBgEJijTTgRxTv7nYSvSGKUoy/MqQN/3UFUVOON4d/QRBOgM44fkOuPZVncM+31wwd21sOFMplMwxpGkKQgIojCA0grHp2fdd7wJzhKlFN/76iWA1Y8Nc9wPi5VN1sn3fQ+Ts+mS/Wl8ohxCCAjGu5Hgbz8cdfow4+EAgnNMplN4woPSCmmem3Zfu34ulMInaXbvbSp3xfc8hIHfJnQJoIGyrvDi2UHXBnZbp/i+yPKiaxsANNK8uFOLmicEenEEpcz0t4P93Rv3FPI//ds/1YPBl0dD7ivSWDfNnaP4VrjPitJJqcA5A2fs0WavHV/Gh+MTNE2Dsqw6xz+Owk590+HYJGx0OStyCC5Mm4CU4MxEmcuybKucPHDGcTabIQpMmfmb9x+WHKUoDCGlRFlV8IQAIQRlVUFwvtRi4LiaKAwgOMfueNwZb87B+zzKskIjJTwhOoPXZLXM40qpLgCQ5XknNFuW5VZUu1gDvSgKRFGIQa+HvE1w9OLYXTMPjFQKk7Mp9nbGyPIC748+QiplHH+lltpKNsHxB4wj9PxgH77vXdse43hYprM5eu04t27vbkvu+70Y8yRFVdcmMak13h997EQcy6rqxEhPTicYD4eYJedB/VmSAlqjqs04vovYa/VigHrbsNMGrI3CGINWGp5n7J9tGrtd1w2SLEPd6tpVVf3F382g18No2EfTyBtHBpJ/9W/+Z/3qxfMveiHgfkr/86KElF8udGVH3gW+B9/z0EgJ3WZoHI6LpFmOk8kZAI393R03Bsqx1ZzN5saJanUCsqJAWZZd0DMKQyRpatTkBcd0NgfnvA0C1GgWMqnWaNgUg3ed2M8n8D0UrRZDFAZdRuYivThCL3YTQFaJLedXSnetEQC6suqz6RxxFILR5fnmH09OUdU1irJamfDfuqCUAhro9yJwzpHlRXd/7e+O3ez2B2Ixc/jTb18jCnzkRbmxgSXf8/Dq5fMuaOG4PxZL8eu2hL4fxyjrGlI2oJQhCgMURQlPCMzTDFEYIG+1XaRSyPMClJoJXYfP9pGkxiHMC7Me9OIY748+ohdH8IRAmuVdYP421+Rj2LPtVKTA9+EJgSRNMRz0AeBRJedOz6boxzGOTydIsuyLvjcbCLjOf7mTVzPs99bu/JeV2cDv2r/Xb0sjmsaM9nsMivSO1ZOkGc5mM/TiCDujzSoZcji+hFG7QVqGoofSO88Q1U0DDbPWCsG7KSCDfg+UUBydnMD3PRzs7eLkdIIg8MGZaZ/Ki7JzsDbVML4KqwQMGA0YzlmX1bNGlempE2gaCa/N/NWtoJcNEPTbbK1j9TBK0Y/j87G1UnXfmSmhDzGZzsAoxSxJEbTfA2MMjLLtMXiJ0TSgrYAcZQzjNosjVY00z9GPTTbHBaPXS1lWXfWF4MbR8jg3mdUNZXc8wrBvphA55//u1HXTrR1FVS30yZcAzNqTtzpYjJkRvZQSUEKhoTHs982+qlSr/SFwOjnD2cwELDljiMIR5kkCrngbPI7w7es3kEohzXJUlRE7t8FnuzctCvIBt993t2YtvAClFP3YBEeTNOs02nzPu7eR8/eN9T36vRg74yGOTyeftGvexCxJEAY+vP7VtskXVQBEYQApFb736uVn/d3nIqVElhd3cv4Zpej34q7X/6EpywpFVaGua2itMRoMljZ0u/lYpFJLRo9jfZy1Cr2EkC6q6HA8Baxyre97UNJsMqdnZ2CMYTjoI0mNyrVSGkHgQ7UVWZPpDM/298Bb7RSjOmwyIFob44QQs4lfNFzWic3U21E/op2oME8zBL4HKY0jH4WBUdj3vC7Tcri/Z6bMSNkpeI8Ggy5gQil16/GGYHtgm0aCEoKiHQ98n7OZV421U2zFTt00+PrFc9O2E4XQGiBAV7HjWB3TeYLZfI4wCJCkGfZ2xjg6PtnY4CalFOPhAE3ToBfHj9IhsuNwAWA2n0MIM33JCnVP5/PuucN+H2mWwffNei6lxmjQ7/4eAJpWlR0wTnFRlm2Qt+k0dSbT2aUl8lEYgFGGsqoQ+L5pk/MEPCFwMjkDJQRRFHbHlu1eavchwEzakq1Db7PyNzl2216u/7lYfZTxaIg0y5HnBeIoBGUUvejxXeO34eT0DGVdLSVdboPveV37yMU9g/zTf/Yv9e//3j+89cHiKERV1Xh5+GytWQ8b8brLwmsVeAPf6zbV+5hHbyM1VpHY9vjYxeY6TJlpiLqpzUgKbjNUTWd4OgXh1XMyOYMnxI09Mw7HU8E60JYsLzqn5OjkBIcH+92s9TTLIWWDPC+7THojJXbHIzDG4AuB98fH2BkOEfg+sjzHvG07sMaPFSd89eI5yqrE0fEpDvZ2kCQZRqMBPC5QlCXefzwGpRQvD58hCoNu1FGWFxj2e+CC4+PxiRnZmZm+ytFwYCoW8hy92Gh6SKVACcHp2dRoyBOAUQZKCfb3bhbQcWwO9hqczuZQWqEort9ntwmb6bJtkP1eD0E7iafXi911ukLevP+Ag71dJEmG6Xy+0U6XNezTLMPuePxobEIr7pmkaTc20SYdb/N9XCZke5sy+c8Zb0cp7Z6/KAB58XUdt0dwDsE5RqMBtAZ8IVBUlWupu8D7o+Nu2tNtA920raQLAn+pIvSzAgBWbOFgb3ftAgtZXqCu664c9XMghHSROH4Pqv7WwS8rk30QQiDPc8zTL+vduIrd8QhSyq6NYTKddWWsYRCAMQrf85dKWx038/Hk9JNKDIfDcTuSNENRlp0okQ1gjofDVtwmxXg4RFmakkYN0y+vpAJlRs09zbIuMFtWVRdseHn4rJ2lW2N/dwdJluH4ZGLGqbVO0N7uDmbzOfK8xP7eDgB0vZa2L3M8HLQBBpPhoZQhCoLO4HNr5uNhNk9MEF6boACjFIQQNFJutXFus2JBEEBJiaIs4XkCaVZgZzQEZ8y1onwhNojYiyOUZYV3Rx831vmnlGJ3PAQhBErpLru3rdR1g+l8jnmSommaL7L5HdtLL47Q7/VAKUFZlNAgGI8GLrB5A1IpfPh4jOIzdEl2RkPsjEdoaiNMfKsAwHmvY7T2MiOttSmPyfKuTOe20NaAtIrt6x7pZ43b6SzZqM1iMSgAAKIdD+FuqGXqusFsPkfk1P3vBd1u7FLKBYNcgzEKrXVXXm1L+5RSIIS0ho7qqmEc24MVN7LVUJOzaTeX+GJk//3RR4yHQ/O86RSCcxzs7eJsNoeSCoQSjIcD1HWDRjZdNdWg3++CCQCQt72Si6P2LlYzOB4/tmUjywskqenfNr26dKP26y/BjJP0sLszRppmmKcpDnZ3zYz6Qd/t9V/AZDqFUhrT2XwjS/4ppRj0YnjCQ93U2N0Zb933XJYVJtPp0jQZ2+PueDr4nodBPwY0QVWbio/xcLhVyv2bwjxJcXw6uXU1QBSG8D2B3Z3x7ccARmGAQa+39t7ouh299rkLsCnJYRBcrN3Qy/ICk+n0XntaPxfBeZcNsC0J1qnqxRF8z0Pg+9eOy6jrNjv2CA1nq8Xgyotuh21BsVBK0TQNOOeo6hq0HcEllULTSDBGwSjtBFsAcz0xbsTjxIIzLxc0PrTW4JwjL0oA5mcrVCc47wICWuuN0fVwOBybj9XTmUynyMsSRVFufW+tLUPuxzH2d3cwnc+xtzPG3/78W3z94rnTq/gM3h8dL/WTbwqCcwz6PTDGUJblVpT7LybvTk4nXXuX4+li27H7vV47hl0iDkO3Rq2AJM1Q1TXOprNb+c7Dfg9xFIH88Z//+Np6G0opRoMBPMHX3m/2JX3/hBBwzhD6/loz/nXdAASYnE27vqRtx2okACbwEvgewiDAcNDvZn7P5gmiIHClhVvIxd40AJ3jbHrXTNZdaQUCYsbRtM54WdWglAC6G7sN3xOd833R8VZKddU7lJDOYU+zvLsv7eN2DWGMoWrFMC2kPV9rQNjXs9hAg4UxBq/dPGQrukMp6YIFLkDgcDgWOZmcYXc86gQEbQWf3fO20VERnCMKAxBCumkIg34fUjbYGW13ifi6sTpNb95/2KjvXnCO3Z0xlJKYzpJ7ab29LVZzw47gtC1b1pHLC1OFRSlFUZQIAt9kKavtFuh0fD42OCkE7/y7KAic078GpFI4OZ3cykcd9ntXBwAopZ2hHvg+dsejtTqBjZSo6xpVdfu+f98TYIwtObLrwCrD2jEcT4koDNCLI0RBuPT9u5LazWTRwYcGatmAEgIhBLTWxsDRxrFmjEJpDa3M8xdFbLTWl07foAsCmvYuJcBG9u35noDWAGcMnJtxPbaSwQUGHA6HxYiOZY9mn395+Axv3n9AFIY43N+DEBwnpxOEYbgxTuQmUDcN3rz7AM8TmD/gmD9bnck5x7DfQ9R+T0fHJ/B9f6MqFfOiQFXVyIoCvSjqAvyEAJzxdnRdCcE5tNaYp6kr839i+J6HftsuXjfNUjueY/3M0xRHx6c3Tgu4MgBgxx9FQQAN4OuXnzcq8HMx0fjbbbyUEAS+D6/NSK6LeZLiZHK21SWCd8WOLmHM9NEO2o1ICIHA81xlwAOw2M5h2zRMT30DRs1mrLSG1mbD1fo8MADgTmM1t5WucoEQBIEP3zNjhKygpn183RNCHA7H5rIYCAh8H1lRbPVEgfHQiGlpmExcVuToRXE3AvMpU9cNPhwfgzOGohUovW9s1UkUBhCcY9jvdxoV9z3Sbzqbg3EGaHzy2rZyz1bmTc6m3WPWseeMGzuxHQ/rHP7HjbVBLbYKKYoiNI1J5o6HQ+cjPCBv3n1Akl3dqn5pAMAuSnEUoihKfPPq5VojN1VdoyjKW4n+CW4WGU+ItZb8fzw5xdl0tpGZzYfGztVe3BCiMHDjCdeMUqqtlDHtGgA6IT2tNZRWkI101+wtIYSAUQreZiqUUt31a39/GTYA43A4Hi913bTCcHbe+Pb2MUdhiIO9Hfzy3Qd8dfis27d933uSWTkrDJnlBaIwuPe2TquB04ujJTE/O/P+Ib+T6WwOzxNLwshlWXW92jbpcF0QqSwrJFnWim4S1HWzkcKKji/HjJaLzChfrVFVFfxWV8yJjm8GZsJG0u1jF/kkAGAXpp3REGczIyizzkhkVZt59zdlJY1BzgAQ+J4AbUf7rJokzXB8OnnSWf/PxWvLywETKQ58IzAYhoEZT+gWgjuhlOpK9LWyWfwGUirItlzfsRooIV0AxbZO2HYJK2pY1XV3zbuKAYfj8WIzn9Yxm87mmM03a+rP57A7HsH3PJzNZujHMUCMPcXZ0xqDmaQZ8qLA6UIm+z6glOJgb7fLltpzue9s/02kWQ4AKMoSvu+hFy2f36KaP2dG2Nf3PfieD8C0A8yTFHXTQCuNNM/v/T04VofN9vd7MUaDAQDjK55MJpBKYdjvIwydrb+pSKXw7es3nwThPgkA+J5nZiz75kZed+9RUZat4vfVGEPc9Pmbft7Vb1RSKbx9/+FR9P9tEpRSxFEISig8T7gRRbdAa22EcrSJsltxvrpuoJRyGf57ghDS6RsQQkAXBBA55xCctcEB5oIBDscTYDpP0IsjKKlwMjHq5tsG5xyh76MoS3DOsTMeXlr2/dj52bevPzGIL5Y1rwprV+/ujJHnxdY7S3aihrVP0jTDLElAYASAjciw6rTEXPZ/u7AVjoxSDFpNClvxayePPPUWom3jMh93KQBgS7sHvR6iVt1znahWZf46d4a2BjZjrMv8rxKrXrqtm/m2ITiH5wkIIbAzHD6prMNtkFIiL0owRiGlKfl3Gf7Nwgoh2ikDUkowxtp/E/ie140rdDgcjw87FShNs60VOaOU4tneLppGglAgCkLUTfPoAwFW56Gua+RFsdakTxQGGPb78D0PXHAoqR6VzWPHKdetsr+Usp3GI10ybQuhlGI8HCxpfJVl5fr4HxGT6RTHp2dQSp0HAMbDAZI0w+54BKUVxsPhWk9Ca40kza4t/ScwY74IJWsd8/f2/RHm6cMpwD5GrhqpZMVulNaQUkFwhvFwCL7Qe/3U0Fob1VwhULaG5FMU6nsMcMa6ICVnDIxdrSXgcDi2G9sikGQZJmczFGW5dYGAfi8GNMw45SDAbJ7g8Nn+o92Lj08nmM0TfPPqJX727euVf1923nng+wiDAHVTw/f8R58xtdoAp9MpqqpG0zRLI/+2eczmY2ax6nvY7yFJsy4Z7HicfPfmHfKiMAEAW+a/v7eL2Xy+ducfAIqiRF5eXfpPgM5wDoPVO/913eD9x49bGbnfBqxAiFVXNw6/iQpzxiCEAGMU/TiG0hp5XoAQoBfHW18ed1uklN3nkxely/Y/AmzJIyEEge91rQF2/VJKnU8keALXuMPxlKjrBmezGdIs3yqdAEopBr24a2cKfB9KKfR68aPbi1+/fYcsLzAeDtYi/vfqxXMIzpFk6ZNw/G8iL4pO5yvLC3iCL7UE1HXjAgNrZnHEs9WfCMMQURCgkQ04M74WZfTRVak4LudsOgP5s7/4Sx0EPvKixFeHz+6l1ENKiSTNru1lDnwfUpoRXXYU3aooywrfvX3nFpw1YRcb4wAZkUDfFyAgGA0HyPICWZ4jLwojrkTbqQ6coR/HSNK0VZwVj1JNVEqJRkowSlGUleuPewRYnRIAIMRcr1JJaKUR+B6EEABMtUcjJZRU4JytdZKJw+G4f6RSaOoGx5MJ0izfiqCu7X23LXphEKCqaoSBEfPlnD+afdhWAKx63+3FEfpxjEG/11WGOC5HKoWytX3yPEdVn+sGCM474WMAXc+548uhlOJ7X70EZRRZK/CYFwUopRj2+87hf4JIpUD+v7/7Vs+TFLs7I/jifso+kizryoUuIwoCEELAOVt5lsw5/w/DYtTxorBkXTfICjOWpywr7O2M0TQSnifMjNx2HM22L1JKKSPkp838eVfm/3iw01PiKPyk938x67+oDbBo4DgcjsdHXTetzpFei9O5ShYF8MIgwM5o2DliWmvs7Ywf+AxXx9HxSaf5tApbcDwcdAJ/j11DYRXY8YsAcHo27cShy7KCbK+5PM9RN2baEYCloIDj6sBIL47gex4Yoxj0+0izHKHvQwiOLC/AKHU9/Q4AAPk3/+v/oX/n7/86KLmfi0JKiVlydb+9EBxxGJqTW7GI1mQ6w/HJBEo753+V2MVGStX1vy06N2VVoa4bM0KtquH7HoZtlHxnNFyKltsNIElT1HWDRkr0ezHiMNzqRcuK+7kN7PET+N6CMW3WME9wNy3A4XjiZHmBo+OTjW4PWNYwYdgZDVE3NbK8wLDf33oH1yrYT6bTlbQAUErx1fNnSNIM+7s7KzjDp8dtKibMTPM58qKAlGbctOACZVVBKvmk2nl7cYSyrCAEh+C8G8FICCClQrjQduJK+h1XweMoxGye4Nn+3tpfrKwqVFV95eOCc1BC19IfO5lOcTqZbqTzb29gwNy8jFEkaXblcwHc6Ej6nrd2I8M6OWVVdUGAMAjgeR6EbDoRnOPTCQ52Y2RFgbquu/L+YRh0rSBJkkII3s6T9TFemBCQ5QVmSYIRHWzdQmYd/6Zprp124dh+KCGdbgkB6cQum+a80sM5/w7H0yUKA3zv1UvM5gmyPF+aPLSuEXSfiz0HwjnKssK7o4/Y2xmhF0VI0nTrNXpOJ2ed5s4qEJyjaSSCdnS24/O5zfUkBP+kCsVWj5ZlifFwiDAMjE1aVmgak0Aqq/PAwGKQ4L7ut8X++7sgOEcvjtCL4yVdCdtSq7SCzz1QshxM2eZ71bFeyL/+X/53/Z/9o39wLxdJXhQoysudUkYpOGeI2uz/qpBKIUlSHE/O0Dxg9tWW5dj3l2bGwY+j6MaSHJsV933vk0y573vIc9PLU1YlyrLCoN9H1DrXk+kUwPli53seenEMwCxIRmfBRFEJAMoYOGNopOzKhoDzni37d0Ur4Cg4R+D7yIq8K9U6h2BvZ7T0Pozzf+7E13XTRnBV1++f5QXKqkRdNxCCg1LWjSSxv9sGyrIyqtBb0APquBu2dxYwmhdKKWitwRhD0zRuEoDD4ViirhtQRjGbzzE5m210dVgUBmgaiX4/RlXVGA8HAEyrwDZRlhWyIkdV1SgrMwbwrlBKcbC329kojs1gNk8glexEzZM0g+Ac0/m8tZdN4ipJs0+SZQ8RjBOcY3dnDLR2Q1GWGPb7AICiLBH4PuZpiqoydrTr33fcFfLP/9X/qP/b/+qP1v5CWpseuMucIUoIoigEXVDLXhV5UeCX7z48SGRdcI7RcND1Nz11rnPe7TxZI4xnRuLZzywMA+R50ekBCMG7Y1ktCXvceZKiKEvsjEcP+pkXZYmmkQ9m1Nmec8f6saWygJlY4rL8DofjtpRlBaVVl6zI8mJjgwHDfg+MMdRNg9FggKZpMLig6bPp2GTGyWSykln1lFJ879VL1HXz5BX/twHZ+gKM0qWfgfPEmuAcJ5NJq39hkl5mj9cQnH8S0F+sMvA979IKZiFEV8Frk37T2RxKKwguuqQbYK6pRp6/9mKVsMOxKvh9OUl5UVyZCbWlU6t2/suyehDn30byLordPXWui1T6/nn03PYY1nWDeZoiL0oAJipqv0t7LCFMmWJZVvB9D/1ejH4vxtlsjjgKkecFhOD3lqmwow611t3mch9Yh5+3feaU0jYDTU1bDTQoOd/wlFK2PR0EBKodw8MY68YTKq1BW9E6pZSrZLgGQgjCwJWAOhyOz8P3PUilcHI6wXDQx+HBPt4ffVxqD9gUpvME/V4MrTTSLOs0TThnW1ENME9SBL4ZzZflwUoCAEopTM6mXbbWsdlcVx5vbdCyrHB4sL/02E3Vp4vJqEVNg7woQAlF3TTI8hzDfh9106AsKzDGIKi4NHDkMvuOdXMvV1hZVSiv6P0PfB+U0bUoYb87+nivzj+lFHs7o67kyHE3hOBGgOiGhfeyyOhoYDZj2gYTJtMpBv31VmJUdd3Nu10lhBCw1qHXWkMDS9l9wfmSboZSCpQSAASEmNaaoqzABAMhxuEHpWCMtqXqAOcMTWOOq7RG1AblirI0wQSgCwbYIAIlBBomjnDxnB47pmWJgzG6VAHgcDgcnwtry8gBU6psx3bZSoAPxycP2sK4SJrl2B0PkaQ54ijEx5NTvDx8hjfvP2BvPN7oTGUUhWCUYjKdrjRAb8UERcGd/fcIuOwavskhX3x80c60gTHf97rkln3uJt8rjsfP/QQArun7Z9QY0Kvm+HRyr0q7vufh+cG+u6HXwF0ioXYhDnwfp5Oztan0SilX7vxTQjqn3vMEmkaCUgJGGZQ2IwVNuRnpDEVGmYk+M9r2njMoreF5AlqZ8jU7ik5rDeaZiQ1GxMgzv4dx5o3KrAAhBJSSrqogaCsxtAYoJaiquuuZs8d9zCMOPWEi9q7U3+FwrBoj9BUZtXpt1tkXz/ZR1Q1OTicP3h6glMLHkwkE55gnKQ72dpFkGQ4P9vHh4zH2d3Y2Nntp7YEkzVaS/V9kceqLw+FwbDprX6XtDNmLUELgex44Zys3pKfzBCeTs5Ue8zJs2c7h/v7GbngOQxgE4Mx8Rx9PTjHomfaMVQRsirLsRhauCpNVpgh8v+tZZIwCMOWWAEPg+2iaBpSa6Qv2Z6KMAj2jtCvptxlqUx1wXimgtQajFIQDjZRQSi/1nGmluyCCVhplXQFtywCltJtaYYIEDE0jwRjt9BkIMefSSAnBOfKyNCKTTdOJT4o2k15WtRGiXKh2wMK/pVLgjHWZG1t+SoAr2xPuqoXQBUranj2vDYg4HA7HOmHtug6YvuU0y5fKkpVSePP+w0OdXheIsJWWdd1gdzRC3ZhxbRcV2zeFJM2uFKO+C/M0w+54jFmSYtCLV358h8PhWCVr9Vq11l1WEBeMcNY6OKse93d8OrkX5x8AmkZif29zo92OZez3tL+7s7JpAmbcjFzpSCHPE115ve0lsxnni87nohiN/dneU9bpXyxPX7zf7M+krTS4SqleKQXRHsPzBLTWqKp6SYyxrKpO5MbqBxgFfLmk16ChO60BuzZQaoIERVkhjiNwxpAXBTwhUNWmdaiuG9BWi8A6/Lw9BqUUlABaXaK70AYJumBC914Z6rox59lWL6j2ubYdSWuNKAxQN41z/B0Ox4PBKO0c6pPTMxSVGXv2K9//BpOzKWbz5MEqA+waXNU13h19xKAfw/e8jXWEBed4efgMAPDm/eo0omxAZjjobdW0IofD8TRZ6wplxsypT4xyzhh831v5QfQnxgAAIABJREFUaKzJdHovzj8lBEIIvHr53Kn7bymr2JylNCr/qzC8WDvWxarIrzowdhcungshpKucsP9fFICSUhpnXWv4nkBZ1WCMIi9K+J4AtWMn24CGPX4vjlAUJTwhwJmpGuCcQ0mFIPChlBE1rKoavA0GCCE6577WzVI7kScEaNujv6iRYCsHPGGCNjf17/uea+txOBybwW47WjfLCzNBQGm8evkcSZpCSnVvCZBFlFKdEnqec1Sswe7OqBt1uEl2ku97eP32HXpxjGG/1/Xvr4KyqlDXjdHO2bD37XA4HIusNQDQSNmKkZ3DKIW3MA5jVSRphqPj05Ue8yqEEPjeq5f38lqOzaSqa1RVvRLn32b9PSGWfr9Yrr9NdJUH7b+tOv7i+7OTP2wHRtOYDH+/F3cOfSOlyfJTtZTFZ4xBcNbNwr0Ni9l7+7MT7nM4HNuKbUH0fQ9N3ZgS/J0x9nbGeP32HaQ0k13uqzJgOZOukWU5hoM+kjRDGAYb5QzTtj2uF0UrDQAARhAwCsOVHtPhcDhWzVoDAJ4QSNLsk9+tWiivLCu8O/q40mNehnU2rFqv42liR7h8adm/4BxKKXieAGfsykqYbXT+v5TFz8A66N3M3AuOeugcd4fD4QDQiin7Hg58Y5dIpfDi8BkYpajrBsenEyRZdm8TkZIsgycE6kZ24oCbxsGu+azW9Zm8O/qIr188BwTfqMCHw+FwWOirF8/XdvCqrpecJMH5yvuiyrLCd2/f3dvm9qPvf3PpzE7H08CU+NWf7fwTQiAER9jOIO7FEQLfX3kbjMPhcDieLna6Ul03mKcp+v0Y3/vqJUbDwb21M1V1jSzPoaTCx+MTZFmOvChWOnrvLgjBQRnFPE0xHg5WfnyrB2ArMxwOh2PT4Ot0Zpvm3EmirYr2Kstu79P5XxSOcTxdyrL6LCOGEoLA97t+wKeU1Xc4HA7HwyAEx85oiLpuUFYV4jDEs71dlGWFeZpiMp2t3XbKigIRCXEyOUMvjkAJxawo0IuiBxfJU0phnqQYrSEAAJhKwe/evjOVAA6Hw7FhrM0baRbE0QghRjhvhdnOJM268TP3weHB/spbFxzbg9YaeVHgtgPlCIzYZRgG8DyjeeGcf4fD4XDcJ0Jw9OIIvThCXTeQSmE8GuJ7X73EsN9b+96U5TkopSjLCnXTmHGwRfFgUwsslFJ8/+uvMOj31lbVqZTCd2/foVzD2EGHw+G4C2tb9cuqBm1ndDNK0YujlR5/Op+jrO5nUT082Hdl/08YpRTyokRZ1bcKOPmeAG+F/Thjbnycw+FwOB4cITiiVpBPCI7d8RivXjxHP47W2o6WFwWyougcf1tFN5lO1/aaN2F785VUGPb7awuC2CDART0sh8PheEjWFgBQyoz/I5TC97yVOkHHp5N7WUwppTg82Mew31v7azk2F1tCaVXor4JSil4UQmmNMPDhe57L+jscDodjIxGCtxUCMb46fLbWRIdSCmezOaSUIIRASYUoCB+0R346m+NkMkGW52u186wmwC9ev3mQMY1X4SoTHI6ny1pCvnaBt2X/nidu/qNbYEvI1r2AUkqhlMLzg/2VVy44tgsp5a0qTWgrvPT/s/cmv21s+77ft1ZTPUlRne29zz63SYAHZBDgBXkZ3FH+3IzeIJMHZPKQYUYZB0Hevffs421bHUWyutVnsKrKVGNv2SIlSlofwHAjq1ikqlatX/f9OgeUebhmAoHXzlDFfIzKt7EWQkgkSQwhJJq2Hb82P5ihaVqs6xpHBweomgYHsyl038bdiQ5pkqJpW0yKAk3XgjOOJI7BOcO6qjEpCwghQQhB3TSgjCJCBGstpFLIswyUEH8eUoBEpO9cYlBaj7olSutxBK6qGyilMD+YwRo7tnU/90x34OcpixxCSEwnE8wmE1xcLXbSom+txWpdIc/8dVvmOaqmwbQsn2WvNZtOUJYFVusKbdeBM7bT0QQhJcSVRN20OD6cI89SGGufzSlAKgUA472tlA73cSDwRtjJna60hrXWt0FveTHZtd3fsHlSSofg/40ztP7/meif9xQm4JSBsWBRFwi8Bb63aTfWwhoLztkYgDd9gEEJwdX1ElEESKXRdt2d7yeEoBMCzjkYY7GqKlyv1ri4WoBEEeytbqQhKZ7EMSjtW5udw6qqxnOVSsMYM1rxdkJAG4OYcTRdO3qjp0kCbTTWVTX6mV9dL5EkMYosw/VyhSxNcLW4RickjDHIshRJHKNpWzBKQSkFZwzTjapqCC72mySJYazFYrnEpCxgjMFyXW39dZTWWK4rJHGMs+YSs+kEnDFUdTPuv56S4T49u6jxy7tTfD6/2Lm2VNt1+P2PTzg5mmM23Y0I4X0IIdF0LYyxcM6hE8ILdN9yh9B9wi+Jk/HnsU0Nr0DgLeOc24vR4Oj//L/+b/cf/rt/2toBtdZoOwEAyNLt2ZwZa/Hvv3/caXZ22Bg554Li/xvHWgulNJp7NuebsN7VYpj336bLRSAQ2D82A9nbQe3Qzsy5FzoTQuJ6tfYdcSSCUvrZxc8eQ8w5HLy7ibUWlFEk3Hf4RVE0VhSP5nNYa1HVDSIS4fBghqbtxjbrofMB8AFhnqYhObBHCCGxXK/BOUfbdqjbdidB8bQs0bQtppMSSmnMD6ZwDk+uuaSUxmpdQRmNJOY4u7h6ktcduk2P5geYFAVYfw9sqyNAKY3FcgmlNYSQ4JzBGDt2NQ4jips/2yT2e+Bh5FFpjZhzFP1443w6DYLYgcADaDsBvSmGTwgYo3DWQRsDQgjSZLsj8j/CThIATdshy9KtZgw/fv6ys7l/zhgcfFYmiTl+ef/u2VqyAvuBkBJN+/3gnzOGKAKcA4o824uMXiAQ2B5N241t8EOAulgukacZkiRGVTcwxoBzDiEFlqsKQkokcfxkIrUvgWGjM+wJCCFjkEEpw7QsxmDoYrHA8Xx+IzhhnIVn8jNQ1Q2UVkiTBHXT7mT8kkR9Bx1niDnH8dEhhJDPkgQglOCPz1+eLVE3n01RFgU4Y+iEQJok30yM3U4+Nm2Hpm0hpAQlBF0/MrvtxA2jFIwxvD85DomAQOA7WGshpBo1xCIADt4lDP2fGaVIkhgx386o/I+w9QSAlAraGGRpspWASCmN5Xq9s7n/YXabUgrOGX55d7qT1wm8HJxzqOoG2phv/p/BOomQaOsil4FA4Olp2g5JEkMrjU4ICClhrUVZFGOLLOcM55cLdKK7kSDc9ezwW2FoR445A2MMzjlMyxKMM0gpQSIytqoD26uUBr5P0/rxlabrcHZxufWgMk0SnwTon6vTSXmnLf0puLhaAAAWyxUAPJnN9H0kcYzT46MxEdK0Hay1yLK0766pobUBJRRSyRvjGkMybRfkaQpCCKIoQhxzpEkSxmUDge9Q1Q201t+1EU9i3o/wPV0XcfS//e//h/tf/+V/2doBhzajbaifD1nY3//4tIUzu8uwSMbcL2If3p3s5HUCL4u6acdW1vsYbtThIRgIBF4GxlpopUfRvYvFwm+q07SfZc9Q1f0s8Nn5GNQb458TURSNVma73GQH7pJnKaxzKLIMlFIwSiGlGrsNB42FYNm7OxbLJax1ICTC1fVqbG/dJsOz9fBg9iyB5ZfzCzjnsO47TvflHh+6aADc6FDYdfKREIKEcy8gGkWomxZwXjiSMTqOCsxnszDGEwjcg3MO66r+Uz2xKIrAOUOWJE/iIMa2XVm3zm7txK21+Lxj0T/SZzHzPNvp6wReBlrr7wb/jNJRLCsQCOwvm0J866pGmiRjW77SfgNd5t7/fLlewzkHKSXKPMffP30Go/TGvOztlv59CQzeCkPHRddrDA0ktReOs9aCM4a6acckrdIaWe97H3g889kMxlosV2ucHh1CSInFcrW1e4EQAiElZpNyTLYx+rQOE5OyhFIKptcB2kUb/c9grb13LHHXnUe878RxzmE6KfHLu9Nx3GC1rsA5w+nRkU/AaYYkicP9FghsEEURJmWBumlhjLkj4jvgnIOSCkZ/FevdZZFxqyMApm+Z3kZwpJTG5/PzP53DfiyzSYnZdIIsDVWDt44xBlXdfPPmpIT4RJFzWxO3DAQC22GYiVVKo25bZEmCi8UCxth+bpXeCOI5YxBSjUrYtLe7u02o9L88kjge7YdJFH1VNA92hVvj4moBKRWSJMa6qreueUEIwcnRIRilT94JoJSGNhp106Kqm6Dn0ZNnKeazm50Zy9V67Jo8OTpEzHm4xwKBexhE8r83XjzgRcUJYs53Fm9s9ajbCPyNtWjbDkorNG23083XydEh0iQJwX8AANAJ+d3gP0sTRABoCP4DgSdlEOgCMAbq1ljUTYs45mjaFkmSYMZLXK9WMMZgXVUwvU992z9D7lO9Hv7+redMCP5/nqEK/9SfoZDyZtC29g4GjFLfyoxo7PorizxULH+C48M5AOB6ucK7kyMIIfHl4nJrx7fWYnG99NaA/TP3qUTnOGdYLJdglEFICcYYIuy+2r6vDJ+/c95ytBMCjHldjtlkgtl0AsAnhZ5DzCwQeAkwxhDHFtyx0S3vW2hj/C9tRq2NbbN1EcDHcnZxiSxNd+7F+o9/+RVnl5f47ZcPO3uNwMtBaz3O/N2GRNEoUhQq/4HA0zEE/oMq+KYq/9nlJYwxoJQi5hydED6Jd+u5ESr4dynzHFEUQRuDtLe+pZTCWgttDDhjoJSg7QRizlE3LY7mB1hVFfIsw7qqEXM2Js+1MYiiCFEEaG38nDCAiESIEI0/p+Hr3xuzeio4Y73okh/pSpIE07J47tN6kTRtB+ssOGX42x+ftjoSAPhkQxLHT9pebqzF7x8/IYljVHUN69ybEvtM4hhZlmJaFohj73gipUSR56NYapLEWK4riL6LajbxiYDbHQC3HQsCgbeMlArqT8aNb8MZ27rb2F4lAJq2g5ACVd3spPWfEDIu4FmaIE2SMYsdeLtorVH3Cru3iaIIWZr07Thh7j8Q2CVCSKzrGseHcwghsaoqUEpxvVyBM4ayLFBV9eijszmj/1bwSvgc1joIKXE0P0AnBKTSiACwXqwr5hxaG3DOcDCdomq8argXGuLj2iaEvNHSq1QvLvaIDbux1gsCMwZCyRi0bQYCVd2gLPLRg50yCmMMGGMQQngLJaUgpbqxNn+ri+OxeJG1BK63HUyTBIcHs62+xmtnta68/ZxSqJrt2Db7wLIEpRSdEPj1/butHPchDEmANEmwXK+f7HX3idmkRJIkmM+mN/69qht0QvjCCGVgjEIqjXyjo1ZpnyRYrdfgnKPMg1tAIODtAeXYofgQhmd6EvOtxSJ7lQAYPGfPLq52cvwh+GeMgTOGv/4aqv8BYF3V35zJybMUEaJxnjQQCDweYy1W6zXSJEHc2319Ob9AliaYz2YQQqLpOjhnsViuoLVBlqbjg/OtMSiAK6UxKb0tIWMMxhhMygJCSBBKYI191d7cw4jg5eIalBJEiGCd3Ylve8w58iyFc24UvwsOA3/Ouqpxubj216vWWynmEEJQFjlixkAo9cnAJ9QF+Hx2jk5IvDs5wqcv56/eBYQxhpPDORj7Kur3PevNwa57SNLel/Az1uJqcY2D6TR0AwTePEJKKKW9WPED1xHOGOKYj9b1jyX6z//lv7p/+U//8dEHeixDq+d/+/ffd7KoEkLAKEUSx9DG4MPpSViEAhBSfnOD4ttgKbJ0+7M3gcBbYrDfI4SgFQLTsrih0l/VDaq6hlAKXSdueIAPVlO7CPKekyGAGN4rYxRpkvgW+9q32Jd5AaV1EK/7DpsdC8vVGogi1E0DYyyatt3a6ySxV2RO++7BoB1wP0JIMM5wfnGJmMdQWuF69fjqOe+D0WlZYrWu/FjAEya7lusKVV0jzzJcXF69upGAPMtwND/46SSXsfZP7welNZqmHTUDAoG3inPOj071Y3cPhfWBf5rE4I/U22AXi8WjDrBNPp+d7yyjSgkZg//Dg+BXGvBYe7/oH+cMMeOh8h8I/CRKaazrCpOiRNN1yNMUhBK0XYcsSbzQ1vUSUipwzsYN5MnRHHXTjok58UIL/owxUELGuT0SETi4ft7eb5TnsxmquvFe2xvzzZub8PCs+j6bn88QWMwmJQA/Vqi1Rie84BIh/vpT2mA+m8IYr0egtL4zanAbpTSss+iE10Vo2w6ERIjjGJONqudbZwjK35+e9K46FvPZFOu6gX5EsDwkwtZ1DcYZrHva6vtsUmI2KbFYLjEpS2hj0Ha7dal6KqZliQ/vTh51jIdc/8OYzXK1Rp5lYW0LvFmi3p1GCAli7TcFyG+jjemLB34EkDM2jsX9KHtx9w2VneobImyPZVAi9u3/T28pE9hPhJCw92TeGKVglIbgPxD4QYy1qOoGs0kJzhkODw76FjcDay3OL69grMXlYoEkiVE37Y3gzFo7Csi9JGLOQfpgn1KCPM3GACWO47HT4T7C82h3DImUaZ8Q2EQIiU5KzA9mWK8rCKUwLQtIqYAoglIKbdeNiajNgFMqBWONT+YQiuVqDc4Z5rMp4jj4oA+UhReMu16u8ZcP73BxtXjUPq/pOmRpCikVDg988mzoDHhIBXobzGczNG2HumnQdR2SOH6xY0lpkuCX96ejyv+uoYSAJrHX4wrBf+CNwyiF5QxRBAj5cEHAoWuAkAiqF+P8qdf/qe/aIsPD9XJHnQicMaRJjA+nJ/hycYn3p4/LcgZeB865XrTm5k1HCfGZufj1ztEGAo9haLnerOoD/t7Ryldb0zjGH1/O8P70GHXTwjmHVVXBwX1ty77VFcwZexEb6flsCuccpNKYH0zBaV+VpBRZmt77MA4B4f6RJPH4szrYEDjL0hTLdYUizzA/mIESgqbt0LQthJDQ1kAKBWMsoijyNofOQkoJISSyLAUlBHEchzEB+Pv65GiOq+slGKU4mE2xWlc/3e3Zdh1izvukC4fq2id1BwB8YinPUpRFjs9nFziYTrCq6helCXB6fIj57HlELkPwHwh4KCGQ3+hE/h5SqX4cwBcxfyYJ8Ox34bqqUOT5TlT/kziGtRaMeU/XXz+8e/MP44BnmLm5PXtDCPHCf1u02ggEXjpt14FE5EblZsZ9VXVd1VBaoRMSxhg463DRd1t9Ob98cFC/r8F/lqZjR5BUvk385PgI1vjNvrV2DBQDr4PZrY6BIeAbEP1cyufzCwA+oWyJg9YabduNVop13SBJYpS9ddpb5vBghuW6gpQSH05PcHG1+Ol7XiqFy8U1AOD9yfE2T/OHyNIUf/nwHp/Pz5/tHH6EYU98enwUOo8CgT3gMWJ+2hgkMR91SH70GfOsCYCLqwXSJMGns90snn5jNkWZFyHjGLgBZwzrqr7xbzHnSPv2tEDgrTK0tzrnUBbFmGkmzAf/16s1un72VWmDmLMxkTba8onnfAePgzGGaVmAEALnHDohcHJ0CM4ZVlXt2/wJCQH/G2bYaP3DX34B4BMCy/Ua2hgIIb1nfcwhpAJRCterFYy1+OXd6XOe9rMzJFaU0phNSxhjx0D+Zzm7vILSGpOiAOPsye9Lzhl+++UDmrbDar3Gcl096es/FEII/vG3X5/7NAKBwC0oJdAa+PE+AD86kMQcxlo4536oePlsUbGxFlIpLJarnbRNDcIInHEvlBASAIENhJQ3qv+stxbalr9mIPAS8HZ7vrVZaYPjwwNw5n3jV1XlPZyrCkYb5HmKj5+/+Gp4EkNJhU7KrSqtPzWDnRghBJOiQN22aLsOjDLMD6Z3/v+0LJ7hLAP7TpLEOE2OAPR7GynRCdGLOyZYV77l/dOXc0zKYpxbf8tY40ApxfuTY5xdXv30PtDar0mESVGAPtPn+nUsoMByve7X1K+ihySKHiz0tU0OD2bIshRlHir+gcA+kibJ6HT0M2vEkARoO/FDRcxni4rb1s+P3q7CboPhzU8nBZq2xenx0dZfI/Bycc7deTAnSYz4kZYagcC+M7Qur2s/r8o5QxInSOIEeZai7TqcX12NquiMMcC5UbAPAFoh0IqXWeLPsxRZmoKQCNY6pEkCSgmc25wJf5652MDrgBKCLPXX2UAUAV0noI3B4noJYy3SJMFsWiJL0ycTsNsXOGc4OjwYbeFOjw6xWK4eNQZ0ubjGcrXG6fERJs+YqCuLHGWRj4KoVb/WdkICzo37013qBSRxjNPjo2AfGgi8AAbdMUoopFbQ+uG2gANaG3DuC96bz57vvu5//i//1f3Lf/qPP/xij8VYi//2779vfREcZrgpIZhOJk8uDhPYf4SQaIWAcw4kisAYQ5Fnz31agcBOqOoGWZZCSom2E6CUjuJ9F1cLUEIgpASJCLTRIITszJHlqSGEYDYpkaYpSBSNM3PGWJRFDqV02CAHngxjLZarNZq2BSEERhvE/R5lNpm8yWtx+EyKLMPn84vRFeRnSeIYaZo8qzbAtxBC4mKxQJ6lWFyvbhQifobBOYX0I0l5liLLsiA+GQi8MLQxoxWtNt5h5kcZ7O4R4UFC5uzo8OBnzvXRXF4tdpIBPT48gBAS89kMnZQ3hHsCAQDo+ipDFAGEknCNBF4NQkgwztA0LSZlAWMt6rYdZ/oBX+nWRmO58POqnDFEUYQoivZWiO+heJ9pr74+nUxQVTWkUui6DpwzpElyIzv+FgOuwPNBCcHhwQyHBzOYfv9jjUXbdVgsl2CMIYnjN5WQHj4TIXzlivO7+jw/gpC+9T4C8G7PkgBJEuPX9+8AANPJZOzIElLAGAvd21WnSYIoiqC1HoN8qTSUUtDGYDYpMSlLSCWfTck/EAhsh6EYaYwZtYd+BmO9BhNjDFKpP+1qZsMC9FSo3iZqsVxt/dicMZCIoCyKGxY/gcBA1wlE8DfcUAkNiv+B14LSGp2UEEJAGz16mkulQUgESgiWqwoX+tq3hzL26CrUc0KiCJOyAGMMEYA4jsEYHYP8NEmAKLqj6h4IPDdDhZYSAs5LFH3VdlXVWK0rOPiRFbi3kahKkhhH/ACL6yWO5geP0oey1uJ6tYZUCr+830/3p6FiD+C7RYihS0kIecOFBQAKvJ1EUSDwWhkKMGWRo25aRFH0qCQAf+D3s4+fP+N//B/+w0+90M+gtN7ZrPVsMsHZ5RXenxyH1s7AvVjnxuA/TZMg+hd4kQytpEMATwnx8/rwFlmmF7hkjPlssJQQQsFYO26qX2q1fxDuS+IYSmu0nQBjDJ2UvqNno3oaEsGBl8IQpA5Ck8ZarKsazlnkafYmrmNKCI4P51iu1piWBaTSjxIZbdoO63WFyaTcyyTAQxj2sW/h5x8IvGW0MYiiCIQQRLhrU/5QhBBeh6TvKPhWkZOpnxAbeAxJEqNtu+0fN46xrmtMihwx5yH4D9yh7TpYa0EpBaUEnIVrJLC/DMJgVd2gEwLGWkyKApeLBcoix+HBDJeLJTijPqG1Yak66efbl+tqp2JTT0USx5hOilEcZzaZAPAeuseH8+c8tUBgJ1BCcDD117lSGlXdvBnv9tl0ghkmWK0rxL316M+yrmsYa3E0f55x10AgEHgIg73wY/dsDkDdtCiLHFKqbyYPnzQCWiyXKPMCVb1d5X9v4ZRDKo3ZdBIypYE7WGthjK9+xjF/kEBGIPDUVHUDrTXiOB7n9suiQCcknLNAUfg5WcYhlUbbdajveVjsqxf1Q8mzFJwxxNzfp2maoOsFDA9m07GaF9b6wFuA87ep5s4YgwPw7vgIXy4uf+oYSmnYxL45p4VAIPCyGEYBGKNwzsFY+9OjANY51E2LNEkgpLw35nnSJwpnHNbarW9OZ5MSnZA4PTkKVd3Avbi+9T9Nk2D3F9gbNuc6q7rBqqrAKAXr29ydw6hcXzctfv/j0/i9SRy/iur+QBLHo4K3z14XyLIUQkgkSRzEOgOBN0aepeN9TwjB5eIaUqkfOobSGtfLNZxzwRI6EAjsLVEUARFAI4pWCFBCfnoMAPgqCpimCYwxd0aenzRaLoscf/v4x9aPOykLWOuwuF6GBT5wL0IqUEpD8B94VgbVfUoIzi4ue3s+hVYIpEmMw4MZmrZDVdeomhacM3T9jLu+Jdb3Umf4B4bOLc44tPGz/HHMwSjFyeF8rO6HwD8QCCRJjOOjOS6vrn947bPOoqobMMpwOA+q+YFAYD+JOYexFjFnjwr+B7Qx0NqA9loAZKML6skSAEP7lbU/187wLWaTEowy2MjesHcKBG7ivCJ4IPBEVHUDpdVNmybn0LQdrDUoyxzz2Qznlwtv/6Q0/vbx0w1v5yzxre+3g/+Xynw2RdLfh3XTgDEGSgmSJMfh/CB0cAUCgXtJ4nh0ebLW/rB7iXdIEbi6XuLwICQBAi8XpbxdpJAC08kElBBcXC2wWK6QJjGsc0jjGG0nbuhdNW033jdJHI9fm04m3nveWuSZF9EdxIUBgHEWxmeeiCiKoJTy3Z9b0ujrhMBsUqLtBPLsq/PZk+62/u33j1utWjHGwLkfKwhqz4Fv0QnhNw9hAQvskMFSdV3XOD6cgxACSr1909nlJaRUOD46RJrE6ITAal3j7OLqxjGyNIXSGrZX69+FXepTksS+dX9IgizXa6T9LFrZ254FAoHAQ+Cc9V1DFGeXVz88ArWuauRZFlyiAi8KYy2EkBBS4OLq+sZ1f3ZxdcPOt+lF1rtOfPeYm7HYMJadxDE+n1/c+H9ZmiJLExR5jjxL0bRd6MrbMc719rCMef2yLYx61k2LNE2glEYc+07oJ1kBldIQUm69ZXVaFqjqBkkSg9mQoQrcxTl3p+0lENgGy3U1BrFKaUilkOcZpFT4cn7R+7oWEEqBMwZjLM4uLv3/7x/WeZaiE3J8oLfd9h1SnhLOGPIshTG+I4tzhiiK0HQdZpMyKPYHAoFHkSQxWK+Z0vTOPj/C+eUV3OEcZZ6HJEBg71Bao207NG0LSinqpv3T2OlHu2G+xX2v03Yd2q7D1fUSwNfOgSxsj/LpAAAgAElEQVRNQQhBmiRIkjjEX1uEcwatvSXgNoJ/wI8CGGOwqSn4JKsf5wzL9c/buHyLLE3hnEPCw8V3m+GioYTcUb99S2q4URQFxf/AVhgq/EOnkerFqC6vrnF1vYR1FkkcI445CCFYV/Vow0c2rF02N6zNDixRn5qhyj8pC3TCtyS2XQdOWWgdDAQCW4cSgl8/vENVNzi/vPohYUBrLS6uFrDGoizy0Dka2AuEkLi4WqBqmuc+le8yJAlu710IIaNoZ55m4b56BFEU9cVLIIK39dsGUirEMR/3pDtPACilfypL+2e8Pz1BWeQoe7/rwF3qpsW0LKCVRiUllFLQWkNIBefc1znjNOl/T5HEcciKBwIbXFwtQClB03aYTSdYX9WYFIWfXycEV8trzKYTCCnRtN29WfTXpNZPCMFsUsI6h0lRQCr/vq+ulyiLApQQlPnb8CsPBALPR1n4debj5y8/9H3WWlRNgygK882Bp2No5W/aFoCvrhtjX7ygL9DfU3WDqv6awMgzH1MEcfYfg1EKFSkY40Ap3YoYIOCvv2FcJInj3ScAqqZGnmY4+0kP1/sYNqDLdYU0DrP/t1muKwghsFxXuFpcAwDSJEbddqCEjIsNiXzGjlIKSumNeZPwQAwE/II5m0zAOUOZF1hVFbQ2qNsGWhv8v//6796B5IXP6j8ELxZUIoljKK0xKQoIKZGn2U2hw0AgEHgiyiLHP//1N/z902cg8lWuh9AJAUIiWAfMD6ZhzxPYOrcD/rppYYzZWsv+vtO0HZq2w3JdYT6bgkQEk0kRxH4fiHMOEYmA7cT/ALywIGXeDpBdXl1v78j3oJRGg3arFbBJkaOqG3w+O8d//0//sLXjvmSatsNiuYQQEpyzsT1nCPaH3zeXHess1nWDtE+g1H3r0dH8YHRUWFf1mBQIyrmB18jQQXR2eYnZdDK29udphk4IXK/WKPIMWmus6+ZVVfO/R1nkSOIYaZLAOTfquEyKApOyAIDQLRQIBJ4dzhn+6a9/weezczDKxoDrz+iEBKUUF5dXeHdyvOOzDLxmNoUlr1drSCnHEcAkjuGc+6FRldeEtRarXmjw/OoKZZFjNpmMHTyBu3Dm9ZO25QQwYJ0DH1wALhaLrR78NoQQLK63Xx0rixynx4dvOmvr223qUURsyCo+JLtY5jkiEmE+m47B/qAboPuAqO26caM/CIHEcdBbCLxMNsVUrLH4+PkLlNaYTcpRef/icoGyyBFF0Y15vE58X1H3tVAWObLUz/MPg2ecMyilx7UgEAgE9pH3pyf4+6fPIBGBdX+eqLXWom5avD85RtN24IyFpGbgUbRdhyxJwCjFpCwgpMJy5TXQNrWA3hqbcUlVN2iaDoi8nsf705MgJHgLax0ieC2AbWKMASHeinmnK51SGmma4HKx3S6Ddd0AZ+c4mr8tRekhgKnqBm3bjtYdP4OQEpwxrCufQCBRdOMGZZyB0a+XRxzHWK2qce45ENh3lqs1ZtMJTL/JSzjHxWKB96cnUFr3bew55rMZLheLcXbtNczj/QhlkSONE2S9gI8QEkrpG1Y/YVMcCAReAh/eneLyavFNPZbbWGuxXK9R5jmqug7zygEopdEJAUrpGLATQiCkgDEWnHPMJuX4/4WQaLoWaZKgE35vvVguX818/y6wzgLO33+fz86htMbp8SGmk0mIMeD3XG0nEEXRVoUAo776D+w4AcA5Q9XUWz3mYOd2NJ9Dm7fl5dq2Haraf56PCf4BjAFQJyWKLMPR/ACcc0gpx2ro5mdLCcH8YPqo1wwEts2gVzG03zX9PZJnGYT0qrqz6QTTsvBjMQ74fHaOPEthrR+BadruzczkDZRF3gf4EYwxMPZrm1nQVAkEAi8VSghOj49wdX2NpvU2an9G3bSwxiJJE1xdLzGbhiDkpWKsRdO00MZgPvvxPWvbddDaQEiJOI5R5Nl4LWwmxZfrCrNJiS/nF2g73yF4oa/fbIX/MQz7r7OLK5xdXCHPUrw/OXlT8d1tBicA5xxI7+a2DaRSyGyyexcAISSM2d7NkGcpijzHpCjA+dto1TLWQisN6yyaR1b9b8MZw8nRIRijYJzBCImD2RRK6yDSEdhbjLVYXC8xm0xAKBmVdDn36qbWOWRZiqqusViuIKTE6fERmrZFFEWom/aGUu22FtZ9Js9SZGkKSgmM8e4fSmnMZ7M3sY4GAoG3xeHBAWLu13kp1Z8meVshYKwFYwxJH/gFXh6UkHFcTQiJumkwm90v8jjo/wzPQKU04jiGc75qL6WEvFXBJ4SAUYqYM6zWFYoiR5qmo3aQMQZCKkSR1+YaipYhMfBwmrbDv/39I44PD960wDCjFMq5MRlgtzAOsHkf7GznJ4SEUApttz2fa0LIKEQnhHwTlaqqbmCMxuViudUFhFGKdyfHICQa5/qH7GYI/gPPzXB/V3WDJI7RtC3imEMbgzzLQOnXh+qX80tkqZ9pmk1KpHGMxfVyTJbdtqbZ5LU+lDljvrU/SeAAVHUNrTU4z1DmRQj6A4HAq6cscnDGcL1aY1VVf7reS6VAGcXZxSUmZYHjw7c1ZvraSJIYjDO0bYdOCMwPZmjbDkkSgxACQgm00mMHIecMxlokSQzOGISUN4TqNoX+AGCjIQAAcL1cjUmFKIqQZ9mDBSkDN7HW4uziCk3boSyKGyMXbwXKKKRWgOtb97eQAOCcjUmpne0C17X3yu7E9uZfZpMJmrbzqpqvPPhvesu+xfVyJzNElFJ8Ob/YS+Xbqm7Qdh0Opr4bIb+9yj6Q24t1YD8QQsJYC2t9V8twfQ+ZXqU0CCXohECaJOCcYfHZV/IZY5gUue9S4RxdJ5ClCUwv6veW2KwsMMYwn02QJikoIWPypKprlEWBX9+/e+azDQQCgacnSWIczmeYTgp8Ob/80/1U23Y4PDiAcw5V3QSl8hcOJQRlkY8/R84YmqZFWRaghIDeiiWGCmnT+I7Bv3/63HfNRaOH+ib37TOjCGg78WoLDE9J1Y9ptm2Lk+OjNzWawyhFFEWjE9s2IE/SASAljg/nW70BVlWFmHPEnL/qKvW6qiGkxGK52tkCEkURTo+P9rLNbXOxXlf1GNDcx+3FVwiJVghQStB1AkWePziBMMyTP5aqbkbBmDIvUDU1kjiBtRZVXY8PEELImNm8uFp49dg0RRRFozPDoEo8BM0AfjohsmuaPrO+2Z1T1Y1/4LYtijzDl/NLUEpBSATGGKy1cA796Ikas+fN2s/lp0mMJI4xP5hBKTVa0Sml8fHT2wr4BzjzVYo8S8EZQ5IkyFOvacA4G108Nu+jQCAQeKtwxsAZw+HBDBdXiz8dB7herVAWOYzZrgVX4PlJkvhBBURKKZIkhtIKSZyM/z4ULvIsgzYG3UaX8zZHdANf4cxXrX//+Amnx0d7uwfeBWWeY7WuxjGAx8BvibjvLIredpZmUvTZOkoxfaWtIMZaVHWDz2fnO30d0s9IvYTg4HA+gxAS55dXOJwf3Lmumq7DjPvrQSmNJIlhrEUUAUXuH+CrqoYxGkmcoKprEELutPZtBv9Kayyul6MY4gBnzDtQwF/ft7O+1jl03U27uDNcfff93f55N+3DR2bKIkfMObQ2SOIY2uixcyROYkyKAnmW3kiSNG137+KplBeFHJItmyq4wFel5CSOx5n7oZKymYzzrxNB95/d4fwAl4uFD/o7P2YipERV+7Y4RikopbhaXINS4hMnQvbz/P58OyFhl9u3En0pbGZsOWOYTcs7SrlKaTDO7q1oBAKBQACYTkoYa7Fcrb/bCWD7vRgckCbJq+84Ddxl2CdtdiYqrUEIQRRF6ISv8AupYK1FFEVI4vjGdRVzDqkUCCFI+2vIOgdG6fh/ldLjqMGwf9tMUPkkv//eoRA0/J8hMAZwY7/62uwGRS9OnnCOs4tL/Pr+3Zvq7k3iGM0WxukZo0/jAjCITG3rWIREODw4eLU/dCEkFsvlGGDuiiSOX9zNkyQxTpJDAMCiDwTTJEaWppj1D/TNgHyY3VLai7Iopb+6RxzOQQkZPX+H1pohoyukxHw2xXw2g7UWymhcL1dwzqHux08Av0F4buX4b821Az4xcv2IoDnP0jEZMVTqx03RLW48rDiDdRaE+vm65Wo9fn1deQcLQsiYNFBaQ99TZdk85mt6kP0oeZZiPpvBWIuyyEF7Ndi27W4k8F7S/RwIBALPxXw2BSEEy9VqVG+/Dx/cyTchEhv4czaFx79VgTbW+gJG37l5W2QQuFnkybObHbjz2WwsxHDG0Ek5igtyzjGfzUYrQgC97eDXa1hrjeX6ptbFsN8aRqe/t2/cZ6y1aIVAnqb428c/UOTZmxkJ8IVNLy75s0RRBBKRsagH7CgB4FuAk60FSL766D3oZ5PJq9nsDg8WISTOr67uVI93QVnkL/rzu8/WZXMBML194aqqkMTxGCQNC/PiejlWnbUx6IRA23aIoghCyq9t+hu2cm+RIWlirYX+gfv4IZ/XkEwI3A8hBLNJibIoxkTJbUvOl9C9EwgEAvvIbFKibVvA+erit9S1hZS4ur4GJYc+kHrBe6fA7tkU0wbuT8xvfv32CKtSGnXT4GA6Befs3s6T28mH23uB96cn435383surhbQWqPIM3DO4ayFdQ7GmLG74SUwOD0RQnF+cYn3pyfPfUpPgrWPa/8nUTSKZw/sZDUz1iKNY6x7z/ptkGcpFssVKCWvyhaiaVucXVz9UJD1s0zL8tWr2g7JgDLPUTct/vXy72CM+VnyJLnz/qdlMYqldULeaN96KQviLnjL7/05IITgw+kJCCGghIybzeW6CsF+4MUw+Ba73rpoU6hySPppY+Ac4JwXr3TO+aqEc3DwY0HOOSitwSiFdQ60T0ZSSsd2W/IDlZ/hfAKBgfenJxBC4up6iVX17dntumlh7AXSJMG746MnPMPAa+d2goBzb839WG4nIgDc2PsOyQHGGazxHZuAv9Zlr7PUbHS87hNKayRxjMVyiSSO8cfnM5wcHb765Nx9ApQPJYoi0L7wuclOPrGmbXF8OMff/vi0lVmU+WyKPMvw6ewcebp/onU/g7EWHz992apN4vdI4hgf3r2NTBngF4k0TRDH3M+WRwSL5RJfzi/G8QFKCfI0G62Cmq6D1hqdkGja9lE3XCDwZwxWfWVRjKMoZZHfqAq8ReubwH5ijEEURdDGgBICqTScc8jSZPRZT5MYUmkQEkFrMzpUUEoAh7HSGvfXt3MOqj9uzPkYqGtjxmAfUQTrHJQ2ffLAIU0StF2HmPNxjzEkBAahpCHgj6IoBP+Be0kSvy/qhIBU326v7TqBMstxvVpj0qvHBwIvlc3Ogs1rOeEc1hjwosD70xNopdF0LYSQdwpkz4mQchz1pZRAKPnq3eE4Z6CS/PRI0n1jK2wXAbVX7PaCFLdFMX4GQgiqusZff/nwKn7Axlp8Obt4suC/LPJX1TXxEIaqqVIaTddB9UIs00kJ0leP1lWDi8trWOcV1WPOvQdszEFI9GJnpQL7w2ZwMqyHccwxn03hHFDVNWwf+A+89kx2YL8ZgvCham+d68WsfGBPKYXWBoD/f1IqWGcRc462E+NGI4oiMEr9898BxhpY63qBTz3Ox1Lq9YKEkON9Yq1FHHM4578u+9lHxhi0Nmid2FBo96KjnDNEUTSOLxljkKUJrHWjwKjpEwvD+/yRLoLA6+X96TEurhbfHWG7WCxwMJ0gS5IgtBp4ldx2SKD93wehQmMtLh/govEUDOfQtB3yNEOlfcf5a9UFGOIX0SdiHpoI8Ml1NnbQbcJ++/X91k+U9kreALaSMVosV30L9+tYdBfXy62OR3yPmHMcz+ev5rP7UThno0sA4K8lYwy01mCMgtEMxlp0XXfn4f/alFQDT4+1FrNJiaO5b78jlKCqG2RpiuW6GkUpA4HnYmjZBzAKUAmlwCiFlAqUEjjrQIhPCkSIRmVrSodqPYFUyoulNi2cc7B9IiECIOHb+Tljo/DakIiVSt/wO3bOgTHWe2+TMdCnlEBrPeq1kChCJ74KiBprwcYNjh8rUNqAkAhSaf8+nEPXJxo2Ld44Z2M3QeDtkaUpfnn/Dl/OLr67N1tVNaaT8l7v90DgtTIIIA7j3dbZ0a58H3SyLhYLnB4foqpbfPz0Bb9+ePdq91VJ4otIVd1AGwPSd8h9i8Fx4r4uuJ2sYFXdjArs28BaiyLPsFguX3wl26v9P42l2WxSvtps2M+yKSJYNQ0W18u+mhUBuHkTheA/8LNw5h+WkyIfRWqGpGie+gppaO8PPCdfg2kFzigQRaMgFOe+0k4phVQKnMEH/VEEBx/owxigf8xH+ubmYvib6+f6AZ9c2KwcGefGKsbtitJ91Y3bbiG3Nz2DbkAURWCgIMQfR0rz3Q3S5vGd9d0OEYnGpIQxZkwMhATB64USgl/en+Ljpy+omvu7/6y1uLpe4mA6BaHkTe2tTD9+w1hIfLxVNm2Gs34fo5TGcr3GYrl61j3z2YW33M7TFH98/oLffvnwbOeya6IowqQs0AkB5xx0Px5HCYHDzdglSeI7lf+BnYkAbssCcPDApOSugMFLQwiJv/3x6UlukrLIQ/D/J5R5jjLPYaxFXTd9JtOh7QS0MSEBEHgQg3Af5wycMZz0QlHW2BtVorfahRPYD257VjNKIZUEIREQ+Tb6LE1xvVqDMQpjzBiID/PR3wqk3e1gfLdv5bsMiYAfQRsDmK9/poT0n4EFY8PIwFeBQkT+vne9p3dIDLwe3r87wecv599MAlR1468PSt/MKIAxZvSvDwRuc3w4x/xghuvlCk3bPltXwKDldTCd4PPZ+at3CEiTBFKpURQ3z1Ifv/TPP8bo6CR1H1tPAAwemKv1eivHG7w0rbOYFZOtHPOpGQLMT2fnO3+tmHMczg9CdfEHoP1szbT/zJTSQATUdQOpvLjVMJ/KOYMQci9moALPDyEEp8dH4/1mrAUlZLSjDASeG+cctDFo2w6kF0R1zqHtOqRJ4v2FhYQxBl3fpfI9f/S3gLEWRn51LRicORQcrLGjbgGjFI1Uo+/3QEgIvFwoITg+nINxhutvdGsu1xUoZSis/aYn/GtB97ZrlJAgphm4w7DuUUJwND/A0fwAy3X1LFoBhPjnW9sJUEreRBKAEj+ixyj1zy1jEMd8FNb9HlvfoRJKbgj8PJYiz3G9XL3Y1v9BDPHLxeXOX6sscsQ8DrZhj2RY0A42xgWMtajqBkIIJHGMtutuzAHuwxxUYPskcex9Zze6QcoiRxLHyLOsd40QaBhDnqVjx03ovAk8J0MVvOvEqILPetVkNqjrA+iEeFB7/FvH9C4dA7p3LhgEE4eNrunFC1UvfMg5G8UGQ/D0ckiSGO+SIxhjsK7u1wS4Xq1GHYnXnARwvQhoIPBQZpMSs16wbrFcYrn+ts3mNhk05yglMMYC0Fiuq1ddEB3s/QYtnzRNvlv132T7HQBSIsvSrWV+lNYvNqBVSoNQgo+fv+y8nTzM++8WSohfRHoBoOPDubdGkRJt297wuw68Hga7mdmkRJ5lyLIUVVWDMoo8S9G0HU5f8cMl8PJoWu96MlTtrHOwfaAyWOwFHs/QWTEw7HkGgULGGIw1oIQCMHC9MOHQTRDYf355d4qP7su9jkDWWjRtiyiKXm0CYGj9DwR+BsYZjuZzKK2ftEg2dLIdH55guV6jLPJXHxtJpRDBJ6UfGtlvPQFQ5vkodrUNhnasl8bwGXz8/GXn3pmcsaAm/oQQ6j/nwTLF+7kXKIscbdehbtobHQJK6TAy8IIghGA+m95Zd6q6wWq9Rp5m4zz/a934BV4WQ/a/btobQeltMb3bs/qB3WCd2/CV97/79lQNSimiXkMg5jx0Buw5v75/hz8+n93rDjB0h11dL3F48DK7VL/HUF0MBH4G2usj/fbLBzRthy/nFxvr4u4YLJeX6zUmReHHtl55fJTEP65HsvUEwLaDHSHli7NcGVQxge3YIH4PQgh+ff/uwS0fgcdzeyHJM2/pppQX0RrUUQG/Afe+naK/LiqkSYxOSKR9EBnGB/aDPEtRFjmmkwmEkDi7uOx1Hzhmk/LFdiIFXi+2F9wNrfz7j7UWFl/dDAgh46gk58yLyoVgay+ZTScwxqDp7j6rV1WFwuZIk+RVJoQHF4yQqAo8hjxL8U9//QuuFktcXl8D2G3H7BB7XV0v8euHFNfL1Y2x3sAOEgCL5XKrwTpjDIh8kPRSFldrLZIkwecdi/4xxvDu+Cioi+8B35oxor0y53DtnvYK8U3bwVqLTghwxp5sRirgSeIYlBJwxsAYw6QooLRG3TQ4v7hElmWhqyawl/h1w6v3CyFD4P9CsdaOG2CtNSJCQIgXbgqdAftFkWdglOJisbh3HKBtO1R8cKx6Xc+MEPwHtsnhfIY45lgslzsvfimtkSYx6rpBlqYQQoZ4aYOdlI2TONnKcXgf4AJ4Xl+hH+CPL2c4OjjA5dVi569V5lmoSr5QhoTA8PMb5qSEFGNyoCzysftluap23k3yWuCM3ehCStMEjFDkeTomEsu8QNXUML2i9zDOEe6nwL4ilYIxZvT8DbweHAA4B2McOivRCS/WmGdpCL72hCSJcTyfQyl951lsnU/KVXXzqgTHBpHL4fdAYBuURY6y8OPin87Od7a39TodHToh8ddfPmC5XuM0OdrJa71Etp4ASJKHKxD+GYPl2mK5fBEuAEpp5FmGf/v7x52/FiEEB9PQzvJa4NzbSOVZeuNaV0qj6TqkSYw8S0EIgdYaSRLDGDuOyITkwFeG4P9ofoDjwzmMtbDG2/JNJxPovu12Opm8umpN4PWhtIaU6klmJwMPI4IXVNxm98UYZPXHNMagblqkaQLnXBjz2wOSJMbBdILzy6s7P/u260CJ7yp7Kd2q38IYn2T0+w2DeLB6CyMqgS2SJDF++/UDfv/4aad7WEoI/u3vH3F6fPTiRsp3ydY/hdmkxGK53NrxBltBtuc/MKU0tNG4Wlw/yesdHx6EVpY3AOcMM/7VUmXzZy6EHIXqhJD9HLAFJRRSKQgpxxbTIVnw0rhdzd+EEIJJkY/2ZgBGez5KyGjdtVqvUeYFgF6UJtw3gReAtfaOqF/gx4ii6N4kn7X2TgA3qPMb+1UwysH7K1NCYayBtW48LucM1vjjkCiC69sUI/jEACERjDFDPA8HB2ssHNC3+Pv1Kooir+AcRTDawDoLEpHx37tO+PMyBpTSkAh4Zg5mU3RSYrla3/la1TTIsvRFjwK0nQBnFFIqFHkGDQMh1ZgECAS2CSUE//jbr/h8dr6zUVildS+S57yzU7iWAQDs//n//nXrBzXGfnfj/iN8PrvYewsHYy200SDRbs+R9IqaeZZiOpns9LUC+8fthM/m34cWdiEkCCGYbrQhVnUDzph3JtAaUqk74iudkHtpYai0Bme+OyJLU9+uHyfjv42Jj/7c7xNiegndQ4HAJlIp1E373KexVwytyCSKRhs9SgmACIRE/d8prPGJP0IiX+1hDA4OaZJAGwPbB/hm43e2UdmMNo5/k3u80B+xj1Raj0H94LN+O7hnjI6t14OF4/A9gefj/ckxGKVouw5dJ2Hd12fnYrmCtfZFulcNbiJKG8Sc+/uNRDDGeT2uQGBHvD89gbH2Xo2NbUApQVU3+O2XD6M7zj7HlU8By9NsqwdUSo+BxuPxD/Z938AvVyswyvDl4nJnQRQhBIxSWOcwn83e/IUbuJ/7ukKGufbha7c7CYaWqME/HAAQRRBCQEiJmHNkaYqLq8WD7mtCCNKNEQXgpl3eMHcPYBThG8izbOPP6aiS7X1kW/+9G9f+kPgIBF4L1lp0nXju03gWhuB+EB4jJIJzgHMWQATfIe/6irh/1iYxh1QajFI458AYBXVkfGZuri+bATa79ftT85BK/u1AP1T/94fjwzmqukGbdLherW8IOkqlbnSSvBT8GANFJwQmZYFOSGRpAunC+FFg97w/PdnZOEDTdjg9PsTZxSWSOEZZFlt/jZcG++3X91s9IOdsaw+pX96fwpr9q0puYqxFzGMslsvdVlAdEMccv75/t7vXCLwJbgfMQztUnqXAZvV8o4vAWItpP4YwZE+VUiCEIM8zrKsaMecPbn3cnMv3x7o5lzW07w/nN+gjBAKvGWMMqrp5M8r+PgFIx+q+f9tf33sU+aDfGN9yT/vEwG1BsvQbSuX3V/IDge1QFjk6IfH+9Bifzy7GPeC6qmGtxV8+bHd/vUuGMRSlNdI0GZNw1lpEJAgABnYPJQQfTk92Jgy4XFU4PJjh6noJzvmb31NuPZ2slN5aq1DTtIiiCE3X7aWyatN2aNp2VJrcFYQQzGfTG9XRQOApGYL6G8mDjcXzYPpjIym0H2cZuD2TNXztpVVQAoHH0L0yW7+xfR0+gQ1EYIzC9LoGESJQ6gMNY3ygQUh0p/Jtrf1uMB8UygPPxfHhAaq6wV9/+YC//fFpTAII4XUCZj/4bHwOhq6jYcwkz1JYa8EogTZmHFEJBHbNIAz4779/3FIn+VeElGi7zotna/3mbQF3srse2nsfS5okKIscVV1v5XjbZrVeY34w25lwxdDCSImfXXnLF2ogEAi8ZoSUr0bpn0SRf37nGWaTErPpBJRSEBJBSoUIETjzvumMMT8HH3Nf5b9nvj1U8gP7TFnkIH31csBah+vVeuxk22eatoN1DtZaxJyDEC++PYinhQRb4CmhhOD05Ggn6/71ao35bPqnSeW3wNbfvbUWZxdXWznW5/NzANjLtndjLeazGbTSO2v9p4SA9jOM+y6E+LMMojO6z/SZoHgdCATeGG3X7bSL7CngjCFNYpRFjumkRMzZqF4PeOX7JI5R5JkfFQpCdoFXBOd+n3Z6fAQSEVhnoY3Bl/OL5z6172KtP0/n3Nh9pI1B03Ywxu6lOHDg9VPm/l7aFUP39q4KuC+BrXhqx0YAACAASURBVI8AbDPbqbVfhPZtTsNYi/PLK8ynU/zb3z/u5DUGIaT5wQxd12F+sN9CiMDNNs3hoaG0Rsz5V5sjY8AYg1IK0eia4BVmOyEA5x8+nPnNo7UWSulR4R7w1pCD/dLma5LIt5dSSkN2L/Dqce6rJZnWGkobZGkC0beRx5yNM5ybBDXn/UIqhU68PItOADdE9tIkhpTKW931yWsgVO8Db4v5bAprLK6WS1hjIKTc61ZjIeX4LKH9nqvtk5GcM2htwFi4jwNPz2xSoqrrrTsDLNcVDqYTNF0HIQTyNH2T1oBbf8dDlTrP0kdXNPzMIPZOTbVtOxzND/D7x087OX4Sx0iTGFmWoes6HB8d7tX7v43WGtY5CCHBGButY2LOQftWMuccrPW/tPbeyMZ8ne8Z1N43E0ibdk83WmM3/sgY8xZQ7u7oiVQKjNLxGELK3gs0ENhPnHPohEQScwipQIgXPNtURzfGwDo3qp5H0deZaa31jY2mu2eeXGkNEkWQSoNScuMeCTwtzjlIqcA5G9fAfSdNEpDIz+5b61X3h3V7X4Oct4Qxxou5bSTOHdyNai6lvYtCBJCIjOtIlnqrRLrhxBD4cY4OD1C3LYSUMNrg/OpqLwUBh/Vn8+/OuVGGk1J6Yx8WCDwlxlocz+djLLmtbhRrLYwxOJwfQMTxmwz+gR0kAJK+BfCxGZs8S1HVzVj936cuAGMtzi4uty5QAfgsa1nkuFxcY1KWODw42Lvg3xgD3W8ypFT9w8GBUuKTAdZX59tHWllZ52C/MxIQRRG0EDf+PmxkYs5BKYGQCpz5KtVm8O+cG7sRhkXFORfaUgNPytB+GXO+4QnOYKwFZxTGWGij+24ZA0Ki8WHIKIU2BqRXRb/dfRVF0ThG5O9Nc+MBSikdj0F7a7VOSMT9w3DowAn3xO5wziGO+Y1N+L5BCYF1DpQQZGkCwOv0D/PBQ2Iq8PRYa32isH/2KaNHEwVjLZru/iKMvvFc/fpn27uvMPpVqJFSOro7hZ/zw/n1wzv8/vHTGFRfLq5xND947tO6we092m0BUuccWilR5vlTnlYgAMA/e4S1OD0+wuez860ee7mucDSfI0niOy5Ub4WdvOPTo6OttGwkcQzO+F5VFYSQSOMYl1eLnRx/UuSQUuH9yTGAu+roz8XQim+dA2dDtdEnAXZh1/EQblc3h787526ck5B+c0T6agal1PvUWwv0SRzGGKRS0MbAWt8+PVRCQst04DFo/dUZZdgMDsH1cM22nYDqvaNJFD1ICX7YxFtvlH7n68456D5Z963vH+4T0ncRxDGH1gZK++6ACBHaToQAYEcYa2GM3Uky+TGwfoyKcz5Wha35as3pn81hXXwupFRA5DvntikcOawVm9ej7cXgKCHgfVcfIgRl+D9hsDRbLJcQwquP7wvDc2joJvsWxlgYbW48wwKBpyRJYiRJvJWu8tss12tYa5Hn2d7EWk/JVt/xsDk4u7zcyvHSJEYSx7Bmf0YArLO4ul7urPqPKMLRfIa6aTGbPr/tX9sJJDGH0hrG+uC4E4+r7D81Q5A1POiGDc0mJIrg4De+lNKv7dEbDz3Xaw5EfUuc1hqU0tAmGRhxzo0t9gBuaGIorcfW3EETI8Ldqstz2MBZ5+7cF0NHOmfef324/jshEUUR0iSoQ/8Mvmor+yTQ86+nQ6fIME5FCAGJIt89xf1IF2dsR+WCwEMxxowV26FS/6Svby1Mf63SfhRpdCoKXUL3kiQxZtMJFssV9B7ZjkWRT+zeNyK2yTDeGRK/geeCEoLFconjwzn+tuWx63VVo8gzdJ0Ap2wv7s2nhG2ztV73O8ZtzGkQQiCVxnK9xmzy/D6qw8P26nq5dUEKwG+y//kffsNyXUEbg0lZbP01HoqQEkppkN6rve3E+CB4rQzvTWk9KuICQI0WSRyPVZYyz6CNGccJpFSIYw4hJSJEiGMe2qbfGM45SKXGGW7OGaJ+/QIMjDFjUmDzHtqctdxn1EZiIIq8fRulXxMCYVb44bh+NCpLE0il4JzzXV/Kf8a7VNwerj9CInDGkSbx2IkCYLT+iuC7pPIsrGH7wJB0G66XfcAnAyQYpUDs9XaydH/GNPeJLE0hpcL1coWqeX4756GIYYz50ySSNmbsBgpJgMBzMZ1McHm1wNH8AJeL660dVyqFw8SP5bC32AHwL//z/7S1g21zgUjiGNZaHB/Ot3bMx9C2HZIk3tkGzViL5WqNqmnw/vTk2ToerLV96ycbK5X7sul4Km6/XyHlGOCs++RP1wkvyNbPcHPOwPpuAGMtpNJ92xztA6bQKfDakNKPjBASjb7mSmt0nbg3WfYaEmhDsmNIiDFKEXPv3z5c3+E6/z5xzMfOKpZ81SChG8H49xi0TobvAXqxLkJASARGqU9GRf7n4wBE/fdt/hrYfG6Htv79YR8D/9toY6Bb79ozdASEBPhdyrLAum6wrmowSjGbPk9Ra+g+8kLMD7umdP9zDQSeC0oIjg7nsNZisVxtNQ67vFrgn//hNyil96bT/KnYageA0hpqS/Nog2L7PrRMDZW9xfVyJ17NH05PfBtoFGH6/7P3Jr2RJPuW37HJhxgYZE5Vdauvnh4ajV63oN60vr82WkgLAYIgqd9Qt6qyMpNDTD7YqIWZOYNMkhkR7h4D6T/g4mZmkc5ghLuZ/adzJpOD34S1lE0LqNIaxtiztaXqi8eb5aZA4WZAFN/HLE0arQQAzQwtY/SBavvA+VGUVRgD8UFUVcuTPaD3CSHkXmOg8vd+GhR1HweZA/cwSn2nkHNYFQW09lojm1oNsS0/CqrGcREAjdMK4OewjTVNklEHIcmnAv2B8yDOZq+L8myShkprqJWG4BzjkR9dHKrG9zBK8R9++Qk3d3PfPXEkZytKKbI0xV293Pp7oiPEwMAxic/LL58+4vfPf3V+/flyCSEEZtNJ59c+VTpN94/yDPOOZuOvZjPUssaX62v8/W+/dHLNfbmdz3E1m/Vy001GI9wtlvjl00cUZYnR+LBqq3Utfcs7c5BKH03Q77VggwDhU+9jIgRA0IjASaXAQvt0rOoNiYHTpa4lksRXu6uqflZc763wOOnRqI5XvpKcpckgHPUE8XnXQUWfUQ1rHWgI9uOBO1pwAfhOj+Qh92JssYI/HNjPE6lUsyefI0pr3C2W/r5mXifA/3nY1wBgdjHFfLGEVhrsSIWtXUdYhyTiwKlQlhUE5023ZRcorbFaF3DO4fZuPiQA9kUpjVGWYbHcPrv4HFprTEZjCH58pdk0TXF9273qf5okUFrj04f3uF0s8On9u85/xkvEIFVwjqKq3mQVs2teeg83OwWU0sH6zT5QXNfaIEnEg/nq4TB/POK8ZGSxXJ1NVe6YRN0AzhjyLH3TiYA4V0+DnR4P9osE3klFcA5rXaOtEEVGgXuxt2ENeP1orVGU7ffhWCnjoS0/utlszntvjpH0QS0lKCHIgm3kgIdRineXM9zc3YELfvAuALNHYuktr90Dp8VkPMJfX7/5EeUOhdhv53P8/W+/4PLitNx4+qbbBED4QLqYI6zqGsYaXM1mra/Vhm83t0iTBPPlqvNrK60xyjP8/vkv/I//4dfOr/8ccc7fOddYfg0clsf2bFFxPQoOxs4ApXXjET9sxIcjzvdzzvwzotQQ+O+BNgbLddEEA29RMZwz5rVCtAFj9wd+tsV7MSQAXz/OORRltZedn9gYBwG8AKnWBlmWPpiTTYQfOTHGNB0o1tkH1o5dY8PvJTiHEBzGWCSCD/sYgOl4grqW6HIEdxvKqt55fnqfpMHAQF8wxpAS0uk4dlFW+NfffocQHKM8x9XsorNrnzKdr8S1rDsJKKMK/bGZTadYFeserjuBVBqjPD+o6J/WGiYE/3Uth6DmxHg8OsAohVI6JNV0M/8bKzhDe163WGv92sMojDTDSExHxGAAuNcKOLa2y6EgxAvz4Y0lPgZ+jHMOy9V66yA82tWmoUuMEArngosD8ZZ80caRC/GgGOPb8cV9AiCMnGitodT9uaBrortFFKoctAF8oqZPx4+niG40u+KcG84aAyfD1eUMWmnczhedXjeO7v7680+dXveU6VwDANh9xugp0jSBEMdt/48ChN9uurOdAHxFSAjhVS3N4cRgaikbheih6n8eRMGgzc8rVlG9nRd/cxXVPtBao6olGKOghGJdlMNITE9ErYBKSmRp0lhqDgy8JWopUddyq+CfEIJEcGRp6jv3QlXWJ5fEswH1ZtD2uPJOKQWF30+yNG0CRG0MnHWdJgTiPhaDycl49OYDykMnQKXSe49+vPXPauB0YJSCpQlm00mnndmU0jfngtP5b9vVojYdj1HVNVbrApMDC+NF0jSBCe3yXSE4x6+//AQ4AO6wm0AiBNZF2UvwHzeIIWjqn83xgRK1r/Zwb0PIN5wHnHNDu+UPcM5hXZRgwc6urKqhK+ZAWGtRlBWqqm4CgrdeGRx4GxhjUFU1frTSEEKQJgmcc8jSpKmg95E0iyMpWmvUUoExilp24+oUUVqDEgIpFYy1ze800C/WWmit9zqfbY4tDQycAnUtMbuYwljbScEZALI0aWzn54vl0aw6D0nn0UFZdTOXYZ3FqigwGY87ud4+FGXVabAsOMfV5Qx38wWkUvj548fOrv0SVe0966uq7m3e7/HGEhMC7IWWv8dtZX21IL527CNv9ki0DosHO8FZYxE2gEZoMUkE6lqiGmYdj4J1DmVVg3OGNEmG+3PgVSOlQlXXLyYaCSGN2jVj9IEQZN8BM+e8ERA0xna+L1vnUNY1GKXDfn8g1kW5t7MEIUMC4JSRSsEYizQRzfgif+XnvDRNUJQVPr1/31kCwAuw+j8fu/v8UHSeAKCEIs+y1gINi9X6oLPxT5GmSacJgGjrNB6N8C74ZfdNtBTSPXqV34vUMQDBvzoEV1maQBuDupZN+9n9HPu91kMMTGN7Iwv/FsUKzYYaOwGGKu0WOOfgANigyC4lacYFhOBNy9NbnMmMzwUhvjVyOIgeF9XcowrTyfhVH14G3i7WWtTy5bZ/wTmSRDRnn23EIvuAMYbpZAwXEswqKNV2cSaKe7o2BsbaRrtgoHvKlpa1gwjgaeFCwtw8EpKu6rr5c2MrTSnSNNhwBpvp17K31rLGKM/AGevMNrUoS9zO5xiPRgcX6DwGvYwAtLUBpJTCaHPQ+finYJSiLMtOrnU5u8BiuUKWpiiq8mBjDb6Nr/vKelQfjlVUDwFj1CvYOwfOGZxzTSUjVvwfCAHl/jvjYkYJ8cE+CAj1XtnWuuZhrGoJYwxGedZUKM7VM/nQWOdg9feHuETcz5ByzprKzGvVFijKEmmS/PAgPnB4jLXBR1wgzzI454bAYOBVEA/uL+1XWZogEeKk1t84hpAmCaq6BiHE770t187ofjDKMyjthW6HZ717BiHb8yYWxepQxIvinT/6HsDvp2VVN/82zvOm8HjuiYDoEDe7mOL6thudtqj9JKX04tsHKNIek85/O0Zpqwxxmviqe56nuFsscHlxcdQPoarbL57T8RhwDr98+oh1WeLdZf/WhtbaJljuKsihhMCGgD7COUeWJmFW0HtcS6Uaj3tHAGtM05K0qV6vtQZjrHmNjFJUtWyq0wCaWUdjbdNFEDsDCKEg1GEkMkjlbdsEv/cHJfBSC/F1DzzNg9GB2m8MeRCbiljrIAR/8PmdW+dALSUYpUiEwHJdDFX/E6aWvq1xOjneCNjAQFf8yOovrrlxjT3Vw3mWpgDCTHkIStom4IuyQp6mfv8+4d/9HLHWNuegfcneiFvLqWGD+HNZ1a3OKpvfuy5LoETTccM5O+vEm1IausMu7aqu8enDu6Pbzx+KziPrtqqM0TLmajbD5y9fjxb8R/HBtu1ujFI4AEniBQUPEfwDaKrsXVXH46EkFQKUEjgHUOqr+b6qTyC4ryTnoXLxowpGFKjjnDc34mQjuVBLCW394iU4gxC8qdwKzsPvRmGsAef+4JRnKYT2SQC34XuM0A41VHx/jHMOxSMtj5jY877k/oBmrX9/Becnb+lWVjXSRKCq5UlVRGJyioauC+fcdwmrfZWbzx1tDG7nCyRCIE3EIGg5cLaUVf1s8E8pxTjPYMz5JFQppWDOYToZo6yq1oWSsq4xyjJUdQ0eOgYH2hFFVtvsHHEUc6Bf4lkVQFPkUkqDcYY0EZBSdVrE0sYAxkAq5Tt2w89klD4owJ06SmtcTKdYrovOxNqV0litC6QHGtM+Jjy2YHXFKMuglNpbAyB+iMvVGsYcL1iLLfqC870DBkopRnkOxiiklPjp44cuX+Kz1LUEZe06MTaDjmgRFJMAWZr6NiRrm0N5H6rEj6+5+bMIIdDGIBGi6SKonW93ihUEwTlGeQZtTBOsxgTAZiX7LQZXuxJtnB4TEwOxA4MQrwERZ1hp+N9TxAx3nzZwxpjmcLpYrY/+WW/eb3HTdSHpCfiEACEEfON9i50W8ZmLfwb8GvOjJN+5O3RIpaC1xniUv3g/DQycInHu/ylYqMIZa08+ifqYGBhyznEhBGqpGr2AfSjrGnmW+mDHnN/7cWpUdd0klfclumANSYB+ia4YieCwzsFIf56K2jh9YkKXSHOOqPzZORbcTplRnmG1LpAFUcC2UEpxO1/gdr5AmiT49eefXnUSgP8f/+f/hf/2X/9LZxfs6s26mc/x8d27Tq61L0q1e/istRjlGdZFedBWVmU0nNp/0Y8BQyKEzwYSgix9qM59zIN4fB2bixNjDKM8b/4eEwHaGD/Lwzmo8IJ3eZ7BGgtjBw2BtjyVGNDGwFa2qWoba0FDsBuTSIzR71o9H7tCtEVpjbqW4Jyh6lEE8zk4Y/c6GeF3iwdc/1540dQkEaCENImKLE2gtL8n4+HLv2/384CMUozyDA7+8BDX3ZjRp4Q2StuUUkilQAnx7qNnmAiITgFvQZhn4HWxKc61CQ3PcEwEniuCc1QheK/qGokQTQfeLkSNhDxNkSRvQ4W7TxhjrW0c00Sc9b156tgobk38udbv+65VIm0fHj+pMe7R2kAIjuSEVfH92tNeeH6TyXiE1brw2iSvOQHw7fa20wt29SFkR8481eEwvllt25XYGn23WOJiOuny5T2Lcw6CcZT66UPHNlBy39pPNv58TuTZ/axiI14EgjzPfGsVpXAOzcKWJALWevGPQS9gf+KhzzoHu5FYsc4BxniBT2vhpP86zlgjbpMEv2sg2mAxWOvFJGPle9ukkzEGUipQShoRnENACAEPqt2xpS/LUhBCUNey6Y4wxsA5AsKIT0I5r7HAKG08uK11yLMUlFKfyBAJEuFgjAXn92q+/t61EJyDB30MqdSDBETjJw6v4VGUVaO+HZM0p442Bqt1gTzPTvpAMjAQ0cZA66cTzJutt+dKXJdjVyAAODhkSYJK7p50dcEiEOS+/fzczh6ngBcyax9AnvO9eYrEsdxo8xmJbkyb9ztjvnDRVWv7rhhjwBiDlKqJhxIhkCTi5J7Jrmz74nv986eP+Prt+qgi9IeAf7i66vyiUShmH0a5z+QQQhqbh2NAwywMoxT79gAorbFcrTG7OFzwX5RVCC5223hj63aeZ00wcWoP+T7EgHHznoxt1g4OhJKm1dBagzRoNfi/d++B/JZ5nBQA8J2NTTwUG2tR1ffJgDgbjxBgC+FdJWKwvYkxBmVI+LStgPyI+IxQQvzsquC+hTU8Q9a5ZpTJO3KoJqMeBTU5c804C4AnZ90Zoxvilz5o0EGTgcDrMSilkaZJY6tZ1RJZmmCxXCEPSQh/LdaM8iRh3q+WEnD+84hdBqeIdc57WiemaZ8eDqkDp4o1FpR9rz0jBMcoy85+nGXz9XvbMQZKaKPqv08V0znXdG45qTAe5T/+poEG09EaTgkZEq0dQylFEhL6tZGN6CeApksxzuJbZyE4Qy2PkwBw8DFMjA0IIf55JnF06TQq41eXM9iOx8UXy6UfT33lY0j8P//Hf+70gmmaQKv92+bjYW42nWKxWjXq8IeGMv8z2wiGCe4TCG0SIrvgM3Z05003Eb6CmASxkfQEM3xdEu+xzc9lXZTI0gRaG98yHkYIxqMcjFIvpnPCgdFr4alKdJOACcF/7EwxxsJR3zZKw1gB5xxaG1BCm2fXhM6DSFf3drS2jH8mlKCq6qZ9NTqa0B9U+QghSH6wxsXNdvP32Py3x5txHDcAvE1OJGo1xETfYrXGxWTsW/2Co0dVS6RJ0ohmaq1PrkMgOjpQlmEI/wdOkfjcPD4PCe5na889+H8MC8lYpTWopSAEe3t0G2tBDIEQfrzgUGeo14DXTGl/TnE4f6u4U+VxYEnCmC3gHXCkUkcvPsWfHc+9sXAWR2u9ZsHxYwVGKayxmE0nrUXoI1++3QAAbudzXEynB41Bo4vaIeDv3112ekFGKW7X60atfVeWq/WDvxcHnp+PaKWxqMq9fw/At6VEB4C6lr1mk6T0mbl6RzXeGFBxzgH3dme+YpUhbpyT8ag5zMQ26jzPwCjFcrVu5tsfH24GUcFuieMokfh5NIdr7e9f7RyE41BK++fg0TOrtQahFC4EsiIkvXY5hHuFXN++H0UxY5DtQqU/TZMHr/nU1KwfbCyMIZl5z/HYISCl33ykuu9ikKH7YlPT4RQw1np9lSDY+hbXrYHTJQrPbu4GsTvn1NaFLhHc6wYVZYUkEdDlfsFo3FtHeYZaypMXJDsVGGWoTHunGz6spweFBQttF1yBTq3YFC21y7ICYwyJEP5ctaHvdCyW6xUm43FnCQAgFlsItNJgB+oEcM7hkO9ib7tQW6utNE1QXdf4+P44QoBpmuDb7S0Y2z/zMx5lkFKhLKvGVaAvHBxkvZtViOAcIGiUR6M36FvmcZJGhhbE2B0xyrNGuKmqJQQhUFojS1OokLUd6A6H+6o35+y7Q6DWuql+l8G6MApAxnkutjkmEGbzY5vkNvd7bO+PiYc8857VMTlojG3GEs7x+dmcQ2acBeFAvw2ZoKHBubclsqEq4ZwDTiDZ5ZzDcl00n8k5exoPvB6M8Z1kj+1UOaVvwlfdi/JmsC3td7UxKMrKJ06oPpm241Mkar2UVTc6XK9Z/OwUiTo9gvsxQs5Y0wXw2Br4GMSCV9QFi53GSSJAQjHlWEkArQ2m46RVwfax3tvV7AKUkIOOAehH3ap909sTLjjfW0E/Vqny7LiKz20tAK9v50iFAJn0/1AIzlHtIHbGws3uW+xkIzY28JDYGZAIAUPNg/acPEuhlG6CzTgrxTkHpb5FfdN6cGA3aNhMtPZ+uNbez4YCPslICIXSBlJJOAtUsm6qa88JeG5bKSYAeHDBsNb5A621fvQgiCy9ttZU8WjUgAMbWX4/lxi1CACAbrT4EuAoh5SofRLHFwangIFjEztlNhNknDGMRvnRW2YPBaUU1hgkiUBVS9Cg7bIr2hhwbMwjD5XpJ4maRV2swYkQQ8fFkaCUIstSZPBJbROERI0xsC1tHbvAOdeM4EXxPf93djSBwFGeY1Ws8enDe/z2x597XeOps6Kxh+3CYJRCa3OvLdVzTNbL1bM03Tv4f391Cboxc61a6Am0pc2NbK3FdDxqFLr7Rim908LPOcd4lENwjjxLh031B8Qxic0WakopQNAkT4y1mE7GXrzI4UEgkiYJsjR9M4e/LrDBPs+GdUBKCalU4zc9yvPw3hMkXMBYAwLAtFxA4zyeEAIEBKM8f9DBk6YJ8ix79QIxEc45GPPdF1mSNB0VvhJAwDlrREPpEe/vKKLUpR3QwMA+cM4fnF0IcJZuOm2ISufO+cRim0R4FCeVSkGG9X/gnjiCti7KTq4Xk+wDx4WHfXc88meQOLJ7zH024oWaa0il/GikNahq2bgfHZLJeASlNEZ5d8KqjUXjAaHBJSr+XGtt45LVB710AFBK9+4AWCy98J8XpEqP2oZEggrqvgfKqpb46eN7P6eK/nQM9hGno/Q87f1OjZglz7O0EU+0QbiShPYhpTQYo95CRdw/F87dZ1MHniZ2VPgEjLesSzayzkoZCOG1GqKNTptkFgtWg1IqjIIApLUWSmskQrz5FlTO+YP3wB88DaTSoIyCEuKrFUfqetFaNw4Jx55LHHi7OOcenH8452+2MyVNRLMetPE2r6XyFTJioI1GnmXD873B43GTNmyObbx2K7RzII4rJonAiHkra+905Mckj5kQU0qDwAs0S+VFxPvWPHuKGPhH7aJ9i9CRoqzw93e/dPHSdiYWjU04e/b1Xnb+ZN/O562+X2ndLDiEkKN2AGRpivFo/9l95xyq2rfl93kg9qqv279PMbERX9tAN2xaDsZgNWZwpVSogkCj1iYIQfmvSROBPEsxyjJwxgbxHdzbcE7GI99qxv37sime5ZW0fXu+sbapVO+Dn7/zHrecMUwn46ZqRylFmiTDYfMJYmfMKM8wznMweu/ScAxsCLyW6wLL1XqoFA4chcdV6k27r7eGn9/32gdtxQ9NaHNnlKGWcqdzz2vFWtuIx3UBDQ471ze3uLm9wzwU5YD793/gsMS1IxHCn0fSBJcXU2RZehJ7nFQKRVWBcz9SzBg9eCfeKPfjutF9qS21lPh2c9v6OrtijPEjFYzBGIs8S3srEnaeALiYTjHKs1YfQKyKLlarTj7IfRGctxIBTFPf9q03khpdEzODu7T/p4nwVmBH1lh4zcTuChbE4aaTcaMYnwgRsqUaaSLgXMiiUv/10V4lJgNYOEC9pQOktRZKae8KQp6e2y/KEpQSyJaLowijHVFALrY/vvVq/67EjpfpZOzHn4Q46n1rrB2SAANHwbr7IOlx4vItEh1EGu2QFmuCcw5FVfl1hRDUtTzImOWpYqztNNiilIIyn4C/mEwwyjKsixJKaRRlidu7Ob7d3GK1LoZkwJFJkwSz6QRZmp6EJV8tJazzoyheu0AfbP+NHVZdCq6rZw0SQQAAIABJREFU0LHUtrC9C8ZaWBvXSq/50Nf+0flVGaWtq/baGFR1ffRNkwveKnBfFyUSkfQ6X7+rToK3LrsP/KNy7MBhiC3qsfIf25Tj2IuzDnmagjLaqL+WVd2or8eAKo58sJD8eS1BDiG+lSxLk6b6/hReANCPW7QRPWKUNhlWr2yrQfnghtEWxtiGtaaG0qapVB1S0dhYCynVm9FrGDg+bmM9jt0ww3riE6ppkkAb02oUIFKUld8rstRXHSkFY/RNJW6NMShbBv/GWqxXa1xcTCE4b9ygJqMxiqpCWZbIsgxfb24wm06RpSnmiyVu5wtYa/H+6hIf3l119BsN7AoNZ5hN54AuO0J2IcYjgvNmdPKQz+PtfN4IE3bBu8tLAIDg3V3zJbTWUEo3cVmaJCGOFCCUNFpLXcH/7//vX/Cf/+M/d3ZBwLfxt7FjAHwbteAc/IgaAFpp3BXF3t8/HuXgjKJPZ0dr7U5tcIxSGGOapMQQ/B+HB9ZrG3PraZo0IioO/pDjwtcLdt9eHb/eWgtnLbKgNfCcFkQMuk7BTmYTzhjSNGms9rbGAQBptcbEBKNzDnnmu5Zil8ZAd2zqBnDp7+GuxKq2oZYSxto3O4M9cFi8WJ3fk33CfVhTIixUlgkBjLGtvc61MViti6Zb0xgLY30yNwqmvVastahlN9bDPqhfIMsy/PzxA8qqwt18iQ/vrzCbTnA7n2O5WmO5WvvE/IbN7nUYE0gEx+XsAtNxf3pXA88T9dL8GdE/X8fqoFZaN+5Jthnbeb6g0yVZh+4VKgTkX75d927lDoRjbfzZSoNz1gigZlmKMoxZJB0lOXpJAABoPbNAKUVRlbhKZx29ot2JHQD7CErE6iWhFK7HNqldZ7K6VMl8iqqu4eNLB8Bbh0WhsEiXN/BrZLNj5GI6af4cEz2cc99eZUyT8Y3B/2PP5Rjwx6A/JhOO1TEQrWOcs61E9RijqPYMIn2lyAsHTsejoNUhh4P6AYiimWziuy2klL0npLyLhEIdZicHBvrEWgsCNGrdg8POPTxUBq29b23tIkhRWvtqI2NIhICzDpWWSIL2wmvrwLDWYtHReBOjFCxNkKQJpiHIoYQiERz/+tvv+OXTRxCQ5rOy1uLxiVNrDa01irIKrjk5LqbTQUDwgGwmu6JmUS0lyh3swbvEhpGfdVFiPMoPYtFLibcqfs4CelfKsgRjhzs3SOn13KxzoFo3na7GWlRVHT7TEmRMOumQ76W83sWHzCjFal3gana8BIA1vr1YiN03KUYp5oslPr5/B92TkOE+N7gJSuldvw4vRGiav8fWdKXRKKlb53shlNKoqhqUeXG1Y496nAubwfL3avf3wWtMuMS5S60NhPDz7Ur79qzYghlnMWN3gE/b+L8765rqaWwL9Ie3h233MekQN6A4qpCmCaqqDoKHvBOP2GjN0tbv2LsJcEjlq/5vqW30FGCMIWesGb+oa9nbPKlzznfTVBW0Mc1owsBAH0S/emvtYKf2BM65Zgyu60S0DolxINoQsvtRsbC+nPtab4zBqig7f+82u/C44NDGYDoe4ffPf2E6GW99Bi7KEkVZwhiL2XR6VCevt0o8+3mBXtLr/voS2hgIzlHVNRIhsFytMZ301yEyCdfO0qQTXYyirFArhX/69W+tr7UN0UkB+N4xZfPzW60LXEzGrWO5zp/MOI/eZgRglHuP7WMHhkJwlFW1V/ZYaY1R7m3EVrIfSwxrLYzZ/qGmHVZ+YybYGNtYCqYpa9p8YqAWZ5GstaEafa8m6+Bv5Ml4NFRKOoQ8aqfffF/jM7VtB0Y8wG5WUTYPU+TR57b573GGqUvWRQkheOOosAuEkKYiIQRv7U090A1pkiARws+zVnXrtuCXUCGr3vV9OTAQifObjDEwOuxpj/GuKgKx4dUGBxepVKfdac45LNdF0/EV9zJVVSAgIJSchHDarkRNoK7ZnJ1mlCLPc9zNFwDgxXh35Pr2DmVZ4e+/HsdK7a0T9ZRYGIeppUQt22tv7EosOhlrkYWEf1/7L6MUdS076/hRWj/owu2bXdaioqyQZWmrOLmXCDtmvvc4owMArmYzlFW1YflyvDaiRIi9NqQsS/1DV8veZkcYYzA7tPfwIPDShpiV+lFwFx/A+DVZmobZSAUpFchGW3qc4cuzdEgCnBhPfR4vifP13WrJQ0Vnn2eShaz4pjDXa2sNPVdi0mo8oqhq2ZvtDQDUYWMakgADfcAZhzH+Hhs6AL4nrr95ljXitsbY3kbT4jlys+uNcw5OWFMl5MGt55T3A+ccirLqba47e1SkupiMcXvXTv28qCp8/vIVP3/62Oo6A/sTk5GjPAel9CgjASq4AWhjMJ2Me00C3M7nmIzHWK3312+LpEmC2cUUdS1RSYlZz8kASsnW66A2BuuixCjP9h6p7ny1E4I39nf78ueXr7i+vcMoz5rD2rGIwjK7simS0hexCr8txpjW2e5EiMYybVdi0mAyHnkP9zAjCaDx7h58fQeeo6prUEpRtdjAvM1f+0TYQD9Q6mdPo4Vg1zjnGtusqEtieuw4GHiDEF/bZmxwE3kJY0zTgXXfFdA/NhQiisqvAXyjO0DveKbqk/g6rLWo6hrz5aoT94SneE6g7dOHd62vPV+uDmqjNvA8aZI0DkuHRhuDNBEoS9+B09e+m6beGrGLUfRaSsjQNVGW/QoXx6B/l3OPcw5VVe+dOO3lLijKqtUiGr+3KKqjjwFQ4q1ldsU6hyp4Yto9EgjbYMxuc9Ax835sol94lqZeKDH8e8xwxz8PDGwS14JdZ/+jGJcQHONRfrCD5sB++E6AHJPxCFma9rZmrdYFpFKtbWsHBjZx9t4CcOB5ojYMZ/55t9YhS5ODdnwaa1HWNRarNVbrYsN/+2Fi8FCFCedcE3TEPy9Xa5QtDvnb8Fw1Ns+yToKp+WJ1UOeXgaeJnTcXkzFm08nBu6ul0kjTBNbZ3tbHTd24LuLHGJMcooslajfsgrEW8+Vqr5ibfrjq3r9TcN66hTNL08Yy5phsWljtAiUE7y4vkGcZ1j1njrYhPmyndChJEuGF4TYWIWNtMwd8Kpn4geMTu1f26QhyzgVdCt+CNrT+nwfR33ja0wiVdQ5lWSEZEkIDHWKC3s2QaNyOJPH6H3mWIk2SZszrUMQDt7EW67LEcl1gsVyhrGovnhb2jKh9U4cRpfjf2hC90q21fuw1iKZpY7BcF76Y1mPgT4nXQXhOo8pYi/dXV3tp7mxSS4kv364HzZ0TIY5ATifjgzpyxYq1UhpSqt7O+PE+62Jcpqor/Pnla+vr/IgoYLrPexLHK3aF/rf/+l92/qYfIQRHnrXLGM6m045eTTv8zPDu3+e1A4BVUfT2gD2e2foRpxhQp0mCUZ49yERWdd2pYOHA+UMpRVXXex0gYnVjlGdH7yh6DqU0TDhcrosSZVVhuVrDWIsv367x9foGRVnh+vYOq6JAWflZ0LKqHiRFXmM1mzHmFW97Stqsg6L2Ka6PA+fJqXTbnQtxXfcHYIc06WcEaJfXo7RGWddYrQssV2usixJVLeHg7QtFUMqP60Z033HOoaxqGGNQ17JJGpRVjaIsQ7BfN8kDSgiKsoKUCmXlW/1rKQ9y/rEhOf4cLDgHjfP2zilSKZRVe2X2ge4gIVE5DULch8BYCyE4rLO9doVcdBRDUkp7dyoCfOGcEoK9Ak7cn2N2oZfTcFeH0FOwa1H63t5uFwgh0EH9Mh31I3YRVc23uSmjFdYpwhlDmiQoNjaHsqp7E08cOD+id/Q+JIKDnpj/e11LFFUJa71lYi0lRnmOu8UClxcXWK2rZh7Vi+YoLFerpkVstSrAGMO6KJBlGcpv13h3NYOzDquigFI+uz4Zj0/CUaUtjLFGjXe5WnfmFODtLv2BvG+P4oG3xZAA2J5YJCHWYjIe+eogc4117bHYPDfZDYvBKKTGGYMxthkRSNMEzDkwRqGNacZHY5eRlArrogQhBCspm/U8nuHsgfVIKCHIs5f1ugTnGI9HWIfkRRv+/OsrfvnpIyaj4Wx3KnDO4ZzDdDLuXYA3UlY18iyFMV6cMzp1dEWX4ut2o5uAUtprYrLte2CM2Slu7uVUuCrWzXz3vgvGl+trcOZVWo91MDMh6NinXdg/UBNvJVhWvQSzu4j6ReXbqIJ+SkTVSwI0m63SGlKpB960A28Tu1Ed2pVECFjrwPnxW/6NtSjLClVdY7laI00TpEkS7nUN5wpcXlzgbrEEpd4yc7FcgXMOQkljrblcrn1HhJT48P4KUmkkYZ2xzkFKicuLi0YwkRCC9bpAkiRhHIKAEj8GcewRq32YjEe+olZ3o2Yc/cjjoWRgoA2J4I3q9anttaeO4BzrokSepUgSgfli6YPs4BZwauiNpACAZ73H433w+Hc4dMD/mGQLJXYhOGZigi/frlv/PGstvny9Rv737KgdHgMPIYRAKe1F3BOBxR62j7v+vLqWSBIBKVXnMV6aJiifeRZ3pSgrzKYTpEnS+3mpbYKtlur4CQBjLNq8T2mSwFoLeeSWTEYp0iTZq23JOoeiLDEmea82gNseMKxzTUXxFK32kkRAKvWgm8FaC3KCr3XgsMQWrF0OgLGdzVoLSo97CF+tC3y7uW2q/DGQL6saVVUjTRMkgqMoK1S19JlmQrZKePzjjxrW3StpJ0KAc4av1zdBhdwnEi4mk6B/QGCtgzQ1nAOE8gv1eNS+xfNQEEKQZV4cUBvj17WWwYHSGgSA4GxIOA60gjEGqfQQ/O/JeJSjlhKCc4xGOera/9la21nnz6E5xeQFoxRiB5vKD+8u8eXbTeufq7TG5y9f8evPP7W+1kB3xC6V1brAKMvg4PzIS0/3rgNgrYMQ/IEbSNcIzjvpIiqqCmqp8OFd97p5EcbYg0LorkilMHLZ1ntPLyedaAG4bzYjWu9Nw9xnzEwdA200GN0tCKWUQodDfFnV4IyfRKUtScRJBv8AnqyWOOcGu7YBlFW18xiOg6/EkSN1kBhrsVoXWK+LB62TxROCoE9tTtusnM1mGXaLmOwoyspXVwigtYGkCl+ub2CMaVpt42a/XK2QpSmkUsjSBJz592pzvTLWnmS1Jk0TpIjjFO2y/bHVd12UuJhOhuBtYG+c82M9/nk8vefmHIi6Lc45jPIMMow0JUJ0kvAb8MHGLnvjKOsuSVwUFb7d3PYaTA3sRxzB4aHA+FxXSxvieV8bDc4Z6lp2ak/IKG3sxrsYacizDEqp3rXpjDGt17Zdiry9nIx9xa5de6afD/GH/mMGz6Ms31moIm78ozxHlqX7p3M6Zh8tg0Oh9ffjDJTSnWdaBl4X3vd4u2p4JNr+ccYPqvC+LkrczudIkwTL1br32dWnEqxxs47q0gAa72jBOYw1SJMExphGiIrR+znWWHlLg/3eZDw6yeB/kzT1rXlVLb32QYsN1DqH1brAeJQPwdvAXsT7Zrh/2hMPslmaIhECSmkQ4p9To9sflt8qlJCdu77iyFoXAZV1Fte3d2CMPrBtGzgNkkTAWgtjLMajHFKqToLTTfzonU/gj/IMtVQ7dTVvw99//QW//f5n63uWMQalNZTutxjdRbeFVBr5MRMAaZo8WenalqqWmI7HqKV81p7kUFBGoc3uB3lrbPMeTCfjrl9WQ56lUKvtXp8xBlKq07S9It8HNEprsC1m1AZeL4JzOKt2+h5KCPI8A4Iqc99dL6t1gS/frkEIgVTqZP2O4wa2mdHnnGO5vp/3S5OgS6C8D3UiuNcLYPSkhQR9wjUD8gxVVX83TrQL2hjUUrZ2shl4uzS6NkMnSSfEg7EPTBjKqkaSeKclGdaqge2JXbq7f1/yILnclm83d0iTdBBgPUHinlpWdeM4ttpDaf5H2NB9RwjpdEQ5do53kbCKydzb+bz3e5Uz1mrUSWsN55Kt9p5eTnT3qtbZXu0jcUbWOYe6Pm4SQGsNELLz70KD+ivn/QoZ7vKwOHg/1lNMAEj5/YFdawMrho39LbPPYUMI3gjL9HkAr2uJP/760lTYzxH96L2tpdcgmI5HYf7PJ3ThHKRSGI9GcHDIs9MVccqytNn4tTZbJwLingP4JDSB1xo4JaIXOQ3uL956zDb2Y9oYsHBwq4JPeRz9cs7blw2V6f7h3B/iTjlpdk7EddwYA0op8iyFNsb/nRAY50AJGToCtmCUZXufqWcXU1BKcTtfdPJarLVYLJdDAuCEybO0CaInoxxFWXVuh7cuygdjP12c27qs1vsz0RijDuwwf/Rz2rJLF0Vvu1Pbw6F1FiAEd8slpnZ8tAUizzKUZY1yRwuy1brAu8tLcM57PwREgZxtH8pjJ1Ue81wA5UVqhgPUWyaqaW+L91KlsDC9VuBW6wJ/fvn6Kr3jrbWYL73loFqtgNV9d048+I3zHL/8/OlkkwCMsWaztkGP4aX1kVHaBMZxE66V75Y6VsAcfcUBL5ZUS7lVZcBYi+W6aP5e1Q8rIJuJDkYpSGgHfly1HqrX+3Ns+7rXyKaei9Iazjokwj+fKogu0pAE27zHB3xXXCwWtTn75VkGa11nCQBKqbeeO7Ez6cBDojB7LRUuppNOrXhdSN45ZyFD1b4r7a9VUexdiI5QSlHXNVbrde/ClV7jpN37qndwoOktujLWIk0SrDYOIrsQhawopUdfGKyz4JwBO8gaUEqxLgpMxnnvQWyWJqifqKA/hTbmpLKtxhg4655dTIZD6NsmTZLvApiXEJwDBL0GbsZafLu5fZXB/yYv/X7aGPzjz8+YjsfIs/Sk2+UppZhOxijKqkk2UkoB55qKoXUOJNgBxqQGZRRVXfee9Y9VfcDb+Oya9NqVzWvHPWO+XIUAi4FRL8JLKQGj7Oj777kSBTcHukeEwkpVe5vTNE28bXRVAQZNV8BbhxICBE0ca20njlSEkM6U1eO6t1yvh3XmxImdN8YYZFnqx5xbiu9uYowFYwA6em79+EIFSloWo4MWwiHOe110MJlwntimO7y3yHSUZzBm/zesKCt8eHcJpY6fRTfG7JyRiottVNXuE845jLFbtyLHmZ5TENeTSj37uk/h9Q0cD6kUnHVbB0PxGSUgjQ1gH3z5et3JXNk5E39/ow0Yu4I2a1hjkSTiJJMBscrNawZjDaTSoXpIGqsja61PjhLSJK77sCGN2XmllE/cBnGlY7cwO+eglMbD1divz2mS+IRAGCUYxgh+zJC87p8s9QGJ1gbKaoyyDCaxoaLoUJQVOOdwYYTpLUHCekIBMM6RB+vUtsQRo/ly1fpacZRJKX2ybjMDD2GMgYQgc5RlnSQBHPx5P3YyW6U6SaBWtbdZXhX7FaIjnDMw1r8jXVc7Ri0VRvmPzy69PW2CCyRhpmPfw4LgAkpr3N7Nu3xpO/Ph/bu9Fs6DWu4RbN1poLRu5ueO1SbnnENV1yGz9v1rIIQgPUGtgoHD4QMiu/WzRymFdRZVXff67LXdTF4T0dP55naOdVFivliirKqTSNw+RZomGOV5I3RorcPFZIxECFjnfAsi5xjlme8GYBRlh1UOX00wkEqBh0P5aJRDiNOdzdfGYF2WWK4L3C2WWK7WWK7WKMoKtZSvvhNm4LRhzHepMEaDE4i3CSyr2u8JQSsjTcSbSspEzY8kEZ3q4UR9qy6w1rvPEAL844/Pnc+WD/QDDaNjIH4csC3OOUgpmyC7q3tVKd26g8+PqdQQguPr9U0nr+s5uhNA3C7Z2VsqI00SrAqvLr3PAcFaf5C31u6tWNoVt3fzvarRxhho02/GKJImSWjd3M6qo6xqaG5Cp8bhrfaqWkIb/ey8yyjLTvZAPHAYeGgz3DZJ5cXReK+thJ9f6dx/W6q6RlXXmE7GuL69884BlOBqNjvJ1k4/tuDFjZxzje2RNgY2jK9Z6yvijDForV9cI6MAH4GvZlhjQSiBMRaCs6ZyXkvlBeK0X/viRn1O4mXWOVhjvhvb4owhSQQSIQb71oGDwzlvqv3GmEYoMO4f1jpkadIIDh+746ZPOGPgnIP14N4iOMdkPO6kAyAyX64wm05wezfHh3dXnV13oD8SIZrOuVnQBWhrwRsr7Nb6juYuugC66Copygqziwt8fN+foxvgu17baivE5MmPzixAjwmAGPS2mRWqpdywpTpMIP0UWmuMR7vNTlFKIZXCjE17elVP/0xCyNYzNEprVLXPksf/9Y0JB0ef+X36RhecH+2z3pV1UTa6CpTSoYWtQ/xs9PYbCqUUnLPeNDd85XOo/r/EcrUGZyw8w6Kpnp9iEgDwiVPnHJwxGI/y5uDBGUOepVgsFRLBIdXzm6kxBkppODhQEjRrwpdqopuviar8Vf06gw5tDHRpUFVeLIeF+wDEBySEkCGpO9A7m2KBgE8MaK1hrWsKMsy6e80A+Nbb2I5+rsSxN0ppCPxZb0m4vGMdKc45jLX9BSQtqGvvjJPnp+t8cywIIc26nqVp63EAYy2osT5RpxTQMgHwvoNkkrUWgnPMF0vwK9ZrbNKF+GFMeCr94yR8r8+bta7VrFBRVvhP//xPUEqjqCrMxKTjV7gdk/HuWZ9YRTokMYjfZROrpYIQHM4F1X3Be2uTc0F0q67ls6+RbihSnyJKayxXa5RlhVr5+V1GKW4pRZ5l+PD+atgkOoQztvXsJmesM/XYp1isVt6dZOBFdEjylXUNbTSU0cAKuJhMTjIRsBkwxANNWdfIw1q0LkqM8uzJjPqm2I7Wpmk9jnj1bb8uT8YjGONtCZ31M8nRyu+1YZ2D1bpJ/lNC4HDvtpAmYugQGOideI8xxkCp7/SpqhqEOBDqn29rLOqNPYadWSKAhjVrcx2x1vX6fDFKkSZJZ1o4JFzTbVSBT4U0TZCmCYqyQlXV4Jz5wuQJ7mXHII7ZpGkCtbHm73WtIFbp9ePaxwB1LWGdbeUEEAtKaSKwWK56FVHvqiPJwXdl5j+wMe71KYsWeG1ahb58u8bVbIayLDGbHicBsE9ldzzKwRnr1Ity25+7Whe+DW7LTUwpDUN8tsjBNUFU01HQgqgz4HCfSX0OcsLBf0xCLZZLqI3WXSBYz1GCy9l0CP47RD/RZvwSUqlGC6PrSmN0NaGEYrHqrvXxtVOUFYqyQp6l4Mx7oyeJOFl7T0IIyqpuAv9xmM+XSiPbOPDFZEC8zyilEIL43y9ULfxICv3ue6xzMM6CMd+xEgWwXgtPHWLiv2ljgKCBEJMBcWxgYKAvYmIP8AGdMcYHGQTQ1mAyymFCV+Lm3n7qdoLRAjpWYePozY8O/m3pY71argv87adPnV+3K0Z51gR/y9Uai9U6OCIwzC4O1+l7ikTb0/Eox3y52vuZMeFejoWWx3vorqRpAmtsq/OGEBxFWeHTh/f4dnPbq2Wladn+/5gfjQH0egrLWmYIrbW4nS+OrgEQuxh2yXjWUiFLDVz4/kNBCMFkPMK6KHdapK1zUFqDUoI6WEBZ65AI7zAQOwN+FJxr7WdmN2d4vNL/j2e5R3l2klWhsqqgtUFRlE9nEQnwy0+fTjaoOWd2mbePFmYxI91lEoBRCgKCE8xNnQVlVaOWCuM8R5alyNL0pOxINxmPcixX6/D/K0zGY9RSPrifNgODuC5G4cPlymvfxPsw0pVv8mshHvaU0v5QteE0cIpJ4IHXQez44RwPzigmuJgA922/tZSNneCpJAN4OF/FdSdNEljnlfQn49FBxKdZSNx11QGgtMblxbQZGTulDoCnmE7GmE7GUFrj5vYO679KzKZTVFWNy8uLN1kI4swns7M0edAFt891fAcLa/28sVC8bdOVEPf1bze3z44td0Efa8uPxmp6fcrSNMF8ucQoz1GU5c7fHw9QUdzlmK1BoyzDSqy3XvBm08nBBAAfQwjxGeAKD0RwfoRX5pe+HSscwmRQypZKgYYWrTjXyUKHgHMuWBEaKO0VeLXWUEpv7eGeZ+nJBdDGWkgpcTdfopbyyc9+lOf4+dOHk3vtrwHBOaTcrv0/VkDYRvdKlyilQRnF/Hao/u+LtRbL9bqx5unKl7prrLXN4ZZRjrKqwKgX7jPGBkug7w/ZfpTKwdj7tSBKssQxAADNGMCA35+otUAYu0gTAaUNSOjkiXvLwEAfNN06QaRTKj8SqZQG5wzWCaSUQGvTiAseSzgwimwqpZvOmfjvADu4/erffvqE38yfe7dWP4YzjnVRnNVZSnCOy4sLgACfv34L4yQS7y8v39yIQHQFcLZ9ssw518QXbalriTzbfwQgJg/WZYlxnvf2uW4WEbrAdwe9/Bn0/qQJwUMLxe4JgOgAsFitcDGZYFWscTWb9fAqf8yqKMJcynZY55CnKaqq8lnZA2cEWRCx0trP4u7yMDo8rFZRSpvZnCQRkFIhz9LQxun9MYuyhNa7HWyjCm+Wpkfv8niMsRZfr29QVfWLHsJaa1RVDTE5n03rXNhlE9msxnaJsRar1bqZ1R7lGeDQifdt12xWnBMhMB7lwQ82g1IKifBWWat10SQmvQJ+Aq39obKWEs768SEfsPqZzC49tOOcoE8sSry7vOzs2l3AmA/wlVKNkE4MFF46m8aK3Gb77QN3AHf/vjr49W9znd3cI6JeylvAOgeEA1+0bksEb5LH8d+E8COFQ3fAQNfE5FweEnsEPukrOGueUc5Zo3zu1y+7VyJvF/cBzvzPNNYLjVZVjdnF1BdYtGkcRl4DSitczi6gjem1zbpr4uv8p1//hm83t1itC3y7uUWSCLy7unxT3QCJECh0hbyFIKAOulpxv0xavn9pmsBYi+vbu3bXSZKzEbHd9uzce9RyNZu1yhAKzkEJgeA+O3gssjTxwfSWN7UKStLHDGy98A1ttVkBQY09/FmXfjNcruNnsX9gQCmFYOzBbO2psFyum2z/S56anHNMJ/1ag7xVog/71q3TDp1Zx2yyLktcTCYoqwp//9svuJ0voMMc8zHJshSpELiYTpvRh1WxhtYGhBBkaQqVIgQCAAAgAElEQVTGGOpaIssSIASjaZo2owxSqkZEilGKNCQJCCEw1mI8yhvBSx10MGJiEQjCTfDr3a4t7j5pqGEt8OHdaSUBAEAI0XQ9bW6muwSgJOxdAJ6sZN9blNlQYbRNazyA0IWwwzNwxjT7U+xEIwQ03Icpo6hriaqqBwGugd7ZtBSklIKmtNENMNY0CTqvfp6AEII6JKystU2A/9RBfDP4j8r91rkm2AcJCcAgol1L2eiNUHI/53/szhildavK6mPWZdWoyZ8rH95dYToe48v1Napaoqwq5Nnbcg/IsxRS3o/W7Ipzrjl/dNENUtey1fsfk855mkJpjaKsehlfjL93V9cKf3rx6w6ygrR5s6RSqOoanz68P+rC4BfeHdoznM8YEUJgjT3aAhA1AcqqAjV2p5GAPsnStHehmn1ZFyXmyyUYoy8G/6Msw8+fPhzwlb0t9mmV7toFgFGKnz5+wGK5xMf373A3X+D2bv7iTNnj2e8umYxHjQ+z0rpJjgLReSTF1Sx78PWPMXa39eg5N5N1UTazqFIpVFUNyiiM9qNA24xLSaWwWvtk208f32/9mg7FZnUteh6zKO7aweEkbvjx58RLRg2LPEthrZ/vjcJItVTNmFab2cZTJQZIzrlm/lpp30UhhACh5MHaMAgIDvTFpu6R794hIJYiTXmTNI2Vytj9Q+l9l5W1rrE+vpiMUdUSWmskiWgsQ1frAi5YCWtjgvaACjpM3go3TTgQCjqngtYaozxvXVmNWGv9XL3S4CeuAfASaZogS1PUUuLb9S3yLMV0MjlZzZuuIYSAMoqUb+/g9P1FvKsOD6M5bQLjSkrMppO9nQDuuyH9PdpXAsAXbZLO9vQ4UpAI82yX0EGestv5fO9sUB0+vL++XWOc50fTAUjTBHmWYbkutjrcr4oC2hq8m81CC+5xrU3yzNtYSaXgQqX0GER/7WNnr58jVpmcc1gXL4+tjEMwNtAP/oDFoLFd9bMvxw1rLUZ5jm83t5BK4fLiAmVdYRW6YDjnGOcZlDYAvEbGcl0gS1MkgjeimLfzxU4/Nwbek/EIH95doawqL8jJOZTRGGXZXr9vV8nI8Sh/9r8Za1GE56eWEvPF8tkqdi2jO4jDTx9PN6FGCHlg+Re97fvgseCgdX4czgcZWXgN/n7X2oRAwe9LDv0ICh2TmGgyxqCqa2Rp6me0jUVdy61FagcG9uV+DOg+4UopxWK5wsV0AudcExxMJ+NmVIAzBm4taqkglR/JEpw3B/3xKIeUCtY5SKmCsJ9o7uXYYXBqaGOQ8O6Sb9ZacMZxO19ACH5wTYMueXd1ifliASl9xVgbg+VqddL7W5dEAc29LTUdoI2GC1pBbcZconvcLiPcmzR7a9CZmvaoW7Tva3wKtXE+eO79I5+/3fV+UijKCuuiwM3dfK/vF5wjy9KmEncsHYDPX76CMbb17yE4xy8/fTy5hSxW5rQ+XBtzIsTJez8ba/Hl6/Wzgn+bcM7xH37+aWhF7REvSllvLSTJGcMozzqfiYwbWFSTXa3XAAisMbi4mEJwDmMt1kWJi0fjIEprlFUNwVkjyFLVNepQCXp3dQljLYzRyNIsbHa0OUiWVQ04gHEGSglGeX527YQxGVDVNVbrognUnHMPnjPOGC6mU3x8f3XEV7s9tZTPdkccCx1EWKuqfrVCg7HqSsIs9WSUN0m2GCidUqV04O0QbY83zzkxEPKdUl5XgBACpTUICJJEwBhzlu4X1zd3mC+XnXYijfIMn96/fxVnqz//+tqcJwXnEELg73/7+dgv6yCUVQXOGFY/KKQ9RUyCpUnywFq3Df/Pv/zb3p2ZlFBcXV4A8GMefRATiF3FZJSQIBRKnu22PtgIQJomuFss9/oAlNZABSyWK1SVBI4T/+Pjh/e4vrnd+utVUI0+dvX/MfHQmiYAKb21WcxAdwklBEJwMMpOfjFXSuMff36GtXareVtKyMn/TueOn4ve/uv7ODzNF0tQSlFW3gdWcP5kApJR+l3wD/gk4GOByPEob1wFYjBf1xJc8EZwcJRnoITi3eWRFrsOYZQ2tkkf379DWVWQwbJqtS5wt1hAB/XbbTVWToFTFN+KgUciRDM6oI3vVrDOhqTLcbUr2rKpFUBDUEW0aQKtODdNKR06tAYOylNrwmaSMN/475tfe8qFkZdgjEII0VkC4H/49RdQQhunmHPnl58+4tvNLYy1UNpbYf/2x+c3kQTIswyrdbFX93fU3uhylLLNtS5n0ybh31c8F3/nLvE6Os9f82Crjg7+kG2sGEZZBinlzjOsXaGVRp5nmC9XW99MVV2f9CFklGdNi40xFlrrRoBjm9/xsR82C1ZsifAiNV37sffFzd3dTouUGOZOe2fXll6lNVIrOg3MRnkOIboXeny8gcTDzuxi2unPOUXyLEMcoZtNJ5hNJ43uRlXV+HJ9g/dnoJ6slO5cc6JLKPUzxjH379vnJRIhGnvC2DFwrtjg0MIoRZqIxso2fi5RXPEUkzUDA+eOt9/tLvF+fTvHZDx6VSNMsWK8WCyhjAGUwucvX/Hxw/uT3+PaIjjfe3+x1kJrg0R0E0fEgsM+rIsSWZpgOh73pu/UNZRSEBAYawA8Ha8cLDKNM/T7JgDeXc5AGcWH9++O9tCkaYJ1WSJL061tDa9v70Bw2tViSqm32hCAtf4QpbWBCxZgjFEw6gWnfKLAz5x6n1wHRhk4Z6AbM7Kb1z5VYiJptS52bpc9ReeCQ6OUF3rr08ud7ljV18aiy9zMKXXuvGbGoxxZlvour7rGfLE8+e6HLgSKDgljDONR3rTKE0KahK9UGkqpsxwbiFaLsXMrS1MQ6sUx/XnDNfoJ5/JZDQycA1GTpivKqgIh7YTDT5EP765gjEFZ1V4TZ7nC7GJ6cuPBXSMEbxK0u+8tBJz772uTwC3KCqxlN0Etpe/cDHbJfRDd2rqCcwYQnEYHAABMx+O9FUOlVPjy7RrT8RjGmqPpALy7nAUlyB3mWsjuytvHIt7c8YHbdF6IwRClp6nevytxUfL2W9vbbHH2erx32yAER1lVvbVE7bPQaq0BvI77863BKMXVzM/ZdWUt1SfRovKUO7yeYvO5iq3HPLTTx+6vc00GAL7rDgBKUiFNExDi56/jWjWdjEMC+7w+t4GBU4MLjvEo31ng9jmuZhfQWiNNXt8e/uH9O/zx+QsoobDO4h9//oWr2UVvM+WnQLSu5JzDbOEKtIlzFlqjsSXel5hMalOA5owhTVOUVd1bgopSCkq77XxRSr/otkb/1//tf+/0B75EmwPFqvCzJJz7mfJj4d/QbKfgZL7wra3nDg1e46+Jr9+uUUvVCLRtgzYGo1eeud0WxnyWEfDPRkQp3clc4K6JhVOxuRxoxzlUgF7TjLngHGmaIEkE8izFxXSCq9nFWa9z1jmUVY2yqmGMQZ5lmIxHUEo3B0r9Cm0UBwYORV13Kza6Cu45r9HelFGKv//t58YCMjoDnZPuzT5oY3bu5AQAa13TYbd5ttyXKMS4D9oYlGWJu8Wit/Ffa+1OhcgfEc8nL1pWf7vdXtSuLav1ulW7sNYGhPhMThc3xD4Iwb3a+A4HI6U17jrKkA50h/cqV1iXxU6JjUSIs/ap7ZLxKMcyCNdpoxuxm0rWuLmbtz4cKKV33jzkmYucDQycAtZaJInAdDxCmoi9DnGngHMOy3WB5WqNqpao6hrLddEkCo9liTswcO5cBIu1LqCEYjzKkWdZY932GpldTMGYX0uttfjjr6+vMuERYYxC290D2xgM+/n/9nuPDWfTfSGE4D/98z/1dm9Gl6muMMb68YsXupUPWs4d5TkSsf/stDYG325uIQQHZcerRFNKg73C9qyK3efMB/pDaY0iCHvIWu400pFn2VmMcxyK2cUUjFIkQe3YGouyrPDucobrm1vUW9r4PUX0994WSshR14aBgdcCDdZlnHtP7tnFFFezC4xH+VnO0hvrD0TWOXDu9RtsGP+qpfR/H/bogYGt2WkU9gdY54WnueBHK/AdgsuLKZIkfdCFdBusxV9jjJAIAQKys2AuISRUxW3r/UYp3bpbj1KKz1++trrGj3ipXX9XGKM/1J476Ek5zzM4Z/du7/SLDcH1zR0Ypa0CizaIoHC/LZRSjPIc88Wyx1c1sAtFWWFVFCireieV0kSIocX8ETEZwiiFVhpSK8ymU1zf3GI2nTYVNqX1zhv7zsk2QlBV9fAZDQx0yOYBTHCOy4spsjRFumMi/FRQSntFaOc7C2Or5Hy5Qr3jrOrAwFuFEBpUxtszyjOM8hyL5X524efET8FSOHI7X6AoKyyWry9GiE4RbMfCjAlitYLz1qPHRVW1vsZ0PO61U4MQAmO6u++V0tDavPgsHTQB4K16Esym+1tdUUIwDw/JMduwszTZ+oay9setGAOHY12UjT3Uroc96xyUHlpGX+Lmdg7rLD5+eI91WaKqa/z2x2es1gW00fi3f/yB3/74E2VVbZXx3iVz60J17xwrlAMD50B8tvIsxSjPMZtOQjLgvJxRjLVYlyWccyjKCuuiBGcM1vpOgHXRXXVz4O3ymqvZeZp2pqORZxnuFkuMsvzVj1gKwfHzpw8PComfv3zFKM9f5f3ikwC7hZvRYlwZ3XqsczadtEoAfPrwrtFA66tLwznXaeGKUm/L/lLnBf1f/uf/qbMfuA2ziynSJNlbC2BVFHh3OcN8ucJqXRztYeGMI9lBDEJr/Sqze+eIVApKqb3agvIzPOgeEqU1Pn14h7++XsMai3eXs3DALjFfLCGVxnQygjEW//jjL/z3f/vth96shJCtRy6iheVrryAMDJwKlFLkWYo882vjuSXfzMZsaGyZXK7W4JwNIoEDrYlib68NE9r1u+rElUrhYjLG7Xz+JkYs8yzDdCMOUlrj+vbuVVoPx2B+l50hBsTOutY26tGyel9u7xb469s3TMbj3jrPtTEd753+WvULyRP6/t1lhz9wO8q6xmQ83vv77xZLWGt8VudI875C8CYrtC1aG9wNYwBHJVpcgRCkSbJzS0+cE32Ns1pdkOcZ5oslsjTFv/7jd9S1xHQyRiIEainx+ctXfL2+hVK6mfn7/fNf+P3zX/jy7fpJRVxK6U4jN9oYVEcaDxoYeKsQQjDKM1xeTDHOc3DGzk44cF34jiXrHJTSqGrZJBO7rtAMvA3SNIHW+tWpvV/f3EFKieUPEvjbopSGsQbvr16vLd5jsjR9oCq/XK0xXyz3tks/VXwCYHdrZ0II8ixtXdARgre6htIazjmUZdlbcoqAIGuZ6GiuFfQTCH35mkeJnsd5HpQd9/vxSmssV8UPK4d9k2fZTh+YVGo4QByZoigxnYwhpdor22ad8+McbyBDvQ+MUoxGIxDiW/f//Y8/8e3m9rvxF+seLsardYHb+QL//vufuLm7+y7BsvP82GAHODBwNJJEYDoZYzIeYZRnEJyf3ZppjPEK1sY0I2PaGNS1HNaWgZ1IkgTfbm7x9fpwrlt9cnM7B2fMd/p1UAyJnUNpkkKbt9N1Mx6PvkuSLpYryFemQ8IZQ5qInc/czjkYa1vfYzFWbDMGkGcZeLDL7QPGKGSHHe2UUpRlBf2CteBRdmQhOIwxuLzYTwvAWos0EVisVgCOq5x5saOeQVGUry4TfE5wziCVhlIKq2KfBJL3JR06AJ7nYjKGMd66xVq7c/vV1+tb/L//8m/4199+b9qt0iTZSUU2Kn4PB/WBgePBGGtG/i6mE0zHo51G546JdQ5VLbEuSqzWhS9ahANsl37NA6+f2XSCRAiUdYX5cnXsl7MTm2O2dS3x19dvYJxhVRSdCWb++vNPSASHg0O+g8X2ucMoxU8f34OS+1CsqCokIjmayHkfxNHMXQs5lFIopVvpp9XB+hXA3omENEkwynOM8nzv1/EjjGmf6NhEKoUsS19MvB8tJc8YxWQ82jsjs1iu4ZyDlPKolYXZdLKTnsGqKCClelUP97lgrEVVS9R1Dc7ZXg9bmiRIRHJ21axDczGdNNlMpfVe73UtJW7n8+YAskvmNW44L2U/BwYGDgvnHONR3rgInAvGWhRlBescrLNQ2q8ry9V60BsZ2ApCCJRSKIpyz+LD4VFKoyhL/PX1Gjd3d/hyfQPO+LPjevuQZxn+/Y8/8fHD+05V0M+FPMu+c1NZrFYoqtcjQsoY2zn4j90CbTURYrFu37FQSmlnrfkv/hz2smDfTtcK7gmM0heTJ0eLYi6mU9zczTGbTvb6fussBOe4Cf6Zx+TD1RXyLNs6mXF9e4e7xWJIAhyY65s7WGNRVTW03i8wdA6o6qGD40dMxiP89OF96+vMlyv893//DauiQCLETnPFSuuzm0EeGHgLxNnO6CBwDs+psbYRHqaUQCqF8SgHpXTQBxj4IYQQUEKxLnxAfUrnPz9/bzFfrppRhb++XuP69tYnvoIfu3MO325vO016ZWmKi8kYq3Wxdzxw7jzWRJNKQUp19DHnLrHO7TQC4JwX/+tiXWWM7n3P2vBclGXZW/s/gE47i6214Jw1e9NzHK8DgFIwSjGd7C8GuFoXIITg89dvR22rStME08l4a0V5pbXXMVgXJ7UJvHYcHCgjTXv4XtdwtpWA5VtiFCp9bf1XAeBLODCN8gzJlt7jzjmUVT1U6AYGThRKKdJEYHYxxXQ8+m4PPUVHAWMtpFQwxgY9ovV3goEDA495d3UJEdrcjTH4/O0byqo6qu2bUhq38wVu5vMHc+dKK2jt7+nFaoXFaoWbu3nn46uJEMizFJxzjN5Q6/9jGGffjT7cLZa4W7wi9wgHWLt9ME8JARz21uv6/9l7j91ItnRLc21h2lxRhcqTeQUKNe9hj/oFetSDmjTQuIML3AdoNHqYr1bDGtUDNHCrbp6MExFUrkxv1YNtZsGIoHBh5nSS9gGJczIzwukkzbf4//WvdRfOdlcRNKlfWVFA9vhZpbVxXxe4rgvGGNIsf/Rn96w65tPZDMvVGqez3ZIIhJSAAWDMs1cOZ5MxJuN44yJAXpQQQiCvZ1MG+kVICd9z22znXS+l6zQbOj0bYufbzuC57t7RiUJKXN7c1JEmZCsVQFlVUGqIBhwYOEaatZgxhjgKMRnFrSnYsa61NmmkRFGUYIwhK4rWsGrX4vLA64ZRilEUgdbPdVGU+HZ1A6kk0iw/mK9QWVYoywrrJEVau5q7joPLm1t8vbzCzXyBdZJ2OuP/M02qD+cci9UaSqlXGX+3KaHvI7pnvnxXpeoxQiiBwebrue95kErtHwEo5V7Gknb+30ccReA9PqNlJTpplgEApQRKKoTB40W1Zy0AOA4HpRQO53tcyFIIqY4iNmM8GoFv+L1orZEXBZSy0YCvSepzjFBKUZYVKKWohNj5MtjMAg0mgJvz7ux06/mv+8jyAp+/fgMlBGEYbFwVLsqqVQIMRYCBgeOk+TxTShH4HkZRiND3j9pvRRuDsvYh0lq3CQFZXiDLDz8qtk2s7XN2nt8qk/Hoh5ncsqrw9y/fcLtY4ur6ttdzRVkbWq6SBJc3t8iLArfzBb5cXuHy+gZFcbhmFK0jQ89Opgh8D2cnbyf67z4ch6MUvxZbyqrC1c3tM7yj7tFKY4v7P5RWdk/YswYs9jSDbgpTNgawvzWd0u7UbrJOsLENs4d59pLb6ckMeV5gNhnvfInXWuN2scTpbIrL6xtcdDB7vAuMUnz68A5/fPmGbAOplJASq3UCxijCIITS+tmVDK+VPC+QF+XeZh5ZXuD9+XlH7+r1Y+dlreGnUnrvjoLWGtfzOd6fn23VIVRK1S6rBq57vBeKgYEBWwwghLSHL8ooqkocbXe9MRsNfR9am9bj4FAora3cE8CiXNXdMwmHOxDS/sxmk0n754W40xUjwOX19zg3SimiIIDSNsklDqM33Z3tmrOTGeaLZXtG1Fojy60yMc1z/OnDu70Vc3dRWiPPC5RVBSkl8qJEWVXt13wOlNY4n5zgdrFEHNqz7zEX+g7BKIpQltUva9xrKdQxRrHNt6KUBucUdM/mESW2OOtwvlWBtIFzDtdxQAi2MnzfFsZYJ79rSgikVNCOefK+8+yrOqMUQS1ToHQ3o4aiLPHbxw8oy2ovT4EuYJTi4uwU8+UKy/X6yT9fCQEqKYzJQClBURQ4Oz1584th11RCgDPWmedCVVVvKq5mV9oDPKGdzfMmaYYkzECoHQXQGxQBtDHIigIO5yCUgDN2lPPFAwMDlkZJ5zgcQkgEvocw8FEJgbwoj3I8ICsKcMYQ+B6WqzWCwIcxBozSVvbcNUJIOA6H5zhYp2k7/9l0mh3uIAh8zJdLzCYTXN/aLHrf81AUGWbTMSajERzOkaRW9v3t+qZ9/UvcwnNd+J6LOIoQR6Et7NYH8+Gssh1xFCJJU9Dq1/OulBJfvl3h3flpJ+eLRvXYeA2s03Tv19yH5ow/HY+wWic4mU7s8zo8Q3XB0/mlAJCX5asokNho6M2/B3vx5ntFAALWML6sqp0u/wCgtYLSGp7bX0FXaw0CdLKncc6htd7otZ69ANCgtEbo+zvHo3y9vILvexjHMbK8gOc936LieS5mk7E1+xPiyQdPG42iLBEGATjj+HZ1jXfnZy/+A39MKKVAKAE6GKmaL5d1h2coAGxKGARwHKd1Fd6Xm/kCF2enMNSA1LO3m2CMQVlWkIwOv7+BgRcApbSdAzXGAAbwXRdlVW1U/Ds0Uims0wyOw+sZXgOHc0gpOy0CrJIUgee1RVbPc3+Yl23WWa01bucLhEGAdZKiLCskWdZexq7ntiDAKIWQEp7r2q6Z+b6mllWFsqp+MVsOAx++5+H89KSz7+stcH52Cm0M1smvF/KyqvD3P75iPIp3bgYprZEkKUAI8jx/VpPsn3l3fgZeF6iUevkX266whaFf7z+yjlF+6T8nx+GQW4yZSCnhOhxmy/SAn2Fst8jv7+9DgRICpVRbbO2apjDSxQgQZwyGUWhtniy4HEUBoEkECINg50qNkBIRDaCUQhD4uLmdP9soAGA344vTEyxWK6w2zArO8hxaa0zGI+S57Vb2GTvxVijLCr7nQQiJsgMJaZJmOH3jM2vb4jgcjsOR5X4nBQAhJa5v5/j47gKVFBsvnFKpNiNVSAlGaWfGKwMDA/1CCIHn2cu/73lgjKIoKzDGUB1RQcBmvsvWYC3LCzDGkBdlGx34FELYg7/S+l4zp/FPakelNZbLNQwMhBBwXQecO/BcF+M7o4WjOMJqnSAvCqRZ3p63mjPKNmNajdfB7WIJz3UxGccIffv9DWMDD8MoRej7dXrEr5cibQwWqzWyokAUBJhNJqCMPnkJVFrj29W1HXcz+qBz/Y/RFJtmkzGyLIeBwfuL8xd/qe0ape7vUBVFCSd+2Z8nvWVUKucMUip4HtuzCLD7nuC5LpbrBKFvC519rWlNjOy+CgBKCISSCDxvI+XE0TxRcRTi6maO9xfn+P2PLzu9xipJEYUhsizHxdnps8tmPM/FdDxGFIa4vp1vtLEWZYniqsT56QmCwG8vNsNCuTtpntsNyHRjAiekBGMU17fzN29esy2z6cRmaddV7X0oqwqEEgR1jngl5EYLaGPcxTkDOEclROs6PjAwcPzcnZF26vlO33MhpGyTXp6TZh3SxiAvS3DG4Hsu8lqt1Kw1D605eVFY2anjohICaWabA4QSlGWFcRz/chhtYpUpo8jzAkVZQkqB2/nCzsA6HA7nCIIAvuvW+xiDW8uO1Z4mqWVV4fL6u2FZHIWIo2jwNXqA6WQMIRUIsalQ91FVNg9+uUrauGlKCISUGEURtLGpE0ppZHfm/I+JxkF9lSSQSiGKQviD7P9e4ii8VwX9Gs4mxpit1hdaF0+B3b9/ISSUsrGtu1BWFU5nU2it9/YieIzGo2pfKKXt+rBJAYD93//P//vXvb9qR0RhABD7S9vF7McYA6MNKiGwTlJUlbCv+YxwzuC6DgxsdWdTdUOW561ZCwEAY19rYHuEVOB192XXOaCfmY7HKKsKUdifKchrhBICXs+adjHvlOUFJuMRPNetXf43e01jDHRtCqiUgnfnQDwwMPBy4Mx2iKSy6zznDASbeYMcCkIIijohQEoJAoKiqkBA7k1IcWrjKcYoPNeF6zjtP8PAfzBVhTEKJRWKsgClpO6guYii0HrgVNYJ/maxgFIavudC1Wtm1xfHSggkaQbf8+C6Tqev/VrwfQ9Ga0ipHlWxGdjnJs1yFGWJSlgzPyntz7goSxRleZQpN03By+W8jfgcnof70domiPz8e2S1kfJLpiy3U3d7ntuawe4MATzHxc1i95S489MZiqL8oSDRB0qrnWMfm5+R4zhg1J5hNxk3OxoFQMNytcbJbIKs+PVDsAlJlmE2GUNrjZPZ5Gg66LPJBL7n4XaxRCXERhWpvCiQFwVgDHJK4RYOojAcpHVbQmCfqy4dpC+vbzCKntdw8qUSR2Ebm7UvZVXh29U1Pr67QOD7MCaHUnqjkQADtJeGLC9gYNqRgNdQcR8YeCtQSuE2poH1Z9dzHXtJekBWe0ia9UjVhoAg1scgL0pQSjotPDoO/8Hxvyyr2gROgBKKILAd/2auv2++XF61I1d//vhhGGu8A6MUURjC8zxc3txsdC6USgFKQQiBZ0ia3IhmxOXi7BRlWUIIifEkhlIagT+cXx8iy3M4nP1SjDtGw9NteWi84SGkVHA6eFb2bfoZU1+me/oVNL/rogOD8ubY6nubGRay//3/+C9/LcsKSqujMMXy6tkFSunOMSXGGHieiyDwrcnNzS3iI7isOZwjCkNbCRNi4+eprGw0iMOtI6bRpnVAH3iaVW2Ao7XeehF6CEIIxuO407iet4TS2ha3OqCqBMIggOs4cGoH1G0SRZrZNEpoHY9ln5FBDTAw8PIghIBSikpIcG4d+Rm1KoG7qoDnKPI1762sBCil8D0r8ae1Z0AfKj/OGXzfQ1zFo3oAACAASURBVBxFkLXUdF+5/zYYY1VWpp5rp3QwYL0L5/ZMF/g+pFKdqRSfC4dzeK4DzjkC3wMhdmQnCIK9Y5hfO3Z0p/qlgcEYhe96L1YFrJRCJcTGhQxKSK3m2q8AUBRWGbPrXdJzXYxje86/z4elC8q66LdPBCAhBKzeT5S2Pleb+Mywf/nXf/trM2N2DAszJaT+D0VelDtd2JRS0NrYuV6QNl7jGC7MlBCEYVDH6niohNhoIzbGoCjL7/NBxlYLOeMPygEHLFIp5HUEXFcqAEYpYMxRFJZeImEQ/CCL3Zc8LzAej2rzKadV/Gw8EoA6ioUQeyAzaA/kgxpgYOBlQWqjzybus2pjBAO4Dt/YL6QPmiKE3dMrBL5XX8oVUB/k+iLwfcRRiMl4BN/zQKmdFz3kzyLLc6zWCbweTbVeGpxbLwZKCIwxnaoV+8b3vLrAFMJ1XQAE4zhGGASQys5gj6LoxV5eDwmjDFlR3DuOczKbHsUdZhe2HesmhCAM/L3PXo0fyi7NJodzEEIwGY2Q5llvd2PrU6D2KsgSQuC6DrQ24JxvXDj54U+t1gmi+nL63MyXS3z68A6/f/6yU0W0rCosV9YR9znTAO6jMesRQsLzXFzd3G4sxdNaY75cYb5cwXNdK5NxHIzi6NnHHI4ZxijMhpfBTXA6yCd96zSz910oAYSUmC+WrSkjYwy+58FzXaRZvnFKgNIauhLtKEBjEDgwMPAyIYTA91yUlYAuK3iug3EcoSgPI4F/CGNsPGCS5fBdF8bYBkGWF711mxqaM4jveZhNJiiqCkmatjLUvo3khJT4/PUbPlycIwj84exS4/setDFwHI51kj7r+AqltL0EOQ5v57EZpTZOt7LpG4xSKKURR2FdaLN7e16WdSFgUHtsSqMK+vlM9NJVIdu+/y7HMPc5XzZjUvt05zehC/d/zhgqIUHJ5kXVH/5kWVUoy+ooDrznZ6coywph4O+cYbpOU0zHI8wXy3Ym7pg2miYajbNzVFJgsVgh2+JhbR5OlzsoihKcM4RBMCy4P1FVFVzHQbqjDOghppNxp6/31piMRvB90dkoQJbbWKvG+LORQFFKwTlrpVZP0RiKUa3b3HHO2VDwGRh4oVh1o52LrIQAMQa+59aH7fJZOq7aGOj6YJyXZas+IoTcUWRuNsu5K00H3vNcTEYxsrzAar2G0npr065t0Vrj89dvAIDZZHx0jZrnwOG89ciJwhBJmmKxWvfytZrny3EclGUFXu9vpi5AlFUFx3FsMcigPqsyaGMQ+B54zjEaRe3/V5YVTD1+N4qiQd2xA1pr5PfEQgJAkqSYjEcHfkfdQOl2l3nGulFe6jodYxeU1vBcF57rIknTvd/LfQgp4bkOVsl+hWhCCKSyn71tzqnsX/713/76wxsSElG9AD0njdRFG4O8KHeukFRCwnU40jzHOkkRReHRyWg4Z/BcF3EcIY5CaG0vIJt+z0prW6WSEkqqNvaOMnp03+tzUImqdcrtitl0PCQA7AnndsYrzfJOvBkIrNIjDH5M/nBdp10UjdYbe280YwFaazA6FAAGBl4DjceQnUutfQI8D1rvn8O8L0ophIHfzs03nddD4TgccRSBM35n7evGsPUxirJsU3Xe+pmF1nJeAjsO0LiPK6U7fT4dzjGbTmC0BiF2v/N9F7xOoDDGtL46Tr2HMsZAACilbRoFZyCUIMtyeJ6dk/Y8dxhL3ZEmJeTns6rn2gjIPl3o+8Iajm4+/88Z++HMtitZXiBJ050bTJ7rIgoD+z4IehkBMFpDKb1zobVR5YSB36a6bLNf/FIAUEphvlwdxcwOYxTzxRKB7+3skGhqg6+qzv1uZi2OMYaE1nOLozhCGPjgtaHZppcjrW0mbFlWyLLcmgdW4mi/30MR+D6WqzVASGcHGVpLKAf2I8tzcM53Nmm5i75jLPhzEaCRMWptbGzYNoWAOr5TCAFtNIQQrZnXS6MsK7sGGj0UNAbeNI3EufkcS6UwikJQSp9PcksIdB1l7DhOLbOmkEod7POqtAbnzJpfeV7bXOibxotqUNZZGKNglCEvChhY9SqvfS32OcuEgY/3F+eIwgAEaD2ypqMRgsAHZwxRFMJzXRhjzQkbZQIMEEUhfM8a0jWeXa57HB5bLx3GKBbLXxOrlFL48O78md7VfhRlBb3heauJcd3Uxf4xkizFcrXe+XMS+D5mkzHSLEMchp3fh+0YjbCG8DsW9pr9q7nj8S33iF8KAIDNElRKwnO9Z6/khWGAvCjqIsD2HVxK7ebZFBHOT05ap/Dn/t4ew+EcYRBgOhkjDAIboyPExtnG2hhUlUBWFKgqgeU6sRXdN7pQL5YriI5knpRQnJ5Mj2JU5qXjOtYtuHk+u0BKidl0cu//5zjcytFqs6VtvmYzGgDTjBcYSHm4g/m2GGPaza8xW2SM1fnix/meBwYOTdNFac4FnHNrIMhZe/E9ZBe+8SvRWmM8ilGUFWg9d910hPukudQ1MGaTFJ7Kqu+Cxi28MbV66zBGEUffO7+EEoxHMRxmx0etOmOzfYxzjnEcYTadgFGKoDZZC0Przs9qxWhz0WGMwnPdWqnXZIsP+0aflGWFVZremwc/m05e3Nm9MbTcdN1wHKdOjtjv+xRCQgiJVbKbdN8qsTVOZlMslmvMpt0XJaVSoJRsPJp6H/TO3kXo9gay9xYAmkNjnhcYj+Kd31wXWHMDDlV3wreVCjcLo+NwRGEApZVd2F5QHInj8LYIMBpFdXSQ3Liy1UTwFEWJNMuQF7aQYox5Mwu6gUGadeMBMBnHOJlOO3mtATunVQnR2Rxu87n4WQXQ0HT+QNBKHTctrAHfFQFSSpu7SgiUUp0a1+xCszY2hYpKCAipvss1a+nzwMDArzSqnlbdY2q10J1/HnJAwMBK42EMjAEIbKe2SSs5BIxRFFWF2WSMOAzruXA7293XWEBVCcDYtXmIO7ZwzhAEPuIwBCV2vNN1XRgYxFGA09kUURTC6O9FXr9OWWgM+s5PTjCbjNviFgCAYPj5HhHGGCRpdq8JZxSGL85XoRKiVhw+vXIyShEGfjdnFAIIIb6npm3JKI4gpULo+/A8OwbTNXlegFG2l7rK9zxIacfYGsPObbj3u2qqjZRS3MwXOJ0972XH81wkWYZRFELIzS++d8nyAkJIGAB5XiIMS8RR1Msvti/uSs5HUYwkTZHlBWQ91hBHEarKZogS8l16A1hFAAGQFyWkVJBKgoDg7GT2ooohuzIejTBfrPaWMlJKh+i/riHdm3NuMvfVKDiaTl9RlFsVAnQt4aqEtJGjRNU+BAy6NkPq86DexIgBpu72G1BKoJSGbk3OnCHGcGBgBzjnYMy0+2MlBPK82GqN6IJG4qkpQZJmcBw7o32oz/WkbgI5DsdvHz8gywvczOe9jgWs0xTrNEUY+Pj4/t2ze1IdE415NIC6qaXbn4/LnfZ5LcsK2uhHZ5eHn+txUVYVXtt2vUmSRTtG0tHzuFonez3bN/MFzmYzqwhj/dwRuxg1U1q18/+77Af3fmeVEDiZTtp50bsLzHMRhyG+XF4hCgOsd5R1ND/sihB4ysViucJ0PH5xVTXAbgKz6aSVOudFAVO7lYe+3y786zQFDJDmOaSUkFK1BR6lNa5ubgFC4DocpyczMEohhHyRP5PH0FrbMYo9P3AXpycv0ojlmHE4x3g02jnt4z6K0ho/xtHTRo2UWqmjw3lbUNt2NKAoS6CsfTzqiEiO75tfM7+5K0opEEIghGzfn4GB0aaVMFsIGKNwCD3oJWFg4DXSfH4aM7wwDFBVAkLKgxkGCinrRoV9L1VlJfJGm2dJJwkDH2HwAZfXN5gvV22Bog+yvMDf//iKj+8uXt2ZpCvuns3vNnPeQmPn1UHwoGv9S2pWAvbsc98ow32EYdCpEoUQgtvFcq/XCEMfWZG3CXJdopQC52xnVTKtVWqMMQip4Oyo5H7wiUrSDJxzSKmQpCkmo+eNn/A8F799+oCr6xuMoshebHeEMoplXSHSxmAcR6DkZY0F/ExT5f05AnBUd6vvqgeU1iiKElJKZHmBOAohlcJqvQYBac0HX/LP4z72lZiPogiu6wwHkR7o+lkbRSGyPN+oANBg1R1he7gvinLrmddGFQDYZ41Raud3OauVNwqu67SXB0opmm2PMWbVPOq7akfdKUY0owrkztdi9TiDgfnF1OxYuXvA0XXUTpKloJS1c9hZnt+b0R5HITzXQ5plrZdBXhRQSqEUoo7tceC5HsLA/6WYWZbVq1vXBvqnmcFX0j5PzRhel8kyjyGkrFMBHCilrJqxiWt7pmf64uwUk9EIn79+g8P5vZ/XLijKEvPlcogJHHjVNLFzD/GSzp2N8fomZ27PddpzUhdc384R+P7O65Hn1vGweQmyZXzhpkhpjZh3RRsDCmuaWCqxc3Ppwb9V1YZznDFUlTgKFQCjFOPRCIvlCp7r7vwLLoqyNbWpygqFYzuQbwWbMWvno19qrui2tBejPeLmKCW9yYHeOoxS+L6HoujmQJ0XJcLwfg+Ap2gq7a7jQEi5Vx620hpK/xjzIqRszVuaDmNj8LWJvJhSal2hiS3WdSmd6wIhJMqqaqO9GvWD73mYL5c75/ICD3dHGnZ9fprCqRASQkpMRnH9s3WxWq9bV+LGV2K1XiOOIhRlCd/zfvj5/1yEHXgdEELg1jP4RVnBcx04nEEpjWzHqKlt0LWhljEGLqWtSR5jFEmaWVf3Ayt+PM/FX377hK+XVzuPZ27CfLkC52zw3hl4teR5gVVyvwrypalOq0ps1P23+ybpdN3atxB5OpsiDAOs1muEPUT/lbUh867JdqweLbVFVwF/j+Lvo7cZrRRo7dKdJOlRXBbDwK+NaBy4jrOzEiAvSoziCFVlY/OkL4HaVXXgdTKKI9zMFzv9XYdznM5mL6oK+9IIvG4KAJ7rQggJrfTe3TGndgRXynbv86LsRPqrjQG2fB1KiM1hJgSB7x3Npb8pkDQX/iwves8N75qfCwvNOIrnutBaI81yUEoxX6zayn2WFw8Whjz3exa2Nd3iYIz2IiccOCy0NqsC7DnC96xTelmJ3rrgDc3aUwkBKSUcx3bPAt9DkmYIfG+vUaNdYJTi0/t3uL6d77y/bsLVzRxVJfD+4mXGoQ0MPIbnuaDp/RdhztlRNGE3QWsNpZ9ODGm6/pyzzgoAy3WCOIpwczvf6e+HgY/VOoGQApPxuJef97Yjpj9jzZztCACn+8VRP14AqN9knhcg5Hi6xbPJGF8vr+B7ns2933HTbbwE4ijEcr0eJGavnLOTGRhjuL6db31BuTg7HS7/PaJq07wuaNYDA+vW34U8ljE7a3vXR6KqxEYGN3t93XrOyypYyMEP9z+jtLYbpBDI8gKM0b06+sfO3b3l5zXjMVVI8/fsSII96KyTDPPFqnXn1sYgCgMURYnJaISsKCCEqOO3PHie+yIOfG+ZwLfKEKmsGZPvuRBSdlYofAxtDIQQKGvDzzgK24Sf51gnzk5mkFJ26uXyM8t1gqKs8NunD8NnY+BV8ajS0ABSSLAjH19r/JAq8bhismlmeK7T6VpVliUcZ3evrzAIbIOZO9Cq+4JLa8q+Y4Ok8UnwXLeNdd6HJ3/yTeRMWG90x8L7i3Ms18leyQANN/MFKKXtIcxGPxz3B21gN2aTMcajGH/7+x8bewLEYbh1/OTAdvRxmHMdB/PlEkHgd/b6jWEgYBdhm1tt158m7maXg39j6gJYSa/rdLsx7ktZVri+ne8cq/NWKavqhyKC57rIiwJFaQ9AaZrB9z0kWdZ6OMyXK7iuvcitk7R+FhjiKEQcRkMh8ghpDmRlJRD4Hhi1hTF9x7+jD7QxoLU5KGDNfAkh7WjKoXl/cQ7Pc3F9u+hNBVRWFf79P37Hnz9+GM5pA6+CxtNDPHBx1jAv4lmvKvFkrj0hNs6U7tm9/hmlNWaTCW7mu3X/G/+h2WQMpXQv+2xZVaCU7uxH5rkuQOx+0oVqgvzX//bfH92ZHM7r2BkXnudieiQqgIYkzWCMwR/fLvd+rTgMUVQVzk9mGNfRNwOvlz++XlpDxLJsY9t+PrSEgY/fPn54MfKrl0ySZvj89Vtnr2fXLsdmWG9hBrgPzbNEiI3jM8ZAaf3gBYASgqBO7TDm++W/KTgd2uEbsJf9rMhbKf9r7vA/B405oZDyFy+bn//73ed2NplAKYVRHOHLtyuM4ghJmuJ0NgPwskyi3gplaQtAuxYGN4XWh2opJVzXqVML2LNdGpTWuJ0voVR/igBKKT5cnB9sbR8Y6IskzZAXxYPO9e8vzts4zmPEGAOpFLIsf9LHiNdqSs91Oj3flJVNfrreUf7frCMXp1YJ3lcBoNn7t6UZRQ3DoDPTRH55ffOo9F1ICc4YirI8ygqU57r4/PUbpuMRFqv1Xq/VmHNd386tdPMIv9+B7nh3cQYpJJI0Q5pnCHwfVSXaLiclFNPxGMCQl3sI4ihEHIVI0v27zM1iGUUhkjQ92CHxvq6b1hpaaxh8j/Cy0n5qC0uMghP2gyngIS/+QkgsVmssVqsXN7v/ErlbUPl5fM3KD+3Bg3EGrW0ShNYaq/XazjgmITzXtbPoYQiprP/CbDKx3hd3xmmGosDzwhjFeBQjy4te/QHuGgQWZYVxHNVmhSUczg9eSGSUYhxHuLy57S0mUGuNz1+/Hf3laGDgKTzXfdAAEDj+CMAmUeypy38z0ug63a9Jt/PlXkVWrTRGo7i3PbMoSxAQyB0u/6SOl3YdmyDVlXKC/S//6//2198+fXj0D8m669DIDo7pYWSMIgpDBL4Pz/P2ujwopay7NqXIigKOM0S+vWYoITAwWCUpPNfF+ekJsjxHGPjgnGEyHh2N78VbQSm1czbqXbTWCAK/NqTRzxpjSprMVmq7+47DwTmzJi7M/vPu5b9vhJBYJWtc384xX6ywXK2RZtnBcs0HHqcpGEmp2vg3XReK7LNiD1yrdYIs/67UMAZI0hSrJLHF7Dq6zhiDb1fX1kvC4RBCtgaFA/1ytxDDGAXM7vOf28AYRVUJBL7/bOo1zpn9ugZttGofJGkGKSXiKHr6Dw8MHCGMUSzX6wdHAJoI6mOkrCqkeYGnPt28vvA3qvIuzztNhOL1fL7TOhMGPiijuDg96W1/bGKdpdp+/fc9a0bMOIOp0/m6YOPbbZOnvFiu28z5Y6G5pOfzHGezGa53nAEB7OZcaY1p4CPNsvZhHXidOJzj3fkpqqpCXhTwPWu+RQkdFCDPAKXdVoV9z3uWWdhjJEkzJGnays9cx0GF3cxyBg7PQ6MYlNL6gKDq4hJv5aRNRNBkPGoL91rrVikwrHGHw2hr+ljVBpp9UpYVOOeohGg9S7qaG90Gz3XhTDniKMTXq+veih/LdYLxaDREcA68WB66/HPOj3LMRWtdx/0+rWxqTIyNAVzX6Xwdmi+WeymNGGVt0kIv0v+yAmV0o2jEn2nGST3P+sw063kXbPSdeq4LbTQ8z0OW79+d64vZZIJVkmA2GWO+XO31WovVGg7nOJlN2+LHwOvExij5KMsKeVFiOhk/91t6s/TRqcry/Cg30L5p1i2ltXW0ZRRxFCEIfCRphvli2Xts2UD/aK3tnPVPE3CNkskYgFLSdv+/XF4BAGbTCTzPxbJOdXAcB3EUDuNOPeHVXRyHc4zjCFlePOoPsg9Ka2ghwDVDWVYIAx+MMVRCHDRTvDk3eZ4LQgi+XF71VgT4/PUbZpMxzk5mvbz+wEAfND5mDxnDRUdY1JJKoSjLB4sWDYQQuI5TKxzvH5Hsgtl0gt8/f9np7zqcAwQ4PZlhvlj2sn5oY0BqP6htYZR2avx3l41utWVVWbm0sZ2EvCiOTgUA2E1mSsdYrFY4nU33zqQVUuI/fv+MKLIzl6M4Gg5HrxQhJUAwHB6ekWYevktW6wTTydsc40izDJxzeN53Y7n5ctmp0eLA8ZLlxS+dZs91EQY+wiBo/7c4CnF9OwdVClJI3KwTnJ5MwSiFEBJSyaPc718izUhAcxE3sDP7fRQBjLExqK7joBIC3JjWYPQ5zEXjKMSfP37A3/740ksRwOEcN/MFpJR4f3He+esPDPQBpRSX1zcP/v8OPy7pf16UqGpj06dwOG9VaF06/t9lvlzWCSy7NTOiMLAxz5Ri1MMYkTWFtv5P28Lq8VDf86Ckgut1+yxs3Na2v7zvkTNHWJQCYCvO4zi2GcqM4vL6dq/XE1JisVzh/cU5tNJI0mwwnHmFHJOvxVtFK93pRcPhvN6Anm8O9jlQ2q5TaZYjDH1cXt/snIs78LpoYgkbhVzcFLejCJ7nYrVeY75cIstzfHr/Do7DkRUFKKlQCYFRPMxZd0FzKS+LCoHvoaoEZE9Rs5UQYJS2hpLPWcwRUuL9+Vkv4wDNBWC5th4Yp7PZMBIwcNQIIZFm+aOX12OZ/TfGIM3yjc4SVlXrQevuDOseIvSDVtW2LZRSKKUxHY+tj0API3G2scWQF+VO78/6Acle1BMb33qkUnAdB2mWt3LCY+0KfP8lEkRh0Imp2NfLK5zNZsiKfJBJDgz0gFQS2nR3KFRagxKKoiyt++wrmncuywpFVUFrBaU0RlGEoqowGcVYLtfIihxpliOpfUzCwIdSGq7roKg3IlWbzQ28XawvRPaLWk5IidvFAu/OzxBHIeaLJQghKMsKnue2ygLPc4e9cEdcx4HrOMiLEoQQeK7zZIb2riit245dmuUIfA9Ka3DGDuoL0KS8/OnDO/z9y7fe1h/7fM7B6OngczFwtNwul3AfGS9ulMfPjVIKRVk9efmnhMD3PRht4Bxg1Ojb1bXdl3bs/s8mY0gp4XnuTvL8TSj3UHhRSuBw28zuYwRgq53bcTiEFNDG9LZRdQmtsxKnk3EnVajb5RKMMfz++QvKDYwvBgYGtqPLA2Gz8NLahf+lIoTEOknx9eoat4slFstVnWwQIw4jMMaQ5hlgDJbrBKNRhD99eI///M//iP/8z/+Id+dn8Fw7g2uMsXKy4fI/8Ahaa1RC4PL6Bqu1Nf5dJymA72aSv//x5Ye98Kl50IH7CXwPYeCDEGp9G3qS5zcjAYxSrJIUtD5MKqUOmgASRza16c8fP/S6Lmd5gb/98WV4LgeOkuU6gVIKq3pdvQ/XcXq7mG6KNfsTT64RnuvC9zxwxg5SdFuuE1BCd/Z745wjSTOczuzYbx+FbDtuRXdSd3HGoOrEAM67TU1ov8Y2f3i5TuC5DpTSiO7MEB4rk1EM33WxWK1wMp3g+nb3dADASorXSYpxHGO+XA5zZgMDHUKJXSi7yo2mlMJ1HTDGIOTLNPJcJSlMHWV4Op1Ca411mqJKUyRpCsfhCP3glw1XCAkh7X+yPAcM2g7uMA4wsAk/ewgwxrBOUyRphrKyxnKe62K+XCIIAptBPy9wfnY6qAK2hNaS2bKqwDmD6zgoq6qXw39elnA4R5YXYIwh8D1IpQ4+Bud5bq+eAIC9vPz7337H+4vzYXRz4KjIsry9UzxEG6X5TBhj7sTX3X+JbeT+OGBEvBASUkpUcvdGtO+5kFJBqv7OhkJKaL1bcZVzDocz8B5/pvy3T++3+gtKaTiOgyTNwDk72jGABs9z4dfvcTIaYbleP/E3HqaRmaySBGHgI8kyFEUJx3GGzWVgYE8opRBl2dlhsKwq/MNvn1CWVaejBYdCaQ3PcZAVee30vkYYBJhNJ+2hIC+sk3hT3MyL75e2xn13E3lcMytbFBVmU5uCIesCQkOTKtAUF+5Cqe1eCiFRVhU81603v+8/99lkXBckbG590/277/ftcD6oFI4MpRRu5ov29yaExHg0AqO0NZacjGJc3dxiMoqP/mxwjHiujXrKixK+70EpjaLcfnb0KRolAOcMWmsYbdrRgEOqpYqqwmwy3tuw+Skur28Q+v6LLAIPvD6W6wRB4CNNswf/DKUU3jNHGCutkefFvZd/RikYY3AcDsbYwdYNIex4mu95SB75+T1Gc6n+y58+9hbJaoyB1hpqh+6/Pbv1Z5zYQP7rf/vvO5UnojCA73kvxjV9uU6QJCl8z8XtcrX3wZJSCkYpTmdThEEwbCwDA3uSFwUosZeJLrrUruPA9zxEYYDghR3+fo4ebYz9OGNYJwmkUjDatJ1/U0fMjOMYRVmiKEtwxqCNQZrmvxRAAt+HqU1dHc7vrTL73o+XgWbNpJSCEMB13V9GoZqZ8Lubahj4v2yyZVW28ra7hYbxaARCCIrC/vnmotL8e/vzUHqIMHxm7lPqNKaCeVHAc12cnsza399ynSD0feiezJZeI5UQvSp3Gu8Bx3HA65hApye56UPkRYEv3656VyZ5rouzk9mbjIQdOC7++HYJY8yjF9jJKH5WlbEQAmle/CL9p4SAc94qlQ65VjT8f//jP+BwvvMZYDoZo6oqvD8/7+1cmOWFPctsWcB1uC2oeK5zvAUA3/NACMGHd+ftZfjYSdIMRVnCc93OXGgdzvHbpw+4ur7F+enJi7pkDAwcE81m+OXbVScde0op/uFPn9pu87F/NhuDtbuX/0YCrJWV/jeHc2sKA2R5/sPFvMFGzxBwziClgjYGURAgjsL2NZ9as+8tQiQpQMhBFE+N0kAq1c5FNyqDu+9rsVrD3HlelNK/qBf6qvIP3M8oigDyfYbVaI33F+dI0gzz5RKUUry/OH8R54bnpDl8m9p3qQ81ACEEge9BCAnGKALftwoEzz3I4V5pjaqqejUFBL6riv7hT5+Ofi8YeL0IIdtknocusJRS/NNffnu29THLC1Tix7l/Sik4o7U0nT+br9Ll9Q20MViudlNzB76PsxObENJXOlTzc1sn6cZjXIQQ25BxnNr8r/+f8V4FgOlkBCkVTmfTrt9X75RlhS+XV510keIobA22srzAf/rHv3TwDgcG3hbz5RIA9o7ubDidTTGKIny5vMI//Papk9fs0iTbhgAAIABJREFUkywvHnVVL8sK3LHGNQ7nYJT+0El9S1GHP1OWdl7a4fyHw30zkkApRZLaWcuyqqCUbkcUHM4hpOzMe2LgVzhj+PDuop0RTbIUDnfabuznr99wcXo6XMweQWsNISTysuzFtM9zXbi1nNcYA2MMWE+GhPdRllVn6q+HOJlOsEpS/PNffuvtawwMPITSGt+urp/s/oe+j9OTw8dYGmOsKWE9+28LgAaMMvi+d/DUkJ9ZrhOUZYnlOtl5r56ORziZTluPlT6aGVIpaKWR5psn0DXjX6QunPc5+9+wcwGgkX6MRzE810UUHr8p4H18vbzCcp3s/Tqu42AyHoESgkoIXJyddvDuBgbeDs0ce1fzoJ7r4mQ2hRQSJ7NJJ6/ZBz93tAf6QWkNXY8d/KxsqKoKRVlCCFmbo1EUZTUUBDqGUopRXTCXUtk9k1JIKV/cmM6habwBmmaDEKKN9usCUo8DEYJagmp9PA556M+LAn/7/KW316eEgDKG2WSMyXj0ZgumA8+DEBLz5RJplqMS9xvYccbw7uIMcXjYUZWysvudVApKKhBK6440b1OEnpvf//gKz3V2dv6/ODuBMfa+5rlub/tNWVWoKrGx+z+rmw9B4LdJTYeAT0bxThfg5uG9uV3URnvei1tM7cHbQRSGSLPdzCQaKiFwdXMLzhim4zE+f/2GwPOP+uIxMHBMaK0RdpguIqTEt6vroyjGNfPPjYme43DMl6t24R+N4he3fr402AOjatbF2L/XtC7LC5RVidAPIKQ9vA3jBLtjzSy/nzcm4xGUUhjX55B8niOOolbq3hQIhs+GvaCHgQ8pJQwAxmirfOkCYwwqIep4QII0s+NFvu/BGAP3ALnenHHMJuOdD/hPoY0BJwRVJXB9c4t352e9fJ2BgZ8pywrrNIUQ8sHLP2C7x4c2UC3KElUl2nXFcRw4nMN1+//Mb4rSGtPxCF+vrnf6+w7nUErj7GSG+XLZmxeIMQZGm62i/wghGMURpFQHWWcbuDbAKI4ejaJ4DG00KlHh6vrmxcXiOQ7H7WKJs5MpTqYTfP66/wwaIQRFZQ8vrmfTEowxGMVRF295YOBVYh2o/Vam3QXvL87g8v6NVB4iywvkRYHpZAzX4UizDJ7noqwEIgSYTcbP8r4GNicM/FaGyR2OOArbFIOiLKGUQlVHEkmlWr+JQTmwGU16gHNjRzcYZbi8voHSus2Jv7q+GaIF78A5h6xHVjzPhdamU28AXRcCeD0KAOBg8V6Ow3Fxdoqyqnp1516u13A4x3y5xGwyNGkG+kcqhaKsnhw79j0PWh1unE8I26nmnMP33HaU7phI0gxCCqySdOe9NYpC9DA59QtlVaHYcrS8XWedw3orkP/x969mtU6QF+Ve8/DjOMaHdy+rANBgZ48JpJRIs7wTX4DJKAavTRzsjKnAyfTleSUcO0opKK2hlAYlBNoYeK41nnrueaWBzVksV4jCEP/+t987eT1KCKaTMXzfQ1lWz5JWMkj73xZCWE+Bux3ZsipRlvYy07fL+WvB4dx2nbWBgT0czSZjUEpxeX0zOLnfoUkH8DwXeV50pgYAbDOjMd90XQfGmIOaf/37f/ze22emKdJ9uDhHluc4nc2GtXqgN5TWWNVJZFnxcGGL1sliJ9PDFKWKsgQBsaZzB+w8b0uWF1gnCRY7Gv+dzWZ2rK+qMI7jXr0VHhvveIgw8MEZO6jnCgCQz5e35na+sK7JtcHMLoyiCGHgv1gpa2POMY5jrJJkZ0XEXTzXhe+5iOPIbs5KIY6i4fDSAUopCCFRVNW9MSWEEHie+ywfqoHtEVK2JlBd4Lku4iiEwzniOHqRa9LA60JpjbL2FcjyvB4vGKIMH8PhtiNsYzBTxFF0kASKl4RSCnlRIvA95EXZ6aWZUfpDEd2rkwEOUVzP8qITVeZjNPtEmuV4f342xFMO9EKWF1inKVZPmNeNoggf318c5D01KqLnUkhuyrera4RBgD++Xe7095s0KACgjCLPi97uYJUQSLPNjf8A6/kQBn57TzGt+WL/kK/XCwNYA66irGon++2+gYYoCOD73rN027pACAmQ747SXy+v9n5NSiniMICuZ+g4Z4PkrANW62SrbgdnrM4vJ3Cd+3PPB56P5WqN+XLV6YWIUoqLs9PhwjBw1KyTtM0LLqvq0cz3JrHgLXJxdoLxaITVeo2yrHA6m4Eyivliidl08uaLfNYksADnHNk9+d374NRjB6zeRwPfO8jFIS8KXN/Oe/fd8Fx78f9wcT4UAQY6Q2mNvChQlQJpnj36HAe+j3dnp8PzdwelNeaLJdI8R1Hs1pw+mU7gui581+09DnqX7r/nuvBc51kalW0BAEB7AHcdB1c320dxxWEIbQwYo/j47jBVrD4QQiIrClSVwGK16qQC3WwwcRRiFEXgDn/zB5ZduC+fdFsaZ1PHcUAJGRQCz8wqSeE5Dv7n3z93Nj/96f07LNfr9t8HBl4CP4wPlBWyPH+yKPDWCHy/7UA7DocxQBQGB4/MOkaUUpBKgdRGd10+M67jQGttTarqqCpVzw73RdOIeSwybV8810VZVZiMRyjLalACDHSGkBJfvl2BMfrkMxwGPj6+fzfcC+5wfTtHJcTOimzPtbHK79+dY7laIwz62ye01kjSbOvGpOe5BzX+u8sPBQClNbIsR5bnbab9thuI61jTrfcXZ+2l9yUihARlFLfzBYqy7KwCHQY+GGU4nU3heS6SNANjtHX9LMtq2HzuwRhjDVTKEvv2NZoFtpHZMEbhe4fpaAz8SJJm0MZguVrvrDx6iHdnp4jqMYCBgZdKWVbgDkdVVTDmu6/AJoZSr5FGBeFwjtNabZjnORzuoKhKaK1xOjt8hvYxUQkBh3NUlUBelp2qAQD7O2CMglHWu1N4WVb42x9fehsFaHyabAqND6X1UDQe2BshJNZpijTNHp37B+zn6S+/fRou/3dI0gye6+J//v3zTp/9JnI2jqLWu6TP7n+W55BSbVUAcDh/1pFwfnO7wOmJNadjlGIUR/A9D7fLJVzXBWNsK4fZSgj4noflao0g8DGKXqb7ffOgcM4w8ycYj0adjARkeQHPdbFcrzGjk18kncPl/2G01gAh2NfKUxtj52zq/+44HGUlwJmdhxoUAYdFStnp5T8M/O+PyAFcXwcG+qTZEzirLyl+gLKsMBnHiMMI4s7nJy+KVx9T2OyXQkpcXt+0FzdCKc5mM5sccHsLz3Pf7IG66c6D2PWw65EAISWMYZBQoJT0qgLwPBd//vgBf/v8Bdp0XwTQWqOsqvaSEIY26eMtF5AG9me+XMIAGznCDylhP5JkmU2Xu73dufAX+H6baND3vcoYA23Mxpd/QgiMMfCf+b7H/sv/+X/99eeZfcYo4jBs/50QbKUEaOKQOOcg5HARMn0Q+D4YZyjKAifTKfI6AmoflFIoyhLz5QqL1RqcMfi+j+VqdfD8z2PHGAOtNbQx0Fptla25CYxSCKlACYH1nB5GAg5FkmZwOMfVze6L/H2EYYAoCDAaxeB8+F0OvA4Yo+CcgXOGOIragoDrOgh8H4Hvw3VchL4Pxmh9SXvdFbDm+2u+19U6AaUEUirMF0tQSjFfLlGWAkVZvqn9lVIKzhjyooTnutBad/Y8NAdYAqscpZS0/3sfcM7qyM39xv+eQmsNqSQ4Yygr8ewH9IGXydXNrV17Fssnn9dRHOF0Oh3OKjXLdYK8Llhua6gH1MaeYYg0z613iVKIwqCHd/odKSUqsfl+63AO1+HPrpJ/9GY+HsU2yopzSKkgpdq4AlsJgcVyBaUUKKEvurPNKG2N+/7pL7/h6+UVluuks9efL1dYrhNMxyOs1gnGg2kZAHu4S9IMvu+hqsTW5hqb0MQFWvm/gVQKMpdwXbeNQBroB891MV8uO59t5oxhOhl3+poDA8fGfXLGMPCRaA1KKSajGKM4QiUk8jwH59b3RAiB5WrdeTH1udFaQ0iJq5s5AMD3PSxWa/z50wfMlyskaQrGWCu5fCvqgDgKUZbW20kbjbLafx9tDrqq/ichBFIpMGN6K6BfnJ2CUYbb5bKXcYDm+QFsBzLw/SHKdWBr0ixHmuUbnWuasVPK3sZa9BRlWaEoCvieh8sdfOiAZly4xPnpCQiAyXjU7Zu8ByHlxmsSJQScs2eb+78L+5d//bdfFAA//IF6PtpzXRhY6XSTzfsU2hhUVYVKSttJfyUPeVkJaG0AQjrbiKyDb9lKPF/Lz2ofSB3nJ6W0HYdmBKBjtLEXf0ppm3estf4lAmmgG5q89Jv5fOdc14c4P50hDiOkeT50bwbeJK7rIApDRKH1v/A9F57rgRCCwPPAGMO781OcncwgpXw1PgI/78VaGwghkKQZAs/D2ekJKiFwfXsLY+zPSVTiTXTeOGcwsGsvY6zTLroxBpWQbTygMaY3P50w8FsFZR8YY1ojRc4owiAAiD20Dww8hRASy/UaeV5u1Cz9+O4Cp7Pp8HzVfLu+BkAw38N8nXOOyTjGeBSjErL3c2ATSb7J+yVAq9g7hrvFkwWABsfhGEURQt+HVAqjKIIQAvqJjcQAUFKhkgJRGL6KB93zXORFgel4DNdxkO8YT/EQN/MFyqqCVhp5afN93yJKKTBK4TgOXMfZ2mBj66+nNYQQtRO9nekZigDdkuUFfM9FkmW4mS86fW1KKaJ6dEkp+abkvgMDj8GYLW42owGUUVBC4LkeJqMRTqZTxFEEArya0QFjTCuxXK6TttgYhQHiMEKW58iLAqt1As/1Xn3RnVEKz3WhtN1XXe50qgJRdRG9KEq4rtPbvhmFIRzH6TUZgNRdOsrs6AEBefXPx8D+LFZ2rHeTy3/o+xjHw5jiXTzHxWK1htxBFUophe+6CMMAYRDAdRwwSnv/3BpjbAHgiT2TEALf91qj/GOAbmt04nkuPr67wCiKEIUhRnH05KVeG400y/H5y7deL3CHglEbc+i7LsZxjDgM4XvdXNJbCVqa4dv1DZardX0xfTsRUEJKCCHaTkWSZlgn6UEOpbZLIqBqHwtjzKvpkD03zTjRYrXuxFDzZ/788QPKujMUh4OpzsDAfdgkGnsAcRwO7nBQRlFWJTjneHd2ig8X5zidTTEZxQ/OKT73/OImlNWPSQnGGCxXCb5eXbeRo0JamfdrN09ssGpMBkIJwo6LpEVZgdKnI8/2ZTKKMetxzKvp5iml8PnLN+TF9olYA2+Ly+sbXN/ON+oEU0oRR9GLHo3ug5vFYufztsM5dK2k5syO7RxifKcSYqNCauDZy/8xeYz9EAO4C0prSCmxWicoivLBuAtK7IEjjkN8uDjf50seJX98u2yjE/uYT5uMYoxHdpblLbgbG2OQ5jniMIRSCmUlNlKcdEXT+fc8F0YbcM6O6oP70liuE2htpVLz5arz1w98D6ezGThj4A5/9Z+PgYG+KOtLnONwrJMUruP8cFBN0gyX1zcv8kJ0t/OitUYc2eL9OI6tWWBV4XQ2g8P5m5j9XicpPM9FWVadqAEoIdC18qLpvDXu+n3w+x9fei3cUEoxjiOAEMRhCCElpgeYKR54GSitUVUVkjTD7WK50d+h1I5Vf3x/MZxTYNMS4jBCVhQ7N4ZGkR37DH0fJ7MJODvM+q2UQpYXT66dlFKEgX90hvh7FwB+ZrleoyhKrJMUjuMg8D2kWQ6ldTsjdnYy692V8dCUZQVtbPLBze28U5PAuzQP0sXpKSijb2IBabrwVSUOqiCxZh027xjGmkoNbM/tYgmlFJRSvXwumg01CgMwxuC77lBZHxjoAKU1kjRDXscM2v0nQBD4kEIiK3IsV8mLVEk1TvYN7y/OEfo+kiyFUhpaa5yezF79Hqu1Rl6UMDCdKQ0pIaCUIvA9aGN6M7xSWuM/fv/cazGqyepuDCQ5HwrMA5bbxRJ5UWyleAl8HyfTybPmvx8LZVnhy+UVRnGE28Vu5p7NOgMQKKXwlz997P6NPkCa5ZDycfk/Z7Z56Dq817jUXei8ANBQlhUqIeA6DrjD7azdKoExtpt6dnryahfRvCiwWK6tkRyjvVx6rIyT4d3F2av9Of5MMxoghNzYiHJfOGO150XY60HmtXIzX4Azhpv5ordD2iiOUBQlLs5Oh011YKBnsrxAlueYTW0yjlb20JYVBfI876343TeUUlycncJojVWSggAIAh+z6eTV77GVEFBKw61VH13trIHnwcBAShvF1YcSIMsL/P7Hl85f9y6e6+K3Tx8AAFLIocA8gG9X18jyYqt0Ks454jDAu/OzHt/Zy+FmvsB4FOP3z1/2Oh++Pz9DXhQ4nVk/u0N0/5vC6WO/f1IXQkdReJReYr0VAN4yZVlhlSQQQuJ0NsXX62sUHRsFNoSBD844PM+B7/nY1tPhJdL4Ahwqxir0fShtDY481z3KD/IxkqQZyqraubK7CRdnJ8jzErPpGELIIUJzYODAJGkGIQWkVPBcF1EU2v9NCEgpIaREUVa9rQFdEkchtNbI8gKe6+J0NsUqSeC5LmbTCfK8eNVFRiGl7Whp00nsLiEEvueCEms+6XtuL6N0l9c3vYyW3YVSirOTKa5vF/jzxw9DEeCNorTGt8tr5MXT0u+7UEoR+j4+fXjX47t7OdwuliCEIMtyJNnuniFh4NvUmyA46GdSKoWsVrc/hFfHiTNGj3KEeCgAHIAv365s/m5Z9SpVm4xi+J4H13VfdSGgcd0EsRKcviGEwHWsqzGrZ2OHIsDjNCMxXy+vOzlI3sdkFMPhHGEYgBI6zP4PDBwJjRlWGASI64LAfLmEUhplVcHhvN0LGzO+Y4RSin/6y2/QSuPr1TVOZ1N4noskSQ+SL/0cFGUJQgiU0qiE6ERp1+yblNJePAGyvMBqve5dfWLNrwNMxiN8vbzC+dnpsOe8IYSQ+OPb5U4xlBdnJ5hNJj28q5fH3dGyXT+znuvC4RxnJ7NnKcYlWfboyBSvjVab6N1jZCgAHIiyrOB5Lq5v55gvd8+43ARKKGbTMSaj0as3MqqE6MzA6DFoHSdCCYHveUcT43GMZHkBz3Pxx9dvvRk0TUYx8qLE+ekJlNYIff/VP+sDAy8NIWT7uWz+XQiJz1+/vTjfAN/34HseWO2D0BTZ736Pr4W8KKG1BucMZVnt7b1DCYHjOAAMGLXpPn146vRtCgjYjuNvHz/g89dv8FwXo8HN/dWzrKP9Fsv1Tg0N3/NwOpu+avXQppSlXffTPMPVzXyn16DU+nJRRjEZx5hNDjumZYzBap08OvvfGMkec1rOUAA4IEJILNdrVEKi+imeqC88120/IK+VsqrapIA+aMyiPNfO/zPGjvpD/Vw0zzdjbOM4nF2wl30Hvuci8P3h8DUw8IJouiZlZS+Wfr2W/u2PL0erBADseACjFErrVsEwimMURYGLs9Pnfnudo+qiOiHkyVnXTSCEwHddMM5QVQKcs07VAEpb48bPX/ovLk1GMd5fnGO5TkAJwSgeYmdfK3lR4NvVDRzOd5Kqx1GIOIowGcYT22JikqZ7jew0SqJxbOPoD30GLMvqwcQ7AHAdB8YYhIF/1M3CoQDwDCzXCYQQGEURrufz3jNzAVuN+vT+3au9LAkpkWZ5r8aABNbBVSiJOBwquXcRQuJ2uYTvuvh6dd3563POIaWE73k4O5mhrCpEQTDI/gcGXhFJmmGVJEiz/CiLAQ7nmE3H0MogyTJwbqWdTQcqL0uM4ujVrUlSSkipUFTVXnusHafjUErb+VjOOj8gCyHxP//++WDPz+lsirOTGZar9asdC3mLJGmGL5dX8BwHpRA7PU8O5xiPYpydzHp4hy8LIawfTJ4XuJ7v1vkHvv9MATzLz7XxiHlonJtRO+9PKUHgH/co9uvSrb0QmkqgEBKf3r87yPya0hqrJAEvOIwxBzfM6BvOGELfR5r35wlgYAsNhBCUVTWoAGqUtvOxs+kYX77tluP6GJ7rQgiJKAzgOi6SNAUh5FU9vwMDbxmlNaSQUFoj8H3MJmNUQiJJ04MUyDdFSInL61tQSjGbjFFWFYSQSLMMlRAIfB9a6VfnFF+UFQghiMIARVHuPHJnI30FOGMQUtqIXdgCQxORZYzZy2PHcTj+/PED/nYnGaCvYsBdBQOl9FWOg7xF5sslLq9vAQD5DvP+gFWK+r43XP5rhJRglOJ2udzrdU5PZhBCPNvPVSn14OWfEALH4eCMHV3k330MCoAjoiwrXN3etvN3fRD4PrTWUFrjn//yWy9f4zmxjtT9GS1SQsC5/YAzzsCP1NzjkHy9vILvebjqUfYf+D4+XJzj69U1Lk5PXtXhemBg4EeEkJgvl3AcjtAPUFQVFqsVjDZH5R1AKQWjFJRSvDs/xXK1BmAVAfPlEkEQvBrprx2zq+A4TieGxg7ncJ3/n713eY0k7ff8vs8l7hF5UUqqqu63X79nDmYMXo3xbMYYjA0Gb2ywF2PwwOCFwX/G+8fMfsCLWQzGcGwwnNVZjRcGH86cPt2tkpT3uD3xXMKLJyJaVSWVLnlRhhQfaLpbqspMKTOe+F2/Xweu63QaSfuiKEtUUuHqev8F6a+ZTSfN70QgDINhOrDn/Pt/+PVFIn93icMQjsPf5GrQSxGi2mnNi1KKKAxwcXYGY8yrxYDfE/9zHQee64Ax1guh8KEAcEKkWQ7Pc6GUwnpz2ImA6XgESinqusbF7Oxgz3NslNYwxhzMHcDhHIxRGFP3YsTnkLRBYCUlbuaLvT9+qw4+GY8QBQG2aYZREoMzNhQABgbeAXbXssB0PMZitcZ4lNhpuU16UoWAlnESI44iBIGdBBBVhfV2+2Z2gNvufFsM2FV3hxAC1DWCZleWErIXxWxtfnddOkYRIPB9uK6D2WSCvCzBKB0E33rGar3BNsuRF8XOziT/+C//Yo+vrN/czBeo6xp5Ue50ZnuuawsAr5iv1HWNVVPk/Zp2valPIuHk3/2/f1cHwfvwj+8TaZbDc11c38538sh8Cr7nIfA9TMfjNzG+ZoyBlAqFEAfRBLDjPQx1DQS+14tK377JixJaa9R1jd8OFGCFgY/Z1O77V1JiFEdwXffN7dcODAw8Ttt1cRwOISpwh1vNgO222y89BdqxcG0MpuMRziZjrLcphBAYJ8mbKF62Z7+pa5Sl2NklALC/N8+z1l774nZhd43ny9XeHvMhxkncNW1ap4CB06coS2htcDNf7Cx0eTYZo67rofPfcDNfQhuNbZq9WENBG4MoDPDh4vzVV6u2afbg+lM7zbTP8+vQsH/+L/7lnzfbdNhTOTFc1wFjFDXsOJGp64MFOEprlEIgywvkRWHtK3r0If4aQgiUVnBdB0rt3x6QUvu+cGaLAO0e43thsVojLwqIqtp7YEUpBWcMSRSCMwalNKSUmI5G8H0P9B0WWwYGBuw52561dV2DUALXdRB4Pi5mZwiDwKpMH9gS9jGMMajrGnVdI8tzZHkBz3MxGY+w3m4hqgqc8V7fNyilIITAaIMg8KG12Xn9q65roG6Cfq330kWTSoMQe68+9MSIVAp1XeMf/fEn5GUJz3GxzdJ3PSV46ixWa1SVxM1iubOVdJsADsn/72htk3/1wtzFGIMw8CGlgus4r9qoVko9OPHUrjM5nPeqIUj+6q//pgaGkZVTRhsDRim2aYaiLHeyz3gKruPA81xEYYjQ90EZ7V3Xta5rlEKAc94Fhd/z7HwOhJDO45OAvImpiafyuVH4F5VE8R0blJcQBj6iMMRmmyLwPdR1Ddd1MB6Nevf5GxgYOA6t73sbHK63KdIs677+mm4ClFJ4rgtKCThjiCNrF6ebIsHkjajGK6VQ7kEXAGjsAj23E9ndNaCWUsEYg+V6fdC1ypa74sCz6WSwCDxBhKhAKd2rW8R0PBqS/4b1NkVZlihFtZOewjiJIZXC5Wz26o5Ptun1bQGAEIIo8EEafbA+0a9X+05pP/Su40BphQ/nM2zvBDj7ppISlZQoSwERhTDGYDad9irRJcTu5xdlCc4YojBAmuU7V3kBaweotIbrOu+qI73epuCcIy+KvSf/gA3UylIgCgP4vgff9Xr1mRsYGDg+X3eFxklsA0epkJcliqLANsvhcH503QBjDIqyBKUUYeBj2ShgT0YjlFWF3z7f4Gwy7v1aQNutj8IAeVHutHpni/dVs1Pr7Pza2nvIbGqnXA9dBGg/Y3EUYrFeIwyDoYD9irQNtJblegOHc1zfzveW/P/pDz/2/hreJ0VZQiv94uS/nUCOowiM0Vf/3QpRoXpA+M9zHZBmcrVvDNF1j/A8t7sQAt/HfLlCJeXBghqpVHdYel6G0O+fdWDg+900gO97UEqjqqqdpgFMXcPlHFIq+J67s21RH1hvU1BCsE2zg3zeLs/Puk5NGASg9H1NVgwMDOwXUVWIoxDjJMaoKI8iBvcQxhikTRFCKoW8KHF5foZRHIM7HIvVCoHv93ZcvFXoBmzwbozZqdhe1zWKUqAsBRzH2YvWTlYUCIPgKFMAgNVxOpuMkWY5xkmMvCi7ycGB49IWAaRUWK7We1unpZTi8nzWu7j4UKRZ3gmg7qJd5jgcge+fjJCmajRPvoZSCsZYbwt8wwpAz8mLEmmWAbBJ2iHHHVvvY0oozqbjgz3PoVDKCkXxJnnfJZF1HceOqDsOCAGcPXQqTpVWSGmbZjuL5NyFUgrfdTuxLBCCuq6RxFFvD9SBgYHTRUrV7eUfWlz3MTzXxafLC9wul5iMRqjrGp7r9j5BrKSE0Qam3o9lI228tcMg2Pmxrm/nYJThdrnc+bGeShj4qCqJv/zTH3F1fQPO+aC5dSRa55D1egupJDYvFKO7j8Dz8OnDZe+v132hjcH17RxKaeTFy1y42oJKHIVYrTeYTSd7fpXPxxiDvCjvLRr5ngvXcfbiXPIaDJ/cnhPecXC4PJ/hZr5AmuV7TdRajDGd6FshysY9wO8q/qdeBeWcg3MOpWyuS6W3AAAgAElEQVTnXmv94i6FMQaEEsC6GL1JhLAif77vYbnevFjI5T4814WoKjDGMDubNodsMezQDQwMHAx7blP8+OkD8mYq4LXcA0RV4fPtHGHgY7XeYNzoAWhjYLRNUvqYXLiOAzhAUYrGEYHsZBdo6hqVVCBEgDG601rA5fkMeVHio3NxtImQtvMvlcJ0MobWr6dJ8daRUnXXjDYGSRxhvljutTlGKcVsOkEUBL28Pg+FEBU4Y9i8cMKmbQhJKSFEhVF8GrapUircN3tkLcFZb5N/AGD/8//yv/4ZwFCRfCNEYdCp+BNCDhbcVFKiFFVn77FJs64QUEl50gcjpRRVJe0kwEvVSeu6cQGoQRntVJHfCq1ITiUrrLfp3pJ/SilGcYQawGQ8QhSGTSeuxvnZ6/m7DgwMvH04Z/CbQnVelvh0eQHf86C1fpVCgFIKRVki8L1mNaAAJRSB74ExivU27V5v32h3YjnnMLWBMbtVypXWMNqAcQZCyIvvt04jJuY6zlHcAYDfu4iUUCxWa0zGI/zdz79gMh4d/LnfE2mWQSkNbTRqUyMrCsyXq73ZQXPG8OHiHJNRAs77m/jtm9V60zmJvcSFxeEcoziyTk+UYBTHJ+GS0jb6hKhw9xPEGbNi6W4/z2agWYv5p//5f/Xny/PZUAB4Q7iugygMEPpBk5j+rjq8T1qro1JUUFqjKEswzuBwhrwoTzpw4ZxBVBKB5z4o7vEUCOz4P90hIDk11tsUq/UG3OG4Xaz2ZqvlOg6CwO8q6K1A1vnZFNEexjsHBgYGnkp7f2LcFnLbcdNjCwW2z1lJBc4ZlusNpJTwXK8TLjzlgvpDEGKdDxi1BXLO2c5FlrquUVUS2pjdBAIJQAgwShIYY1CKw7/nWtvR6PPpBIUQuDyfgRICKdVJJDt9RUpbRLuez60FtFJWhV4IrLfp3uLeMAgQhQGmk/6tvx4KISoQSpAXBRar9YtixXESQzcTxKUQmI7HJ3U9EOCL86E914JXtCTcB3legCulcD4dkv+3iOP8vmumjcFmu8XtYtUpbO4z0KnrGpWUuL6dw/c91MYK751NxlYo4wR3usPAR14U8D33xQEAofaGwz1vz6/udciLEsYYjJIYv/z2eW+POx2PUAqBJIqQxFFTIPK6sdeBgYGB14BRijiMMF8uoY3BxewMVVVhm+VHtRBshQIppValfD7vHAK0MVBSnfya3UMwSu19kjEYY3a25JVSYbNNEYXBi0ZwGaUIfB+3iyU+XJyDEHJwe+WWxWqNOApx9fkGlZS4mJ0hy3MkSXyScdIp0q7JSKVQCgGpFD6cn+O36xu4ji2a7evaDQMfSRwP2kRfIURlXS6CoFsNfi6tzZ/vufA97yQb0fkdxysCO63wtfNMH9Fag/ztz1f1W/hhBp6GNgZFUXaq+Nc384ONPga+1SdQjfAe5/zkDtFKSlTNfuJLfg+OY9ct+jwK1CJEBSElUNf4vCeLHEop4jCEqCpczM7Ame0CBYF/Up+DgYGBAd0k4ZvtFnEUQUp5tMTwa9oRU0oJwjBE4PXbFrXt3jsOR5YX+7HkJQRJFO60h9vGRL9c7a/g/RRcx4HveSjKEj9+/ICyca0Y7osP06rMzxdLGGPgui6yPEcchagqiTQvoJQCpXTn+IVS2jSwCEZJMrwvd5BSYb3dYpNmkC/UG0viCFEQdOu0SRzt+VXujtYaaZZ3BUvH4Qh9v7M97TO3ixXI1e3qjUqYDTyGNgZpmgGEgFG7m3YIf3cACH0fhBIEno9REp9UICOEtQV8iWepVQC1+4R9PhSEqMAdjs12i+vbxYsfp73xOpwjCgNwzhunBNLYSfa/UDIwMPD2SbMcaZbBaRxfluvNUScCWnzPg+s4UFpjNp0gDHyst2nvk0VRVciL3eMN37N7w7sU4WWzBng9nyPNjucOQSntuomtRaDDnZOxPzsl2uIcgS38lEJgs03h+97e37MkiuA4HKM4HmKWB7hdLF/c+Z+Ox10yXUl5ksk/AGwbTQkCAAQIPP/NfB5uF6vBBeA9wyj9YgRbGwOghpRqL9X5u+RlaVU+PQ+UUaw2W7iOcxK+uJRRiKIEZ+zZP3erg9D3/f/1dotKSmT5y+xbWtoAeZwkUNoGVYQQmLp+MwfnwMDA2yeOQsRRaL3D12tMxyM4joPNdruXxPWplEKgFAKTUYLleo2b+QKzs0mvk3/Axh+h70NUVRN7PB9CSNeBbFcnXoLjcCzXa5xNxhCiOpogZLv2EUchXNcFIWRI/hvatZdtZu2HwyBAltu1nLpG16zaZ/Lvex6mk3Hvp20OzdX1DdYvVPuPwgCiEqhrAyEEZic49g9YgdZWuJQQgsD34bpvye67HiYABr4lzXJs0wx1XUM3qv77tIBzOIfveSCEYJTE8H3v1fcbs7wAIXi2XZHtbtt1hz4WAVqrP1ObnZN/APB9D75rd1Yvzs6wTVO4rjsENQMDA71GKoXVeoO6ruE4DqSUe7UXewp3p6gYY7iYnaFoPKqnPVSUb393u64E/N495ztN4l3fzhH4Pq5ubo8+7REGPkZxjPlyhdnZFFmW44ePl0d9DadAO41RlCV0Yw+stEZVSTBKD1acmU0ncBwHoe8Pyf8DpFmOUogXd/4D3wdjFJwxRGF40nFhUZaQUsHUVnA0fENC1UVZDisAA4+TZjnyokCWF+CcoxRif36qhMJ1HUxGCdbbFKMkxuSVROGklBCVRF3XTw5EWKNsbIxBGAS9WwHQxuC3zzedGv8u8MYPta5rBL6HUZKAEPseD53/gT5ijAEhBFpr6Oa/GaWoAVSV7FTkv7Yka1WnW0Xq9nvtv/t2Tgx8SSuoSylDHIVYrtbYbNOj2gi2FnZxHGI6HneiaKLZI+8bRVnCGCskvAuuwxGFu/38UipQRjFfLF9F/yEKrdp8UQqM4hirzQYfzs/fbFIqGgFmyijSLEPoB6ikxHy5gqiq7rw8VEHGc11cns8QBj6kVG/297wLrU7GJk2xTbMXPUYchQh8v9n7N9DanOxZJZWy1n/NdG8UBr1s8N2HqCrczBe26TkUAAaeQrt/1Qa0681255t1C2cMvuehRo0PF+eQzTTAsUcc7RQAebI7QpsQeJ7bjR725ZDIi7KpcMoXj3LdpR2VdV0H0/EIUmmMTnSva2DgPkRVQSkNSilKIUAI+cZCqr2+26+3Xud3bVYJIaCEdGPNXz8OJQROo4tBiA1stbYFhraowF84yjxwfNIsh8M5yqo6+nrAOIkBAH4zgeZw3t2T+oZSClLpF2nx3IVR+mJ3gJb1ZgunsRmcL5dHe0/vaugkcdScCR6kktayUBuA4MWrDqdCK+bHKMV6s4WoKmR5gSDwIaU8yu+7XRmZTsbddTRwP+0a1EsLYkkU4WJ21v3/qRdZ0iy31oSOA9ftt77X16w3W1zd3AKA1QCYL1aYnU1e9UUNnDaM0i8OScYYRGO/opRGXdcvthVUWiPNbRB1c7uA5zpYb7adBdKx4IyBUoKnOgK20wJ9MwCUUqEsS+RFsfONtj0YGWVQVCMK7S4jJcfrhg0MvJS2uy9E9c3kz33+0V9/7b5pobquoe/8ubt/hxACSim01lYXw3UaH3B79pi6hjEGSusugalNDcboTgnNwOG428Ua//AJ622K6z25qDzGeptam13GMBmPYLQBpRSL5RpJHJ18oH0Xzjm0MfA9b6cigDZ2nc33rXjiSxiPElzfzgEAPzXv6dX1zYtf01NpPzPaGCxWa3iuC60NSiGstXJVIQyCk3NTeoy8KBEGflcUTfO8myblnKEUlXVk2lNT6TEuZlNEQYjleg3/DTg4HQo77ZRitd7s9N44Dgdlp2kH/jWmKeYHO5wfp4y4k+Cwf/4v/uWf19v0JP0XB04X33MRhSGiMASldqeHMwbO2YtHIdvAt5ISlFqV12Oqg3LOUJaiE617Kn4j3tOHKqFUdrzxZr7YudMC2FFUl3Ocn00xiq2PseNwcP42k5WiLCFEBUIIirJEXdeQSiLLcuRlic02RVXZQIYQ0iVvA6dHWQrkZYlKyp19yZ+DqWu0zyaVQg3rL2yMFWDVTfJflgIAsd9vBotEJVGbGpTSNyE++pZozzzfcxGHYXcvOzR1XaMoRSfeu1pvANQYjxKbSC5X8DwPtAefFc4Y2J0C2Uup6xq489dfcm+OwhB1DSxWK0wnY2itX9zkeC51XXfTAEVZAoTAdVxczM6Q5wWyLIfnuZgvlvB9/2TfW20MZCUB2PcjKwosVivUdQ2jDbQxWK23aF/9fUXXffLp8gKsWd1xXAejOH6zscquCFFhvd1im2Y7nWOz6QRRGKIoS/je6bfLlNaoa3TuVW8BbUw3lWjquhPOJH/1139TA8A//su/eNUXOPA2kFJhtbFjQqUQL+4wO44D33NRmxpn0zFc9zgrAaKqIKV6VhGjtbw79cPCTmsoXF3f7nSgt4FJEkVwXQee54IzhsD39/hqXxcpFYSsUFUSURBgvd2Cc46qqgBCms4Fh9EahBBUUjYqsS60tmPkbWdBG/PN54kzBtd1Hhzl1Mb0olreN7TWUFo/+xo/JHdXBGijJ9B2dQmxn5VKSriOg0oqEIKmS1qBMQpKyLAycGLkRdkoXdvizXqTHi15HMUxRFXhpx8/wWjTubH07XxuC6m7XKf2vuTtdH1oYzBfLHF5PsNyvd7JJveltK+fwE6cjJOkKzjPppMv7ARfGyEqO6ng+1BaYbXeIgwDUEKQFQVkUxwHCLL8OJaL7e+nrmv84dPHozxnn7ldLOFwjuv5YqdJpvOzKeIw7NVKUilELwoVz0UbY1ebOMf17RxK66EAMHBYirLEcrVBVhQvOkh8z4PSGr7r4uOHi4MnRe0qQ1E+vTtOCEHceN6fKnlhR/7X23RnRwfOOaLAt+P+jtOrw/0xpFRYb7dgjMJxHFRCglD7ddJUUAPfb8ao6i44JSBwXafzCo/DEHVdw3UdGGPgeR6U0ggCD2Upus904PswtbU1OpUA7i1ijIGo5F6mXl6DVt2cc4aiKOG5LmrUcB0HWV4gCgNUUiHw317g0mfSLO8Kgq7j4Ho+P8p+s7UwjBqbWoPpeHzw5zwEddOt2sUhgFGKURLvPDHTrgoZY/Db9c3RXQJakihCVhQYJzFqAJMkwXq7hdIage93bhCtmOEhYyYhKnCHY7la29eVFxiPE5hGlHK93Xb71L7rQjUF2GP97trE/3w6RVGWiMKwV2sxr4EQFa7nc5TNZ/0lUErx6cMFalPD75GlYntWn3oz7yUIUWG+su4NWlt3jaEAMHBw1tsUjFIIUWG12Tz7Zh4GAeq6hu+5GCfJwRNOISpIrTo7mqcwiqOT3dFNsxxFWWK12e50oPueh8D3OrX/JOrXjun3SLMcdV0jDAOUpcA2TaGbfVrXdVA1yWMlJSihMPXvv8fA9+E6HOtt2nX0awBBU0VmnHWCkXlRdI9LKYHnuqikhOd6EJWwyt5RBEpJ7zp2p4gxptsJJsBRR/0PicP5HRHBGlrrbmoKgF1BaYpSbzGY6RvdKH5jkZpm2VEKAZ7rWnVzpZDEMdabLeIoxKjR8+nDlFFd1yhFtVPxjlHaaTXssqq33qbQWiMKAvz9r7+9ShGgncCjzaoipRR/+sOPuFks7M9W17ZIH1rbssD3UZQlAn83lfu7U2lpliOOQlsQuVPA/vXqGhezM4iqQppl3SqT1S7wu9HjQ0MpRRKFIM101Gw6aJw9havrGxSl2HlC9I8/fPoiTh/cFV4XbQy2aQohKmzSrDu3hgLAwFG5mdub1GqzfVYn2vc8/OGHj7i+mR9cHFAphaLp0j4Fx+EIPO8kCwDaGPzy2+edbP4mowRpXuB8OkElZWfn0mdaMaKyFMjyvLF2q0AJBYgNGHe9ET6E73mdhgDwuxpxGPid8rTrOF23txACpPl7juN0gd3A49R1jaqymiJFKbr3/S3BGYNulMPbooDjOHbP1pjOqeAUz6f3hjYGn29u4ToOfM/D7WJ5lNWAcRKjFBU4t8XbURwDhPTK81xUFYSoXnwNE0IQ+F6nWfTSwpg2BlVVgTOOq5ubo7o+PMQ4ibFtkus//eFHrDYbaK3heR6klKgBREGASlZwHRelEN3nrl1H09pAKYXpeAxRVeCcdwVtYwwoo93/b9MMnDNrlYYalDJIKa2YKSGYL1evsmJlGxUuHG7vk8fUkOo7v/z2GXlR7Fwk/3Bx/mp23gP3s9psIaX8pgk4FAAGXoXPN3Nrt1WWyJ+YnLqOA8dx4LkOzqaTg3Yv0ix/8g2s7bKcGmmWY7Favzj5p42dUuD7dndaKYyS5CR/1udgxW1SBL7XBTLGGJRNcLnrisRLoY3TRiUlsrz45vucMTiO1Q0IfA9JEiNNs25fTWndXCP9COj3jTGmU9hv9+hFVaE2dq3nrXT/H4NR2nSaNRzuQGkNSptkp8abWtnpK3lRYr5cYpQkQF1jk6YHTyTbKa5SCOt77vu9UeZuqe8IWL1kLaCdxAp8D6aud1L5vl0sAdg951+uPh+tu/0UKKWIgqBT2Hcd3miKEISNDztqW8wYJ7Gdemw0grQxmE0nXaGjkqqxKtVdMVUqBUooGLcJv6iqnUbG9/HzjpMYs7MpqspOi/R17eU1SLN857UWz3Xx04+fUBTlF84oA6/Lcr1BbWqkeW7joIcKAO2OE4DOh70oSxsY3zlskyiC57lWKKuqIJWE1vZB2w6W01QP32swOvA0buYLSKmwzbIn/fm288woxY+fPhzsdQlRPakwQRuf3lMLqoWo8Hf/8MtOjzEZJeCMQUiJJIp6tct1H0JYr+HWYYJzjsD3cX07B2mCmL7QjjiWourEBKVUoJRAa4Mg8JHEEYw2EFIi8L3ee0d/D1vAEaDE7skTQqAaT/H3kvh/jbU1pZ2tEbsjPNk6DQy8LuttCiEEZmdTLJZrbNLdNVruo/0cAMDl+RnWm7Qr7kplV5D6VNhtR8/Lp3r2foXnOvZ62FHpW4jKrnMxiqvrm5MrAvie1ZmxI/l59x63ybrVDCFdYuC5LkZJhKIQALHnals0cjjvmiKnIqLaNimm41F33+tTQeu1EaLC7XK58+c2DHycn03B2ZDznRJSKSxXGxACbLYpatRdrg7cKQD86Q8/YptltjrYdFKeQlsoaGmr2FKpZiSIYpQkYJQOeyAD9yKlws1igSzLnxSsx2EIzm1wezE7O9jr2qbZo12Gttt2SgUAKRX+9u9/3ukxKKX4w6cPcF0XSqqT+vleQl6U+Hxz24zfWxEUp9nbf62uxT6JQquTobUBIQSe63RjnZQQsKYgW0kJo7Ud73ScXgX938MYA2MMpNKN2BcarQY7Bt/ZMr7jYoDve9DK2qsxanUsXMcZCgEngDYGRVEiy3P4vo/5YnmwBKtN5HzPQ13X3UpRHIWghEIb04tzQSnVrFKJF/2urG0xh8PZzgK+7X68EBV+ufp8Esnx92hFRVuLWq0NRFV1RQPgdJL8+wgDH77n42w6hpKqN5/ZU0KICr9d3+zc+KCU4nJ2hvEw9n9yXN/O4XBu7YNRY7NNv/g++bf/51/XSmv8xR9/bBSwnx8QO5zbm0dTCGhHjj3X7b7mOA4Yo5DSTgsYYxAGwTAqMtBxu1hCa40sLx698VyenzWidIc79PO8gHhkB9yOZfOTsg359eoaoqpevL8eRyF81041eJ7b685xa+Gk1O8ezm3Hp08d/31BCYXjNMEfpdBGg1LWCRJ6rturM7lV9r7b5W6T/PZ9bjUeniPq+RZpx59tslODMwalDQix+gC77EUP7IdWjDSJI9zMF9im2UGTMEooPM+FUgqMMTic44ePl8iLsjcJVVHaffaXFPc81wVQg1HWnYu7IESFoixxs1h2HfX3eJ85FJ7r4mw6Qd3kKGEQ9G6N5RS4ur7B+qtk8CXEUQhGKS7OZ8N7cGK0Dh03t3NIpe5dMSP/6l//mxoAfvrh07Of4O5I0HP+ThyFCIPAFgiYrZp+PUkw8H5ZrtdYrDaPjkJezM7gOBxJdBihFyklSlF9dwrA5RyMs5MoAAhR4er2FlrpFweNnuvi0+UFuMN7fz3mRYnr27mdPlKn2804FVzXBYENqoLAa8ShTutcVkoBhHTCdgC6cXapFKrKFr3agkDb9X+L4n8vpf2d+J4LpTQ8z4UQld2HJm1SNPCa5EUJUQnEYYTFaoXVZnuw5+KMIQh8ZHnRJf0fLw9vubtPilJAaw2t9bNXfuyEFIPn7r/Yvd6muLq+2etjvkc818XZZNysHCvEoRUiHiaKn8++PpNJbNdCx6OkV2fFeyDLC6RZBsdxkKYZauBeFxX23/+P/9OfAWCcPH984yWjs+2u5ja1NjhWY0AAsN2JdiRJStX998D7IvB9lEKAgHyhPfE1eVE0o60+6AE6V4wxKKW/mzwQSsAI3XmEcFe0Mbi+tR7TLx1pdx0Hf/j0EYyz7kDv63Uoqgr/8NsV1J3E/72Ofz8VzhgYY6iqyipH1zWkVM3XT+czQIgVobIj/6oT8mKUghJix1sZBSH2Ne/iIf6WUVqjBkCIXeVrzzndTAXs2g0deDmOY/VJGKOQSuLD+TmMMQfpJpvGKSPwPRAQhKGP9SZFEkfYplm3LnXKtHpT2tgVqOcUAWoABIDrOhCVBNujDzgBkMTxF/ehgaeTRBHOz6b4cDGD57moZIXpaIww8E/qntQHrCPUFZbrzc6PNU5ifPpwieBAsffAy9HGYLNN4Xke1pstyurhJuarnuqiqrobWusrejmbwXE48rKEyXWnHzDwvvhwcQ6jDf7uH375bkJrPzfRwcYVH02m2+jhlbm6vkG5Q3A4GSXw7hH5O/XA7z7W2xS3zQhmy1vY8z8Uvu/Z4itl4Nx2/QkhiMLg5M7ebqWsCTqcr4KPVuzMCt3UdjqA0i65bYOVThwP77swRAmxu75SwXEcUEo73/UofJ4e0MBhGCUJlFSYTadwHRerzeYgyWQ7IprmVhDMcTjSLMdsOumFflN7ZuVFCUrps1bgtDHI86JJ/q1Nntecg7tAKUVeFvA9D0kUYbFaD4WAR+CMIYpCjJMYy/UGSv/++xqU/V+GlAq/fr6+twv8XKIwwHQyvA+nSp4XMMagKKyT1F0B2K85qRM9zXKkWQ5KKC4vZl3yn2Z5Z1cy8D5gzY7y2WTc2e3ch1QKDufYptlBPF/DwEdelA9W0BijIK9cAfh8c2tXFXYY+29HufpMUZYQosLn2/lrv5ReEIYBRnGEuFmhObVk/3s8FJhTSq3PdzORc7cuaJruoNZ2qseYupswMsZ0XUMCvBvngLZjWtfWKpESAtd1QClBmucIPA9SqUEf4BVhlII1ExpSSURhAL9xLzlkYdOqRgPz5Qq+52I2nZ58EQBA1wyoMysA+tT1H90IiaZZDmMMHM47O9GX4ji8S1pvF0v8+PEDyqo6+HvXRxzOMRmPQCltBDELTEaj3mhRnCrbNENVyZ0K3W0SORklOJ+d9SpWeE/MFyvkRQHPc5HlBVhjcf0QHACubxcv0gA4FKY23Y5KGPjdXlY47Py8O0ZxjKIs7/VFb+n8lA8AeyTwJYSA89dT0Z4vVy9K/tsDnVKKDxezg4opHhopFTZpisVqPQRV99CO9vue7Wi13TyHO+Cs/1oPT6UN5DnnoM1nvyhFY4Vlaa8jrU1nIdjuyr/VVYK7gaGp624M+vcuKukmBXz/9bVO3iuMUny4OLfn3TbFZDSCMRqbNDvIuSeV6kTsGGO4vp0jjiP4J+Z68xBxFKIUAkrpJxcCatjVGN6s/ymtwRt9gF2ZTsZYrtYIgwB//OETpFK4XSzfvUhgG+OTpuGzXK/x6cPFa7+sN8Nqs7lXAO45WMtIf0j+TxgpFfKyhONwlI1WxmPTRhyw4mGnyt0P7nqbYpzEiKMIaZZhlCRDdfCN4zgcnz5c4urzTTea+DXrbYrZdHqw18A5e/BCaoXGXgM7uiufPdbVBjNJFCKOol4Ecw8hpXp0TeQ94DqOHW9vduABNHuSdqw/8P3Oqmrg92JA8FVC204OcI7uurBFAQLPc1EbmyxLpVDX9ZssCrQ/FwdQ1wSEEORF2XUVOGO9PjP6juNwzM4myIsSV9c3CH0fhBBss2zvz9Ump3lRII5CazHao/fe9zxorq0N6DOKeErbogFjDFrrziVhl3s9oxTnZzZOSbMclFL89OMnpFmOoij2osreFxzOkcQRXMeBNgZaa0xGIwDDmP8+0Mbg5nZuV1B2TP4BKwo6TGCfLlarRYMQoJKqc+J7DPKv/vW/qX/+5Qr/7J/+kwO/xP0yTuJudHGwoHj7FGWJq+vbB/f6PNfFn3768SDPLaW04nr3jFD5ntt4CR93MkWICmmW43b58HrEfXDGkMQ26Q+DoNcWf6v1prNbei9QSuE6TmN5R8EYQxQG0NpaTimth0mpA3B3F76SshGstYVBIWy1vb0fvSVcx4ExBm5j41ujWZcwBr7nDWsBr0g7ySOVwny5gus4UOplVs7PIY7CbqponCS9OWvKUqAGnm0ZyJkdo+WcI/C9vWpiaGMgRIUw8G1BXyks12uk2f3Njr4TBj7iKILvuUizHJyzIeHfM637kZQKpt79HBiS/9NGG4Pb+QI1rKbPc85/Po4T/Iyrw77CA7DepnZ8+XyGPC+gtBoOkjdM4PuYjBNc3y7u/b6oqoPpADiOA1ZJmHumACihR1dB1cZ0I+/PIY5CRGGISc93/QF7/fch+aeUwnPdpptEu8CTc47a1CDUduyNMVCNnZ3RBp7rIAwDKKUhpWz2f63ifRQGANDrtY2+cTfob10HANvJooQgZiGUUqiaqRxK6ZuYDmgLrkpruw9NCILAB2esW58YigCvQ5t4O5zj48U5lus1CiHwh08fsFiuH5yY25U2OZ2Obcd2vdkijqOTb8K06yuMUpRCPFkboF0J4FrIrTkAACAASURBVJwhL0v4rrs31x9GaTfFmuZ2qvXj5QU22y2WK6vW3nfRQM91ra4IIWCMQQiB0PdxMTt77Zf25lhvUyxX653WSjhjiKMQjDEkPZ8QfQ9s0wxhEGCbZsjK57mA8dGov5UdYwx+u77BbDoZVCnfAdPxGGmWPzjStM0yEEIQR+Hen/uhIFcbA47jagDcLpbYPGNcMAwCnE3GqOv6IL+b16B85kF3TOIwRBJHEFUFzjnKUsB1HLuPauxOaVsIiMIQRTNeHXHeJY6e44AyOiT5PYAxe/1zzm1iEPiNZZu0CXRdvwlRwbquAUJQlqIRWmQohbBFkEYzYOD1mI7HGCUJjDYYjxIkSYzPN7cHOyeXa7tb7LoOirLEx8t+7G07Du/WXJ7qFKC0Bipr+1uKCo42e0+M7jawpuMxpuMxhKigjcF8uYTWh7GB3DcO5/A8F67jwHVdCCEglcJ0MgF33o/mzDFpR/6l0i/+jLTnOCEEoyQeYo8esFitIYRoirLk2RMfHEDvxzvmyxWW6w2m45FVMq/7aV828DjT8fjhAkCaIfCtav++tSEeCm7bPcFj8evVNURVPTmoGycxkjjuusZvgaIssUn3v+/6UsLAxzhJ4Lku1tstGGWNNoTt/oe+3/msfx38DO4mbxNKKQLfQ+B71oqQ2c+EVApVJaG07uW6QGenaAzquobXrECJquoCyIHXo3XPAYDr+Rx//OETtlmG5XpzkEKAaMSmAt/Dv//lV1zOzk4+cWh1DJhS4NxOsjzlWlRag2ggCPxu3efQ0y9SKcRRiDCwWgGlENBaI8uLk5kMoM0UQxJFVnOmWY1KswyMUlyez3phI9lXpFL47fMNKlk19rcvY5TEcBwHUsqTv4YHgKyx+9PawOEOhHx+4YcDwH/8H/2He39xx8YYg/lyhc02xeX5DKKqUArRia4MvA3szdB/sAggRIXa1AcQh7w/QDhmwCuVQl4UTxpdpJQiiUJwzt9U8g9YhfZT6P47nONsOkEUBKCMIs8LzM6mD3Y47vv60A15+7QFQkKI7Yo1Gg6tHaFSuvvvvmDqGi6jKEsByYaA8dRwHI4fP34AYAPFcRI394/9T04xShvLtgTaGORFCULsetwpjw9zzsFh7yeEEAghHrjL/04Nu2PtcA6lNPzm5ztUHHB3Yi+OQjjcaj58uDjHepuiKArkRdlZGN7le/7fuxAGfrfWFgQBfNfFartFFNlpNkop4ij84rUPyf9hSLPc6tA8oyn0NYxSTMYj+J73ZiZE3wObNIVSGoxRyGcKgbeQv/rrv+lfG+IJxFHYech/vLgYDqA3RJrl+OXq873fS+IIYRDsfc9da42itNX3zi+cEAS+txeLoKfw6+drbJ/Q+fZc13YfgwCB5725z/7Pv/62F2XbXQgDH+dnU1SVhOs6QwI08CLaoK3VdwCs/7qpa7AmgD/lG3QrhkgI4LouKCFdd3SYBjgdVpstWLNeJKXEcr05yPO0hec4ihAEfm8KnJW0PulFUT75eiOEIIlC1HW9N02ApyKl7f47Dv+iqFMKAVFVnTDpLsRR2IjLOvD93+24t1mGs/EYhRAQQuBsOunN+/xW0MZgs02x3mx3WgtxHQeX5zP4vje8hz0iL0rcLpZQSiEM/Bc7iLytzOAOaZZDiAqX5zOst9thEuANQSntKuFfU1USs8lk78/JGtVjAJ0YICHkKEGulAqfb2+R5cWjf3acJDC1geu6iMLgzR3q39OAOAZh4GM2ndqqq1R25Whg4IW054fDebci4LouHM6674lKdkKQhBAQ4GQ0BXTjr+65DoqiBOcMvuehkhIO50ddjxp4mLY7b5oRYUoZ8qJ4sl3Uc2iDUdXY500n45O/D7mOA601XNftivyPdVTrusY2yxEG/tHtgO8W9R3OkZclpJQQVQXWdOAZY6CU2JW05s9VUnaFxlbcsMUY84WmR/vzWxvQAoJSOA7HpHF+cBwOHEB0eeD7CFHhZrGAqGRjUft8WjeocZKc9JTOwP1keQ7TCENvd3AMebMFAMB2VX65+ozZdNLd/N5aN/Q9EgY+ppPRvY4AoqpQSXmQQy3wPeTFl0k4P0KAm+b5k5L/dtd8lMQnH3C9lPKFo0774PL8DKMkwWK5wmQ0GsblBvZGm+zfnSbSd5T3W1GttrteSQmlvhUxey0rQlFJcMasawVV4Iz9rhfQCEsNvC6tPoAQFYAanusgiSMsVusXJxJf0yaN621qE1BC8OvVZ1BKu5WEU4UxhjCw9/O2i/7YWk5d18jyonEJ4CCAVbw/4v3XcTjGzrc6Mq3FoN0T1l3sQgjBOImx3qad/aDj8G6qoG2wtF9zHI7RoFNzEqRZjjTLrI7MC6/ZKAzhe+7QFO0pUiosVuvujNllzYcLUb35CtB8uUKa5fh0eXEQgbiB4xP6D++1S/U0Zd+XYAWvJAghYOzwga0QFW4Xy+/+GUoIfN9H4HvWr/uNJv9SKjDGMBklWG22R3veyShB4PtWjXmxxOX57GjPPfB+abvn7f25quwUAKWkO38SNwSlFFIpFKXoxrxfg9YqsEaNSiowymBIDRxZKHXg+3ieC6/xYc+LAj98uMBitd67PsBitYbnuphNJzB1jevbOaaTMegdocJTxXNdEEKgnqiqrhoND9fhzTX6+j/fXYvB+2jFZzs7ybarf4ehYXYaaGOwWm8gpXzxuHcY+AiDAKM4Ht7XHtMW/fdxVrN/8s/+iz//8OFy5wc6dbTW2KQZpqMRtLZWXAP9pX0/7+t2ERCAkIPt5kulQWC7/84dT/B9o43BL1efv1vpbYWWatTwXQ/jHtt6PgZj1r+5rmsU5eEnAabjEaIwQBJH0MYgCoKhEzLwajDG4HAO3qwjcc5hmrUA2uiROA6H2wTydlkAR58IUM39lTKKuq5hTN2MSD9spzpwfNxmt3uxXAE1cDE7sxoBe1SX11pjm2WQUsH3PKRZ3tw3Tz8BYc3rNMY8eeWmFRQkBI1A1xBnDuxOluVYbbbIiscnQb/G4RznZ1NMRiNwzt58w/cto43BerPd2yQst+NgT8dz3Qcrou3e0EP72a+NMQZ//+tvuDyfDRdBz/E8F3EYYpN+Ww01dY28KDA6wH5aO9Zod+oOm/yvN5tHuw9B4IFRhih828mplArr7Rau62J1IAErwN4s4yhEFIYQVQVKKVzXHUT+Bk6Sr8XH6rpuFMFrcM66DmArYnqM6YC6rlEKu4tMKQUIEHCvcz4YVgJOB0YpPl5edKJxP3y8hBAV5svlXrVWjDEoKxu0FmWJUggQQjAdj/b2HIciDHxUlYRU6klxragqKKXAOYdT2+tz+LwPPBcr9LcFAcHNYvmijm8UBriYnR1NqHrgsPx69RnlM3P278EBK4AyHY+gtN0p9F0PSRzBcTjWmy3mqzU+Xpyjavar4yiEUqobRfl4eQGHc1zfzjtf2FPFGIOr6xsAGPy3ew5j94/Ziao66H6T41gLoEN2MfK8wHy5/u6fmYwSEELexY7eYrXCKImxTTOEYQBfe0izbGcxNEptlzIOQ3y4PO++rqRCNBnv+rIHBo4KpfSLYM8Y0ynyJ01BNC9KKKUObjuom+cmhKCSClrrZreYDAnRidGuBQDtqPAnXN3cYptmexk1bZPncRKDEOvWs95scXV9g4tmpepU1wJIo8HheS6KskRVyUfvO9oYGCnBOeuEO4/tFDDQb6qqQpoV3+hOPQXPdTEZjzrxz/eC1nbqpnX1QA2gmTyzk7RWI6euawS+B20MOGMnsbLzGJttuncBbO66LsLAB2UMYRM4BIEHqRSMMRiPEsRx1O0TaWOwWK4QhSFc14FSGmmWdZZFADCbTpBEEX65+ozpZITlatPZlZwKV9c3MEZjOh6C/L4yO5vea2dkjPlC3GbfOPz38dpDIJUV+Xgo8KKU4mJ2hro2iMOoF+OUu3I+O8NytUYcRZ3tSSXlk0ehPNeF3wRxUqpOUM33PAAAd/gXASgbJoQG3gB3A5v2PPE9F/Bc6x/dCJ0dSjywBjrRQgCopbXNbAO1gdNEiApVJfHDh0sUZYnlerOXQsB6m1odHWE/D5wzzBdLhEHQC1HVoLHDq6SEqL6vNdQKBLqOA99zj+4UMNBP0izHerNFXr5MkyMOQ5xNx6DEnv2nWljbFa01lNaghNg1M9h1M0IktDbd6s5D9zWT2+9zxjpHDEIIPNdprG1P61r9fDvf+2Oy/+a/+x/+/NvNLT6ezzCdjBEGAeaLJaRSXSXFcTho88ughCAKA2htUEmJs+kEcRRhm2YohcDl+Rlm0wkIJda6SGv89OMn+K4dAdzFs3LfZHkBpRTiqN9WJtoYUEIgRPWFtoE2BkVRdrYvbw1KCJar9b2+vVFoRQIPpfVwyKT7883td6u+ozjCdDIGQGww/w6QlUQUhSiFwHy5xGqztfvFdw53p9mJbkeM253oOAoxGY/gug5CP4DjcIRhgMD3wTmz+8ondtgPDOwbu5ts/zHG2OYIoTYhV/rJ/ucvfe42EG1ji7camL4FOGcwtUFeFGCMIYkiMEb3Er8ZYyCqCr7nQiltu3HNqspDU32nBKUUjuOAMfqk60Yb0/ycNmbpQ7dx4PhoY3BzO0eWF8iK4tkF2TAIQAhBksQIw+DNNYbazn3rVmEn2TS0NhCNK05bFGgn3x57POD3wrhpLG2VUjC16axAT6VQvd5s9yrSCgD8D58+4Ha5+qIT/vHy4tG/aMfEft+L/dripWr2Z8dJAikVKKXQjQet57rdGsE2y/f+Qz2H9TbtXmdfdQGKokSa5RCyQuj7qKRVqZ9NJtimGW6XSzDKMB2PQCl5U/vMjuPcG5RIpRF4hzkAD3kDz/IC2zR78PvjJAaaYPq9uFloY8Cbm5nrcKtiyzlKYXeaXcfpbNI4YwgaO8SvH6NNON7ajXFg4LmwRkhQUw1RSbiuC0oItNGopNr7NIAxphMsRPPYbTJ0ap2WAUsbE0qpsFzb6avA93E9X+xtGqBdWdlstxiPkl6dza7jwHUcCFEhL78/3aqNgRYCQA0XtiA2FAIGWtIsh9K6+/dzoIRilEQIggBeEwu9JdpOfikEjDbfNH72/nx13Uz3SBsz1rZY8Nq/V8bY3tfryd/+fFX/7//X/43/9r/+L/f6wHdZb+zhDgDL9RqUMsRRCCEqhIGP28US8+XqYM//FD5eXvRaE2CbZthsUxSiRG0AU99/g/ZcF47DEfi+3Qmt+50Q/d3Pv9xbAPjph0/Ii6JXXqdFWeLXq+sHbwCB72M6HsH3vF6/Z8+hKG2VV4gKUWS79u3YMmO2qNh6FmtjoKT6Zpx/YGDgcURVddeN1ubRpGYX2lFLh3PQVixw4OTJixKOw3F9M0ea53t73MD3QAjBDx8/wGiD+XKJi/MZGKXdDvOpnuntikt7X3oM1hQ9GKODLsA7p2jO2Jv5AlKqZyX/lFJMRgmkUgh8D6EfvHqSui/aTr9UqunIH9fJ5mt8zwNt9LZe6161WK1wM/++Jfhz4cfoIrbJf0vo+7i6vkFelPh0eYHzsylc14XWGqv1ptsXPCZ9FwZsBZ7KqkKNhw8RUVUQVYU0y7FcbxD4Howx+HBxDqeHNyPH4Q+OJfYp+QdsoeyhG0ASR80YZj8slPZFO62S3HF0eOgmxygddvcHBl5IKx6olAJjdsLIGPMk0bPn0joF1HUNRtmrBlYDT8fzXBhtMJ2MEUfWhWcf2k5FKUApxXK1hjYGoySB0XZq61QT/xbSWA57rotKSuRF+d0JGm0MCiEQeB4qWcL33OGz/w7JixLz5cp2tp85UeO5Ljjn8FwXF7OzA73C41PXNYSwOcprJ/13KYUAbdbnKDWvUrRuVx/2ydEziXas7MePH6xSarMWkOc5tmmOy4sZjNFYrjZHdxNoiwC+6/aykpbEEThnuJkvIIR8cAqgRSmFbapACcWvV9dIohCmrjGdjE/+ptviuS7S7NtOxHqz7dWIfFGWnavG17iOgySK3lXnf2Bg4HVou5J1IwTsuS5ArDDcPoMyQohdD/QopFS9vOe+N9qEnDKKvCjww8cPSLMc17fzndcCjDHdJOhqvcFsOoHvW5HWODx9gUDA3qsZpXY/+Tvd3LqukZdlswJjx3vfqlbTwP3Ml6tnK/yHgY9RHGO53mAyTnpzXXyPthislHWKOZ20/0tMXSMrrKhnqzF2TFx3v+eD57ogV7er+n/7t//HQVcAHqNVa8+LEmHgdxXloiyxTbOjCwf2fR1AiAqL1brr9j8Hzu349HiUYJTEJ18IWK7XuL5dfPP16XiE2dn05F8/YPf+r65v7g0YKKH40x9/7P2qxsDAQD8RVQWtNUijKi2qam8aAa1Fmu97KEvxzbTgwGmTF6Vd42AUi+UKi9X3rWufi+e6nZd531BKIS/KR9cCKCHwmxUIh/NBE+MNk2Y58qJAKapu/P8pUEIxHsVI4ghKWd2jvq86ZnmBGnUnBNonKCFWx67RoDrGNVuUJW4Xzy8a3YfnuvjTTz/iJD49bWLTjqA7nCMvCmit4fsezibjo45btOsJfcXzXFxezDBK4mcL/imlIKoK6/UW//DrFYQ4HdeG+/Bc796vmzvTJafO7WL5YPJ/eTGDUoexMxwYGBh4DM91EQYBWNOtDH0ffE/KyK2gk1QKvu9BVFXj1zzQB8LAh9MkIp7rNs4q+7tXiarCarPFcr3fwsIx4JxjlMQIff+7LjOmrpEXpRUT7HHcOfB97E67xHK9eVbyH/o+Rklsx88JRRJH8Dy3t8m/bsQOKykhDyA4ewxMXWOb5dBaoyi/v/KzLwLfx9lkd9v6JIownYwANCsA/9l/+p/s/KD7oE1ylFbwPQ9BIxC4WK1xMTtDVVVHcw345eoz/tF/8FNvLzJGKc4mYxhj4Hse8qJ41jSAkPbPfr69xdlk0guP3rvwRhju1Mny4kEve6vPoBH4/Z1GGRgYeBu0I4iiqsAY7WyC9xH8KKVBYJXRpawQDsKAvWOUxCjKEkkcQWuN5Xqzt1jt+naB5WqD2dkUxhhMx6O9PO4xcF2nsxf73jSA0hrUGBRlaeOXHmoyDXzLYrlGJasHVzwfgjdrIb7vYTIagbLT18N4DKkUiidMxTwGvWNpC6D7d7tSo7UBpQR1bQsO1oVO73WFra5rVJVE4PvQWh9U0FNKhflyhSgKwBl7vlMEpZiOR4jCAK77e/GIXN2uTrr8IqVCludYrNbdjvt6kx5lLSCOwm/sDftIUZa2cKL1sw8hwAojuq67l+rTvpFS4W///udvvj4dj3B5PnuFV/R0rO/rAuvt9pvvxVGIJIow6vEqysDAwNtEKYWiFF0Qtg/hXkZtUYE1yT/nDJRS1HU9jEX3CCGsBfTNYgGt9d672m1cJkTVO92IohSoniBwxhkDY9Sqj/c86XuvSKmwSVOsNttnTTVRQuE4HONRgrIU8FwXZ9PTi72fi1QKeV68KAlviyHaaDicQ0hr0aeUBmMUDueoYQsDNdCIy9LuuQgAEAKtNKRWUFLtTWuAEALOGMLAP+i1KqoK2zSD4zjI8hzFIzojgNWF8z0PSRz9rudz97WfegEAQGOPoeA2gm/zhbVCOIZI4OX5WSdc2GfyogQhwHyxsmOWz6wgfTifgXOOIPBPqgp5M1/cu3c4m04wTk7bV7goS3uDWH9ZAPBdF+NRgkmPuhwDAwPvhzYpL4UAAQEIUJZi5w5LW1CIw8AGcYwNyX+P+fXzdecksc94zeEcl+ez3k0mAvbaKUrxaBOLUQrXcUAZHQQCe4Y25kWaGNYe0q5XXc7Oelfg+h5plj/pDKDEToIRSsAoQ13X8D23mzQjhEBU0k6hNUXjp2KMseKzSqGqbNF6H5MBhBAEngdT1wj8+9eSd6W1uTa1gRAV5qv1N4UlSimMMZ1FpOe6320inm52dIc2iWsTz1ESY75cwXPdg08CXN8u4HCnlzeau4SBbxWXme2qBI7zrD2km8USSRRCaYUkPh1xwIeCw2OsieyKqCTK8svPr+s4CAIfydD5HxgYOFHac9f3rI1sKQRc1+n8m18aUNV1DQIbLPpNQDUkP/3lw8V5FytcXd/sbYVTKoVfrj6DUgrXdTCbTE6uOfEQhBCEgQ+3Eb5+aBy6tQt0OEdtarjuccTGBl5O613/6+dr6Gc02ThjcF3HTkAxBtfhbyr5V0p9N/nnjIFzDkoIGLdJvzHGdv2bEf67vDTJbh/HdZxGa64EYwxmx+JkXdeopC1KKKX2vg4glYJS1rEtz0tooxF4HjJtYOrfO/tBsy7y1M9OLwoAwO9FgHES4+r6Bn/88RNuF0t4rgvZ2BUdit+ub/CnP/x40t3kp+A4HLPJGFlRYJtmoIQ+ahXYYoxBUQpIpaCVwexscuBX+zQe2pOjlEJU1cm+Z2mWw3Odb/b/A9/DdNwfG8aBgYH3DaUUYRA0ArISnueiquSL9zzb4kFelgh9H0qpYRKgp9y9j9numI8oCLBcr/cyEWCMQVkKbLYpKikxHiW9uXe2IoGPdUalUt3EpuPwYSXgRBGiwnK9ftaaLaXUaj1pg7oGLmZnb1L7QT8gyN26XrQd/vvO+UPt1hNCEIWBLTBUdOc8sr1GDa+7Lvy+cDiHUgppnmN2NkFRlsjyApwzOI6D6XgEbQw22+2zCkfk6nZVzxerk0nonoIQFbQxkFIizfNOqf6QKwFh4OOnHz4d7PGPiTYG2zRDmmbInmkpYW15QgS+dxJTEXlR4udff/vm67PpBGEQIAye54JwLOz+//yLm0Uchjg/mx618quNAaMU2hhUVfVs14iBgYGBFq01RCXhey5KISCq3bUBOGPwfQ98KAL0njZW22YZ0izf6wQn5xwXszOM4mhvj3ksKikhxOOrmZTafeegsQ0ceH3acf/VZvusBDLwPcRhBMflKIoScRSdbLy6K0VZovzKUYwSAs9z4XD+rDH+Q2GMQSUllNI75ZIO593PdepQAPibf/f/vPbreBae5yIMfPietQicTkYHF2DIixJplh/s8Y8Jo9ZK5CXdcVFVKIWwFh4nYNckqvsV9H3PO+kLUEn1RfLvOg7Go+SoyX+W20mQ28XyIGNLA6+PlMoG2l/dfO8bPd1VmXdggDViSDYQJgh8b+eOrGpso56zsjZwmnieC89zMZ2MEUchfvrh097u00op/Pb5Gv/fv/8Zn29uT97C+C6u4yCJIyRRaNcaHOfe68Y0jS9RVc8aMR84DFIq/PzLb1is1k9O/j3XxWw6BecclaxgTI3L89mbTf4BwJhvV8IYY43Y5esn/4AtrvmeB89zEYXBi+9bWmso1Q97Qw6gt96jnudivU0bkUB7GLYiCIfgt+ubXlsD3oVRivPZGfKifLaCc14U8FwH1zdz/PjpNF0SpFK2Wn6iKwB3fY0pITibHtdq8Wa+RBwFmIySoz3nwONIqeA4HLeLJc7Ppt98X4gKZVWhKAoYU2OUxF3FebFad3Y00/EI17dzcM6glIbX3Ni0MY3fdNFUuxXCIIDDOUohsElTGGMQ+oF97Ob6aZ839H1IpTofYikV0jzDKEm6SRIAb+KMHHg5rYp/XdcIAh9lKZ4tPPs1UipsdYYoDIYx6J7DKMX/z96bLDeSrdl6a3fewR0g2EVXWbdKNSiTmSZ3cCcy00TXTAOZSRpooNe5z6EH0FBTTTXTM9Sgbp06eSIjgiSIxnvfjWuw3T1AJiMCAAHCQfpnduxkZgQQCMLd997/v/61Ls+nKMsKn96/w918vrcGi1LKOq9rjcvpFFzwk3kecc4xiUJUUkIIjrKsYIx54KlhGhNBxXUnIR/UAC9LWVa4md0j21JB67ku3l9fYr5cYRyGvVDRvgScsz+dM9oo2b4hOIcxBuEoQFFWW6uUTF2jrq3qIfD9A33K/UC+3i3qf/nXf8M//9M/Hvuz7Mzd/RxZXsARHEmWd5WXQxQCXMfBP/z2ae/vewykUvjr3/7YaWMW+B7GUQStFc7Pjjc+8qMRAN/z8OH6qpcFgLwo8MfXm+7n7rku/u7j+5PZpAxsT1lWkErB9z2UZQVGKeI0xfTM+j20kVbteFNRlPA8F1IpyOagzjlvOj/GZkYTAsZ+fM34nrdVFrfgHNoYGGMgmvnUtusqOAfnHJ5rzXeksou557o2B7cpLBBilSVCCKCuIZXCfLkCo9R2+3p4Pw4cjrquobQGAVA098Bzoc3s5qBYeh0slitrIikcrJL9Rzz7nodPH96d5PpallXj00R+GB/IGYPvucP98EIsVjFm88XG0X6UUkyiEIRYV/vJxDZdTvF63AWtNaRUyNf8rlhj3tnuJ/qIMcaa2iq101iAEBxh0O8Cz0nEAG7C3f0c88UKge8hybKDJgRMohDvr68O8t4vzWIVYxUnO8krozAEAfDh3fF+Fj8qAFydn/c2O/Xb3QyrOAGBlUF9fHd9UOl/O+ffkhcFOOe9HpE4RVoH4HYsxXNd1DWwWK0aKTRDUZadQUxZWflfJeVJpFb8DBtfZK8xSmiXYe04DpTWyIsC7y4vHrxmXY2QF0XnP9Fn746B3UnSDIxRlJXcizxyOsSkvhq0Mc0cdICbxhtnn89ESimmk/GTqqq+00Zuaq2htH4ybpNRCs9zh8SMAyKlwtfbu626/tFohHEUgjH6Zv2VVGNimRcPCwCjwO+lAgD4HhdojIFSGtrordNtAt/r3Pn7yqspAADAMk6wipOtZTm78P76CpNXEtV2O5ujrg3KqtpqHKStbEbh6GgPt/lyhbv7+Z82C+dnE1xdnB/lM/0MqRT++vmL7egyhrNxhIsDbUpaeXYYjKC0guM4nUz7rVSfD0F70HddB6r55yRNm4N83UXCDPwZwXmnAqCEdmY5SmtQSjCdTJDlBRbLFSglYIzB97w3I5V8zdR1jaqSqGGjAnXTYdkFSikI8NOM44HTRRuDu9k9Fqv42e+1PhYqOMf7MrEqNgAAIABJREFU66uTLDCWVdXlnrfS5C4bHQAI6QoBQ3F/f0ip8O1uhjwvNk7NEpxjNLKmzm99z1VJCdR4YDjuOqL38njA+s9UVYW6RqcG2BRGabdv6evI2sGeEq2k9SVpD+RKKUwnY9wv9hM18xQ3dzMYY15FF8JxxE5FE2OsFHm+XHWHy5dGa/2nwz+lFG5PpUVxkoJTCk0IojA8yOG/LCss47gzNfn89RvGYQjHcSClAv2JbHzgIVKqzvjSc13czxeo8d0xdmA75KM84CR7OPd7c3ePwPPsqERVASAPzK6+3tzi6vICy1UMoIYjnKE4cCKQxvW5ktLmOxu9c0pAO6bSvtfA68J2CAMABEVVoiieNvvdhPX9gVQKv//xBb99/HByRYD1bqKV/DNbjJbSdiab7PQsL+A6Aq7jDN4Az2S+XOLufrGxGoVSimgUwHXdB2eDt3r4B+yIipTf13xKyMlcl5wxlLX9/233e22B23ow9VMJsPcCgGzcD4816zmJQjBKcXc/x/RsgvmBigDGmJN3Ye0i4JoZnU1nmtYpivKoXZinvlvPdeD3tADAKIWpaziO2HvxKEmzLqGBNvKlRVni03tr1Hh7N8P0bAJVqTcrR/sVrQKmlaWfqkHqKZMVBbK1kaRlHOPr7Z3d0FKCbzd30EbD93yUVYVwFGC+XHb+Ce+vrzqDwsFzoH+0B/ayquC59EEncxukUtBagxAydDxfIeEogOs4nSnqbL7Y23svVzEIAaTSJxkbCDRqKs6hHWFjBJtimmlGq7S2RTLHGQpk21KWFb7c3G41Rnx+NoEjBIqqGpRJa1BKoY1+8O+nVLQVgne+S9tACYE2preHf+AABQCtNDzvuIevcBTA9z3keYFR4GOxig+SDjBfrgDgJOfKgO9VySgcQTbVrW2LJVIpCCGwXK5wPn15M8An64g9HWqJkxRplsMRwkqf93Q40cbg680tpFT2wUrsQXYchbi6vEBZVkjSFFEYYna/wNVl/0Yjjsl8uUSelyjKsjPBG+gf7WasgO0GtsWZu/s5KKUIfA/RaIT7+QJnkzHiNEGcZPBcB5xzuI4D3/e64gCAoUBwRFq3ZUcESLN8pxhKU9d2Jlr0e6M1sBtCWGPSSRRBCIFVHO+lKJtkGcqqAiEElJCTVhExxuBRCsE58qJEvWZeZoxBpSR81+3tvHWfuJ3do5Jyq0SKMAhwPp2gru2eejIkKz3ANksfPttP4VpsR9Z29WgSJ1Dk2Pvupy/yYkYpXMdBltsDVyXl3osAxhjEyXcn71NGqSZGkdCN55xasiwHpceR9JRPyHK0MciKAhPRryrsMk6glMT0bH+Rf3lR4HZ2j7woQRtZlTEGn96/g+s6WCxXUFpjEkXIihxXl+dvvltmZ/ruQAixUmStUVb7cSgfOA7GGCRp1m3c7hdLBL6HUWDnDO1ibg0H20KC71mTnuAZmb8Du0MpBaW0iwosd0wJUE30ZWuWNvC6YJSCUYoAHmpjwBlHkmXP2ssZYz2PPM8FpRRJmp10EYAQAs45opBDKvXAKNBo0xQ7KDx3GAt4TFv0v58vtvKcaEeOW5+agad5fL2dwuEfAKpKdl3/bcz/gOZ+ZAy853/XvZ8EHCGglAJj7OgPGiE4Ls6nnTSqbmak9kklJe7ni14azm2KMQaMWZmO5zoP5Leb0OZdplnebbhfAm0MjP7z99lXExxKCTzX25t55GNZpKlrOELg3fUlGKVYJSkoYwgcB8s4xvUjF/a3QHuoyPIcnHMwxjBfLA+WEDLQH7L8zyMctCkMO8JeC0rpTg4MAIKLTnY88DKQxryMc7tZ2qUIUFaVzZVuigrH3nsM7B8hOM4mY5xNbIEvzbJnqwGKosTvf3zp7vm+u3ZvguAcIuRQSqGSqnMyBzHg3B5KhvvjO/fzBVZJuvEIrDW9dhF4PrjgQ/H4F2itO3WXbcz2uzPexv+BADXqnZRpNlJZg9X9vjb2vsup6xqcc2ite7EQM0oxjkJkmZ3pPcQowGIV42w8PtlNo9YGdW03v7v8bKRS8FxnL9FO21CW1ZPGHIzS3slBrRyvxsX57nP/rWdDlhf4enP7p1+fRBFMbZAXBZarGI4QGIchtDFv6vBvO8Gp9bXQGqaud/K3OBUO8Ux7rRhj74+8ABAnAOxi7TZjAq0SSgiOJM2gjUHgeSf7bD8V2sIMJWqnMZy6rpHlBRwhwBh9FQe5gR/juS5Qo+veP5eyqvD5yzeEowAXjXP7qcM575Qx7XhbUZRwhIDjiKPvzY/NKklxP19s3AwIgwDXlxfIimJYE7bAmNqqUxvzv1NQAFTS+svUdb3TucZxBIqi7L0yZG9XcDtvpJTuKjxpnsNz7MbqmEyiEJ7j4G9fcuvmuOfNsjEGs/kc76+v9vq+L4XrOnBdB1mWg+wo5S+ramuZzHP50SYx8Hso6a2ti+9zChOMUtzczazRJvDgUCs4R5KmcF0Hn798s4t84zXwFsjyoonia59D6s1I+ofD//N4nExAaYxoFOBiOgVlFFWzQaSMYr5YNvPIw+Zv3xBC4DjCOidrvbXrcl3X1hHdsEZRMHxHr5XA9xoX/wm+3c2QpNmzi7xSKcyXK6RZjquL85MeCViHEALf8yCV6maaKynhee6bUwNoYxrPn80NfgPfQzgaIQwCCMF7N1rad5RWnS2X4P0+/FeVhBAcdW26Jva2EEJOZhxtbyukUrZasi69Fk0Fsg+4rgPf8w6W0b2ME0wnk5M8cDFK4XtuJxnbhcUqxtXFOfKieLGq148OeFn+sqMIm7CKE5xPJ1u/ThuDVZzAcx0ba9nE0j1GKgXaqAMopZieTYAXLsi8NHGSoihL5EUJAqBSuyVZnBI22tFBUVbdwd91HDBmv3vPdTEKfBRl2c2ftfeJ7Y4ymKbDWknVSd/X3++tY4zBMk6wbBQCrmOjBgPfh+s6KGUFyigWyxUoJRhHUf8KjieM6zrgWqNG/SA+ahNMXYPWNYqygtCDMeBb4PJ8CkoIsrxAUe4eF9hSSdn46hQ4n569mntbcA7OmF0vSTMeRwk81+1tTvm+0Mbg7n4OJdWfomd/hOs4mIxDTCeTIVHmGRBCAWjQxnOpz9R1jbwooJRNl9nW+R9AM2Ioev93BQD+L//6b/jnf/rHZ71JVUkAtvrue26XmS1Vv2LyLqZn+Pz1GyZR2G3u9skyjnHtnp7UWiqFOEkbt8vdD42MUhTly8legif+HEeIXlbu+Y6VT9aM0fztyzfrXv6TA257gItGAQTnGAV+NzbwWkjSDKqJ/oqTBHlRvqqDa+B70Nog8D0YY7rv2/c8CCE653SpJDjjnZxOKhvtuJ5IUpa2UKSN6czvlNbgjGEUBBg3xYD2nm1VE+1svOc6UErbztGaE+5bGzkoqwplVXV+G23iQDiy8WFfb24x8n1EUdh5kgybxefBGMPI91HQClVVoQY2lmIqrbtnXllV4IydhOx0YDcYpbi6OG9GvhTu7ufP9gaopMRiGUMqhXdXlzDavIp7mhDSKCcsNj6wAiX01Y4FzJcrxHGCfMPiUOB7GIchCKVdI+k1fPfHglEKAoDQfsv/y7KCEBxVJkEZhd7h/Gojafv7d3zMs6/q1k0VwIOZf6U1/CPHAT7GdR1cnE8xu58f5P3bDuz6A/YUyPKi2TAR5EW+8/vUdQ1KXu6wmT3xWRmjvWt8S6kQhqOtD+JSKnz++q27vzY5dFFKMZ1MMFssMHol7uZZXiDNMiilUZTlQRQ8L8XF9KzpvkuMwxAgBEmSwvddhMEIQnCUZdV1LufLJQLP/1MnUxuDNMshhM2CllIhJ+TBa7ngUFLBdZ2u619WFRTQeSNIKTGJIiRZirxQdg6bUusdoTVcx46ahKNLSKWQpGn3vGjNcdrrMvC9rZQEp1pIeJw4wDnvJOeu4+BmNut+bzgaIRwFr+I+fGmsdNmFIziyvEBdb27IpJt7jBDSjSX2RY04cBiE4BCC47ePH/DHtxukab51otE6prYpT7WprfQ7il6dosQRAhB27KYsrbKJUdrrg9qmlGWFOE0fGCX/DME5onDU+Sad2j6+r7TPYUb7eU21kZmU2T0NY7Qzjt8WwTkqKXthgr8Jz14Ri7KCNgYEdiMkpbSVWKVBPPvfjDG9kRhNohCrOD7IfPB8ubLmNCcGZwxVJW2Cg+Ps7JBelCUuptNf/8Y98VSVn/bwIbNL9bgsK3y5ud36OnWFwM1sdvImWLo5ZGVZDqns2EMfDou0yVtuPU+e/D2EQAgBz3UaJZQCowxROOpyrQF0XaVxOHrw+vVN5nTy9NgIo/TB69rN7+Pfw5r3agtD679HSgXaHE4Dz3/wZ7VeE/Y1AnGaYhJFoM1BdxJF3Ux86/Jb17UdPyhKSKUaJ1zTPf8f/7zaf29/nqeKUqobGWhHNHzPQ+D7MMbg9s4WBBxH4Pzs7Mif9vRgzN47cZJuVTRqlUKcMRRlBadJSRl4/Xx8d435coW8KBAn6bPeK8kyuI7zqqXghBB4ntsViZkxJ32vfP76beNYUTviNYI2Gs4zfZoGHlJJibp57vb1vrEJMgxVVYFzvvMYNCWk28ucwuEfeGYBwEryrEtiDRv3UDZVekIItDZQuuzdofi3jx/w+x9fni0Te4ydHY3h+95JdXzs4coaXjxnI140kuP1LuQheSpj03dP/wF+czfDfLnaqUMqlYKpa3x8/+5An+6waGOQZTlWcQJCCNI8P+rBfxKFKKXsukBtdnm5XAGwh9fA98A572bEf3Xvt7/+3GeElKrr2PyKp7oZ6wvy43vmcWpE4Hv2u4lzTM8m3Z85iSIA9hnSzt9enJ3BdZ0uqSIIAmitoPV3FUL77G1/fjaqcb/P42NgjOniB2fzBSiliEYBfN+HIzhm9wuMoxCL1eqkk2OOQRSOkBcltNYbr1OtoSDntsitlELg98sfZuAwTCdjjCOrZHrus6WsKvzlb59xdT5F1Oa/n9Aeb1MopfA9r3tOn1ojoVVltaNrP8MRoovvbse6BvZLbez5kDHamybwOlpr26jQtklRFOXOaWZCCGjTP+X7z3jW7oMQ8sCkp+0CAY2sQitQQnr5ILmYTpHlX/b+vkmaYb5YPpjF7Tu+56IoShBCnnXYKqsKaZ6/WAzfOAqRF+UDxUKN012YtTH4enPbLWK7fBdKa3x8d31yP4NlnEBKCa01Fqv4aJ9jPTmBgODq8gJ/fP0Gf+Qj8H2bsSw43vUgVvGlD4+M0j8919rPIARHOAqwjJPu53cxnXa/ro1B3iQ1CM4RjUaoUcMY08ju2AMlAKXfM90ZoydrUviUoaBUEtPJpIskLMoKWushXWADWrNawD7rNtms2XQABdcRMKbu5X5k4DAwSvHbxw8oywrz5fJZ3k/GGHy7m2GVpPjw7urk1thtaGM5TwFrlBxDcIFKSixX8U/HBFuTNtd14DrO8Mw9IJwzVLJ/s//tutGObbf7kF0P/7zZv4Cgl4WOH/GsK18/4ZC4HgWnpGq6mFYC0idZRBsjc4iu03y5OqkCQJrltqu549zLOlJKmBe42bUxqCr5p3GFXW/gY5PlBW7uZs8+5LiOg+iRpLzvLOMEqzhBlu/uP7Et7dy24ByMWe+Ss/EYwJ+74b99/PBin+vUmUTfI5LWN1aMUoSj4IFBZ+vt0HZn/5v/8BuSzI59BL6PLM+RpFk3TsA5gxACi0Z98SP6PFLQGgou46RLb3AdB57nYb5cdqqfxwqMge9wzjFiDEVpuzWbrltlJTsTzT6NJQ4cHtd18P76Cr7vY3Y/b/Y7u4065kWBv/z+Gednk2bUZ+gcH5Msy6F1jdVqjuIn36nveeCc4eO761c7ytE3lNYQgvfq7FfXdff8tw1LZqO1n3F2YMyu26emPuaz+wXwT9u/sI2RopTC/CAqoYY9qGljMxX7ZsLz/uoKf/nb5713lloZ6KksDFb6X2If92icpPj0/l23aT8kj68n3/PgnEjVuuVx1/85uI6Df/jt0x4+1WFJ0gx5UcBxHMzu5wc/rLUHLdHI9IuyhOu6gznbkVkvwgaelWWHQYAwCB4UZl3HgeMIVJUEARCNRqikBKWkK9wsVqvuNX09/D+mPYBkeQE8GilZT+94qZGqU6LNNq+khBACeV5sZBAolYLWdlazLbYMhYC3wyQKETTFtmg0wnJHPyhjDJarGEVZQilrnjrcoy9Hm3BjavPg2f8Uge+DMYqLs7PuXh8O/y9EjV4pSdSawjDNcpBGof6cwz9vDP8c5/Q8M/i//Ou/4b//T/9x6xe2cvFNXXml6l8BQAiOv//4AX/948veiwB393P8/af+dw6/m3QR1M+IAGxpF9M8LyDWuoH7RkmF1SM5n+D84EWHffP75y87dyLWoZTi0wnM/d8vlsjyAnlRHEzSLbiVo/NGat7G2CmlMI5CjA94XQ5sz+NCqW4q6a7rIPB9VJXE+XSC5SrGKkkRjQKMoxDGGHDO8bUxy/RcF5wzEBAUZXkyhYB15JqhYDgKMIki+Gs/n/a/D4UriyMEjDFN/HC1UW6zqWukWW5VQIz2zqNo4LAIwXF9eQHdRKA+TjPZFNnEphZlBUII3l/ZpJTJsL4cFNk0HpdxjPly9eT3RikFZwyTcdTbaOg3AUEvuv91XSMvSnvOqYG6tqqx5yZKEUI6s8w+/D23hd/Nt4/Eq6QEoxRqC9lEWZZglPauSuK6DqJmdnWf5EWB+XKF6WS81/fdN8YYcMawarpr+yBOn+e6u/mf8fDak0qdjOpivlzCmHpvh5RJFPa2qj1frrqM+ec6Mj+mrei33WTAmrGEwfcFXwh+MtfFwEMPj3AUAM1Ei+e6mIyj7tfazvhvHz9gvlyhkraQpo1uvm8CQuziX5RWet/n8YDHtFGDre+E57r2wKvNUABYozXmRONJ1DpP/wxT11Y9UHPkdQFHiN7NqQ4cFkYpPn2wRfO8KPDtdrZTMV4pBUoo0ixDOAoGefmByYrih8pBSilcIRBFYdcIGDgux1ZZqaYB5Ahh4/4IhQGF0s9vvDmCw9T1SRn/rbPTU8oRArrJkd6UGlby2LcCAABcXV6AUor5L2ZLtyVJ094XAFTjGu8IjnyPfgiM0YMuhK7joHo0+3kqlfevN7fQxkDKH0fJbUsQ9M/ZWkqFoiqxWsU/nc3bBcHtgSgcBajxXTo98Hp5LLGllOLufo7JOMIkCpHmOZRSCEcjmywgFbKiQFmW3WjMfLmElKpJLTgNY8G207ienDA9GyPwfGRFjrKs4Pv+m1cGCM7BGWtSiWooqfCrHYqN8/zuUD0UAd4mvudhFPjQWm+kInmMqQ3uF0vkRQljDN5dXYCzP0ezDuyGNgaLxeqHIxuMMbiOwMf376CkGsYxegJn7KiHf6lsJL3gAkprlNWvi8ObYtcawHVO9x7f+ZNXUoEzttXDUmkNpVTvRgEYpV3E1z43hFle9H5+03EcpFneHKYJHnfVd2G+XOHju+tmPvMw33UUjrBYPSzYhD03v9PGQEkbh5Zkz5/5b2nnpvtCXtgINAKyt78nbXLv7eJPMAr8ocL/xhGCfzdb5X8uEBhjwBjF9eVFV4wUXDSbAJsi4jkOTG2wXCV7GcV5CaRSuLm7B2ALoZ7rwDRO2ABQG2AU+L1edw4FIfbZYIyBZAp5+etYJ20M8qKE6wi4jYxz8AV4e1xdnEMIgThpImiz7U1p86IApRSrxKadTMbRmy7KPRcpFZRW+Hpz96RcOxqNoLRGOAoQjUZglIK9wedeXzlWQbUdT2/3AFJJOzpCCPQeCgCEEDBGwRg76aLxzqezNl93W5IsxyQKezcvMZ1MILjA56/frESkfn4hgFKKrLCLSF83Y0VRdkWZupYw23+lf6a2N+Ah1R52fu/7ht1pjKD6fCA0xmC2WOz18M8Z62SMxyZJMwjBG5O/8tnFtLajX9dW3VEDGAVBr7/jgf7gug5QWj8Wz3WbAoDtEk8uQjiOA6MNlFZQgYbnOmCMdbnhpzAq0KYKIE5AKYXnOghHAbKiwDKOwRlHFI7eXCeSNuOG7T7lV99lOyaitYEQNiGkb42KgcNzNo5wNo66kVBtDIqi3Oo9bDEugee6SNMMnudiHIa93QP2kfbwNpvPnxzPbY393l1dDgWWgQcorUEJgWq6/57nWrWtHf7fy59hjQ3rk/Mce8zOn14pBULI1nIKgrYz07+qSTgK9hoN2KYBTCeTvbzfoVDKzszO99UBI+iilg5Blhdwm65X90cS0iu30XWWcQLUNebL1d67jO+uLvf6frsyX66wXMUgxBqwPQfOOc7GEQgIQNCZ+PRdTTPQP1ozwRYuOKZnE7Am/7esSgghwDnD1cV5l97yX//9965oIJXa+hBwDNr1pl2/wlEAITiWcWznlCnFJIrezD1ECIHXzGZWUqIoyl+aFkuloLQGZwyOqXsXYTXwMkyiEOEowN3sHqjt9bPNfsbeizZeWQiOVZLgXJwNh9UNaCORH++VWmM/zjmuL87fzHNsYDPas6gxBkUlOxVXmuV7jQcPfA8E5FWsDTsXAAghqHc44FnzHQW/hwUAwEYD/te//r6390vSDMs46e18ulRWpl/tcR7dGLPXG+6p91fyYUfHZoT3tBpX15jNF3vvKNImW/1YaGNwP19Aa404zZ51/fieB0fwbvMdBgF404lrGRb8geeyfj0FvgfXdVCWFaaTCeIk7QrT11cXQG3nyv/6xxe4jtPNCD/3Wn8psrzo4kUnkVU8LOMY5axCOAowjt6OPNkRwiYXaYOs+HmBv64bc1ZiCwKuIwY1wBuEUdthblNrirLcOq7XGINlnOD99VXnsTQo2J4mSTPM5gvbPGr2j5RScM7AKIXrODg/O+vvPm/gKNR1bQ/9jSL4+/VRg1K6k1L9R3iuC0JIF/136ux0J1VS7vWH2ieE4AiDAKY2ezOJurmb9bYA4DoOylIiTZO9eiBwzkHJYTaXlNIHpnKCc5yN+2W22HaayrLCzex+7wcGSu1s87FYxQkWcYyyqHYelxGc46KZ4S6KAsbUuDofKvsDLwejtBs1icKRlf5L1XlqSKnwdx/eQSqNqnnmRKOgU7+16QJ9ZP2Z00YLWhVACEIobu9mAADf9xF43qvfWAvOUbMahBIopX/5vcmmyFzXNVgTM/kaNn0D29EmzGS5XaPaSNlt+HpzizAI4LoO8qLEOBwN61zDchUjSbMHykFKaWPs62M6GQ8/q4E/Udc16rq9H7Ud+TJ1592xi0L9ZwjOQenr8ojZacXX+nmHGSllr2MT3r+7wu3dbK+jAH1VAWhtUFQlTF2D7mlzIziH6zoHm48JfA83zeYV+L5Y9IV2fk0phc9fv+398C84x6f37462KJZlhdv7+daboJZW0u+5LjzXhTGml/fGwNvjcZIEZRS6MhiHI7R5hGVZQRuDOEkgBIfj2FScXY3DXhJjTJd24zoOpmcTOIJjvlzCdd1Xfx+2uc32fxxFWUFp/dONolQKdc2QGTseMhQB3iZWMXSN5SpGludb+9wkWYYsL+D7Hkzt4+vtnTXwfaOKgLKsbCqL0vbwX7cjN7brP4miN/uzGfg1VSWhjQGlBIJzFIU1fGWUQu9ZhcwoBWMUdV33dtR4FziAbu5xUxiloIRsFQO4zq/m8I4NoxTTyeRJ85Fdmd3PexnTFI4CzOYLcM53PtA9RggOo80zBkx+zXpxxnMd8B51r5RS+PLt9qCdwWMc/rUxWC5jxGm607XiuS5cR8ARDkDqbsZ6YKCvsCfGbFzXgZTqgRy1LUi6Z04TLVdDKdVbdQBgDQTbz20PNy60MWCUomzklK+588Y5R8g58sYI92eqRqU1oDWMMeCcw3XEq+kCDWwOoxTnZxNEoxFm8zlMXSNO0o1fb2qDNMsgpZ1RLooSvu/1bl94SLQxSNIMaZahbhQVjhAYBT4IIbiYnh37Iw70lDams1VntSN8UqnvGWZ7Hj+ma/5ir2095ADw+x9f8M//9I8bvaCVXOx6+AdwEg8713X2KomXSvXWpb4oy73OOI4PbDSljXmwsXZdtzfXlDbmoIf/wPfx8f31Qd77R7QzkFmWoyjLre/9kW9juc4mY4yjcOuC48BA32gP/u1mdjqZQAiOsqyQ5hnyvERZVZhOxlBao6pkL4sB7fqWpBmSNAOlFFHjD9Deo+1m67UW63zPRV3bok5eFD99vqmmCKC1BmN0GAt4owjB8f76CstVjGg0wipOtkr3aSPtRkEAJRVulyu4rui9YfRzkFLh9v4egnNUlT1DOI5AQCmCwH/16qOB3Wgj/Ri1HXitbcKYlApZlsPU9daR9JvSGslWlezl2e25cODPssef0eYfymc0i7UxJ+HoPYnCTi65D5I0hes4vdtIReFoqyr2r5BP5LXuk/v5svtnxhj6sv2SUmE2nx9so+86Dt4fIfYmLwrczxdbHfwpse7Hge8hL0o4QqB99XD4H3gtsGamPssLCMFBKcX52RnQNLGsK38O2uTT9z1isB1Xa0fWppMJKKNI0vRVH04IIXAcAcYoyqpCJdUPJaSmrmGUgtLWS0AIDtdxhkLAG2QyjqCNgVSqU1Nuc2+3agDGGKRSoIRiMo4O+IlfnsUqRp4XqKQEoQRVJeG5DkaeZw1/X+HBauD5lFUFzpg1+dMGSmkopayPRm4LtYQQG/l3IE+6ke9BG4Ow8f15bfDA8/Hbxw9bvWgfEX59OwQ/xfXlRRMVtZ8D3TJOcHVE47Yf4XveXgsAvnfYA54x3292RilGwfEXkLwo8OXb7UE39v/w26eDvfdTtDN624zCtAd/QgjeX13CdZ2uejsw8Fppi1rryoC8mfcVnENphbv7OS7Pp5hOJvjL3z4f8+NuRFsI4Jxj5HtYxsmrNwtkjCHwfbiO7pJxaGMa+HiutHWfLsuqKwS0aQMDb4d2LACwBYHb2T0Wq3hj9WglJajWcB0HWXPO8kHHAAAgAElEQVRQZpThfHraBTdtDO7u58ib4mjgezgbjyGVguD8VT9HBnajVZgD6Bz886JskiBsMSDN8u4ZW9c1DpU35joCSutX/Uznv316v9ULlFKozfN/5IeMidsn15cX+P2PL3t7PyUVFPo1S+Lt8bOcn03gCLG393uKsvquMOA9WEikVPh6c3fQw//15fnB3vsxSZohy/Ot1S9CCHiuA6UUHMdBUVmVz3D4H3hrtN4Bray8rCq8v76C4HZM4OriHMs4RtU8y6aTMZZx0st4QaVUVwwAbLFjOpl0nbtlnPTS3+Y5MMbgN90npTUopVbFVNcoyhJSKphm81nXNWptiwVSKQjGD7a+13WNqpKd2mSgf4zDEFIq1Kg3jg00xiAvCkjG4HsekipDWVU4P5v0aq+4KUmaYZUkqCqJ8+kZXCG6v8ex92sD/cMYA0JIF7GntYGUCpTaf1dKQ9bf99eHPD8SQhD4Huq6ftWHf2AHmzZKKaR6vtyirCQC//lKgkMT+B7CUbB1/uuPiNMUge/v5b32xbqk/jkIzjEKgoM+4Muy6gyqbDbsYYsNP0MbA6MN/vK3zwfbuFNKMZ2MX0R+q43B7H6ONMu7KuwmrJtiucKB77lvKmN8YOBHCMEhxPfZ1iTNECcpCCW4mE7huy4WqxXSLAdr0kwE58iKopfFgJbPX78hHAV2fQxGr/ZeJ4R0CTNKKVBKEfg+aq/uRhl1Iz8lhMBog1JXqGHdouu63utBnRACtymySqVelSP1a8F1Hby7vgQA3M8XWMXJxhJlpTXiNIXnuuCcIU5TZEV+MuM3ZVVhFSeQSuFiejZcnwNP0kb4AUCa5fA9F6pJ0pFSQQhrSm7Wft9LEQa+HS1+xQf/lp0KAPtgX47zL8H1xcXeCgDz5QrTs349zAl9/oVOKcX0bHLwOL5KSZjaQHArMz/mwlhVFZZbSP22xRECZ5MxppPxQd7/Maumy7fp34cSgtEosIZYlOH66uLVHgQGBvZBOLKxX2VZIU5TVFWFcBTgbDwGZRR5XiBOUjv7SGknl+2TZ0CbwNIaByZ+BsE5fN9/dUqAddaNcttOFQ9sMb/9fnTjUN3+jzEKRhmcplC9r00l5xysrlGW1aAG6CHtPXA+PevMpO8XmzdaitJGmoWjAEbXuJ3d42w87m33vCwrJFkGzhjOp2ev9hkw8HwqKa0SrpLgnDWqKltIdRwB2RQ3XxoCYNSo2t7C4R8A+OV0utULlFJ7MXlrs9JPYeESgmMShXuJBTTGYL5Y4vJ8u5/7IdnHw/ri7Azhgbv/wPfCUV3XGEfh0RbEJM3w+eu3g/4Z4yh8kcO/lAqrOMHdfL7xa6JwBAKCsqrgCIHL8+mw6A8MbIjrOp0ktiwrlLLC/HaJ91dXoGMKkdsOSJxm1hysubf6qApoCwLLOOkUS4Hvd74Ib8E7oC18C87hudY1ut3cUkqtARohTZ70fpSPhBBwzmxKA8HQbe0hjFJcTM9QlhWKsoTveZgvVjD1r+/jsqpQVhWCJkVHKoVxGPbKNC8vCiilUQNDfN/Ak2ht/VMIITDGmvm18Zetmpc0sfJFebykHN/zUFUSo6BfCu1Dwi/Oz/Av//pvG8cAUkqh9xWNJ9XJzDddTKd7KQAAttPapwKA80wZvee6GAX+wTd4ZVlhdr8AYPM+9xlduA2L5Qq395sflnfBc12Mw8PH4mhjkGTpxod/SimicITpeIw4TTEZR4Or/8DAM3BdBy4chEGA+8UCeVFCcI7pZILpZIJVksL3XEglG3+O4tgf+YcYYzCbLzBfrhCNAlxdXmAShZ2C7jUXAdZ5vKYe6nDOGANjDMYYVFKCM3YSTZW3hus6+O3jh84ctFJqYxVsluddYa09NB1735ykmT3UwTYqBgZaWp8SQggIJVbub2pUyqY/OL7AYhVDStlF/D0nVv65EELguQ600W9uL7vTCAAh5NlzGQRAXpYnI18TguNieobZfPHs95JK9SoLfTqZIE1zpHm+0+s9zwV/gY1dVuSoYaXngjOcHSEuJ0kzzJerg3biri/PEQajg2+WpVL4/Y+vGyt6HCEQjgJUUiLNM0zPJkPXf2Bgj5yf2S6alArLOG46gB5830NIbeevHXuaL5c2fpDzTlHXF9bjBAPfaw4wEwhhP2uSZkPu9x6hlMJplAaqrOB77puRsZ4SjFL89ukD0izH/XyBrNismGeMwZebW7iOA9dxEAT+Ue6f9t597Yqege2opERVSWhj7LmGNIWAUqKua3DOwDlDlhfd2XHdzPtYpvCc2fEsrTV8z3tzz0wObJfLva9NRg0AdX1SKoBoNOoMTp7LKraz432Rc727vsTN7QxJtrnXAaUUnuu8mPw7ywtQSm0B4MBJAz/i7n6+lUHetlxMz17k8F+WFf729dtGXQjBOS4vzjFfLlHXNa4vLobF/5m0409SKRDYKjSlFGmWg3PrgkspASUUjFFUUgGoUdfoYsnaxUoIDmPqzoyMUgJGrcy4rcALzrtFdl8S5IHDIQTvVGJlWWG+WEIIgXEUYXY/R5YXCEcBJuMxvt3egTUdwn2tT/tk3TNAcN6YB36XWSZpBtdxhmfKHnCEAGcMZVmBc6sGOIUGy1tjFFhZv+M6SJoI5k2MAtuxAEqtU7lS6uCxy+swSofC3QC01lBaN+dBYmX+TVpKUZTdXoNzDq31UaX9P8IR1rhaKf2mZP/rcAD47eOHjV9AKd1rtUaq0ykAuK6Di/Mpvt7cPvu9lnEC13U7x8tjIzjH9eUFkr9uVgBoNxXvr65e5PCvjUFZSRsxJ8SLyOMfk+U2zutQuI7zIl31+XKFu/v5RsW8cBTg+vICN3czjMPRybgRHxOtNUxdgzfSXKU1WHPYBwDVpKjUdd2NU7HmuWqa2LH21zfh6QPfWlRmE6vDm4M/YwxlVcGYuik26G6Gua7rN+OAeyqs+wXYf3fhuS7qukaW2cOzIwQqKRH4HlzXRVmWiNOsV6oAwF6r8+UK8+UKlFJcNyMCyziBZ5yT2Qv0GUqpTQrQGmVVNRJX99gfa+ARUThCFI7w7tKaTLfjP5uwWMWo6xqB76MnQtKBV4zWGpW0/m/aGFBCbCOBwDYrCEGN73F+7V5GH3C/vCuM0k6VJpWC773Nwz+wwwjAPmGUbhyP0hcmUYjZ/XwvXRatNdIsw9kLubz/CiE4Pr1/h7v7OWrUXUb1k9TA+fTlDoPLVYzaGHDOwZsu0ksipTq46d/15eFd9JMs2/jw73sePNeF0Wbo+j+BlKqbYavrGoQAdW0XQa2tMdKmrPuq7FsOp5pqfbu1TPMcBIAQAmXZFhuAuraqBK0NGLPXYVshb2PNBo7PegduMo6sQmC1Qq1rGALkeQHOGS6mE0ipUEnZS98AYwy+3txidj+H57nQWoMLjlnjrzKJoqEgsCNtfGG7x8ryopO7DvSPcBSAMYr5YoWiLDfaXy7jBFleIMsLXF2eD+N4AzvR7jfagzshpIkZ1WDMdvQfx/GZuoZRCrQx7+t2L43RX19hlNpkjeYzvvU9zdY7emNsJ2lfB3dKrHzklGSp15cXezkM9s0MEAB838Nvnz5gdr+Akqvvncy6fnDTTMYhghesnLWmM4JzXF+cv9ifC9jD2eev3w76YLuYnh3cE2IZJxupVyilGEchHMGHjv8a9Vp3XimNuq4Pqgg5JDXwYJRlfcPJKAVvRgZcR8DUBu3anxcl6to8kHAPHBfXdTAdj+G6DrQxWMUxpFR2I9cc/voWJbiOVAoyUYiTFLP5AtPJGNFohKzIMV8ucTGdDsXHHaGUQhA7MqSNRpopOI5AXddwjjRGN/A0vueBX9jr/PPXbxutLVJZr5C8KDAORxCNrLkvo6UDx0cphRrWd00bY1NDAHBuFYplJeEIAdJ08x+f7X7m+fbYvO9Ys/ybEPgeXMcZVI5rbL2qrm+Cn0t7uCwricA/nQKA6zgIfO/ZXRXZ3Jh9oq0iO4IjHI2swR9jmM0X3YLkOs6LHgzLJiOUgMB1nBcxHGzRxuD2bnbQg17gewctBJVlhTTPcTu7/+XvnU7GuDifoiyr3phU9oF2vt4Y0yljTk29tCnamE66V0kJ1swR50UBSigI4118Tw3bMWgr6W0HYeBlaTvlrDHba9emsqwaJY/T5ZEnTbRgH2lTBGbzhfU4iCJQRptOZw7PdYfDzZYQQrpneSUl8rwAIQRS2mKAOFKazsCfaQtdv336gK83t8jyYqPGQyUl7uYLBJ4HxhikkkPx/g2T5QWklM218PSzfv2//8zXqs+H+k1oJf9tWsrgifKdrZ/8beVkHxdF3chKTG1QVtXJyDFE0xndh6xyvlj2zlRFKgVT1/A8G021jGMIweG5DkAIrl64A79YrQAAlNkIupeSuulGotpGWO2b1kTx+uLiIO/fsoxjzJerX36Wq/OplYoPh39UUlqJf22A+vUe9jdBN2MOTeMAlBBrWsgoeGM2mGY5KCXQ2sB1neFQcWRMo5a6auaLbTRThXA0wiSK8Pnrt94WAVqSNEOSZqCUwvc8XEwn8D0PUipkRdG7dfMUcIQ98BdliUoqmMJAMgnXcU5KhfnaYZTi/fUV5osllFIbR1BnhVX7jMdhr5KmBg5Lq0ZUSj94rpueP+MPTdusbRmaEw/ZaQRgn7P7SmsIwlFV8mQKAICVyu+DsqqsY6/gvZnhEpzj/GyCvCigtAKlFJfTKaRSR+m+kGbOSHD+omZGeV4c7PAPoEmBGB10znUZJ78+/BOCv/vw7kXdhPuEMQZFWYGxxojPmE7i3/eZtmNgrGGALQrAbjBaUyDrGaBgtOlygPkgt3tx1p/T4Sjo1pZlnGCV5xhHIYwxiNMMSil8ev8ON3ezXhYFjDFIswxpliHwPYyjaDj8PwNCCHzPgyM0ykpCa428KME5g+s4w73aExiluDyfQjf7hPvFEvkGsYFSKXz+8g2TKOxk3b7v9WZ/ObAftLZ7FKl0Z843YGGUdskySinwoSHxJFv/VGgzH7pPD4A2AuuU5KOMUoRBsFVs3o+YLRZ4d3W5h0+1X3zPgzYGVRPVeAxDprZ71eaIvtQsaJJl+LKHtIcfQQnF9GyM6QENIDeZ+aeE4vJi+uYO/+2hvqwqaG0a4z6rbKKUWkfbugYlTfKJMahhn1ctrZSsrutuxm7dSOcpWndc1sixH8/QnSqtKVCL7ShSUGJHB+raphEIwW1h4ESe86+B9Y3/JAoxiWx3cLFcNZJhu1l6f311cK+T59KaniVpik/v3x3745w0jDEEvo0M1EZDSgWtDQjBm8zE7iutcVk4CjC7X2AZxxubBMZphlHgo5IS52fDSMCpsm7UV5YVTG16Ga3XBzhj8D2321sNh/8fs9NPRnCGDdNKNkIqBd91rbrghGRorVP2c4mTFFfn/XNxzYsCxtRwjmjAlOU50qyA6wpcnb/M6IE2BnezzZzyd8Uc2Ejt85dvvyxOuY6Dy/Ppm5qptRVz697fekoorbuIvKIsQQi1habmbE6oNdFilHb3/HrUDSUEIAS1qaGNhjHWPI9S2iUEtPE47escISCVspGBza8ZU3djUYzR5vdaE5/HLrx9Z90zQ3DeZO4SVFKirm0hZXB4Px6tLDLLc5RVhflyiUkU4e8/fsDNbNbL1IB1kjTDf/3337uDkOAc4yjEKPC7MYHBOHAz2vuwKEtUlbRZ3mUFwdlgltUzLs7PEI4CpHmG2f3ilwVkYwziJAVqu8/O8mF0pu88Nafe3oNZnnd7goGHEELgCAFH8C7ieJj3/zn8X/713/DP//SP271ojxUV0zhNS6VAKDmpAsDV5cXGs1m/4u5+jsk46tXM1rG7wrrpuo4CD04j5zn0n1dVFeIkPbi7+yQKD/Jda2OwXMUbHf5dx9nbKMup0C4S6zhri8SPijIbOWYzQDyqqfKfPM84Y2CUoqwkGKPgnMBoA9oUGYw2UEZDCIG6NjZvl1IQgsbVu7+d2nWkUg8OaoQQMM5huvhEMqgCjkDge90zqCwrxGmKVZx0nfU4TZGkGcqqsqq/nm0617ugUinM5gvMlyv8/ccPnVFse4/0rbjeR1rfjjbeNC/sz7dViJzS3uw106oxo1GIr7e3GxXr4jRFUZZdbGj7PgP9QjVrJaUUrazQdRxobdd7IQSUsgkvOKGGwKFxHQd+EyVr6nqIO92Q/pTIm73fKUUCMkrx6f27vUQCJllmF1rXGTYrDctVjCzLIQR/sREJrc0vZ+afC20Mfg7B7d3sl0Up13HAOcMo8Idr7Yi0h17fW/O1WH8ic0A06oB1FUE7Z6+0htamUxmcgkKgPbRVUnYjAYyxxnPBgDdqgYGXpT1UTM8mUM3I11/+9hnhKMCH6yvcNAki7Vzy3f28txGYn79+gxAc4SiA57pwTshb6Jgwxrr/GWNgDG1USsYqd6oKlFA4jbpp4LgIwXF9cYFSStyvpTT9CKkU7u7n0Frj+vKwxsMDP+apM8561991nAfjhbqJcgXQrfUDljahyHNtkWSQ+28H+8//8//2XybjEJMo2vhFdV1DKb23+dXa1PBcF0YbOzd6QotL27UqyufNRNjMbQeUkKF6BWCVpMjzAgY1Qj84eKd6vlxCKY3b2X33MD7Eg5ZSiuvLC5uosGfKssLt/fynn3sShYjCEVzXHaSAJ8B6d5w2ix1pDPcE53Ac0Y3o7Cud5aUwzTpSSdmNfxEQFGUJqVSnFhh4OSgh4Jx1XWDf87CKE1ydT3F1cY6iLHF7PwdnrIvG7BNtoUwqhTTLsYwTFGWJwPPBGMUyTpCkKQQXexvhe20wSq1xJ77PHiutuxGlqpKdj8lwfx6X1rjxbDIGYxRplv/yNUVZYhUnqGGbyJTRB942A4dFGwMp5YPDavssJY3psFQKUipIJbv77i0nET2GEoKgGffiTdHylM6NfYH9p//hP/+XrCi2HgMwe7wgazRS2cax9JQipBij8DwPWVFAqef9PFpJbDga7enTnS73iyWqqrKOz+PooAuUNgaMMus0ndsFdN8HKddxwBnDJAoPYsZTlhX++seXn/oWROEIk/EYjDFEJzb33x5Ihk37nyGEQHAOSgkY/b4Y0sazgLYmq/hesGzNV/tSLqhhN0FSKXDG4DoChBAorTtzxYGXgzGKcDTqYnrHUYjlKoZSCh+uryAalUYl7cz4yPdBGX32GngIpFKYL1dQSiHwfTiOQJzaMa9jj7n1GUophBAglACoH3iUGGNQVrL7vk9Ftfma4YwjCkfWFf4X4zrGGGR5DqU0onA0FABekLZrXVaVXX/rGrwpdmutoZT1JLIFfhupK5q5dsboyYz+HQpHCHiNarJNHxrYHm0MyP/5f/3f9f/6P/2PW7+4knKjauOmtK7R1gCLnVQRAAC+3t5huYqf/T5ROMLV+fmbNjC6u58jSbMXM6izLsgGv//x5SDv3x3GKMU//PZp7++vjcFf/vq3nxbkJlGI6WRy0nN/y1WMyXhzpdLAw84CIQRVJZsNPTrDL0oIyqrqXSIBo/RBfNXgE3B88qLAchVDG4PL6RSUUtze36MoSmhjep0gsI7rOJiMQ4yjCEbbw9DwbPk57diRag4pdWOA2t6XdnyHDxvyI9PO+G9q5kkpxdXFOUa+D2PMSe8RTo22oLbevZZK2eKAqTs16roitY9RrYeEEGJVSZzDcx0UZQVKrZfTsB/YHSnVbh4AxpifmlvtQiUluGHwPBeqkX+eEhdnZ4iT9NkbIM91sYxjXJ5P9/TJTgspFfKihBD8Ra6BJLVmefPl8mB/BmcMjiMOEluVFwW+3tz99PAf+D7C0eikF/a8KOC57q9/48ADHm/GncZw1S6oVnJvzYU4TF1Dyv5sLrQxSNKsGYty4DQRguuJCoPs72XxPa9z2Z/N5yCEYDoZg59z/PHtBoSQB1nltIm77BtlVeHm7h539wtMJ2NETc66MQae676pZJRN4ZyDcw6tNUryPT7V1LWNSa1rlFUFSgiicDRszo9Eu87/9vEDFssVZvPFT/cHxhh8u72D57k4iyIUVTWMB74QTxW1CQDBOAytQZsEItWkBb01CCGIRgFYM3JWSQnPdYZnyzOQUiHJUpRlhZ12T5RSVFLu9YDWukGrHm1At0EIvpdM99vZ/Zs2svh6ewelFMIgOPiBVUqFVZJgvlweNPZKCHGQsQ5tDL58u0Ul5Q9/TxgEIAQnv6HNi/KkCxh9oU1B6My+agNKiR29Yhye6/au+GrqGkVZIk4z5EUJ06wV1qm8hNb6pLwPXgNCcFxMp/BcF2mWY75cIgpHMMbGm3qu2x3++/zsMcZgNl/gL3/7jKqqEI1GEJx3heGBP8MYQ+D7iMKRNfFsVERtN1Mbg2WcIM1yZHnxJg8ufeFsMsbffXjfSaZ/RlGUuJndg1GKLC96VQx+S3DOrSmrI2AaFcBbO+62Y42TKEQlFZI0AyE2tnk4/O+GNgafv37DbD6HbIx+d97ptfmw+5SjSKWgm5mOp7Iw+040GmE2Xzz7feIkgSNEryIBXwIpFRzB4TriReSYlFmzozhJ9//ezeb3/dUlamDvFXVtDH7//OWn918UjjAOw94d6HbhLY/E7JO20ArY2K/22rAeAtTO4UsJ33NhjHnQ5Tu2yWBd16iktHPnTfffdR1obbuPvIkWPLV141QRgmMiHj6no9EI8+WyKYhPsIwTzO7nvVUCrLOMEyzjBIHv4WJqFXjaGMwXSwS+/+bW400IfN92/ssKlZTfjQObexWw6k5HiM7geBjleVlc18F/+PSxuxd/tmcwzSEhDIImgtnfS2NrYHsopfA9F3Xt2JGAprimlO5Gb9q1+dRpD/yAXVcoscpEawbMHiYlDWxNWVa4m88xiSLMlysUZWaV/Lu+YVv13RftgkDWLuxT28i5rjXseG5RxFZfb/Effvv0pmLayqqCUi8TUSOlnbM6WORf80xexgmicP8dsNu72U9jfyZReLCowWPQ5t6/pfvhEPxo492OCnBu49Os+VsNrUtrBsYoKmkN+tqNyDExdQ2jNVSWgxICz3NRZjkC3+sKBcOM4MsjBMckivDl5hZSKkzPJsh9D0IIZLntCO9jjTwkWV4gy79AcI5xFNq/Q17g5m4GITjGUTQ8h9Ygzf3Xjm8WjacOqevGab7u1qqiqrqRuDbu86k56IH9M4lCTKKwKwT8zLMjybJmxMoa002iaCjCHwlCSDf+WK+p36RU3TospewKAYz20yjwRw2ENgq5LQC0fz93iG99Nss46a6Hy+kUrusgSVNkub0+2P/yv/8f/2XbBADAfklFWe09Cog3nShHCGitT25RcF0Xq1/ksG+CMQacszfjUqyNwe3dDFeX5y8Sg7hKYgSef5ACgHVP5ggDHwBwcT7da7FsGSc/VZpEoxE4F+CMgfPXYcjkOAKMUitLJBhciw9IO1vPmucwoaTzCmjVWZzz70kCR+5A1GjUY8ZYk0NCQBtD2bKquq7kqa0lpwrnDGeTMQihWKxWcF0HjNnN3dlkDM91bJRcs0k9VOTqc7EjJgUWqxiB7+NiegbOOO4XC8RJCm3qg8S5njKUUjiOaHK5DdAc7tdpDy9lVVln8+a+bOPP9u0vNfAQz3UwHkdQjdncz2jvU9HI0geOy3qjlHO7v7PqGorA97qI4Paeoz1K+gG+d/o9x+m6+u3/t5998PbZD2VZIU5T3M7uMYkifL25xU0Tc96uvfxyurvZnNsc1H71ENmGSsom8sLGzJzaPHzgewh8by8z5fPFCtPJ/iPj+sj9fIHA90HJy9z4YTDCbD4/yHt7rgNHCFRSYRyFe+0WlWWFrze3P/z11+D2/xTtz5AOMYAvSusZoJTCKPCbyKJmg14DpjYQQJcNfmxMXSNrTOjaTiNjDJWUKCtrIDRsLl6Gdi1syTjHchWDc4bp2RhZViArik7t17cRAUopPNdBlhf4enOLVRzD9zxMoghcWJ+Arze3EFzg4vzs2B+3d4wC3xoGVtYwUJumIND8eluga40DhRDN3PN39ecpKkFPAUYpgiAApRRxmkH9RJFTVhW+3c0glUJd15ieTQYFTE/oFG7k+8gAgAeSea01irLqCvftc7b9/0Mp+lr3fus3ZBsKNayak3NbpHCEOLkz3ilg11mr5gyDAF9ubrvve119R/6f//f/q//jf/ff7vSHKKVAKUWa5T91Gd0WRwh7cTRdv1OLlcnyYm+Rcu+vr169I2ucpKjrGr7nvYjMLC8KpFmOVZzsXYraypYuz6fI8nyv4wzt3P+PCm7hKMAkirp/fs2UZYW8KLqH3MDLoJSCqWsIzh84E7d+AUD/YooE/x5NJjiDblJshk7Dy9ImB0wnE2hjMJvPUUmFaBSgrKqDGrHuG0ptx20SRXAdB7TZ4A48TXvYl9I+P35V7Gmzz+vm9/LGr2QY6TkM8+USd/eLX34vruPAdRx8ePd6xgvfGsYYKK07pU27dgvx3QeoLRi06qx67Z6llHbnPUZpFwEqmsZAqxJs1YGtIqFTJQzPyYOQpBm01kiyDK7jQAiBNM2Q5vkP72v++x9fsGsBgHP+wFRqX0ilOnXBKWI3BnbW6rnM7ucIR8Gr3VxoY1BW1YvFHi7jBOEowF8/76dA8xipFN5dXsAYs3cvgz++fvvh4d9xBK4vL16F4d/PkFJBCI44TUEJHRaTF6at1psm9gtoDGEbn2KtrVy07Sr0QdotleqKEkX53fxwvSI+zBseHiH4A1+SwP+AspkXn0QRKKO4uZudhAO/aSIqkzQDpRTRKEA4GoFSiizPB9PAR7RzzJ7rdiaeZSW7rvJj1u9ZwTmqSkIpDd9z7ZhPkwM+sB+mkwlqAyitfjoWaYs4EvOlC631oAY4QSilcNa+M0op1reN9l51uqL54zPeuirnR/4dj5u2g/HnYbHJK1ah9v76Ct9u77BcxZ2fwo949mlBa43A9/Zy2G2x1aYaShEoppoAACAASURBVFU2ZubEFAAAcHV5gaKsnj0eIZVCWVavdjPx9eb2RUz/AHt4NEbj9m52kPe/mJ5BKQVtNFxnf66lqyRFkqYoyqevJUop3l9dvvrDsDYGeVlaZ1gh4DkOVknyau+NPrO+iZBKgXMGQb537PKihOsIaG16pwiQSmEVJ50cUgjRuSw7Qrz6+6hPuK4DKRWKskSZVmCU4tOHdyiKci+JOoekHVswTezdMk4gOMfF+RRSKdzczeC67qtX8G1Le3BvR3ME59b4+AfPifa/E9j9JmMULnc6DwECex0NB4zncT6146atieeP9q6mru217dhxqpHvv7qRw7fM4/Xv8X21/uvDwf64ZHkBQoA8L23kN6X4998/QyqFcBT8UlW3swlgCyHESkH1frs9VmbKum7SqW3KKCGIohCLVfysnwulFFLKTtr9mkjSDJNx9HJda2JnlWeL5d7fOvA9UEIazwZi56X3xO3s/od5ypRSXJ6fwXO9V2P49yPKsoQxNRarFa4vznF3f4/zszPMlzama+A4tDJAQgikVF08n2pMXFsJbx/UAOu0KgabLmENlQgwpE28NARYNbnxVxfnyBrJohAcDhdQWvfu2gHw5GdqlQFlWSGKQgSeBxBAKz2Ylz6CELI2ikNACPArxzKbTGL9oZTWUEpBaW2jQGHjB9v3HtgNzhlGjT9AWxh9Cq01iqJEKSsUZQXf84bre2Dghbi5m6EoS1SNkqqsKtwvlhCcQ2uNSv7/7L3JbiRJuv133CafYmBwyMzK6uo7QbhaaCEI+ANCC5CA3vRCaGjRi9YzCBCgrSAt6tW00kLvcHHv7a6qTCYZk89ukxbm5gxmMjPJiCAZQfoPaFQ2h2AwGG5u9n3nO0d+976588nLSwxGabJXLwD3xAM3Vxp8KSk5BmgnDdxFHeEdc8uqflGdzsVqhSSKn+zw7+djsqLY+2M7s6gQy1WGKAzB9yhNXKzWKMrqq5//4c0F4jh6FQcWEhCQwM2WNU2LOI5RNU0fkTPw/IjOxKtpWzDGnGw3jtB06hW/MT+kA521FnXTAI17fqEQCIDekXjgcaGE3FKBhaHAfLECIW7Ex1iXPtG2cq+Gw4+JVAofLj8hiSPEUQRGKcbjUT/CNHAbxlhfJGxb2Y8PfW1EALi9hmyODPhrl1LaG4EOPAzOGc5PZ6CEoqwq5OXdYznGGtdltMBqlSFNBjXAwMBj0TQtFqsV3r25ACUUZ6czzBdLrLMCxrroxIfcI/dyauCMoWnlLefJ/WChjf6uMckhM9lD554Qgg+Xnw4y23Mb8qIEe+JYmVWWYToZP4rR1HQ8QttK/O79W4xG6d4KNdoYzL+hVjifzV60P8TnhKFAWVUIhUBZV93r3oJSl3MqlXIxgQPPii+Ika6l5ww+QyRx1EdjhkIcZLfIFwOyokRRVkdz4HxpRFEISgnGaYrZyRR17UZ/zk9nR+XXUFY1rhdLfLy6xn/87Zdbe5ljMj18KoIgQBgKJHGENImRJjEYpeD8/gaAFoDq0geKqsIqy1HVza34q4H7MTuZ4N3bC4zS5JsJTWXt3udX8wUWq/0rLAcGBtzeilKKy6trWFj827//Dct1BmPduvbQ/Qr93/73/+PnH97s5uhJCAHpMhzbVu4td9IbSmltnDzzADeM34NzBs75TsZGunPbjqPo6KvZeVF2Jlwc9Iki3aRUnTIlwHqPXhWAm2c8m51gPBphmWUYp+leHlcbgw+Xn1xn8g6m45GLo3rhsv/PKUonD15nBSaTMUZJgl9++wgpZe/qLpV88WaIxwAhpJejNY3zc2lbCUYJjLWwxh5URvHn+Fzytm1hbbcOd67G3uV44HHgnCHu5PPL5QpxZ6y7znIYa5FEEcaj9JsS5UPDe2NYWCilwRnDcr1G2BfLBj6HEoJQCFhrwalb00kQPChy1FrbFwTcXsq6fPQjHC19DkgQYDIaIRQCWumvejVYWLRSIkCAqq4RCvFke7yBgZdIXpT4eHWF6XiMq/kC8+UKk85gPisKWFiwbj+yDcG//e2DvV4s8NP7H3Z6otZaNE2LgAR7q2wHQdDlwzJY67Itj3XT9ctvH78qo7ovhBD8/v0PRyux8of/p37+3vn/er74psPtNpyeTLFcZ/j9+x9AKNnLwVNKhcvrr7thC87xux/evUopaVXXLj+8qhDHEWYnU3y4/IS8KHF6MoUQAnleQCqFn3784dWoI44BHyFouzlePz7mY4nuMQJ8EJAgeBHF2GPjLm+GLC9AKcU6y/ZqRPwUTMcjnM1m4JyhaVpkRfFkaTjHii/KuXF/NyKw7dip21tyCM6GLPIHkJclyrL65l6KBAFOphNcnJ0+4TMbGHgZeEPZMBRYLFcYpymWWYa2lSirqvdW2hX6f/5f//fP/8//+/9hFyNAALcylY0xD6rQfg3/S8ZRCNtJSY/RCwBwv0uW7zZ/bq1FVTc4mU729KyeFmvtkx/+feZ3UVW4mi/6XNN9MB2P8PbiHKPOMGdfB3KlFC6v53d+LhQCJ9MJgq4w9trgjOHy6hramL7QaIxB20pUdQMpFYTgaFrZS7jTJHnmZz0A3MjXALgM4gD9+m6MSw84hoKNlxjXjes+k+7e9xiRuAM3bHbJm6bF1XwOzhhGaQKp3CFQ79mM+DFp2haL1Rp5UXZZ3Bqc8Ven6noI3jjQK0KNtaDkJg72IX97C/RmWS7eTkEp3RsTDtyN4BxRFDmTMQBRKL6IfLUAqrrBuhu/iMJwUAMMDHyHvChRVCXGoxGu5wtUVQUhBKSSuF4s++tsX/e4vZ4gCCFQXSxgVpQ7P0ljDEgQ9PFnlFrgSLNfR2mCaSfd2AWpFFZZfpTRQs+hXMiyHGma4LKL/tvnDOAoTfHh8gqM0b11brQx+OXDxzs/RwjBD28uIJV6UYaQD4VSAiNVf/DX5sZtvmld9CYJCCpVo6prNG2L9+/eHsXh8jXAuiIApRRKaeRFCUopkiRG07SwG/L6Qz3M+eflol4lKCFgjIEzOnQTn4AwFM5HpvMDSKIIeVGAM4bxKIWU8mgUAX7NAlznJ4kjvLu4QF66hsFkPB7WrjuglCKJb4oluivKBQGglH6QZ5IfE0BXEPAjrZTSXoU6jAvcQAnBj+/eumjeqoZSCnlZfmFYLJWC1gZKf8LF2cyN9QwMDPQ0TQvGWV/ILKsai+UaURSCEIKPn676r923hwn981/++vP1YrmzAsDjF0mt92e4oo1BEkedbPTLnMpjgRC68wy6H7WYTMbD3OA9sLDI8gJl9XUn/W0ghKCqaiRJjOl4vJfqtpQKV/M5yvruEZp3F+dIk/jVS4+Nsb2appWyP/zf7kDcdoherjMUZQVtDMSBGtC9RjhnEJz3lW3RzfsC2IuK7Kkw3QHCV+e1cdG4/l41dBT3TxLHfbecMYpRmkJwjjSJwRnH6XSKIAi+6qNyqEilsFit+270qpN+DlGn38Z7jnilYdB9DPbhXiMW6EeTdHdde7XBcC3fQIIAQrioThd97F4bvTGW4TwvlEvvaVuE4XD/HRjwLNdrkIAgL0vMF0u3hsGiLKtHv3fRP/zxTz8D2FsBwC+OfiHeh3N9EATQSncSUrfZP8YiAOcMSRxDbUTWbAMlBFJKjPZkOPdSyYsSgnN8+HS1107iKE0wnYwxGY0Qh+HeDuTz5RLLdXbn5+IoujHGeuXEUYi2lWilBIB+g/YtrHWbkLKqutgi23V4jm8deWn4cRYSBKjbFoQEEEIgQLC3Wbenws8oS6W6ohTQSCcv9pve4QDxOFhrkRcFPl3NYYzBeDzCOE3d/kGbW4eSz9nnaNi+0FqjqhsEQYCz2QnKqoJU6tUXgL+FHxEgnSIHAChx63zIxReF4vvgRgXcdV03LVTX1bZwJoLD9eziXzlj0J1qN4kjNO3tHPK6aVHXLThjMMa+yhHGgQFtTHfQd0bonHEorSC7UaSyrqHUdr4mD4X++S9//flf/+Wf9mo+EwQBpFSg3UjAPrDWdguHywQ+xgIA4IoA0/G4z6XfBr8htrDDgfAbrHPnGL2r98LnxFEI0UlPo2g/Ds5N0+K3y093fi4UAlEUYnYyHSrnHVEUYpXlW23aldYoOhOjvCgxHo+G1/UAIIR03gABlNK9SWAcR9BKH4VB4CZeVuzX61ZK1I1zIickQBAEtw4PWusvPjZwf9zBI3brJHFz4rKVENxttE5PTm6ZtG4Wlg7t8L+J1hrrvOjUDQkoJd28uhr8Ar7BjV+AS2JijCIgQTeuQ7eepTXWQmsNKV1BQEoJYw2sOV6Pqn0RhQKEEIxGKcZpCkLIrUKAhXUmglUNKRXiOBruvQOvhrwosc4yMEaR5QXmyzXSOEZeFJgvV08e9U7//Je//lzVNf75H37a6wP7qjtnbKdut4dumCwFnczoWIsAgDuEVF+Ret8H3x0YJcmwCfgKSXdh7fI6fw5nDCfTiTOkJATRHnwNsrzA5fX8zoKQ4BxRGOJsdjL8nTfw64HqOq3b4k2gyrIaDLgOgKCbveWcQWnt1B5S9bO4x6QG2MRuyJC94VvTtGgapw5wruboFSlDEWA3ekVJ04AzhjRJXCQv46jrpltXBaRSB3349zgD4LovWjLGEEUhZCuRFfkw1nRPKKVglMKiu8YCgASui7/t+8AX+qRyRRml9C1jwtcGZ+7aY4xCaY23F+duvdvIKO/9epq2K9AMaoCBl08QBJiMRyABAYIA6zzHYrV+tjE1+ue//PVnztmjFACMdQ7sWu+eCmCtBWPMFRa6lIHjdmvdPZPeWouirAY/gDvQxkC28qtd9W0ghCAUHFprTMdjxFG4l8e9ni/vnPsnAcFkPMJ4NNpLoeGlkcRxrwLYZRPvXaCrukGwp6LOwO5wxtBK2XfrWim7Q5y7pxwzviBg4daVRsruAKGdn4C6GWsZVAHbIwS/NeZDKUGSxGilRF6UOJtN+zi5Y0FrZ5y5XGcghCCJIxRliSwvIPiQvf49+iIjY+6w2o0LJFEEeoefzEMw3dhr00q0bQulNJRW/TX82pJCOGeoqhppkmA8GqHpFFAeKaUrgirVeQgMDLxc/u0//gZrLVZZhuVq/ezFZ/rnv/z153/+h58eJX+WUrdx45xBSrWzhNPnAAvOQClBK9VectefA86dLO1rWe/3xcVoDZnUn6O1xnK938qa4BxxFKIoK0R7mv2/ni+xXN+dp3t+OgPnHON0iLH7GowxBMCt7sK2aK1RVjVW6wzaGIThfsY7BraHUQpYC6UVRkkCSogzcuQcRpujGwu4i83iuD9AWGOglHM1b1vZp13Qoy56HwZ+VMC/7LIrvgCH6QXwNbwqYJXlYJRiMh5BKgXKKLTSQyHgHvhigL+u/GgOpQSiS5zaVnXkjQS1Nv34z2Zs6GvAmwQy5lRdXj25ORagtYYxFnXTDL5WAy+CxWqFoqyQFSUWyxXqusEqy7pGU/2sBWfOWJ/iQf/8l7/+fH46e5QCAIB+jjMUYi9FAD9/xTlzIwZHLB2KQgGl1M6Hl6KoEArRz5sOMmZgnWVY7LHC5s3IolDg4ux0LzF81/MFrhbLOz93NjvBKE2Gqvh3EMIV0fYl5bXW5dFXdY1WSoRcICDBUAh4Rggh4Jy7zbQxYMwlBxhr+gLwMSUG3IdNVYt1HwAhtIvUcmMvvcv5wFbEcYS2ixOdjEeQUmIySvHu4hyUUjRtd2A7gqJA07ZYZTm01mCUIY5CF6lp7VAIeABBJ1333gGUEoRC9LP9u44gaWN6xZmLKnTd8NcU85gmMZI4QhAEaKW7b1tj0DQt1nkBawdvq4HjY5XluF4swChDWVZYZTkoJYjCEHXT7j2JbBtC4c4v52enCAUH/W//+//p5+l4jJ9+/OFRfmDQVTvdAcruZYbTd4HcLJc96sVzlKY7V4R81F2aJKjqeogLAlA3zc7qik2m4xG0NkiTGITQnQtPUipcXs/vvB682dNo6Px/F21M/77fd1W1ldJ5dVQ1iqrGKBn+Hs+JNwn0Ltxx5MwBpVJdTOzTOOc+J5sSYvLZnHFVNy4hZxgZuDdRKBAKN8r19uIcQUCwWq/Bu1xmXwQ4FqRSyPICi9XajQckMWQrh6bAA/n8GmNdYgyl1CkDAmwVL7iJjxlspYSUNwofZxJ6vHva+8AZ6/c3gnNUnVLTwily8qLEKE2GwvvAwSO7IvLl1bWLuezGhOumQSslqrqGOoARM84Y3r99A85Yfz+g/+V//OPPSRztLQbwaxhjIAR3L9aON1RjLTijvSHgsc9I+hz5oty+QkQIQdu2r94srqprwAJKm70WANIkwflshlGa7kV18tvlJermS+UHIQRhKDCbTofOzT0ggevOU0L3nvYA3PgDtFIijiIQSoZNyTPjunNujfNy3bpuXEwso0ji6Khmur8FCQLwzgjUR20R6j0RbrvAe+M7Pyr32uaNt4VS0o9zke69dL1Y3lLm+ftq28rnepr3xh8ey6rCcp11CsxwuJ/syE0hwBUBQiHAO18qa3YbR7LWQmvTKQNcgdMY0zfQXipJHGGUJgiFQFGVYJT1xr6++BYOnjwDB8ZqncFai+vFEpEQ/b/jKEQQBF+N834upuMRfvrxB9RN04/lAwD9wx//9PP56ezRCwDeAIVSAqV2HwWgxBUAolC8iIppHEUwxmw9s247U0TTdURfK95k5rePl3t7zCgMITjHZDzay+NdXl1j/ZXDaprEOJlM9mYw+FrICqeAeSyZlbUW6yxHlheom7Z3qh94Xm5UAS4xIECAgLgY2ih019AxjwdY3ETgOkkyhTWmMy67KYKY7mOuKI7+njgUAB4GCQKkSYIkjmGMwcl0jLfn5xiPUgQkQF6USJMEWuuDVQbcGh+xFk3bYrFaQyk1JJ3sGe9HQjrz2L0UA7rHVUqjaWWvbFIbvg4v7boOhcBkPEJZVbDWNQylVJ0KzyAMh5SLgefFd/I5Y4jCEJwxLFYr5EWJOI6wznJI5d6zh3Jv8JL/KAxBGUUUilv71icrAHhcfBrduUNjrHVhgMGN2eCxL4ppkjjDJ7ldl0FvyMleo5mK7ObJ1lm+F1M4wMlmfv+79wi5QFXXOxv/aWNweXW39D+JI7y9OB8O/1sQhgJpHPeRj48VF+c7E+ss799n+xgJGdgNIdwmXCrZmXe52W3BeZ8HvuvG/LmwQJ8QAOtGvjY3w5TSWwVw3zU89vvhc8I5w2Q0QhxF/aHLGgtrDSwsfvzhrftY50l0DDRti+U6Q1XX4IwPfkE74g0EgyDox1BDIZwSiRAEJNh5TADoDsNKucNF6wwrXbKWU/q8lOucEoLpeAzOed8I08agaRq3n7MY1AADT05Z1bheLDBKUlxeX2Od5dDagAQExlqUVX3LyPvzw/9zecjMphO8e3uBOHKH/7tG5Z+0AOCl+sZaWGN37swEAIyxIJS4hbYz7DlmxqMUhJCtO5k+0khKiTiOX5UbcF6WEIzh03yxtwsujWNUVYV1nuNkMtn5tczy4s74x1AI/O79O+d6PvBg/IFolKa9zOmxM+M3iwF5UaKVEkVZoaobcMZfzXV3SHDG+u63NTcxeoC7EYuui34sh7YgCMAZQyh4P4dsjYU2uusI3n1jH9g/ddNAaY2TybiPaD2ZThAKgVbKo3lPSaWwzvKu0RAMsad7YFOqTzslplftxGHYJ07ssi/xKlpvhK06FQohL2tMQAiO2XTSq2y0ceMRfq46iqJBDTDwaEipQCnp/3t5fQ3apawsli5ZjFKCq/kCZVV99xz7lId/3/R4//YN4ihCXhZudPUr18uTt62CwMkzQyGgdpTramOcW2/TIo5CKK17t9Zj5vRkCsDi0/Viq+/3FeNPV9d49+Ziv0/ugBGcoarrvR38kjjCeJT2UuJdu7yL1RpX8y//piQIwBiD0WbYzO8IJQTv3lzgb7/89qQ/VyqF1TqHse69d71YghCC6XiEMAwxSpPhb/tEMB8Ny9xaaIyB7Q5nxjpprTfKs12H7lAke5tQQvq5f6mUm/EnBP7Xewmqt2NilDpjVikVyrpGAucJUtX13hRnT0lZ1a67NV9gMh5hOhn33euB3QjF7aKKHw/wpn9a6Qc3wD5fo/x4R9O2/RiCtXYvCUWHwMXZqYu5XGcIgsB5JnFgvlgijqLBJHlgr8yXK0wnY3DO8Ol6jlZKvDk7w4/v3kJKhV8+fOzX+cfwm9oVQgjOT08QihBlVeH8dPZdxQz9wx//9PP/+r/8z08qYRWco2lbMOpijXbBWOtkbNZHeNkXUQQQQuw0DiCVq15VVf1qxgGkVCir6k5zvW0QQmCUxlhl2S0p6DZUdY3Lq2voO4oTk/EIb9+cD3LMPUGCAHEUoaqbJ+vKuYPklxs0f/1med4rc3zREsCgEnhkfGfOy+SDzjAyDEU3MqBcIWDj6w/pUO1G5QJEYfjFczuk5/macNFObiQsCgXSJOn9e0IhEEfOsHHbe/dT42NPV1k++AQ8Er5Dr7Xu4zs33bh3VcPqLlHAaN2NCGhwvtu44iHg0gLSfrxLaQ0pFeq6cWaMO45kDrxupFSd6aZGVTeIhOjXcsZcIWCV5biaLw56PU+iCOenMyAI0DSN+/c9YACepWIYhSHaViIUHM0OzrrWWiilYSn6eBZviHTMUELw4w9v8eHyE1Z3SMbvQ1nVCIXAh8tPL14JUFY1OGNfNdd7KIw5N9qmafHm/GznxyvK6s7DfxJFGKXp0HXZM2Eo8OO7t/jw6ROkVM/mCm+MQVFWEJyjrOq+KNC0LQIEqJsGaRJjNp12efeDl8Bj4Od1vTzXb5gppQhIAN4drpXSvSrgOc0DvcEt70YWBg6PzQ7k2ekMjDIYa3B+OoOUCuezGVZZhlWWP/o40j4wxmCV5VhlOUZpgjdnZ8N6tEeCIPhCGWCMQRw5Y2ypdK/e3FaRZAGobjxAKg10Y7E+wpAzdpR74ySOXLqLVFisVpDSjbHE3dll2D8N3JemaRGGAk3TIi9L1E3TNaUbFFWFuq5RN+3Bq7o4Y+Cc4Ww2g5TSGRM+cL1+ttV9c7NrLXaqrujOzKaqayf/5Me5yN3FxfkZJuMxfvnwcatNhH8Tv/QiQBgKVNX+5P9pHEMb/UVXdxvyogRn7IubuuAcnLNByvZIcM7w/t1b/MfffnnW52GMQStl/97sbyzWPcfpZIyyrkEIgS400jh2+dOUwGgzbML3jM/25l2RTxsD2G7GljoVmbUW5ivqET868BgkUQTG6HDoPzIoIRAhRxxFuJovkBclhOB4e3GON+dnuJovcL1YPvfTvDd5USIvSkzHI5zNZsMa9Ej4fSrr/AKAm/tD27qO97b4+43pCgKU6C6JiyIAegPDY4JzhvEoxXKVQRuNv//6AeenM0RROBQBBr6KlApN26JuGnDOEYYCWVGgquvezI8zho+frp77qX4XQgiMMfiHn34EJQR5UW51+Ae6EYD/4b/8d4/wNL+PX/wE572D+7ZobXoDNbd5MyDksOSc2+ByoBmSOLqZg3ogWrvKclnXSJPkxRmo+LiY5Xq9F5lOKFxURhzH4IztJDNrukricp3dkqMTQjCdTHB2Ontxf49DwueoF2X1rHPemz/bR3YGJAAJnAqgqhuUZYU4DqGURllVoJSg6HxSjB4cux8DHyPoD92cc4jecM+93pQ4k1nGGGhXPNhnR5d1PzeNI/Bulnfg+BCcgwQBkjjuEn2cQehkNEISxxBCYDoZQSv9bIqkh+IjBF26ymAY+BSQwN0XwlDAWoCQYC/rjVfLSimhzc3++Ni8RDhzRYBQCGijnaFl2w6NlIEeKRXWeYairMAZR1FVCIVAWVWo6hp5USIUHNZaFN3HDr3j7z0+rLX48d3bfi0WYvuRrWcv6xLi5E9RFPYS2W1R2pk7GROA8+BFjAJ44ihCHEWIoggfLj89+Pt9jMx//O0XvLk4wyh5OYvlvroTfmP/jz/9iMura5Ag2PmmQgjpJd+bnJ5Mna/AC3l/HjKjNMHv3/+A//zVGQMeghzXHwD8MYB33R9vkFp3/gXTyRjrLEcURcgKN97i1oEQbdsijl6G4dOh4ccFPpfs3oXfQLtZ6gbGGOfWv6FsoxtRQL6w4GX+Q7f/5cE5+2J0rG1bZHkBwTl+ePsGq/UaZVU/0zN8GJuGgW/Oz4bD1iOyuWeNoxCtlODUyX1lN5Z41zjhffFjAkVZgTEGbQwE50cXPxyGAjMyRdNeoaob/Mfff8W7i/MhKvCV4s1Z86JA20oQSvD+7Rsslis0bYt5Z8wMuIbxZTF/5mf8fTabDeM0wWQ8RhBgb/u+Z1UAePwhSXC+k+QJuJkF8tWS3hH6hRCFAuM0xTovtiqW+JlkQsjRLfjfYp1nWKzW3//Cb2CtRRSFWK7WOD+doaprJHG89eM1TetmKtfZrVGCKAwRhhyT8Win5ztwfxijmIxG/diFzxk+FLxbfd00yMsSUikkcQSlNBhjiEKBSIQIhcBvl59w0sUkrdYZgKCPexl4enz3LAgCCM47BRHvN9VxFCIMhbvuhUAoBITgvXP3wMtHG4OQC4zSBBYWQUDw5vwM4zRFEAS9Su/QMcYgy510ljM+jAY8MkEQ9AolrTW0vol19mvHLro2Y4xTBminDHBxlsczdkapS9pBEGCUJJgvlyjKCgFxa/HAy0cbg8tPV1is1pBSIhTCGaDXDeqm6QwjneGvN/w7lshWay1CIXBxduq8Zbp94b44mKs8FAJ102CUxCjK72crfg2ltbuhtq2b8excV19SlyUMBX7//gf88uHjVlJCYwwur67RNA1m0+lRV0zLqkYSR1gsdzv8e85nM7TSmYTs8rqUVY26aVCUZR8NB7hObxQKnJ6c7OPpDjwAzhlGNMXqtxyjJEFels/9lL7JZkHLRwqWVQ1tDMrSydZCIbBYrdA0LTjnqKoap7MTUEJ6s5uBw+GYpLYD+4NuxOtpLMZ6TgAAIABJREFUY5DEEZqmBeMM0/EYUinMTiZYrfODl6ICXhHwW+fSnmA6Hg9rzSPDOkPQVkowFiAIAKU0IsagjXPH38W41KsK3OHIQnCOVipEXWLKIXMyGQMA4jjqRwIayob35AtlleWgXYoP7fx8CCFYrJyqyo/reYXVsYxcbZLEEd5dXDjlj1T9x/bJQSgAgBuXZhdfR3dWAnhIQIAgeHFSa8YoJpMxtNb33jCQDRkq4Ob7sqJ0UuI4PspZdEIJSBDg8no3OQ9nzM2UaQVjzK2Inm2YL5eQSn0h8TyZjIe5/2eEBC5SzVdSq/qwlABfw1qLunFjAf7f6DqHWVHg9+9/wN9+/Q3GWABO+RSQAB8uP4EEpJ91G2Z4BwaeF99dDUiAPC+QlyXiOIbsxkUm4xE4Y0dRCPCqpeU6wzrLEQQBGimHdeaR8IoAf+Ax1nZR2M5kmHSxpzvHCmpnXBt0//aPe+i4COAQWhvUdQOp9b3GuAYOF2/gl5cFlqsMWVEgAJCXJbJu/SyqyhXGupQf/79jJYkjvDk7Q9U03Zjg41x7B1MAAG4ym5XSCAXfuWrjDRP8jOYxLGAPwc2op/1NuP/4Zwd9/zFjDEIhkERRP5tqrXXumHXjYmqO7MZNggBX8wWatt3JP8IYg/dvLwAEmI7HOxn/6U5Wt1itbz2nUAinuBiya58VxijSJIHgHEkSo23l0UjCPMYYyA1vCT8SNEpiaGNR1TUoIYijCKt1hiSOwSiFVBJ5UTiVVed2P5gLDgw8Pb4YCbiZTiddpX3m9PnpDKM0hrX2aDpYeVG6jbeFM7QcCt2PRhAEfRSY694H/X6XEgLKKGB3yzEy1rrIVKVg7Y2XyaErmYTgLiLQAh+vrl6k+fVLRXdjRnlRoKxqfPh0BSklKKUoyhLWAkVR9e9Dv3ez1h7Vof/zcxohBCeTMd5dnCNNEmRFgelk/Kjv24MZAfAQQvrDfyjEzlVw1c1MtZ086iXOBTlTnhSf5nNYY/s5GN3FvwA3xmeUEiitMUoStN3MFwkIRCgwX66QlyXev33znL/OvfGymF3jlUjn8r1cZTDW7DybTwlBVhS3FqNQCLy9OBvmtA8Izt3myXYH5l09JJ6LTaOYVZb3H8/yAmkSIwpDGGtwNV+irl1FWXQOuIQQaGP6yK+BgYGn5XNDvX/+h5+wzjKs1nmvTIujCHlRHrQqwK9B3jCQLZYIBcfF6enRNRaODcE5wNEXiyghaFoJwgMYY7uoU7u1MsB0qrO6acAZ65UIh/53DUOBH9+9RdO0yOoa4/HoxamBXwJN06Ju2/7Q//lB3q8pgCsQ+Jn+lwAhBLPpBLOTKdbrvB8Re4pri/7hj3/6+fc//oDpePzoP+y++JzmG1f/Has6Fp0rs4sHpJQcfAXzofh81PEoRVFWTuKcxBinaVcAcR1/qRRIEIAyutEVdMYYFu51yvICcRg9muxkXxhrQCjBfLna+jF4J507mU7AKMXbi/OdKm7aGOR58cVzevfmHOkOhoIDjwcJCLTROD05QXXHzefQ+ZryxVqLtpUo6xqrLIfWBlHk8mLDMISxFqssQ1U5U9CyqnG9WGA6HqOqayil+nSCgYGBx4cx2sXAEUzHY6RJgsl4BKk0yrKC6TaHx7D5dSolheU669aS7eOqBu6HH6UlhPTGgYDbU3POnGNgF/23LcYY6A2JdSslCDlshS1jFJRRzBdLMLrbeOfA7kipgAAoywrz5RKf5gvUnWnf996bx9bp/xqMUsymE/z0/h2MsciLAifTyZMqhOkf/vinn//5H37C+ensyX7ofQiCAAgAuTHXsS03IwABlNZ9BfMYpEwPgXReByfTCay1WOcFCAlwejLFZDx2DpjGQHXKgMl4hFEa4/zsFG3boqxqUEoQhaGbuSlKZzITHmZagNEG8+VyJ0d3nwN+fjrDcp0jibeP5suLEpwz/Pbx8ovu/+eRUAOHA6VOKs85w+xkCs458uKwDQK3wcJ1h5q2RVFWUMptDpM4QhAEfbyMd9PN8qJT2QQo63qY6x0YeCIYo0Dg9i6UOoXPeJQCcPeZJI6ceudIRpeatsVynQ3pAU9IPyLAGGxn6ic4h+p8tsiOhQCvNnB7HYu2U2QequE2JQRpkqBumn62euBpkFJhsVoBCFDVNT58/ISr+aLfYxh73DP7D2E6HuEff/oRk8kYsG5cRQiO5Bl82Ogf/vinn//xdz/i7cX5k/7g+0A6mZE2BnzHiEBrLQIEfaXSxWsd5kK1D5I4xmQ0Qt00WK1zSKXw9uIcp7MTWOskz3nh4sbSOMF0MsZ0PEbbtq5w0N0cpFKo6hq2e6MeCnlRIo5C/P23jzs9jhDcGS41LU5PpjsZxrTdTPZ6Q4bNGMNsOnlRkYsvGSmdfDIIgoOLCtw3WmuXKFC5taCqG7SthIXLnz4/OwUsUFau8/jh8gpN24IQCs7dNVM3zUGtCwMDLwUSBDeRb5QgQAAEzqMmjqJ+wxwKfjTFAKkU1lkOSgkYZUCAYTb7kfFyfVfkdU0ibQwQuP1P4CpNO3kFaG2cX0DXXLLWgh1oIUAIV4DK8mIoAjwSZVWjrGssVytczZe4mi9Q1TXWWY6yqkHIjbJ7t3fecfHuzQVmJ1PMF0uUZYVRp9B+Lugf/vinn6WU+G/+6//q2Z7E1/DGfYJzGO0WrF2qRMaY/vBPKOk3+i8VSglGaeoUAQCauu3dhd+enyMKQ5RVjeVqjSAA0iTBKE1xNjuBBZDlztXXG6iscxdRxCh79vGAT/M5SODGFbbFbzzev3sDKRUiEW5dFMqLEpwx/Prxsq+qk4A4N8/z062fo6dpWgQkGDZLjwylTjoZRRFOJpMX4Sj7LbxpFODWW6UULICirLBaZ8jyou/WXZydwgJYrTM0TdPn3jNGcT1fwljjCgiDseDAwF7xxYAoFKiaxt0HggDnZzM0TYuiqhAK4RomR1AIqDrTYaPNwc+RvzRIF5vm0wQ4YzDGJQnsOnJrO9NAay2kVLA4zEKAM+Ac3ncPQRsDrTRa2aJp2r7wn+UF6sbN73+aL/Dx0xXWWd57lny+Hr0UCf9DOJud4Mcf3qIoS6zWGWaTCaaT8bOfoxjgsjMPHc4ZjDVgUYimabc2M/HGccYYBAjczN0Bzy7ti0knHwTcRl5KhVZKTCdjNI3r/F1eXWOUpkjiCNPxqM8ddwUCd2OYTsa97Esq9YWB0VOyyrKdvt9Yi2ma4D9/+Q3pjqYbcRzher64tbAlSYS3b/ajrGFdx3XfOaADd+Nzu9+9uUBelJgvV6jq+vvfeMT4964veFDGgMC6cQGtexMeYwzOZidYrFZOJZG5zp6FRRSGqNsWi9UKhBAkSQw+5DEPDOwNb9apjUHTtLg4d+ayo1GKD5efehO4Q/YJMMb05r1X8wWSOMLZbDaMBjwR3isAcAeyOAohpeqN/Zqm3en949W6WmsEcMWrQx0NGLhh8x4PuGKRlBKEEBRlicynfAx8F84YRmmC2XQK0nmrJXF8UOP2R7PaunQAgbKuIYRA225fBADczbOoKjBKwRhFKMSrKAR4jDG4OPuyM900LeaLFQICtK3EyWSC9+/e9E7h68yNE0zHo50c7X0hBnDyRqMNOGeo6hpSKqRp8tVZfDcDGePy6nrrnw+4C3Q8SkEJ3bkI1jTtLRf5k8l472M1TTsUAJ6DUZpglCbIyxKXn64PemO9D/wN3v+e/na/6UD+t19/QxxFiCOKppEwxiAKQ2caqBXiKOq9Q8q6RtU0MEZjnLrDi1dgDQwMbAcl5OZ+EAT49cNHxFGEtnWRWZzzfp90yJt2qRRWWY5VlmM2neDsdDasDU+I3/f6Iq0xBpwxUEqhlNpp9NZY2++zXbczQByFL1p5e6hIqW7u6dZAaxclHIUh8qK4lSA0sD3T8QgX52dOAdE07nriDCeTwzHa9xxNAQBwC1XcGdQlSYyqqrv80+1RWsMY48zuovDVuF5/rSO3+fHJeIy8KPtOexLHeP/ORQTmRYmyrsA4u9fNerFagQTu66aTMZq2RRgKGG2wWK8xHbmDgVT6uzF893EK/R6EEIxHKaRUIDTY+WC9WYwgAdn7VBPtRmG2Ybla42Q62fMzen2MkgTxTxGKskJZlq/+hlnVNaq6dq7kUuGXDx9viqjWIk0TKKUhBMcoSWAJgeqKA2VV9xnWUqpb/x0YGHgY0/EIozTBokufISSA4MLlZ2/MfR9yIQAAFqt15+8TOU+eQTn05BBCEIYCVe08cLwJt8XXE2e+hzee9rntQvCd/JYGvo6UCqssgzHG7bOFQBiGuLy6Pvjr/xghAcFknHbvaXeGrKoaSRQdfLQyA3BUXUVKXXxd07SI4whSSjSt3OkxjbUwWvfGcr76+VoJQ4FVlkMWBTjnvYSlqmpczRcA3Kw0Z86bwXfvPX4jX1Y1wlCAEoLZdHrrZ/SjAwx4E94oETZHFb6G6YzLNvPPH4qPKHLuyrtdpIvV6lZ39O3FGdJHGI2o6hpp8rAowevFEpPRqC+U1XUDwQcX5m2hXREyTWIQQrBa5zD2dd9UvWwQuFEPcMagu+Lqap2BUermQguFvCiRJgmUVm5daRpwzpCXBUIR9h2osq4wGY+HbuDAwD2ghOD8dIbz0xlWWY68KMC6We+sKNy+5ggKAVIpyDzHOs8xHY8wmw6FgOcgCgWs4N24pwZgYe1tJdhDsdY6RUHr9olRKMBeSdNtn/j9XFFWCDlHUVVoWze2sXk/BvDF/x/YDX/u4IzhzflZf5bxfxPqIzePAAYAP73/4bmfx4NhjKKVEpxzWIs+535XpFRuJuoVFwAA3KpclVWNpmycZwKlMNYiFGE/Z+g36K6bfvPmf4ybtpSqjyrbhbPZCQAgTeKdRhnWWY6r+bL//4JzxNH2UYLfgjOGvCgf5LvAGHObvaD7OzYtxNQpCbQxw+FqC/z7+835Gc5OZ1itXLxVXr686MBtkUrdGpW4XiwRCoEoFNBaY75cghIKY90cc5bleHN+hqZ1RqWtlEgiV+iVUoIxdksB45UEAwMDX+I9fHz8VihE72myytx65Q8GuxTSHxs/GpDEEc5PZ8M1/4T41ABCbub3ldZ9YXeXEVw/VuCiuNuhEPAArudLlHU1HOyfCWMMQiFwfubWo6v5AuM0Pcoi5dFecZRSxJ00iXMGxuheLggfYUKC9ij/oI9BEke3VCJlVSMrim5DbsEZB+Psi6rXYxwu87LAjup/JHEEpTU4YztvKLKi6DdPQRAgDMWjVf+qukb0wOc7HY9wNV9gOhmjrmsEQYCyqhDUAT7NFyBBgPEo7W/ySRQdTfXyEKCE4HQ2BeAULtoYrLMMi+X6xXsFPJSmbb/oHnHGQJmbD12uMzBGMF+ucDqbQirVj/uYLlZquV6DUorpeNy91m5ueGBg4Es4d10qwB2mvVptlCaIowjXiyXoRkfrUNessqrx28dPODudIRJi2Js9MX5mnzOGIHINN8E5mlbu1HzzhQBjDIIgwChNXr0/QNO0yIrilumw1mYn5cXAbvjzTxSGmIxGCEOBsqp71dWxcvQ7fUIIeBCgbSVCIfoc0l3QxqBuGyitEYXiVY8D3EUSR/387lMTihBNu30+eygEQiHczSZJdpo7zvICeXHT9Q2F2Lvx3ybj0QhZnkPG8b2f8zrL3SxY0+JkMsG///0XAG5uyUvXvRsz4K6ndMPrYeBh+HGX2XSKsqqxWK1uvUc8h9x1e0q8UqCub65pQghWqwyUEgSEdI7UBQpRuo6R0jBmBc45VusMZVlhPEqdkSslKMvKpZV0Iz73OSwMapiBl850PAI2lH1X8wXGoxRKKRBC+nlhn/BzaEil8OHyEwB3r52dTA9+xvYlwhgDY6yPcqSEwGzEyW6Dl0+v8+JJCzybsu1teagqc/Ne49OF7tojDDwvnDGcnc76JppSCoxRsG7vfUyj81/j6AsAgKtOcs7ArIWUAQISQCm904JkjIW0CpSS/nEopa++Oul5ri5x27Y7LZazkynybh5SaoWYb38RZ0XR/zsUArPp5FEPEYQEqBvXRb3P66+NQVXX0NogLwq0G8kLX5tbN8YgKwr87dcPeHdxPqgBdiDZiJasqhp5UfQxOsPh/+sYY74YpxiliUv/iCIQGmCxWveGg5QStFKiqmtwzlFVzpwwjmNQSrC6ciamcRS52Nfgtus18DhqpYGBQ8Z3rpqmxdVigdl0grws0e7oqfQUNG2LD5efcN0VMU6mE8A+377kNRJHzq8liEJUdQOtNbQxO+67XfGJc/YkqVxKOpVZEsco6xqjb6RPfU5elN3+SiMvCqRJgrppkCauGNC0DUIR3jooSqmQFQXiKHSm5lGINI7x5vwMn67nAJxP0yEW4F4qm82YUIguBt059oehQF6UmJ1MX+Qegf7hj3/6+V//5Z9wvVgetZTBzyoFQdDljrqu/S5zSgCglO7fHBY3c1EDT4+UClEU4uOn7eP/yqoG526eOI1jMLaduuPjpyusOxd4SimiKHz068do40xfBO8j1r6FVhrXiyWqukbTtlAPuKlo7Vx/H2o6OHAbEgQg3ZoxnYxxNjtBEsdOShlguNHfEy8zlUr1BxTbdZ2kUqjqGq1UKEqnEqjbFkVZddc4Q0Cc4qVpJcqqgoUFo84foyhLSK0gOO83sG4MbFjnB14+jFGkSQKtDQghqOoGJAg6f6XdOruPjTEGVd1gleWw1iKKouG6fUL8fphS0kV1cwRBsFOB2xiDVkoECPr742MdvhijiMIQlLq8+6ZpQYmPLLxBG4OyqnofGikVhOAgnalmGIa9Tw1nDFEoEEcRCCWQrQRjFL98+Ohk49T5l7WtRF6UyMsSV/MlmqZF28qhOfDExFGIyXiEt92olLUWnHPEkdtjC8Ff7Jry4sqllNI+v9QYg7C72Ha5iXlfAGstpFQIBYexdutYtoHt8MkCu3B+eoLV2hmO7RL56JMnCCHgjD2q9N9T1i46LXjAzXDbcRhj3Q2vrOoXIXV6bjY7U0EAjFMnvf3n3/8E2a1Vv11+Gm7+O+BfO79pJITgt8tP/TqdJjGEEGiaFqt1Dmtdxb+VEkQTNLS9pYxZZTniMEQUhS51JAgQEOIyrQkB4wxKqmEeeeDooYT0MubTkykur65R1Q1m0wmUUgcfeWqMwWK1xirL8bsf3qJumiFB5AkhhEBsvNas23dvW+C21qLsZuC5dukVj60IGHcJVKt1hhFNkeUFAri57zAUt0ZGOWdomhZJHN26F2hjkJcFtDbQWiMMQ8RRiMVyjTgKsVxlt5SjA08PIQTjNEEcxxilCZrGGQ8TSjAdj1+ViujF/qaMsdsS0Vbu5A2gjYFuDULB+4KCmwlxMTtPIVd67ZRVjevFYuvvdxXqEKPUoChKJxvcAi/9IgGB4Bxns5Mn2WhIKaG1Br+naoFzhskoxXKdbfXzmrbFL799RJrEuDg7fVUL42PijScvzs+gurEMqRTGaQIhBNq2RRzHaNsWddN8s+g1eAl8Hf+6ePVAu3L/DYVAQJwZ5mK56u8Ln+54jBWyr77G07GL1xwliVN1dNeHT0MZDh8Dx8qb87M+TzwrSiRxdBSu48YY/P23j0jiCITQwSPgGfBu/kJwNI27h+2aGFA3LYIggOCPH9E9nTj590nnI7PJ5h4oDAV0NzJprYUxBmmSIIlcRPCtrxWuSHx6coKmadFIiXWWdaob112um3a4lz8SSRxhlLq/zWbBXkp1q8H12u7ZL3pH7w/l7uAnQLXe2UmzaSUCeD8AoG0l2sAZEO7SUR74NlKqviO9DZwxl39sDaIw3PpvdTVfYL5cAQAC4rqKDzGA2RULi6Ks7pVe4CMtd8FYd4Nr2ha//937V7dAPiaUENDuZpTEkXt/agOkKZRW4IxhMhpBKtdZWCxXvVrAbygGZ+CH89DXbHNTtlkMWGU5CCHIi9KlGVAKQgII4bpFgvP+a4uyQkCcYVaaJm48IYldlKp0RohhKLDOMkRhiKKsQKkrWAIvw3Bo4LjgnOH8dIbpeIy8dF3LYzikGGOctLoocT1f9EZeA08PYxQTMULdFQK2wVqLpm1BgqCPhI2j8ElGcb/X9KCEOIWAEMiKAkVZIgxDLFcuBSjq7u/+DMK7e4K1FpwxCB4gK8oHjWcOfJtQCFBKEEeRG/Xd8HX4VkHnNfIqfvv+sCcBY9nOBoEWN9Jq2sWnya7L5DOsh/GA/WKsAd/hNbXWuqg7QrBaZ3j35mKrx/EFCFeNdk7ET0XbSgQB6SvG30NphVaqnbvE3lvjP//+K+Io3Pq1G/g2lNx0jTdvTIQS5EWB2cn0Vkyj7tIdyqpCVdf95nzz7+2LoIe+aT8WPn8dN8cOvNy1rGosV2sA7vWPQgGpNCIhemmrVhpKKhASwBj3sSgUKMoKZVkD3ZhIluc4mUywynIwSiE4B6EE1/MFOOdIoghXiwVOT6aoGxfvBuveM15dssqy/mulUl84vUvl7l2T8djJITmD0eYLh+xN9+rNzzHO7vwaz5CwcNxwzvpkE20MrucLLLr396HjkwMur64xm04wTlOUdYVRkr76zf9T4Lv1ceTm7Jum3WEs0QLWwkgJKaUz7DuAhK5RmvSz/cYYKKUwO5miqirQbs1e53nv9n9XFO7A/dnc3/g0sjiK+nvct67r4Zq/zat6NbxBhzYGddN8UQ3aBm1uNkoA+g1UVTfgjN4yJxzYnrpudhqzEJxj3HUBtn2cdZZDad3/TSfj0ZNtbP17zBnR3O+yFUIgCsWtPNltMMZ0FXgCShmu5gtMJ+PhxvVEcOY24IDb0F7Nb8ZgvFvtZDTC+3cpqso5GS9WKxBCcXl1DUoIpuMR8qIcTAefGGNMXzSUn+Vl52XZKzm01v3nW2MQBMByncFai8vra2deyhiSOEJVN2CMomlb5EUBa9G/J7L8Zr7UwhkZam2AqkaWF9BaI0AAdLcjQkgvX12tXWTojYGugTEWjFIorUAJhenMERlj4IzCWtfl82aMvBu985s0RmlfuA1DMRQCjhxKCN6cn2E2neJ6sehTTQ4dYwyuF0tcL5aYjkcIAgK5ln2m98DjIzh3iielUNXbRzlba2GBfjTlEJptnyu0pFT9em6sgbWA4AxCONPAzY7/cE9+GFHo1NaT8XhQxu3Iq9vBB0EARinSOIbkN/nT1tqdEwO8MZxUqnONFCBBAMoAWAvdbYgOoWp5bCit0e4wg+g6XxxFWeFsS7f++XIFrTVIEEAwhpNuVuwpUFKh7W4UdXM/CTMlBEkc761bwzlDXhQYj1KU1cMicwb2A2fsi7SJ89NZXyDSxkBKhVGSwhiDf/zdj+CcQUrXlZBSgRKCum2hte6LQ8YYaN0VerrD2+Av8Pjc6gZ90Rm7XTCQG2ZsrXy8qLbPN6R+s6rgnp8bd6NoWunMvtqb994oEa44wNlQIHzBcM7w7s0FLoxBVdUoqwqrLD+K9WKV5VhlOabjERophwLAE0KpWzeiUEB2pnnbYq0bh6xJ48apDmhf7cdnPKMkRVa4AmwUCjRdOtDnagAvXz+GUZvHwJtq+9clFAJCuMZtKNy9ZSgk747f973aO7STcHMIzqGUQiulGw3AfuSyxtpbM0+k6xpbbjtDkxt51FAU+DZN04KQLxfL+0K6MQ1jLOiW5lyXV9f92Ahj7Mll8DdFJTxITbJPc0pvVCeVgrXAUq1xNjvZ2+MPbI9/T39r1tV3kbOiQJrEsIwhjZ1hkVSq9yFwUUik37AAwDovXuWGZMB17m5UbBZRGAGwOJ1NnYJhyF9/tfj0gFGaYDadYpVlSOIYf/v1t5uvobRfRw4JXwi4uma9T0DTtENB4JFJ4qj3sSmruk/Z2hZtDNZ5gahz3D9EOGc4vWNc1KuQm7btivcSSqneM0Aphbpp0bTtrW73MRhyfo4fhwPc700pRRSK/uzDOUckxBcGigP7QxuD+WKJMAzRtu3rLQBswhgDY6yXOgNBHyO4qyrAY6yF0frW/BMl7t+yk2E6ZaY73LmDqpNWbjpK+3lKbQwC3DiuvmTKukIoQjTtfKvvP5udIO6ivLzk9iFoY5DlBZTWYJ0M96kXKKnkLd+J++JUAPtxcDbGYJXlboaYmd4A7SlNEAe2g3OGKXfFgbtkc/5w799brOtg5EWJOI5wfnYKwBXjmrZB07SQSh3lRmTgbvwGzc9T0u7QH0XhUXRcjDEoyqpXr1Dqnv99DFMHdmez6/nm3K0XeVEe/BrhfQKu5wtXyCDT4QDyyPjGRBJHbhxX6Z0LzHXTgBICIZ5/JOC++PfZ995vTdMVCJRC0zQuDjoIoLS+NQ//tXuyVxZ871qcjkfIirI/Y/i1NPpKUYx3Z6eb38d168uqgrUWQRD0ZrZhKGC0+e7vuosqZODrrLPcnRuDAPPFEs1mAeB8tp0s+iVBCOk3C0pRKK1BAgKlNZTaTa50F5uyXU+AG5OLFq7ra1vbd30ppTDdxuY1HP4BgBCXuLANURQ6hUfrKqrbHFav5wtYuL/BKE1w0R2GnhJjLKxf6B+wOSGU7F2Kq7WGVAonkwma1pn6POU4xMD+2ex6bRYIRmnSr095Ud7qUIzStF8vozDEKE1Q1TW0NiirqveNQHB7Fn7gcKCE4GQ6AaMU2hicTCeuM0DZUR2C3PvtZixis9huLTrfFueH4DakQ5f3MfGeJbOpGztarFa9B4lfXw5tPZBKYbFaY7Fa9wZzjFIX8cmO63o4Fkg3piiVG8fdJaobAIruvhOG4iC8AXZFSgXOWX9/llKhbSVm0/E3lSqbyTJqY9TibObWys+ZjscwxuDy+hpJHPXrYxLHSOKofx7+sbMiB6XsC9O9sqpBCcHsZOoSjXB7v3qfQvIxFJuPjV8/XGI8StE0DYqq7sf6+r/M2ekg5d2EbVS2mKFQjLoiQPemtt1M/76xQO8VAGsRkACCcmije0fRxzYU9FXjL+TvAAAgAElEQVQ/T9tKMEb3Kid/ENb2s68PhVHaVTC3k4ZJqVCUFayxCIVAGsdbPc6ubC7aD5HLccYQhiGw5et3F/4mXVYVGKOIw9s3iIGXxffGC7QxUFJBSgUhbmKPAGcQxxmH0hpnsxmatgFnHHXTIApDtLJF20roLrprYD/0JnyMQXTz+F6K7bsAs+kEZVkjSSII4TaKdKMIfgyozlDsWweHz0fHSBCg6XxUGKMQQrj77cCjwDnDm/MzvDk/w/ViibpuDj6+1K9FnLnUKMAiDAUm4/FwQHkEOGOgietQK6Wwi+5WaQ1bN71Z6THz+Z6Kc4aLs+83azm/KVjRzwoF3zLO++n9DwBup7x8/jzcOMPd58XNxx6uk8Pgar7A7GSCumm+OEcxAPjXf/mnZ3lixwIhBIIQCM4hlQKjtMsmlbDWmWeZzkl5W/wGxGdF+5nLx6xiNk3bjx24zSKFVM7kzm+o3PMApLKghMAC/fN7KqRS0Gq7yvCmK/U2B9SPV9fO+Z8EOJmMn03u7t9j2zAZj3A1X+x9hrttJSglkErieuHylgfjr9cHJeTOTYbfDGhjYLTpXOI5wlCgle4AkMYJgqACJbTrOgRo2xZCCHDuZI5tZ1jocpVDNN4gKTiOXPJtEJzfafTnTZICEiDkvO9oT8ZjNG2DUIR9t9KP53yrOLd52P/8b3jo1E2zlZu4hSuiBnDKACkl2rZF2M2fDok9j8emZ8zVfIF1lh+0C7oz3sxACEErVe+jMpsOYwL7hnR+ElIplGW10/it7hRnh2YOeCwMh/eXQdO2SJMY8+XqzgbLsII9EH/AcbOFrqvsO7KuKNCCMQa9YSiou+g4bUz/tYSQvjstOIO19lGrlbYzJRScu+hCbW6ZFAIAvrKXCgLnTODjV7xpYRSKRy8ESKkQReFW3UFfvZ9Np2ja9sE37KZpIaWEtRahCDF9Jpm7N0zxPPQ1bx+p22KsQdtKJ/MGsFiu8Ob87FF+1sDxQonzMNm8/jY7CJtSxiwvME4TlHUNKSWSOIblHNZanEwmoNSNZMXcZdq/OTtDGApknQmU821xplBpHKNums77wz2GN5wihMAal/xiYQHrnPV9wXDX6My74J2DsdbGGS5q7QwYpeoLsUEQQGuN09kUSmkIzpGXJYTgSOK4n830r+smn3d2fLHyJR1UrLX9/2BdN/+hB4VeQRUEbv3q/ALKqu4kydFQBHgCzk9nmJ1M8enq+uDjBI0xqOoaSRyBEILleo3T2clwUHoEOGMYj9Le/G5btDF9VKCfmR8YeA14s780SXC9WHx13Orl7AyekWDDnd13VHyhYDNOy0cNGmPAO9PBIAg6o4zHq1IqpW42k0W51YZp8zt8VrSPDtuc69s3hBKEgdjqRiAE7+ePt3H2XaxWiMIQhBCMR89ndOeLSB7xwPlVRl1k4Xy52vdT67s308kYeVFinReIo3BQAgxsxXiUAsA3r9c4cqaWURiCdYfbdZ67AzznCDnHaVf0Oz+dYbXOYKwFZwy6KwDkZYmLs1O0UqIoS0RhiJPpBFIq1G2Dt+wMRVX1hQFtdO9cLZUCLJCXNznUnHNorcEYRVFWYJT2PzMMQye917ovMCRJDCVV//y/dZD4/LV4zYeOtpWwsLDW3dd26RJumlShK774Ir61FlEYDoeGR4YSgndvLvAOruC+WK0OuhhQVnW/mV6us34fNxmPMB2PX1Sx7TlxflxhX+zbNinARwUySiEEH7w/Bl482hjkeYEkjnF5df3Ns9OwWj0yvlvr/0vv+Nxj4VMNeDe6UH3e8d8JNwIRhgJxFDqH/EcoYqyzbOv5fX8YYJw9eNPsxiMCVHWNkPPe1Og5WK7Xty5izhiqur73rC7nDKM0eZQCANDF8GS5k++1ziTursibgYF98XnB8cd3b7/4Gr8Zv0u5czKdAHCHa1908N/jv2/bOLD7rhXHJrl/TnyxnDGXIy67lJ6dH7cb5QPc/dirQzhnqJsWnNGjnyM+FsJQ9MWAVZZjnWUHZxS4yU1qFHC9WOJ6scQoTTAdP9+o4EsiCII+MrBp5U5qAKU10AKw26/rAwPHgJIKSRzj3//+y3fvkcybPgy8PJpWIhROHruvOEMA3WMFiCMBpTRoN87wGCRRvPWMYFXVSKIIRpsHFwCW6zWapkUaR0iT572Zt/L276+0RrxlUeQxMMag7SK4BOcYj1J8up4/S1rCwMDAy0N16gmLm+iwbeb/v4UvMni1BqUExpJeKTDwdEzHI0zHoy8SBA6dvCiRFyU4c0X3s9PZq1bs7IpL7yD9uFQ//rMFSmsYa6GNRvJMZs4DA4+BNgardQYhOEhA8J+//navAjl7LOn2wPPSSglGKcqq3uvh39N0xlxpEj/qBmm5Xm/12KEQvfP1Q2V5sotN8dLe56zmS6lAyO3fPwAe3P2KowinJ9NHUwEA3ShMZ8wWIEBRVkiT4UY7MDCwG8H/3967LMeSpdl5a9/cPe64nWt2VnV1WbHUph6oZeRAbcYJJRNHrWfoF+A76GE4pxkHHHCgoSYa9IQyqtSsrq7KzsxzcADE3S/7ysH27QgAASACiAhEAPszS8sDIC4eQIT7/v+9/rVQS/6tQ1XJWra/eYLcmNVmgKpJtxBxrOkFWEwQqCqJy9EI87zY2xGBQIgUDEacg97DsW2R+yGEoNNuoZLKe7xYe8NPax2stdAasakXeTUopXF+cYlup43haLI05vE+4hXtFSKVNzYqivLZuaoPQShBWUnfddrScwghMM/XNwBMkwRp6hdto/GkkfyuQllV0Nqg3+2gd0/02a6Yzmcoq5vSN6kkOF9fcfHu9ATGmCdHKj5GWfk4rrkpcHI8QJKI2vk9nmYikcjTEXUajp/7t3fOiZvGWAsnFVht1FtVEgQAYywWDi9Emib48O4MgFf3jafTvY8OVVrXzYAxTO39FBME1id4AgCofVtWL3JuE0YWQ0JA/DxHDpGqkiirCpRREErw5dvF2o8Rz0KvDOccnHWQWm21+Ae8A/M2FSTGWhRPnAFkjIJRhrws1yr+h+Mx5nkJRmmzE/SSKGWgF6SPaZKAc/HkrO5ut7NVkyWtNXqdDsaTKRjzu2iU0Btz1pFIJPIUGGMoK/lkGfA6WOdgtY9QpPX1wNRGkJGXIVyPu502up02jLUYjSbIy2Jv/QJCkyJ4PuVFCcYoWlmGLE2jX8CaBEf/55wDrHOY5QXSJEEieIwKjBwExvpx5qvRGGVZIUkSzMaTJ/tj8Mur0YYPMfJSBPkiIeRZhimrorXZqpSKUQrrrI/JWpPg5rzu/H5ZSUil0M5SHL+wkV21JOPcOQf6jN93K8twdnKE84ur5x7evUznc3Q7bYwnM2RpAlLHBMYmQCQSeQ6EECSJgNYa228BeJTSPsqSMXDOfFRlPJftBYxSnJ4c4RRHqCqJn8+/7WTt8xTCtbySEpTSpmGRJkkzJhCVAY9DCEGv08Z0nj+rCeDqRC6pNLJ65CcS2VeMtRiOxqCUwFofX3w5HD7rMfnFMx8gsh8455oc60k+39nzbvOkqZSG4GLtzj6lFEf9PiijsGb1ne7xdAatDdqtDMf9/ovv/kt11/lWKoXZPH/WApQSitPjI1wOt9f8m81z9DodGOvAmIPSGuPpDIMXHqmIRCKHTSIE0PYy8G3429yHnz8m4JyjrKonp9NEtkOaJvjz77/DdDbHZDbb6/GAxcZ+JX3e/eVwhEGvC0opup3OVtWVhw5jDINeF7N5/iylq1QKiRBNtHUksm8opTGeTiGlgnU+Vn4620yNx/7m3/zb//MX332C4CJ2Hw+UkHWaCI7ZM7ui6+BN8rb3ntFaoyjLxvhlneNSdRRGXhTIsscXasZaDMdjOOfw8f3ZXnwWiqLCeDq98/1P7989yQMA8GMbBMR3vqUCHOC2tJcmlQIlxCsZnAUlFNZaJInYyvNFIpG3AWMMgnN/DtsBzjnvIF67kbdbGZRSsWjYQ9IkQSvNkCQJZN1A39Wa6LlU0vv7jCdTXAxHKKsKznkzxKD8C7O/b/06SghpxnGe0wQw1sLUSVHbjuaORFbFWIsv599grWnU1nlZ+ojyDcEBP5OUFz/jt7/+1cYeOLI7fF4xxywvdnqhe2oRuiqUUrTbLczWNAFkjPnRAa1XNvG7uLyClAqnx0cvvvMP+B306Xw7So40TWCdxdnpCfI835opIOCNARljKOp5pbwomvnHMM8UiUQi66K0Rq/bwTwvYHbkCu/gi40wx12UFdJExMJhzxCC40j0cNTvAQBGkyk4Y5jN58iLcq8jBReVC4uxgu1WhnarhTRJ4JzD1WiEk6OjFzzS/aCVpc3m11MVQdoYlJUEVToqLyIvitIas/kczgHtLENelJgX20k+efltzsiTcc6hKMumwDqULvc66CdcqIXgqCqJ6WzuowAfWZxVlYQ2Xvq/T7OdUt3d3UqE2EicUCvLoGdztNtt9Hs9zOZzDMeTZz/uMkzdnR+Oxjg5OsLlcIxeV8dxgEgk8mSCBD/LUpRltbMmQFCkWWfBKIMxfncmqgH2l9AISNME6TyH1hrzvNhbv4DbhBG60KwXnKPbaaOq5J31wFtsrDPG0G63kOfFk5sASmukb1xVEXlZxpMppvM5KKFwzq29+bkusQFwwBRlCUooyhcq/hOx/ZNlmiRrd7601uh22jga9KFXMBC8uBpCKoVBr/fUw9woeVFiOpsvbX70N1g097odzOY55nmO05NjWGu3qgYAgFltEAiEsZU4ehSJRJ5OIgSMsSBabz35JqCNQSK8GaHWaJICopHYfuNj+Hwq0LtTf639cv5trxUB95EXJSrp1Z+UUqRpinaWgTL6JpsAgnP0e10UZfXkxk4lFTjn4HX8ZySyC8bTGZxzUErDWYdpuRsft7jyPkDCzj/nHGVZ7dQIKdBaYa7+uQjBcTkagVK6dhNAKYWiKB+N2AlO+2ma7E0cT1lVKKtq6c82bTzV7bTRamUYjsbodbtI08SrJ7YUFSiVglIao8kUg14Xl1WFXreLfq/75hYsjxGaerGoiEQeJksTKEbhdqQECKa7BADn3CfwaA2xg6Z4ZHO0Wxl++f13mM1zFEWx9Qb4prjdsBDcS+AngiNNElBKwRhFO2ttRDF4KJA6mjp8Pp9CXpTotlsAEJsAka0RIkxLWcEaC23Mk9+zTyU2AA6QeV4A8CeqXe78E0LAKEWWpRB8+28dpTQSLpClyVpJAJRQKKVhjPFJAo/sMFvn8H5PZulm8xxZmuKbuhvT1261VjI0XBdGKc5OjgEAdmZBWwyDfg/T2XbGAoK3QXjsoqyQFwW++/hh48+1z2itYaytpYdJE3fppcUUAAHgmh2euBiJRJZDCAFnDJxzmB3Jup3z9qkhfcfUi7jQpI2Nu8OAUYpBr4tBr4t3Z6eYTKcYT2YHMx4AXDcElNbIixLtVtY0BbQ2aGUpWq0W2ln2JhR3Wd30eEpB5ZxDXpTo97qw1sbrbmSjGGsxGk9q773iRY/l9Z8JXhEmdIgIYGpXyF3SStOddpOF4P5iteZnRGmNNE3QbrV8DfUAeVmg3cr2pkvOGMX55d3iHwB6nfbWd8l73Q6U0iiqCt1OB8eDAc4vLrc+i6SkxvnFFY6PvDxzFw2ml0BrDWNs8x6FqyXM2gB1GgMBgXOAcxaM+VmwspLNzxllYMzLjePccSTioZQiS/3I2K4l3UprcMbgHKC1eRNF1muEUYrjwQDHgwEANBsPw/F4r2MFb3N7w4QQgrwocV6rY7I0QSIEel2vvNuX9c+mYIyh024hM8mTTEKNtZjN850oXSNvA2MthqMJirKEUmovxo54lkbHy0OhkgqM+d3tXcj+Ca53MRhjL3KRIMQXQ+tQVhVaWQrrLDi7fyFm6ii8D+/OnnmUm8FYC2MtyvKu/J9S75y/C5rGC/zC9v27U7TnGc4vljcmNkGlJMzcwjkLzjmyNAV/offcNghxTsYawPlm3koLynoDI6hvKKVQWoOyBM46VNIv9BLBm2ZA3HmMvFVCEwDwc/q7VsgZY8AZuzGbHTlcgiN8u5WhqiTG02kze39I3D5ev/tYYjTxMcP+mps0TeVOnTZw6I0sxhiyNEVerq+WVVqDSgrGTBM3GImsi7EWX79dgBKKoix3LvO/DeccWmtQSsHfn5286MFEVqOSsin+tz3jyCgFYwxa6+sLQj0TtWtm8zmyNEFRrj4CIDiH0hrTWd7sKC9jOBr73dgVxgR2gdYal8PR0p9lafIixbDgHEVZIs9LvDs9QVVJzPLt+ANorTGZztHptFCUFXi9y31yfHSwigBjDAghsHXW8FNNypxz/r71/UP3mBCCRIim6A9GMgBAKYkqgcibg3OOLueQUj1p4f9UVH29nBcFKCGoiESavMx5O7J50jTB+/S0+booS1xcjV5cxrsJtNaYLexIjsYTJMLHW3LOkAiBo0H/IK/DQnC0XIqiWt8sW0q5V8lQkcPB7/iPm+uQ2ZFB7TJCTQQA1lh0220IIcDzvMDF1fDFCrzI41hrUVUSzrmt7/xTQvwcpTFN4fCS7400TWDt+p3bNE3AGLlXMq+UX6z1up29KP6rSj64+5+8YAe6lWX47lOG0WSKbqftd0OkxGyeb1zGZJ3FdDb3XUpKwTnHeDJr1CiDQe8gzAKttZBKwVoHpfVWGiaAL/grKX2DsG7ccc7AKIW1DpxTaGOglAKjDJT6z3ck8toRgqONzBuP7khuGQoM62d4vD+AiEqA10gry/D954/NQn82z1FJ2agG1vEteinSJFmqZqD1tYRRCkYppFL4dnEFSgnSNIExfja+09p/k0FCCDhnaMErAdbBwf8dYxMgsg7//PNXKKVefLef1p9fzr2qN0tTMEahtfHNPcB3Mm0tPz6ExfVbwtp617DeRdwWlBBY5xrHfT9jTF98BmpZzu0qJEKAM37ve3o8nSJL071y/r/PcC9LE3w4O136s10SspQvroa1sVCGDiWNjHCTaK2h4ZUvSvlonnaWYjqbwzmHLE12NhKxLtZazPNiZ5FkgTBCEi46lBA4+O5vmggwxnwxVFY3RgYikdcIIQSEkmZ8TUoFSikqKXemCtDGoCwrcBGjxV4rwUQ3GOkG8qLE5XC4942A40EfnHFI5TcheH2dCMcdFGaJELDOIU1SlFUFpTUmsxnIPIyJUhhjIYTw15w02Zt6IlzrOGNrX5e1MSjK6sXXwpH9ZTyd1eu+vDFpfwk45020dp4XIITgaNDzY+PWq53LyiJLE2RpAj6oc8UrKZEXBdqt1t58aCN+7t85uzX5CGesnrN3yOoTvHMWaZLsRYHgZzrXP/GOJlO8P7u/cUAp3Zvi/9vlEEqre+cK+73ejo/oYcJCZzyZwliDXqcDQgkmW4pQknUnNUgtsyTBlFIIzpFlPvt4X3YhZB0/+RLRnLcJxxB+f6zOKeec1woFP/rC9+BzHolsA1FnekulQKkvVLqddnM91dpA6+166sj68TXVYIxFb4A3gjcX/oCiKFFWVW3+pffC/Avwnw1rLSopIYmC1gZZmqDTbiPVGt9//gRTq0+V1lB1Y/lyOATgGxzBJ6Db6aDbaaOq/BqGEL95E56DUvriSkvGGFpZCqn02h4OZRWb5pGb+MSNApPJbG1lySaghNQjOr7oB3wdnwgfS9vttHF8NICUCs75z3u7fbO+5/1+t/ni/OIK/W4H706jL8A+EHY/NznzzyiFsbaR+jvnmjlhbXxczD4tTt6fnfrjrZUJq2KtRVEU/k3furlTnBfl3jS5/GsjmM7mS3++T42K2wz6PRhr4ewE1lkM+j1obZpFxbYUK2V98S7gIzGHlCBJBBIh8P4FlRL7VPwvI5xHtDHN5x/OQUqFJIn55ZHXCSGkMfFyzsFYWxv2WaSJQLuVQRvTFDqbxjk/BuSLIQ2lNFpZGouJNwCrr9/LruGhuM6LwiuzlG5GunbBYnRgoJKyea9eXA0x6PXurJ8WMdaiKEpoY2pPJW+8KZVCIkStvklBCVmrARAeN4yiMubHIPO8aLwJKKNrr+M4580I3Lq/56Ks9nYtFtktYS01mc7rhKbtQevNrsX3azC7DVL+0IjL0hTtVlaP0uYYjsa1CmC5f8eN72itMc8LvHt5tfGbxzmHsqw2VkwQQoBa4s+5jyuy9UKIc78QaWUvN+tvrIVWeulObsjpXSeTPuQyL7voXI1G+LNPH591vJtgNs8hlbq3+Ae87H5fmhXLYJTi9OQIADCdz1FVEoQQdNttzIti6wZJxho4R1CWXt707XKIJOFoZ62d7jhorX2ndWfP+DxsvUhTWqOVpjHvOPImIIR4xQtjQN3zMsY0Y2+MebWZlHLjjTzVmOrSelRHgzG/uIvJHW8PRinarWxpgX1+cQlKKbTWqJQCJQRS6XqMhKw1VsA5r/1hvIk04wyUELSyrDFXDiZhSmnkRYlWlqGsJIajCXrdNkAIWmnajNOMJ9NG6k8pRVL7Ady+5laVRF4W6NQqxmWGy8u+xxaKmkWyNAVlFNb45om1Fq1WdmON9Jips7W+8WeMWWscQGl9wxg78raY5wWUUiirCpX0/982nDFwwUEJxaDfA2ofOOdc4/l0QyFNAMooYIBVDP7vfEoqKfEP//hHnB4PMBj097r4eM3M5vlGFiCCc4AAzjqAAJwz2HrOi9a7fvvg7Dqb5wjjKLf5cv7Na8rWQGmNbqeNvCiRLTgxK6XR6+yPoUvxQKSQ4Pyg1Di9Tge9TgfD8QQE3iQpTQTKSoJzH40l5eZNUaxzSLkA4wx5UcDaFMZYnBwNNv5c91GU1c5n/jeBcw55WYJWBP1eNxYikTeH32Fkzc7ldeOYrF0kPIZzrh47KMAZg7XekIkxeiPNI/K2WUXJFsYJQpO9KEsYY2+sJ9IkaQrXdiuDELxOpkibuf5W5r9fSYmykuh22pjUM81hkyj4JYWd+UGvB8oo8rwAY35NOZ5eewFlaQql/WcJ8Os7UTciFo9/MXK4qiSss423z7IiPnwvPE5QLxhrMZlOIbhA6wHFAoCm0d1ptzBec2yxKKtGgRA/q68fpTTyssB8XqCS0hfX1jUq1G1BKcXxoA/GfALHeDJFUZQ4GvRhjUW/3202nZJENCbhzedrxZJu6c2ss5jM5kiSJEpeXoCyqp4lnyYACKUQnMFaBwKCrJVCKw1j6p0OzvZm9jfElt1HWUl8/90nTGfztccACCE3VAXaaN9Je0GCMWFRlpjl92fBdw70s3c8uI5eDIsPAM3s3bxWPlBCYd3T3ueUUCSJwPGgDwd/4guNrF37ARTl/sr+V8U6h/F0BkYpOu1WVAPsEcaY5u+x6AVDKW3iIY256xOzODaVpgnowqiX0QainmkNUZWVVOCcISxr31paRBgVcM41KR6sjiJtYjg3yGKsJ2cMSmlwzpAmSSwuIo8SiudlCoKgEDDGIKsVXmU9Ugr4eOWwey+VQpok6HU7zahMv9eFVhpc3Czaw0iDsdanACnld+VrhUFYXzrnQAlFXpWNwtR70FwbO98u8Ne9bi82DwDgeLBew985t7YpoDa+WSfl7tcZkd0jBEeXdQAQCCGQFwWMsyu9byil4HUB7wA4a+EAJMKbk1trcdTv+81ea2GsN5tsZxmSNEGaJMjSFNpo9HodvEtOboy9CM6fbYRN/v1/+E/NyvX7z59u/DBNEnx6/y6+0XeItRZFWT0rPoIQH39HKIFgHNa55iS8D7v9i1SVRCnlvbv/gC+wZvMcxpi1OrbtLEO3641pPr5/h9ncF9sv3dQKne6v3y7v3f1/rZ89pTWssSiqysts65MinJcu+egUjURwaK3r+SfRzCUG+WOWeelkIp5/EnwO1lqUldzZ3OYuSISIsbBbJszKGmMb/wXvneENG2+71IcidFPwetduWeMq+EOEpkOy0Ch4a9JXpTS08UaBjDEQUhsHblHtExo17VYWG3GRF+ExGf0qBI8DbQxaaQqltZf278maJigcZnmx1rk1SK/brSw26t4YRVlCKr/zTgiBNrpJUAP8dVpwf7101sIYC0IJisI3woQQ3meN0EalHHhq4tlz4JPJDItGgItUUuLHL1/x6cO7vY3cem2UlWx2TNdBCD/zzigFpQTOK/5hnYPgbG93c0Jh9xCcebf3slzTuVVK9NDxu2PWQml9Y3d61yya/gzHkwfVDO/PTvfmQrlJBOcAf7h7HrqjIcN0nwkF21MIi4ddRZKtilQKpECzsxN5PlKp2o337k5yXpaPFvibfo88VMAGf4jA4qxjaC4DqE1kbZMXDqAukl/Povh6lzGtTXl1rZygsNY156pN4uD/PvO8AGMUrSwWGpHdsgn/nOBxsMnH3CSUUlBK0eu0MXnAh+k2xlofK1orJyJvh1aW4ZEJk+UsGUe9vQa+b028iWbcffDx9P4GAOALtK/fLvH9d5/2fjF+6ISdhnXlxIxSHwnBOayzjbRrcXdpHwmZ5Y/Nagvho2R6px1cjUYrPz6j1Me3JAKTyRR4wTWUsRZfv10ADnBwDy4a263W3ik1dgk7gMIf8J9X+YxMcbYg696vFoBvbACIxccTCGZaYYdplRSXfWsC3cdiA+O6iXCzARaaBGGBLTh7FcZZaeJlmWE8gBBXvyafpLHJMaDwmWPUjwbs83U8Ejlkwpz1OmvvsNkWiWybbTbOVnrkSkr88OPPsQmwZYqifFLkX5alcNbBOot2ei0b3PcFl5Ry5Xl8Ljgm0xm67faDc/OLBNflRAicX17hF7dGXHaFsRbfLi6RCIF5XjzoHkopxdnJ0d51yyN3eWrxzyhFq5V5gzFtGrm1MQbGWog6pUPXMvGXwruUK/DaJC1yE+9vYRoXeS8JPDwjyE3TNAnq30V563QXHL45P8z3lY9g8s7L3tRPg6YUxnovButc02smhPio1Ec+x6FRElRPjLGovolEdkSWJpiuoXSrfjAAAB5wSURBVLyVSj04thqJHAIrVxmVlPjjDz/i+8+fYnGyBcrqaS7ijFIQACI5LAfh6WwOB6CVrbbICTtKJ8eDlRsAADCZ+ZzONEleZEHlY3BKlJUE0/rR6JCzk+PG0TOyv5Rl1eySPwYlBCT8RwlSIXy8C2NgrP7Mhxky6ndKlfKzZayOZ3qJRoBzDkVZoZWl9ShRPO8r7Y0sjTYHb/z4UhhrkdfxYyEfPDjvh2bToVzLCPHmUIsEE0Hf3PPpJ4SQRpVHCAGBl/o7Z2Gta7Ke49oqEtk9xnhjN7ViE8DVUWyHcp6KRJax1tVGaY0fv3yNSoANkxfFysVEKIQJuXYtDrsoh3JCqioJpRVOjo7Wul+aJKikRLuVrZyDa63FeDLF2ekxKKOYzObodzuNE/+2GU4m0HUB99gxd9vtF/UoiDxOkHRXK8z903rRnwgBQr0SZRF3q6j2uc++sAwKAWMMWO32/hR10HMJTYA08U2LQzi/bIKgzrDONYZ9cXd/89g6Fo8QgmJBKhCM8ELEWJYmB6MWIAvHDviRrkgksr84OAjBV24AAH5TNIwPRCKHyNrt5kpKaKXBXqFB2UtQVhWUfnxhKTj30Sq1i+qyCL9DWZznZYlBf/1CNxgyMUbxpx9/Xuk+1rp6EW/x5es3nJ0cYzbPt54EMM8LXI3GSBMBqXQTv3MflFIcxeJ/75FKoSyrR2f2w+eTc3av1Pn25zUUDdejAaxWDtSjALreXdzxzrNzDmUl4RyWRk4dMlrrJkYvzOzHnf3dsqyx5VB7KdQL8tB4c84hEQJC8KbBFqXykUjkKQSz4eCbVZTVymo7H19NgFj/Rw6UJ+nNvl1d4fT4KCYDbACCh92fCdAscLIsPehdOKU1prM5tDbP2n2fzXMkQqzsvt7KUuRF0RzDp/fvtuqsWVUSUvoM6fFktlLW/cmgjyxLt3I8kecT4oJuZ60vwyt0vLRZLMSprUpoBLjajT2MDzBWRxfVx7DpaLjH8Dse9GA9Aay1TbEfZNpByvkS6orI/dx+Xy+qL6S6mbwRYgvTROxt2k0kEtk/wrU5/F9wvvK60lgLaqMqLHK4NFfLyWQGfH78DpRSVFLh2+UQaSLw4d3ZNo/vVVNJifIBIzHOfHyftbYpJg4VYy3OLy6RJgnen50867EIITg7OcaXbxePRjBRerNZUkmJn8+/4eTYjx9sqglgrIXWGheXQ7RaGfKiwDwvHr0fJRS/+O7Tq4z8ey1orVFWcqXiX3DezPsm4nm+HIQQtLIMUilY62cUDfHvWSnVixStRVkhS5OmybHP2Dr601oHKSWsc40yg1DSNADijv9hE2ILpVK1p4CoP4MkxnRFIpGVkEqBc7ZWrG/C4/Z/5HDhl8MRvv/uI8bT2Up3aGSSxkBpjQ9bPsDXiDEGRVndmyHMGauj7xwSwQ9yt+02UkpQQnH8SOTfKpydHEMpjXYrw2y+uiFgoJISX79dYNDrwjmHTrv95JEApbQ3+StLUMqgrcHlcLRSNrTgPMr+D4AgD38IQghatTO4sQZZmmysQA4zhqqWq2tjQCkF594scJcFrHM+8kzw/TovhSbqHVWE874p3U4bhBBI6QtFax6O4owcJtY5VFI2xptlWYExBsE5kgMzyo1EIrvDOdfEfJaVXOk+lJKD8d6KRG7DldZPks1Z53B21Md4Ml05yi3iGyhFWdW7T9cL0GDuF2YcKaPI0sPd8V9kPJliPJ3h3enxxoz3/AwoRSvLUJSrGQIuYq3FcDwB4OWlV8MR0ixFr9PxMVWP7Mgba2GNxXA89gaOzkHpYi0TmVaW4WQDDZHI9vDycHPvbruPmeQACBjzn+GUbmfXUXDvkl5JWTdiXaMQ2qVBnXUO09pHY5kXya5ZNOjjzO/gMMaac00l/WJulTi2yOsgRPF5RU7t3SElEiH85zT6B0QikQWCWihLU0ipVmqsG2sh682oSOTQ4JwzfDg79SMAa3J+cQVKfGbttk3VXgu03o0yxvj5XhA4hAbA61uUTOdzXAxHaLeyjcfbffrwzidT/Py1WeQ/haAiKKoKo7opcDzoQ2uDXreDRIg681vXbrECVS0JD02EdWm3WujEz8zeM8+XN3Uo9bPwtP7cPmXW/ykQQpClaVP0a639uAGl0MbL3bdNKKLndRPgqUqAIMFfvH9w3AcApQ0EZ7VSyiFNRGPaRCmFtRaVVH40gwCMsjphZPUmXOT1Ejw0AoxSb/qogSQRKCvZRA8C2CtFSyQSeRm0MWCcwarHryNVJZtr0Wtat0feBhzwi9nf/MUv1zJWC1hn8e3yCs459LqdrRzka4QxhtYrXnAopaGNxvnFFThjOOr3thK7N5vPvSs055jl648DLBJO4NZaTOumwHQ+97nU8LtKz5UNc87R67Qx6PXi3P+eM8tz6FvFZCj6CSHe4b/+etdQSkGtbTLTCSEwhQEhdaHzDEXAyosZQqC0XqtwCvnolPr7UkKbgj08ToiAC8o0juumg3UOjJCm4dfM8RsL5erHqf8+QZoZXo+uIxWj4d/bZDH6NUQOOudQOd8IEM7dSOR5LeN3kUhkNcL15NGYnxpT+3NpY5DEBkDkwGg05pRSDHq9Jrd8HaRS+PrtAokQsaiJAAC00fjpyznarRaOBr2tJUYcDwYQPIfSGnlRruS4fx+Lxf3iZ2AV87dVoISi3cr8MW8pgSCyGfKigLPXc+WEAIKLZsdwH2b+OOdg9S4no7QpmI0xaGVp3YRb770bFkBFWTZz/uH9vzgqFkaWCMidhsHiPP7i44ade87914umpqZuDDRfl9WC0aADQCA4a4r7INe8fbkxtUeC1qY5biE4pNK+SRKL/zdN+PtTQpqGLiEEZSVhrQOlPlFAa4O88KNlwW9jVyqfSCTyMviRvvU2Qp3Dyg2DSGSfuFGFnBwPwDnD1Wi8tqTaWIufvp7j84f3sQnwRjHW4mo4QiUltDY46vfR7bS3/n7odto+koUQnF9e7aW5V5okaLcyvD87felDiTxC2KV2qItsxjZq6rdJFovhRLjGydgY613QWQKt9cqFbyhwFtVJ1lrAAYaYpihPEgFjvMv+7c+3c85/P0lgjAFbopIIzYTQaLvPrV3f41Fzu0kdDFWtdQh/JsaYz483tjmufSM0NEiterB1msi6xo6csZ36QBw6dkFRgvrfYdFPpLqhohGEQGuDsqyahA8heEwYiEReIWE0d1USwWP8aOQgufOu7fe6kEo9aaZaKoWvF5f4cHYamwBvkK/fLqC1BqM+xeDoqL8V2f8yGKXI0hTvz05xeTXcqzngfreLLEtwPIiGf4eAMQaEELRbWVOgHQKhWaG1hoaFq3c3XW2I5rDEJX8FgndHUAdIKdHvdkCpd0uupERZSnQ7rabYD8XRMgn14qhNkGWXVXWjWA+vxzcviuaYb5sOLr6WTUT6Lft7h4ZiOG7nXDNeEBory36vnLHm9Qc1Qnjs4H0QmjUBSimSJPHmk48U9GmagBKCSqpml9oYe+M5bh9TbBI8TjCVJISA1mMuBPXYDaOwxr9PZ/MclFK0svRgzhGRSOR+rLWN8g+4VgpFIq8Rfnk1AgD87vd/wG9//SsAPmZNa71yNOAiRVniYjhEt9PBoNfd6MFG9pPZPMc8z31OubFotVL0Ot2dFf+BNE0wnk7x7vQEk9nsSRGBm4RzjnenJ+hHb4yDwljbxMYdGqTOQefc1XFG1XXBXTcCzBMXNOFxsixDVUmAELTr4qfbaT3p8UKR3BTQt2KVBfcFtNKmkWsngkPpa8NDB+fNVJ2DWzARfIwg97weMwBQ7/xQQgCC5jmCc/yyx3j2nPgzo6TD7lOI6AV8dCVj/u8VRi9CY4sQ0jQXgsFiaDjEpIRrnHMwzoESct08s77JpLVGr9tpfueUUpSVRJZ61UvcEYxEDo9mRIj6c/0qxf9Tk9QikZeGX9YO7bf5+P4djgcD/Omnn9eWVM/meT0batDvbcf8LfLyGGvx9dtFk7ecpglOj49eNBLl/dkplNJot1sYjsYYjic7Hwnwu0IZet0OOu31C6PIy5Kl6UsfwrMJhWmn3YbWfv5dKg35jLQMRimSRNQqAwPOvO9As1v9hIZJKJ5vF9G3d8B9GgBpriWi8Tu4+dkWnMO6OiKRsSaaEcBabs3LfAwCWuvaLM7tlQx8MUFm2Xp08XccFqzEGCinm9hEVv9NQzPAGNuMW7zV5kAoAvQtFcdsnvsGQJ0fzjmrY0MtitkcnXYL1tpYHEQiB4IxfpT09nXlIXaRvBOJbAMOAN9//oS//y//9c4P0zTBp/fv8OOXr83iaVWm83nYTInS51dIVUlcjcaQ0s9NHg360Ho/8lCDwd7x0QCUUuRFgXle7OS5EyEghMBRvxejMSN7QShAWoyhlaVNYS2VbqLSHivswg49pRSCcwjOr2emCdl4kbPsMZc9w7pPu6qJ20PqD85fz8wnWxhTWPp9AQDXsZNAnfDyBJ+C10JQBgR4GLtZGDsjISGD0utxkdoPIxKJ7CsOSZLA1j42q1JW1avYOIi8LR5dxXQ7bXx8/w7D0RhK6bVc1qezOThjKMpyay7wkd0SjP6U0n5u1zm0shTtLNtL34det4NepwOlNS6uhijKcivPkyYJ2u0WOGU4OY4Nr8j+EoqQYPQXipNlCx5GKYQQ3lAwSW40gRPxTO165GCglDYxV4kQMMYbQkqlYK1rit+wI/6WWPRVIMSrVKy1KMoKBF5RxDnzDTcpwTlvfoexIRCJ7A9ho9PY1b1SOGNv7pwXeR2stI0RZvmNMbgcjtZSAgzHE+RFie8+fgCAGH92wIwmU5RVhTwvGpdvTgnOjo/3svhnlF5LhgVHu5Wh3cpQSekjA585GkApbRQPId4vEjk0WpnfuViM0AtO/7dN8WIMWgS4biJdj0Dc3P3SWqMoqzc3NhAMBAOsLg60MWCUQiqDeV6gICWy+nNHKUVRVs2IzSF6j0QirwFGKSopQcnq1zljbXMNjUQOiZWr8dAEkFKubQ5YSYl/+ucf0e92cHZ6AmtsbAQcEHlR4nI4hNIGpt7p4bWc+Oz05GA8Hs5OjmGsxWQ6RZakvplRrtYISISAcw5CcAghYLQBYxSnx8fxvRx5FQTZ9x728iIHBiEEvW6niYQ0xtQKwrvJBK8ZXTfVApwxZGkKWkcLKqVBqffrSISAtbaJg4zNtkhkdwRVE0DuxMw+BCEPj4xFIvvK2pVLK8tgrF17B9Vai9FkinleoNft4GjQR1FW0SF9j1FK42o0Rl4UsM7B1u7GzjmcnRyjf4ApD4zSZqdeKY1ZPoeUCr1uF5PptF6sWlRSNkZjaZKg0255c79W1nw/EolEIndhC+MliRCAEAj2MEEe/xZ9BG43BNIkadIlgnGntRbzvABjtEnIiOM2kch2IYSgrOSNeNdV7hPHeCKHytqVzKDfw6Dfg1IaP375impNV2mlNUaTKUaTKQTnGE+myNIESZLE2MA9IS9KzOY5irJEJWVj/sW43/3+9OHdwez6P4QQ/IZsfx8MDCORSOQ1Qylt0lFMHdto69QHKdWbagosrp/yomxiMdM08Q0S65AIX2BorZEXZVN0pPW4gLE2NqUjkWei6rScdXb/X8M6OPJ2aa4a68ryhPBO0OZWR3sVgnIgzNokgoMA+OHHn5FlKU6Oj5oxgbwovet0lFlvnfF0hqIokBelX5QtzG9SQvDu5Bi9qNiIRCKRyAZY3D2ztQw+L8q11xSvhaAQqKQvLih1yOt0Hc45+r2ubxRwrwxQSt+RH0upwDmLIwSRyIporSGlahQ4q8IYA48KgMiB0lTVn9+/X/vOHz+8w89fz2GLaq10gEWss40iAAAcgKvhCMZaSCnBGQelBJ12+0bxqZSOTYENcXE1RFGUUFpD1zsygXYrw+nxMRile2n0F4lEIpHDJxSswTtAKgWtzZscFQC8uViQIk9mc9B6519wDlrHDIb/irJEr9vxMZ3CR3QmQkAqtWDUGIlEliGVhuAc1lmsc6ah1Dfh4to4cog0FXS/v778nlGKTx/e49vFFeZFDq2f37UvyvJGVJvgBt1OG4SQ+mcVjLHodlqgjGI0nkDUnfHI6hhrcXF5BUIIprP5nR0XSim67TbOTo+jvDASiUQiO4MQHzsZ1tVKayilYIxXpRlrQQgBAd5Mc8A6B1sX/Mt+VpQVkkRAcI40SZoYwrKqkAgBSimccygrCcYoOIsqgUgEqBXQlEBJvZYa2hgLzqMCIHKYPLuyY5Ti4/szzOY5hqMxrHMoq2oTxwbAX/iH4wmG4wkA78ZOCIFUPk9XSgU4B8ooBOO4HI2aLvnJ0QBVJZuu+FvGWNvM9SulwRjFdDZfett2q4WP789i4R+JRCKRF0dwfuN6pLRuZLsRj65nmMP1PREcZSVhjEGaJLDWopIKxphmjZalaRNhVknpo3Nr48FI5C1QSQnOWZNSsioEfpxZ8BgBGDlMmivqcw3Qup02Wq0Ml1dDcM42krO+DKn8BX/RPIdSivOLKwjGAAI46+CsxY9fvgLOF7+UEvS6Xaj6/u1WC2mavGoTj6qSUFojTRKcX142X9/HoNdFt9NBt9Pe4VFGIpFIJLI6oSHQyjKvCDAGxlhoY6D0ert4rwXr3FJTZkoIyqqCta5ZPwnOwRiDcw6zee5NfimFNgbGWjBKweMGQOQV45zzo8Sco5LqwbXxMiilSBIRVTSRg4UD3n32+8+fnv1gjFK8PztFVUl8NZcAcEPOvy2stbDWNsV9QHAOSimyNIF1Dong0PWc+2gyqWd+fKTdoTcCjLVNgS/rRUBZSSj18ImNUopBr4vjweDNqyQikUgkclgQQsA5B+dA2IurpIRSy+Xybw1by/4Xd/W1Mc1OfzBbBnyzIIwKUEobA+bFIqeSsjE+k0qDUhIbBpGDRNbrY6nWUxIRQpAkIvprRA4aDgA//PQzfvvrX23sQdM0wS+++4TxdIY0ETB1ru02FAEPES7+oSseJO/hwsYZQyJ8FGFVeRnQUb+PSkpYa+/4CoQiex8M8cbTGRLBYYz/3TpnwRhDUVYrNV0E5zg9OUaWJOCCH3wDJBKJRCIRALV/QBLNBBcIqojQCFg2qmmdA6e0aQIYa2ClQ5b632VelMjSpFEPUEpgrQOcBWPuRpNhOpsjEeLF10qRyG1CLWIXjDbXQXCOLI3S/8hhs9WW7aDXxaAuoouyxMXVCMaYpTK1XeJn4eTS45jO5khTv3i4Go1ACAElXhpHKakjdvyvLS8LHA8GyIsSk+kUx4MB0jTBeDpDt9OGVvqG/0BVyeZiqJQGZbRpKHDBmx18aw3SxJ9cGKWgjOJqOKov4AQgaBY0xtq1ckvTJMFRv4dOp43xZIp2lsXiPxKJRCKvjttmgn7+Xb7ZMQHg4chn7690dzc0NAsoIbXZoPVjBJQiTThm8xxlVYExhk67BeccsiwFveUlEEwInXNIE9EcS1QPRHaF1hpFWYEx+qTiHwDSRGz4qCKR3dOcdf/jf/6/0G5ld0YBzo6PcXpytPTOv/v9Hx68zeXVCL/7/R/wP/3VX9aP/RF5UaIoSlTKXwQ4Y5jnRbNbP5nMMJ5N8cOPX+483qDXbdIK3p+eLu0sh/uXlcS3iysAwPfffXzwPouEWJ3ZPL/zmABwfnHl1QILcvnJQowhZRS/+dUvYa1rCmvvWAw4B2SJQKuV4cPZmY8ccQ6MBjmdj+w5GvQhpWpOUsukjIvHdN/rqiqJ88tLcM59J742Avpv//THRvK3KmfHx/ibf/XXd75/+298m9/9/g/43e//gHYrw//2r/9m6WP/3//P3+P05GijKpRIJBKJRBZZLFCjMuAujzVFrHOwxkAX16lBYWyAUnpDAeCcA+N+Y6OUEs7aG2MHjDG/iWGu1QNVJVFUFdIkacwJI5FNIKXy6l7nQAlB9UQD0TjuEnktkL/9u3/n/td//b/gr//qLx+98Q8//bx24Qh4g8G/+Zf/850C0ViLoijx7XKI3//xTzg56qOSCoNuD71eG2UlnzU28P/+f/+Af/jDn1DK9VMJfvGIJ0IpJc4vLle6b5omeH92cud2g26vaWgsFvSbQHCBLE2QJAm00U1DotftbOw59p1lDa1AeC8/telweTVCXhbN419ejXAxHAIAvv/86dmmmm+ZxfPMQ3/DQyC8L2JzKxLZP0LBa62F1sY3Bczz44zfMqEJ4OpCixACB5/g5JyFcz4/HSDN+i54DJjam4AxP6ZpjGmKrcUUg2BUHAwggagiiCzHGANK/UaaNhpS+c20pyqAep12fK9FXgXkb//u3+2s9X16fITTkyP8/7//p109ZSRysLSyrFGv7Ip21nryc+ZFiR9++vnZx+AzvzUGvR7OTo7ueHEAwA8/fUFeFBj0evhy/g2thYZLVUl8eHfWGFWNpzNUsnrQrfc5rzsQlFBPVU3d/v0dUvMjNG1i8yty6BhjfJpANBHcCZQQiDremRKCNPVKRVk7s9taOcAYazwHKPWqAykVfL+BwBhzw3PAezld+xSkC47t1trm32GEMqgYIodP+PtWUsIYC8BBKl0rbp8j/U/qsaLo/h85fHbaANgX/uzz9UJ/Mp1hMp294NHsD99//tgUUkXhPRvOTo7ww093xzGW8VDB+sOPX3aSCPHQ8RRFufJriWyfxb/PS7w/tkFocq7LJl7/v/j1nz96m7wokSUput12HZ96uXbBvqxZskzh8Ntf/6ppeGyD84srVLJCmqQ3FFahubLYUFm1MfHDTz/j7//Lf73z/f/jf/83mzvwFVhUFC3yUHMpshkWi0OgdgqvmwGLu4aLO92R7cIZu7HrGgwInXNIhABjrPk7BVVBIgSE4FBagxACY3xalHMOjDFwzsAZq8+7/m9JiL8uFaVXjQrOYKz1Roc1WZrcGHUArpOoOPdJUw7eKC6yXSopITgHqZUmUikYY5EE361a9r8JKCEY9Ht3zg+RyKHyJhsAkUgk8hoITbttqqoWG4OXVyNcDkcbf47FZtB9ryXcZhuv9V/8+s93MqaxSgEfGhsPsTg+tkhVSfzhT/+M/+E3fwFgcyqSp4w4PUURtNiwWZVdjtdoraG0gaxniRehhEQvgQ1DCLnRYOHMF+SNeeCtrxdv55yDEOLegi1NvOogOMErpcE5a7ySFsdPrXPQ2sA663eQjVclBBil9VgD4Jqvb0YnwqFRJ0ip4ODq40iawvU+ws61EPzGcSntxx8o9WaXxhg45+rY65uvPfw73GZR8bBKURvGLRbvF9QTwdthMWkivKag6lhEa93cRyoFZ92N2zjnoLSux0ZcMwpy+/VUUvnXuzBKwjlDUZQb/yx2O+2m4RSJvAZiAyASiUQikQiAmw2fbSG4aBKClnHbN+eHH78gL0vkRQHAq1AG/e7S8aCAUrpR96Vpgu8/f1rqxbPIfQqQgHOuKXTOjo9xdNS/LhZXXEkdDwY4Puo/ertWluLzxw+rPegb5qEmAKEERpsbxWAivHx7MdlgWbHIGUOaJuCM4acv5/h26U2lKfMFMGcMlFJ8/vABjJHG28B7F9gbx+Scu6MeCV8zxpClyXX0Yu2DEEwRGaN3fBBaWQpbNy1A0BTKYUd88Tkem1c3xvjxi4UGQDDJFJzf+L4xBsb6BAildNP0YIzdOLbQWAnHEFQXgG+GaG3AGYN1Fq0sa15bkO0rpSEEBwFBWVUghPgxEEphnW2+Vko3IzvbJE0SMEqR1E2jSOQ1EBsAkUgkEolEDpL7xm62pVZ5aT5/eIf/8be/Wes+P305R1EtHzH6/OHDHcf9oqzw09evjz5uK83w+eN7HA8GGI7Hj97+04f3L+buf3I0wPHRwBePlDZF42Mz4WEnPdz+py9f8e1iiGk+AyUUH96dAQjFv8Dp0RHev/ONJq1N0xeq5HXyVSjKbzcftNY3illKCDjnoJRAa3NHEfHf/ulP6LQz/OZXfw6pFGTtbJ8IAc4ZtDGw1jVF+HUh7v9vjF1oalkQct2EAICkjruTUoExhlaWegUBAGssOA9FvQLg4ByaQjmoDcpK3mhuNK+N0mbnvpWl9aiFN4kkddR1IPhAUEq9YqD+HYQECufck+f6H0MIDlEnacXiP/KaiA2ASCQSiUQikVfM8aCP46M+yrLCT1+/IUtTfP747s7t/vGP/7z1Y/n84R2yFRsBrTRrmhc/ffnW7Nwv4y9++WdLv7/4mpbdZjrPoZVGUscPhp3th34X4ff5EL/+5S/8PwhAyU2JvYODs7eW36Teubfuzn1CA4NS4nf+F0iTmxJ765YXw5TQRpkQXiMhBFma4PvPn6/vv6SYJgQghAJwjbkicFP2H5oIwXjRNxeCAgJ1se6LfOBaMVFJ1fgzFGWFn8/P8d3HD42Pg7XuQUNOQggIsHHZf3j+KPuPvEb+OyaJk4fH79SDAAAAAElFTkSuQmCC"></image></defs>', 3)
  ]));
}
const DefaultThumbnail = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$j]]);
/**
 *  Copyright 2024  VideoDB 
 *  @license MIT
**/
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var win;
if (typeof window !== "undefined") {
  win = window;
} else if (typeof commonjsGlobal !== "undefined") {
  win = commonjsGlobal;
} else if (typeof self !== "undefined") {
  win = self;
} else {
  win = {};
}
var window_1 = win;
const window$1$1 = /* @__PURE__ */ getDefaultExportFromCjs(window_1);
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var topLevel = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : {};
var minDoc = require$$0;
var doccy;
if (typeof document !== "undefined") {
  doccy = document;
} else {
  doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
  if (!doccy) {
    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
  }
}
var document_1 = doccy;
const document$1$1 = /* @__PURE__ */ getDefaultExportFromCjs(document_1);
var tuple = SafeParseTuple;
function SafeParseTuple(obj, reviver) {
  var json;
  var error = null;
  try {
    json = JSON.parse(obj, reviver);
  } catch (err) {
    error = err;
  }
  return [error, json];
}
const safeParseTuple = /* @__PURE__ */ getDefaultExportFromCjs(tuple);
var lib = { exports: {} };
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$2.apply(null, arguments);
}
const _extends$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get default() {
    return _extends$2;
  }
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(_extends$3);
var isFunction_1 = isFunction$1;
var toString$1 = Object.prototype.toString;
function isFunction$1(fn2) {
  if (!fn2) {
    return false;
  }
  var string = toString$1.call(fn2);
  return string === "[object Function]" || typeof fn2 === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
  (fn2 === window.setTimeout || fn2 === window.alert || fn2 === window.confirm || fn2 === window.prompt);
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var InterceptorsStorage$1 = /* @__PURE__ */ function() {
  function InterceptorsStorage2() {
    this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map();
    this.enabled_ = false;
  }
  var _proto = InterceptorsStorage2.prototype;
  _proto.getIsEnabled = function getIsEnabled() {
    return this.enabled_;
  };
  _proto.enable = function enable() {
    this.enabled_ = true;
  };
  _proto.disable = function disable() {
    this.enabled_ = false;
  };
  _proto.reset = function reset2() {
    this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map();
    this.enabled_ = false;
  };
  _proto.addInterceptor = function addInterceptor(type, interceptor) {
    if (!this.typeToInterceptorsMap_.has(type)) {
      this.typeToInterceptorsMap_.set(type, /* @__PURE__ */ new Set());
    }
    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
    if (interceptorsSet.has(interceptor)) {
      return false;
    }
    interceptorsSet.add(interceptor);
    return true;
  };
  _proto.removeInterceptor = function removeInterceptor(type, interceptor) {
    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
    if (interceptorsSet && interceptorsSet.has(interceptor)) {
      interceptorsSet.delete(interceptor);
      return true;
    }
    return false;
  };
  _proto.clearInterceptorsByType = function clearInterceptorsByType(type) {
    var interceptorsSet = this.typeToInterceptorsMap_.get(type);
    if (!interceptorsSet) {
      return false;
    }
    this.typeToInterceptorsMap_.delete(type);
    this.typeToInterceptorsMap_.set(type, /* @__PURE__ */ new Set());
    return true;
  };
  _proto.clear = function clear() {
    if (!this.typeToInterceptorsMap_.size) {
      return false;
    }
    this.typeToInterceptorsMap_ = /* @__PURE__ */ new Map();
    return true;
  };
  _proto.getForType = function getForType(type) {
    return this.typeToInterceptorsMap_.get(type) || /* @__PURE__ */ new Set();
  };
  _proto.execute = function execute(type, payload) {
    var interceptors2 = this.getForType(type);
    for (var _iterator = _createForOfIteratorHelperLoose(interceptors2), _step; !(_step = _iterator()).done; ) {
      var interceptor = _step.value;
      try {
        payload = interceptor(payload);
      } catch (e) {
      }
    }
    return payload;
  };
  return InterceptorsStorage2;
}();
var interceptors = InterceptorsStorage$1;
var RetryManager$1 = /* @__PURE__ */ function() {
  function RetryManager2() {
    this.maxAttempts_ = 1;
    this.delayFactor_ = 0.1;
    this.fuzzFactor_ = 0.1;
    this.initialDelay_ = 1e3;
    this.enabled_ = false;
  }
  var _proto = RetryManager2.prototype;
  _proto.getIsEnabled = function getIsEnabled() {
    return this.enabled_;
  };
  _proto.enable = function enable() {
    this.enabled_ = true;
  };
  _proto.disable = function disable() {
    this.enabled_ = false;
  };
  _proto.reset = function reset2() {
    this.maxAttempts_ = 1;
    this.delayFactor_ = 0.1;
    this.fuzzFactor_ = 0.1;
    this.initialDelay_ = 1e3;
    this.enabled_ = false;
  };
  _proto.getMaxAttempts = function getMaxAttempts() {
    return this.maxAttempts_;
  };
  _proto.setMaxAttempts = function setMaxAttempts(maxAttempts) {
    this.maxAttempts_ = maxAttempts;
  };
  _proto.getDelayFactor = function getDelayFactor() {
    return this.delayFactor_;
  };
  _proto.setDelayFactor = function setDelayFactor(delayFactor) {
    this.delayFactor_ = delayFactor;
  };
  _proto.getFuzzFactor = function getFuzzFactor() {
    return this.fuzzFactor_;
  };
  _proto.setFuzzFactor = function setFuzzFactor(fuzzFactor) {
    this.fuzzFactor_ = fuzzFactor;
  };
  _proto.getInitialDelay = function getInitialDelay() {
    return this.initialDelay_;
  };
  _proto.setInitialDelay = function setInitialDelay(initialDelay) {
    this.initialDelay_ = initialDelay;
  };
  _proto.createRetry = function createRetry(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, maxAttempts = _ref.maxAttempts, delayFactor = _ref.delayFactor, fuzzFactor = _ref.fuzzFactor, initialDelay = _ref.initialDelay;
    return new Retry({
      maxAttempts: maxAttempts || this.maxAttempts_,
      delayFactor: delayFactor || this.delayFactor_,
      fuzzFactor: fuzzFactor || this.fuzzFactor_,
      initialDelay: initialDelay || this.initialDelay_
    });
  };
  return RetryManager2;
}();
var Retry = /* @__PURE__ */ function() {
  function Retry2(options) {
    this.maxAttempts_ = options.maxAttempts;
    this.delayFactor_ = options.delayFactor;
    this.fuzzFactor_ = options.fuzzFactor;
    this.currentDelay_ = options.initialDelay;
    this.currentAttempt_ = 1;
  }
  var _proto2 = Retry2.prototype;
  _proto2.moveToNextAttempt = function moveToNextAttempt() {
    this.currentAttempt_++;
    var delayDelta = this.currentDelay_ * this.delayFactor_;
    this.currentDelay_ = this.currentDelay_ + delayDelta;
  };
  _proto2.shouldRetry = function shouldRetry() {
    return this.currentAttempt_ < this.maxAttempts_;
  };
  _proto2.getCurrentDelay = function getCurrentDelay() {
    return this.currentDelay_;
  };
  _proto2.getCurrentMinPossibleDelay = function getCurrentMinPossibleDelay() {
    return (1 - this.fuzzFactor_) * this.currentDelay_;
  };
  _proto2.getCurrentMaxPossibleDelay = function getCurrentMaxPossibleDelay() {
    return (1 + this.fuzzFactor_) * this.currentDelay_;
  };
  _proto2.getCurrentFuzzedDelay = function getCurrentFuzzedDelay() {
    var lowValue = this.getCurrentMinPossibleDelay();
    var highValue = this.getCurrentMaxPossibleDelay();
    return lowValue + Math.random() * (highValue - lowValue);
  };
  return Retry2;
}();
var retry = RetryManager$1;
var window$3 = window_1;
var httpResponseHandler = function httpResponseHandler2(callback, decodeResponseBody) {
  if (decodeResponseBody === void 0) {
    decodeResponseBody = false;
  }
  return function(err, response, responseBody) {
    if (err) {
      callback(err);
      return;
    }
    if (response.statusCode >= 400 && response.statusCode <= 599) {
      var cause = responseBody;
      if (decodeResponseBody) {
        if (window$3.TextDecoder) {
          var charset = getCharset(response.headers && response.headers["content-type"]);
          try {
            cause = new TextDecoder(charset).decode(responseBody);
          } catch (e) {
          }
        } else {
          cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
        }
      }
      callback({
        cause
      });
      return;
    }
    callback(null, responseBody);
  };
};
function getCharset(contentTypeHeader) {
  if (contentTypeHeader === void 0) {
    contentTypeHeader = "";
  }
  return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
    var _contentType$split = contentType.split("="), type = _contentType$split[0], value2 = _contentType$split[1];
    if (type.trim() === "charset") {
      return value2.trim();
    }
    return charset;
  }, "utf-8");
}
var httpHandler = httpResponseHandler;
var window$2 = window_1;
var _extends$1 = require$$1;
var isFunction = isFunction_1;
var InterceptorsStorage = interceptors;
var RetryManager = retry;
createXHR.httpHandler = httpHandler;
createXHR.requestInterceptorsStorage = new InterceptorsStorage();
createXHR.responseInterceptorsStorage = new InterceptorsStorage();
createXHR.retryManager = new RetryManager();
/**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Björklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */
var parseHeaders = function parseHeaders2(headers) {
  var result = {};
  if (!headers) {
    return result;
  }
  headers.trim().split("\n").forEach(function(row) {
    var index = row.indexOf(":");
    var key = row.slice(0, index).trim().toLowerCase();
    var value2 = row.slice(index + 1).trim();
    if (typeof result[key] === "undefined") {
      result[key] = value2;
    } else if (Array.isArray(result[key])) {
      result[key].push(value2);
    } else {
      result[key] = [result[key], value2];
    }
  });
  return result;
};
lib.exports = createXHR;
lib.exports.default = createXHR;
createXHR.XMLHttpRequest = window$2.XMLHttpRequest || noop$1;
createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window$2.XDomainRequest;
forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
  createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
    options = initParams(uri, options, callback);
    options.method = method.toUpperCase();
    return _createXHR(options);
  };
});
function forEachArray(array, iterator) {
  for (var i = 0; i < array.length; i++) {
    iterator(array[i]);
  }
}
function isEmpty(obj) {
  for (var i in obj) {
    if (obj.hasOwnProperty(i))
      return false;
  }
  return true;
}
function initParams(uri, options, callback) {
  var params = uri;
  if (isFunction(options)) {
    callback = options;
    if (typeof uri === "string") {
      params = {
        uri
      };
    }
  } else {
    params = _extends$1({}, options, {
      uri
    });
  }
  params.callback = callback;
  return params;
}
function createXHR(uri, options, callback) {
  options = initParams(uri, options, callback);
  return _createXHR(options);
}
function _createXHR(options) {
  if (typeof options.callback === "undefined") {
    throw new Error("callback argument missing");
  }
  if (options.requestType && createXHR.requestInterceptorsStorage.getIsEnabled()) {
    var requestInterceptorPayload = {
      uri: options.uri || options.url,
      headers: options.headers || {},
      body: options.body,
      metadata: options.metadata || {},
      retry: options.retry,
      timeout: options.timeout
    };
    var updatedPayload = createXHR.requestInterceptorsStorage.execute(options.requestType, requestInterceptorPayload);
    options.uri = updatedPayload.uri;
    options.headers = updatedPayload.headers;
    options.body = updatedPayload.body;
    options.metadata = updatedPayload.metadata;
    options.retry = updatedPayload.retry;
    options.timeout = updatedPayload.timeout;
  }
  var called = false;
  var callback = function cbOnce(err, response, body2) {
    if (!called) {
      called = true;
      options.callback(err, response, body2);
    }
  };
  function readystatechange() {
    if (xhr.readyState === 4 && !createXHR.responseInterceptorsStorage.getIsEnabled()) {
      setTimeout(loadFunc, 0);
    }
  }
  function getBody() {
    var body2 = void 0;
    if (xhr.response) {
      body2 = xhr.response;
    } else {
      body2 = xhr.responseText || getXml(xhr);
    }
    if (isJson) {
      try {
        body2 = JSON.parse(body2);
      } catch (e) {
      }
    }
    return body2;
  }
  function errorFunc(evt) {
    clearTimeout(timeoutTimer);
    clearTimeout(options.retryTimeout);
    if (!(evt instanceof Error)) {
      evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
    }
    evt.statusCode = 0;
    if (!aborted && createXHR.retryManager.getIsEnabled() && options.retry && options.retry.shouldRetry()) {
      options.retryTimeout = setTimeout(function() {
        options.retry.moveToNextAttempt();
        options.xhr = xhr;
        _createXHR(options);
      }, options.retry.getCurrentFuzzedDelay());
      return;
    }
    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
      var responseInterceptorPayload = {
        headers: failureResponse.headers || {},
        body: failureResponse.body,
        responseUrl: xhr.responseURL,
        responseType: xhr.responseType
      };
      var _updatedPayload = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);
      failureResponse.body = _updatedPayload.body;
      failureResponse.headers = _updatedPayload.headers;
    }
    return callback(evt, failureResponse);
  }
  function loadFunc() {
    if (aborted)
      return;
    var status;
    clearTimeout(timeoutTimer);
    clearTimeout(options.retryTimeout);
    if (options.useXDR && xhr.status === void 0) {
      status = 200;
    } else {
      status = xhr.status === 1223 ? 204 : xhr.status;
    }
    var response = failureResponse;
    var err = null;
    if (status !== 0) {
      response = {
        body: getBody(),
        statusCode: status,
        method,
        headers: {},
        url: uri,
        rawRequest: xhr
      };
      if (xhr.getAllResponseHeaders) {
        response.headers = parseHeaders(xhr.getAllResponseHeaders());
      }
    } else {
      err = new Error("Internal XMLHttpRequest Error");
    }
    if (options.requestType && createXHR.responseInterceptorsStorage.getIsEnabled()) {
      var responseInterceptorPayload = {
        headers: response.headers || {},
        body: response.body,
        responseUrl: xhr.responseURL,
        responseType: xhr.responseType
      };
      var _updatedPayload2 = createXHR.responseInterceptorsStorage.execute(options.requestType, responseInterceptorPayload);
      response.body = _updatedPayload2.body;
      response.headers = _updatedPayload2.headers;
    }
    return callback(err, response, response.body);
  }
  var xhr = options.xhr || null;
  if (!xhr) {
    if (options.cors || options.useXDR) {
      xhr = new createXHR.XDomainRequest();
    } else {
      xhr = new createXHR.XMLHttpRequest();
    }
  }
  var key;
  var aborted;
  var uri = xhr.url = options.uri || options.url;
  var method = xhr.method = options.method || "GET";
  var body = options.body || options.data;
  var headers = xhr.headers = options.headers || {};
  var sync = !!options.sync;
  var isJson = false;
  var timeoutTimer;
  var failureResponse = {
    body: void 0,
    headers: {},
    statusCode: 0,
    method,
    url: uri,
    rawRequest: xhr
  };
  if ("json" in options && options.json !== false) {
    isJson = true;
    headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
    if (method !== "GET" && method !== "HEAD") {
      headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
      body = JSON.stringify(options.json === true ? body : options.json);
    }
  }
  xhr.onreadystatechange = readystatechange;
  xhr.onload = loadFunc;
  xhr.onerror = errorFunc;
  xhr.onprogress = function() {
  };
  xhr.onabort = function() {
    aborted = true;
    clearTimeout(options.retryTimeout);
  };
  xhr.ontimeout = errorFunc;
  xhr.open(method, uri, !sync, options.username, options.password);
  if (!sync) {
    xhr.withCredentials = !!options.withCredentials;
  }
  if (!sync && options.timeout > 0) {
    timeoutTimer = setTimeout(function() {
      if (aborted)
        return;
      aborted = true;
      xhr.abort("timeout");
      var e = new Error("XMLHttpRequest timeout");
      e.code = "ETIMEDOUT";
      errorFunc(e);
    }, options.timeout);
  }
  if (xhr.setRequestHeader) {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (options.headers && !isEmpty(options.headers)) {
    throw new Error("Headers cannot be set on an XDomainRequest object");
  }
  if ("responseType" in options) {
    xhr.responseType = options.responseType;
  }
  if ("beforeSend" in options && typeof options.beforeSend === "function") {
    options.beforeSend(xhr);
  }
  xhr.send(body || null);
  return xhr;
}
function getXml(xhr) {
  try {
    if (xhr.responseType === "document") {
      return xhr.responseXML;
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
      return xhr.responseXML;
    }
  } catch (e) {
  }
  return null;
}
function noop$1() {
}
var libExports = lib.exports;
const XHR = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
var browserIndex = { exports: {} };
var document$1 = document_1;
var _objCreate = Object.create || function() {
  function F() {
  }
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error("Object.create shim only accepts one parameter.");
    }
    F.prototype = o;
    return new F();
  };
}();
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};
function parseTimeStamp(input) {
  function computeSeconds(h2, m2, s, f) {
    return (h2 | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
  }
  var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
  if (!m) {
    return null;
  }
  if (m[3]) {
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}
function Settings2() {
  this.values = _objCreate(null);
}
Settings2.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) {
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    if (v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0].trim();
    var v = kv[1].trim();
    callback(k, v);
  }
}
function parseCue(input, cue, regionList) {
  var oInput = input;
  function consumeTimeStamp() {
    var ts2 = parseTimeStamp(input);
    if (ts2 === null) {
      throw new ParsingError(
        ParsingError.Errors.BadTimeStamp,
        "Malformed timestamp: " + oInput
      );
    }
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts2;
  }
  function consumeCueSettings(input2, cue2) {
    var settings = new Settings2();
    parseOptions(input2, function(k, v) {
      switch (k) {
        case "region":
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v, ["rl", "lr"]);
          break;
        case "line":
          var vals = v.split(","), vals0 = vals[0];
          settings.integer(k, vals0);
          settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
          settings.alt(k, vals0, ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "position":
          vals = v.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "size":
          settings.percent(k, v);
          break;
        case "align":
          settings.alt(k, v, ["start", "center", "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/);
    cue2.region = settings.get("region", null);
    cue2.vertical = settings.get("vertical", "");
    try {
      cue2.line = settings.get("line", "auto");
    } catch (e) {
    }
    cue2.lineAlign = settings.get("lineAlign", "start");
    cue2.snapToLines = settings.get("snapToLines", true);
    cue2.size = settings.get("size", 100);
    try {
      cue2.align = settings.get("align", "center");
    } catch (e) {
      cue2.align = settings.get("align", "middle");
    }
    try {
      cue2.position = settings.get("position", "auto");
    } catch (e) {
      cue2.position = settings.get("position", {
        start: 0,
        left: 0,
        center: 50,
        middle: 50,
        end: 100,
        right: 100
      }, cue2.align);
    }
    cue2.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      center: "center",
      middle: "center",
      end: "end",
      right: "end"
    }, cue2.align);
  }
  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }
  skipWhitespace();
  cue.startTime = consumeTimeStamp();
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {
    throw new ParsingError(
      ParsingError.Errors.BadTimeStamp,
      "Malformed time stamp (time stamps must be separated by '-->'): " + oInput
    );
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();
  skipWhitespace();
  consumeCueSettings(input, cue);
}
var TEXTAREA_ELEMENT = document$1.createElement && document$1.createElement("textarea");
var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};
var DEFAULT_COLOR_CLASS = {
  white: "rgba(255,255,255,1)",
  lime: "rgba(0,255,0,1)",
  cyan: "rgba(0,255,255,1)",
  red: "rgba(255,0,0,1)",
  yellow: "rgba(255,255,0,1)",
  magenta: "rgba(255,0,255,1)",
  blue: "rgba(0,0,255,1)",
  black: "rgba(0,0,0,1)"
};
var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};
var NEEDS_PARENT = {
  rt: "ruby"
};
function parseContent(window2, input) {
  function nextToken() {
    if (!input) {
      return null;
    }
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }
    var m2 = input.match(/^([^<]*)(<[^>]*>?)?/);
    return consume(m2[1] ? m2[1] : m2[2]);
  }
  function unescape2(s) {
    TEXTAREA_ELEMENT.innerHTML = s;
    s = TEXTAREA_ELEMENT.textContent;
    TEXTAREA_ELEMENT.textContent = "";
    return s;
  }
  function shouldAdd(current2, element) {
    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
  }
  function createElement2(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window2.document.createElement(tagName);
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }
  var rootDiv = window2.document.createElement("div"), current = rootDiv, t, tagStack = [];
  while ((t = nextToken()) !== null) {
    if (t[0] === "<") {
      if (t[1] === "/") {
        if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        continue;
      }
      var ts2 = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts2) {
        node = window2.document.createProcessingInstruction("timestamp", ts2);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      if (!m) {
        continue;
      }
      node = createElement2(m[1], m[3]);
      if (!node) {
        continue;
      }
      if (!shouldAdd(current, node)) {
        continue;
      }
      if (m[2]) {
        var classes2 = m[2].split(".");
        classes2.forEach(function(cl) {
          var bgColor = /^bg_/.test(cl);
          var colorName = bgColor ? cl.slice(3) : cl;
          if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
            var propName = bgColor ? "background-color" : "color";
            var propValue = DEFAULT_COLOR_CLASS[colorName];
            node.style[propName] = propValue;
          }
        });
        node.className = classes2.join(" ");
      }
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }
    current.appendChild(window2.document.createTextNode(unescape2(t)));
  }
  return rootDiv;
}
var strongRTLRanges = [
  [1470, 1470],
  [1472, 1472],
  [1475, 1475],
  [1478, 1478],
  [1488, 1514],
  [1520, 1524],
  [1544, 1544],
  [1547, 1547],
  [1549, 1549],
  [1563, 1563],
  [1566, 1610],
  [1645, 1647],
  [1649, 1749],
  [1765, 1766],
  [1774, 1775],
  [1786, 1805],
  [1807, 1808],
  [1810, 1839],
  [1869, 1957],
  [1969, 1969],
  [1984, 2026],
  [2036, 2037],
  [2042, 2042],
  [2048, 2069],
  [2074, 2074],
  [2084, 2084],
  [2088, 2088],
  [2096, 2110],
  [2112, 2136],
  [2142, 2142],
  [2208, 2208],
  [2210, 2220],
  [8207, 8207],
  [64285, 64285],
  [64287, 64296],
  [64298, 64310],
  [64312, 64316],
  [64318, 64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64449],
  [64467, 64829],
  [64848, 64911],
  [64914, 64967],
  [65008, 65020],
  [65136, 65140],
  [65142, 65276],
  [67584, 67589],
  [67592, 67592],
  [67594, 67637],
  [67639, 67640],
  [67644, 67644],
  [67647, 67669],
  [67671, 67679],
  [67840, 67867],
  [67872, 67897],
  [67903, 67903],
  [67968, 68023],
  [68030, 68031],
  [68096, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68147],
  [68160, 68167],
  [68176, 68184],
  [68192, 68223],
  [68352, 68405],
  [68416, 68437],
  [68440, 68466],
  [68472, 68479],
  [68608, 68680],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500, 126500],
  [126503, 126503],
  [126505, 126514],
  [126516, 126519],
  [126521, 126521],
  [126523, 126523],
  [126530, 126530],
  [126535, 126535],
  [126537, 126537],
  [126539, 126539],
  [126541, 126543],
  [126545, 126546],
  [126548, 126548],
  [126551, 126551],
  [126553, 126553],
  [126555, 126555],
  [126557, 126557],
  [126559, 126559],
  [126561, 126562],
  [126564, 126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590, 126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [1114109, 1114109]
];
function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }
  return false;
}
function determineBidi(cueDiv) {
  var nodeStack = [], text2 = "", charCode;
  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }
  function pushNodes(nodeStack2, node) {
    for (var i2 = node.childNodes.length - 1; i2 >= 0; i2--) {
      nodeStack2.push(node.childNodes[i2]);
    }
  }
  function nextTextNode(nodeStack2) {
    if (!nodeStack2 || !nodeStack2.length) {
      return null;
    }
    var node = nodeStack2.pop(), text22 = node.textContent || node.innerText;
    if (text22) {
      var m = text22.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack2.length = 0;
        return m[0];
      }
      return text22;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack2);
    }
    if (node.childNodes) {
      pushNodes(nodeStack2, node);
      return nextTextNode(nodeStack2);
    }
  }
  pushNodes(nodeStack, cueDiv);
  while (text2 = nextTextNode(nodeStack)) {
    for (var i = 0; i < text2.length; i++) {
      charCode = text2.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}
function computeLinePos(cue) {
  if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track, trackList = track.textTrackList, count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}
function StyleBox() {
}
StyleBox.prototype.applyStyles = function(styles2, div) {
  div = div || this.div;
  for (var prop in styles2) {
    if (styles2.hasOwnProperty(prop)) {
      div.style[prop] = styles2[prop];
    }
  }
};
StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};
function CueStyleBox(window2, cue, styleOptions) {
  StyleBox.call(this);
  this.cue = cue;
  this.cueDiv = parseContent(window2, cue.text);
  var styles2 = {
    color: "rgba(255, 255, 255, 1)",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline",
    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext"
  };
  this.applyStyles(styles2, this.cueDiv);
  this.div = window2.document.createElement("div");
  styles2 = {
    direction: determineBidi(this.cueDiv),
    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext",
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };
  this.applyStyles(styles2);
  this.div.appendChild(this.cueDiv);
  var textPos = 0;
  switch (cue.positionAlign) {
    case "start":
    case "line-left":
      textPos = cue.position;
      break;
    case "center":
      textPos = cue.position - cue.size / 2;
      break;
    case "end":
    case "line-right":
      textPos = cue.position - cue.size;
      break;
  }
  if (cue.vertical === "") {
    this.applyStyles({
      left: this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }
  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;
function BoxPosition(obj) {
  var lh, height, width, top2;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top2 = obj.div.offsetTop;
    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top2;
  this.height = obj.height || height;
  this.bottom = obj.bottom || top2 + (obj.height || height);
  this.width = obj.width || width;
  this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
}
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== void 0 ? toMove : this.lineHeight;
  switch (axis) {
    case "+x":
      this.left += toMove;
      this.right += toMove;
      break;
    case "-x":
      this.left -= toMove;
      this.right -= toMove;
      break;
    case "+y":
      this.top += toMove;
      this.bottom += toMove;
      break;
    case "-y":
      this.top -= toMove;
      this.bottom -= toMove;
      break;
  }
};
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
};
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
};
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
    case "+x":
      return this.left < container.left;
    case "-x":
      return this.right > container.right;
    case "+y":
      return this.top < container.top;
    case "-y":
      return this.bottom > container.bottom;
  }
};
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};
BoxPosition.prototype.toCSSCompatValues = function(reference2) {
  return {
    top: this.top - reference2.top,
    bottom: reference2.bottom - this.bottom,
    left: this.left - reference2.left,
    right: reference2.right - this.right,
    height: this.height,
    width: this.width
  };
};
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top2 = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
  obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top2,
    height: obj.height || height,
    bottom: obj.bottom || top2 + (obj.height || height),
    width: obj.width || width
  };
  return ret;
};
function moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions) {
  function findBestPosition(b, axis2) {
    var bestPosition2, specifiedPosition = new BoxPosition(b), percentage = 1;
    for (var i = 0; i < axis2.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis2[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {
        b.move(axis2[i]);
      }
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      if (percentage > p) {
        bestPosition2 = new BoxPosition(b);
        percentage = p;
      }
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition2 || specifiedPosition;
  }
  var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
      case "":
        axis = ["+y", "-y"];
        size = "height";
        break;
      case "rl":
        axis = ["+x", "-x"];
        size = "width";
        break;
      case "lr":
        axis = ["-x", "+x"];
        size = "width";
        break;
    }
    var step = boxPosition.lineHeight, position2 = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
    if (Math.abs(position2) > maxPosition) {
      position2 = position2 < 0 ? -1 : 1;
      position2 *= Math.ceil(maxPosition / step) * step;
    }
    if (linePos < 0) {
      position2 += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }
    boxPosition.move(initialAxis, position2);
  } else {
    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
    switch (cue.lineAlign) {
      case "center":
        linePos -= calculatedPercentage / 2;
        break;
      case "end":
        linePos -= calculatedPercentage;
        break;
    }
    switch (cue.vertical) {
      case "":
        styleBox.applyStyles({
          top: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "rl":
        styleBox.applyStyles({
          left: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "lr":
        styleBox.applyStyles({
          right: styleBox.formatStyle(linePos, "%")
        });
        break;
    }
    axis = ["+y", "-x", "+x", "-y"];
    boxPosition = new BoxPosition(styleBox);
  }
  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}
function WebVTT$1() {
}
WebVTT$1.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};
WebVTT$1.convertCueToDOMTree = function(window2, cuetext) {
  if (!window2 || !cuetext) {
    return null;
  }
  return parseContent(window2, cuetext);
};
var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";
WebVTT$1.processCues = function(window2, cues, overlay) {
  if (!window2 || !cues || !overlay) {
    return null;
  }
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }
  var paddedOverlay = window2.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);
  function shouldCompute(cues2) {
    for (var i2 = 0; i2 < cues2.length; i2++) {
      if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
        return true;
      }
    }
    return false;
  }
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }
  var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };
  (function() {
    var styleBox, cue;
    for (var i2 = 0; i2 < cues.length; i2++) {
      cue = cues[i2];
      styleBox = new CueStyleBox(window2, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);
      moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions);
      cue.displayState = styleBox.div;
      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};
WebVTT$1.Parser = function(window2, vttjs2, decoder) {
  if (!decoder) {
    decoder = vttjs2;
    vttjs2 = {};
  }
  if (!vttjs2) {
    vttjs2 = {};
  }
  this.window = window2;
  this.vttjs = vttjs2;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};
WebVTT$1.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function(data) {
    var self2 = this;
    if (data) {
      self2.buffer += self2.decoder.decode(data, { stream: true });
    }
    function collectNextLine() {
      var buffer = self2.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
        ++pos;
      }
      var line2 = buffer.substr(0, pos);
      if (buffer[pos] === "\r") {
        ++pos;
      }
      if (buffer[pos] === "\n") {
        ++pos;
      }
      self2.buffer = buffer.substr(pos);
      return line2;
    }
    function parseRegion(input) {
      var settings = new Settings2();
      parseOptions(input, function(k, v) {
        switch (k) {
          case "id":
            settings.set(k, v);
            break;
          case "width":
            settings.percent(k, v);
            break;
          case "lines":
            settings.integer(k, v);
            break;
          case "regionanchor":
          case "viewportanchor":
            var xy = v.split(",");
            if (xy.length !== 2) {
              break;
            }
            var anchor = new Settings2();
            anchor.percent("x", xy[0]);
            anchor.percent("y", xy[1]);
            if (!anchor.has("x") || !anchor.has("y")) {
              break;
            }
            settings.set(k + "X", anchor.get("x"));
            settings.set(k + "Y", anchor.get("y"));
            break;
          case "scroll":
            settings.alt(k, v, ["up"]);
            break;
        }
      }, /=/, /\s/);
      if (settings.has("id")) {
        var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        self2.onregion && self2.onregion(region);
        self2.regionList.push({
          id: settings.get("id"),
          region
        });
      }
    }
    function parseTimestampMap(input) {
      var settings = new Settings2();
      parseOptions(input, function(k, v) {
        switch (k) {
          case "MPEGT":
            settings.integer(k + "S", v);
            break;
          case "LOCA":
            settings.set(k + "L", parseTimeStamp(v));
            break;
        }
      }, /[^\d]:/, /,/);
      self2.ontimestampmap && self2.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        parseOptions(input, function(k, v) {
          switch (k) {
            case "X-TIMESTAMP-MAP":
              parseTimestampMap(v);
              break;
          }
        }, /=/);
      } else {
        parseOptions(input, function(k, v) {
          switch (k) {
            case "Region":
              parseRegion(v);
              break;
          }
        }, /:/);
      }
    }
    try {
      var line;
      if (self2.state === "INITIAL") {
        if (!/\r\n|\n/.test(self2.buffer)) {
          return this;
        }
        line = collectNextLine();
        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
        self2.state = "HEADER";
      }
      var alreadyCollectedLine = false;
      while (self2.buffer) {
        if (!/\r\n|\n/.test(self2.buffer)) {
          return this;
        }
        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }
        switch (self2.state) {
          case "HEADER":
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              self2.state = "ID";
            }
            continue;
          case "NOTE":
            if (!line) {
              self2.state = "ID";
            }
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(line)) {
              self2.state = "NOTE";
              break;
            }
            if (!line) {
              continue;
            }
            self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
            try {
              self2.cue.align = "center";
            } catch (e) {
              self2.cue.align = "middle";
            }
            self2.state = "CUE";
            if (line.indexOf("-->") === -1) {
              self2.cue.id = line;
              continue;
            }
          case "CUE":
            try {
              parseCue(line, self2.cue, self2.regionList);
            } catch (e) {
              self2.reportOrThrowError(e);
              self2.cue = null;
              self2.state = "BADCUE";
              continue;
            }
            self2.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var hasSubstring = line.indexOf("-->") !== -1;
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              self2.oncue && self2.oncue(self2.cue);
              self2.cue = null;
              self2.state = "ID";
              continue;
            }
            if (self2.cue.text) {
              self2.cue.text += "\n";
            }
            self2.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
            continue;
          case "BADCUE":
            if (!line) {
              self2.state = "ID";
            }
            continue;
        }
      }
    } catch (e) {
      self2.reportOrThrowError(e);
      if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
        self2.oncue(self2.cue);
      }
      self2.cue = null;
      self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function() {
    var self2 = this;
    try {
      self2.buffer += self2.decoder.decode();
      if (self2.cue || self2.state === "HEADER") {
        self2.buffer += "\n\n";
        self2.parse();
      }
      if (self2.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch (e) {
      self2.reportOrThrowError(e);
    }
    self2.onflush && self2.onflush();
    return this;
  }
};
var vtt$1 = WebVTT$1;
var autoKeyword = "auto";
var directionSetting = {
  "": 1,
  "lr": 1,
  "rl": 1
};
var alignSetting = {
  "start": 1,
  "center": 1,
  "end": 1,
  "left": 1,
  "right": 1,
  "auto": 1,
  "line-left": 1,
  "line-right": 1
};
function findDirectionSetting(value2) {
  if (typeof value2 !== "string") {
    return false;
  }
  var dir = directionSetting[value2.toLowerCase()];
  return dir ? value2.toLowerCase() : false;
}
function findAlignSetting(value2) {
  if (typeof value2 !== "string") {
    return false;
  }
  var align = alignSetting[value2.toLowerCase()];
  return align ? value2.toLowerCase() : false;
}
function VTTCue(startTime, endTime, text2) {
  this.hasBeenReset = false;
  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text2;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = "auto";
  var _positionAlign = "auto";
  var _size = 100;
  var _align = "center";
  Object.defineProperties(this, {
    "id": {
      enumerable: true,
      get: function() {
        return _id;
      },
      set: function(value2) {
        _id = "" + value2;
      }
    },
    "pauseOnExit": {
      enumerable: true,
      get: function() {
        return _pauseOnExit;
      },
      set: function(value2) {
        _pauseOnExit = !!value2;
      }
    },
    "startTime": {
      enumerable: true,
      get: function() {
        return _startTime;
      },
      set: function(value2) {
        if (typeof value2 !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value2;
        this.hasBeenReset = true;
      }
    },
    "endTime": {
      enumerable: true,
      get: function() {
        return _endTime;
      },
      set: function(value2) {
        if (typeof value2 !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value2;
        this.hasBeenReset = true;
      }
    },
    "text": {
      enumerable: true,
      get: function() {
        return _text;
      },
      set: function(value2) {
        _text = "" + value2;
        this.hasBeenReset = true;
      }
    },
    "region": {
      enumerable: true,
      get: function() {
        return _region;
      },
      set: function(value2) {
        _region = value2;
        this.hasBeenReset = true;
      }
    },
    "vertical": {
      enumerable: true,
      get: function() {
        return _vertical;
      },
      set: function(value2) {
        var setting = findDirectionSetting(value2);
        if (setting === false) {
          throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    },
    "snapToLines": {
      enumerable: true,
      get: function() {
        return _snapToLines;
      },
      set: function(value2) {
        _snapToLines = !!value2;
        this.hasBeenReset = true;
      }
    },
    "line": {
      enumerable: true,
      get: function() {
        return _line;
      },
      set: function(value2) {
        if (typeof value2 !== "number" && value2 !== autoKeyword) {
          throw new SyntaxError("Line: an invalid number or illegal string was specified.");
        }
        _line = value2;
        this.hasBeenReset = true;
      }
    },
    "lineAlign": {
      enumerable: true,
      get: function() {
        return _lineAlign;
      },
      set: function(value2) {
        var setting = findAlignSetting(value2);
        if (!setting) {
          console.warn("lineAlign: an invalid or illegal string was specified.");
        } else {
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }
    },
    "position": {
      enumerable: true,
      get: function() {
        return _position;
      },
      set: function(value2) {
        if (value2 < 0 || value2 > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value2;
        this.hasBeenReset = true;
      }
    },
    "positionAlign": {
      enumerable: true,
      get: function() {
        return _positionAlign;
      },
      set: function(value2) {
        var setting = findAlignSetting(value2);
        if (!setting) {
          console.warn("positionAlign: an invalid or illegal string was specified.");
        } else {
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }
    },
    "size": {
      enumerable: true,
      get: function() {
        return _size;
      },
      set: function(value2) {
        if (value2 < 0 || value2 > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value2;
        this.hasBeenReset = true;
      }
    },
    "align": {
      enumerable: true,
      get: function() {
        return _align;
      },
      set: function(value2) {
        var setting = findAlignSetting(value2);
        if (!setting) {
          throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }
  });
  this.displayState = void 0;
}
VTTCue.prototype.getCueAsHTML = function() {
  return WebVTT.convertCueToDOMTree(window, this.text);
};
var vttcue = VTTCue;
var scrollSetting = {
  "": true,
  "up": true
};
function findScrollSetting(value2) {
  if (typeof value2 !== "string") {
    return false;
  }
  var scroll = scrollSetting[value2.toLowerCase()];
  return scroll ? value2.toLowerCase() : false;
}
function isValidPercentValue(value2) {
  return typeof value2 === "number" && (value2 >= 0 && value2 <= 100);
}
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";
  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value2) {
        if (!isValidPercentValue(value2)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value2;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value2) {
        if (typeof value2 !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value2;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value2) {
        if (!isValidPercentValue(value2)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value2;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value2) {
        if (!isValidPercentValue(value2)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value2;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value2) {
        if (!isValidPercentValue(value2)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value2;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value2) {
        if (!isValidPercentValue(value2)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value2;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value2) {
        var setting = findScrollSetting(value2);
        if (setting === false) {
          console.warn("Scroll: an invalid or illegal string was specified.");
        } else {
          _scroll = setting;
        }
      }
    }
  });
}
var vttregion = VTTRegion;
var window$1 = window_1;
var vttjs = browserIndex.exports = {
  WebVTT: vtt$1,
  VTTCue: vttcue,
  VTTRegion: vttregion
};
window$1.vttjs = vttjs;
window$1.WebVTT = vttjs.WebVTT;
var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window$1.VTTCue;
var nativeVTTRegion = window$1.VTTRegion;
vttjs.shim = function() {
  window$1.VTTCue = cueShim;
  window$1.VTTRegion = regionShim;
};
vttjs.restore = function() {
  window$1.VTTCue = nativeVTTCue;
  window$1.VTTRegion = nativeVTTRegion;
};
if (!window$1.VTTCue) {
  vttjs.shim();
}
var browserIndexExports = browserIndex.exports;
const vtt = /* @__PURE__ */ getDefaultExportFromCjs(browserIndexExports);
var urlToolkit = { exports: {} };
(function(module2, exports2) {
  (function(root2) {
    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
    var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
    var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
    var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
    var URLToolkit2 = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(baseURL, relativeURL, opts) {
        opts = opts || {};
        baseURL = baseURL.trim();
        relativeURL = relativeURL.trim();
        if (!relativeURL) {
          if (!opts.alwaysNormalize) {
            return baseURL;
          }
          var basePartsForNormalise = URLToolkit2.parseURL(baseURL);
          if (!basePartsForNormalise) {
            throw new Error("Error trying to parse base URL.");
          }
          basePartsForNormalise.path = URLToolkit2.normalizePath(
            basePartsForNormalise.path
          );
          return URLToolkit2.buildURLFromParts(basePartsForNormalise);
        }
        var relativeParts = URLToolkit2.parseURL(relativeURL);
        if (!relativeParts) {
          throw new Error("Error trying to parse relative URL.");
        }
        if (relativeParts.scheme) {
          if (!opts.alwaysNormalize) {
            return relativeURL;
          }
          relativeParts.path = URLToolkit2.normalizePath(relativeParts.path);
          return URLToolkit2.buildURLFromParts(relativeParts);
        }
        var baseParts = URLToolkit2.parseURL(baseURL);
        if (!baseParts) {
          throw new Error("Error trying to parse base URL.");
        }
        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
          baseParts.netLoc = pathParts[1];
          baseParts.path = pathParts[2];
        }
        if (baseParts.netLoc && !baseParts.path) {
          baseParts.path = "/";
        }
        var builtParts = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: baseParts.scheme,
          netLoc: relativeParts.netLoc,
          path: null,
          params: relativeParts.params,
          query: relativeParts.query,
          fragment: relativeParts.fragment
        };
        if (!relativeParts.netLoc) {
          builtParts.netLoc = baseParts.netLoc;
          if (relativeParts.path[0] !== "/") {
            if (!relativeParts.path) {
              builtParts.path = baseParts.path;
              if (!relativeParts.params) {
                builtParts.params = baseParts.params;
                if (!relativeParts.query) {
                  builtParts.query = baseParts.query;
                }
              }
            } else {
              var baseURLPath = baseParts.path;
              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
              builtParts.path = URLToolkit2.normalizePath(newPath);
            }
          }
        }
        if (builtParts.path === null) {
          builtParts.path = opts.alwaysNormalize ? URLToolkit2.normalizePath(relativeParts.path) : relativeParts.path;
        }
        return URLToolkit2.buildURLFromParts(builtParts);
      },
      parseURL: function(url2) {
        var parts2 = URL_REGEX.exec(url2);
        if (!parts2) {
          return null;
        }
        return {
          scheme: parts2[1] || "",
          netLoc: parts2[2] || "",
          path: parts2[3] || "",
          params: parts2[4] || "",
          query: parts2[5] || "",
          fragment: parts2[6] || ""
        };
      },
      normalizePath: function(path2) {
        path2 = path2.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
        while (path2.length !== (path2 = path2.replace(SLASH_DOT_DOT_REGEX, "")).length) {
        }
        return path2.split("").reverse().join("");
      },
      buildURLFromParts: function(parts2) {
        return parts2.scheme + parts2.netLoc + parts2.path + parts2.params + parts2.query + parts2.fragment;
      }
    };
    module2.exports = URLToolkit2;
  })();
})(urlToolkit);
var urlToolkitExports = urlToolkit.exports;
const URLToolkit = /* @__PURE__ */ getDefaultExportFromCjs(urlToolkitExports);
var DEFAULT_LOCATION = "http://example.com";
var resolveUrl$1 = function resolveUrl2(baseUrl, relativeUrl) {
  if (/^[a-z]+:/i.test(relativeUrl)) {
    return relativeUrl;
  }
  if (/^data:/.test(baseUrl)) {
    baseUrl = window$1$1.location && window$1$1.location.href || "";
  }
  var nativeURL = typeof window$1$1.URL === "function";
  var protocolLess = /^\/\//.test(baseUrl);
  var removeLocation = !window$1$1.location && !/\/\//i.test(baseUrl);
  if (nativeURL) {
    baseUrl = new window$1$1.URL(baseUrl, window$1$1.location || DEFAULT_LOCATION);
  } else if (!/\/\//i.test(baseUrl)) {
    baseUrl = URLToolkit.buildAbsoluteURL(window$1$1.location && window$1$1.location.href || "", baseUrl);
  }
  if (nativeURL) {
    var newUrl = new URL(relativeUrl, baseUrl);
    if (removeLocation) {
      return newUrl.href.slice(DEFAULT_LOCATION.length);
    } else if (protocolLess) {
      return newUrl.href.slice(newUrl.protocol.length);
    }
    return newUrl.href;
  }
  return URLToolkit.buildAbsoluteURL(baseUrl, relativeUrl);
};
var Stream = /* @__PURE__ */ function() {
  function Stream2() {
    this.listeners = {};
  }
  var _proto = Stream2.prototype;
  _proto.on = function on2(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(listener);
  };
  _proto.off = function off2(type, listener) {
    if (!this.listeners[type]) {
      return false;
    }
    var index = this.listeners[type].indexOf(listener);
    this.listeners[type] = this.listeners[type].slice(0);
    this.listeners[type].splice(index, 1);
    return index > -1;
  };
  _proto.trigger = function trigger2(type) {
    var callbacks = this.listeners[type];
    if (!callbacks) {
      return;
    }
    if (arguments.length === 2) {
      var length2 = callbacks.length;
      for (var i = 0; i < length2; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;
      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  };
  _proto.dispose = function dispose() {
    this.listeners = {};
  };
  _proto.pipe = function pipe(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
  };
  return Stream2;
}();
var atob$1 = function atob(s) {
  return window$1$1.atob ? window$1$1.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array$1(b64Text) {
  var decodedString = atob$1(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}
/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */
class LineStream extends Stream {
  constructor() {
    super();
    this.buffer = "";
  }
  /**
   * Add new data to be parsed.
   *
   * @param {string} data the text to process
   */
  push(data) {
    let nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf("\n");
    for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
      this.trigger("data", this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  }
}
const TAB = String.fromCharCode(9);
const parseByterange = function(byterangeString) {
  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
  const result = {};
  if (match[1]) {
    result.length = parseInt(match[1], 10);
  }
  if (match[2]) {
    result.offset = parseInt(match[2], 10);
  }
  return result;
};
const attributeSeparator = function() {
  const key = "[^=]*";
  const value2 = '"[^"]*"|[^,]*';
  const keyvalue = "(?:" + key + ")=(?:" + value2 + ")";
  return new RegExp("(?:^|,)(" + keyvalue + ")");
};
const parseAttributes$1 = function(attributes) {
  const result = {};
  if (!attributes) {
    return result;
  }
  const attrs = attributes.split(attributeSeparator());
  let i = attrs.length;
  let attr;
  while (i--) {
    if (attrs[i] === "") {
      continue;
    }
    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
    attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
    result[attr[0]] = attr[1];
  }
  return result;
};
const parseResolution = (resolution) => {
  const split2 = resolution.split("x");
  const result = {};
  if (split2[0]) {
    result.width = parseInt(split2[0], 10);
  }
  if (split2[1]) {
    result.height = parseInt(split2[1], 10);
  }
  return result;
};
class ParseStream extends Stream {
  constructor() {
    super();
    this.customParsers = [];
    this.tagMappers = [];
  }
  /**
   * Parses an additional line of input.
   *
   * @param {string} line a single line of an M3U8 file to parse
   */
  push(line) {
    let match;
    let event2;
    line = line.trim();
    if (line.length === 0) {
      return;
    }
    if (line[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: line
      });
      return;
    }
    const newLines = this.tagMappers.reduce((acc, mapper) => {
      const mappedLine = mapper(line);
      if (mappedLine === line) {
        return acc;
      }
      return acc.concat([mappedLine]);
    }, [line]);
    newLines.forEach((newLine) => {
      for (let i = 0; i < this.customParsers.length; i++) {
        if (this.customParsers[i].call(this, newLine)) {
          return;
        }
      }
      if (newLine.indexOf("#EXT") !== 0) {
        this.trigger("data", {
          type: "comment",
          text: newLine.slice(1)
        });
        return;
      }
      newLine = newLine.replace("\r", "");
      match = /^#EXTM3U/.exec(newLine);
      if (match) {
        this.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      match = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "inf"
        };
        if (match[1]) {
          event2.duration = parseFloat(match[1]);
        }
        if (match[2]) {
          event2.title = match[2];
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "targetduration"
        };
        if (match[1]) {
          event2.duration = parseInt(match[1], 10);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "version"
        };
        if (match[1]) {
          event2.version = parseInt(match[1], 10);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "media-sequence"
        };
        if (match[1]) {
          event2.number = parseInt(match[1], 10);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "discontinuity-sequence"
        };
        if (match[1]) {
          event2.number = parseInt(match[1], 10);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "playlist-type"
        };
        if (match[1]) {
          event2.playlistType = match[1];
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);
      if (match) {
        event2 = _extends$2(parseByterange(match[1]), {
          type: "tag",
          tagType: "byterange"
        });
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "allow-cache"
        };
        if (match[1]) {
          event2.allowed = !/NO/.test(match[1]);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "map"
        };
        if (match[1]) {
          const attributes = parseAttributes$1(match[1]);
          if (attributes.URI) {
            event2.uri = attributes.URI;
          }
          if (attributes.BYTERANGE) {
            event2.byterange = parseByterange(attributes.BYTERANGE);
          }
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "stream-inf"
        };
        if (match[1]) {
          event2.attributes = parseAttributes$1(match[1]);
          if (event2.attributes.RESOLUTION) {
            event2.attributes.RESOLUTION = parseResolution(event2.attributes.RESOLUTION);
          }
          if (event2.attributes.BANDWIDTH) {
            event2.attributes.BANDWIDTH = parseInt(event2.attributes.BANDWIDTH, 10);
          }
          if (event2.attributes["FRAME-RATE"]) {
            event2.attributes["FRAME-RATE"] = parseFloat(event2.attributes["FRAME-RATE"]);
          }
          if (event2.attributes["PROGRAM-ID"]) {
            event2.attributes["PROGRAM-ID"] = parseInt(event2.attributes["PROGRAM-ID"], 10);
          }
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "media"
        };
        if (match[1]) {
          event2.attributes = parseAttributes$1(match[1]);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-ENDLIST/.exec(newLine);
      if (match) {
        this.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
      if (match) {
        this.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "program-date-time"
        };
        if (match[1]) {
          event2.dateTimeString = match[1];
          event2.dateTimeObject = new Date(match[1]);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "key"
        };
        if (match[1]) {
          event2.attributes = parseAttributes$1(match[1]);
          if (event2.attributes.IV) {
            if (event2.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
              event2.attributes.IV = event2.attributes.IV.substring(2);
            }
            event2.attributes.IV = event2.attributes.IV.match(/.{8}/g);
            event2.attributes.IV[0] = parseInt(event2.attributes.IV[0], 16);
            event2.attributes.IV[1] = parseInt(event2.attributes.IV[1], 16);
            event2.attributes.IV[2] = parseInt(event2.attributes.IV[2], 16);
            event2.attributes.IV[3] = parseInt(event2.attributes.IV[3], 16);
            event2.attributes.IV = new Uint32Array(event2.attributes.IV);
          }
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-START:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "start"
        };
        if (match[1]) {
          event2.attributes = parseAttributes$1(match[1]);
          event2.attributes["TIME-OFFSET"] = parseFloat(event2.attributes["TIME-OFFSET"]);
          event2.attributes.PRECISE = /YES/.test(event2.attributes.PRECISE);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "cue-out-cont"
        };
        if (match[1]) {
          event2.data = match[1];
        } else {
          event2.data = "";
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "cue-out"
        };
        if (match[1]) {
          event2.data = match[1];
        } else {
          event2.data = "";
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "cue-in"
        };
        if (match[1]) {
          event2.data = match[1];
        } else {
          event2.data = "";
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "skip"
        };
        event2.attributes = parseAttributes$1(match[1]);
        if (event2.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
          event2.attributes["SKIPPED-SEGMENTS"] = parseInt(event2.attributes["SKIPPED-SEGMENTS"], 10);
        }
        if (event2.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
          event2.attributes["RECENTLY-REMOVED-DATERANGES"] = event2.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-PART:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "part"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["DURATION"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseFloat(event2.attributes[key]);
          }
        });
        ["INDEPENDENT", "GAP"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = /YES/.test(event2.attributes[key]);
          }
        });
        if (event2.attributes.hasOwnProperty("BYTERANGE")) {
          event2.attributes.byterange = parseByterange(event2.attributes.BYTERANGE);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "server-control"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseFloat(event2.attributes[key]);
          }
        });
        ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = /YES/.test(event2.attributes[key]);
          }
        });
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "part-inf"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["PART-TARGET"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseFloat(event2.attributes[key]);
          }
        });
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "preload-hint"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseInt(event2.attributes[key], 10);
            const subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
            event2.attributes.byterange = event2.attributes.byterange || {};
            event2.attributes.byterange[subkey] = event2.attributes[key];
            delete event2.attributes[key];
          }
        });
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "rendition-report"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["LAST-MSN", "LAST-PART"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseInt(event2.attributes[key], 10);
          }
        });
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);
      if (match && match[1]) {
        event2 = {
          type: "tag",
          tagType: "daterange"
        };
        event2.attributes = parseAttributes$1(match[1]);
        ["ID", "CLASS"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = String(event2.attributes[key]);
          }
        });
        ["START-DATE", "END-DATE"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = new Date(event2.attributes[key]);
          }
        });
        ["DURATION", "PLANNED-DURATION"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = parseFloat(event2.attributes[key]);
          }
        });
        ["END-ON-NEXT"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = /YES/i.test(event2.attributes[key]);
          }
        });
        ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach(function(key) {
          if (event2.attributes.hasOwnProperty(key)) {
            event2.attributes[key] = event2.attributes[key].toString(16);
          }
        });
        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;
        for (const key in event2.attributes) {
          if (!clientAttributePattern.test(key)) {
            continue;
          }
          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event2.attributes[key]);
          const isDecimalFloating = /^\d+(\.\d+)?$/.test(event2.attributes[key]);
          event2.attributes[key] = isHexaDecimal ? event2.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event2.attributes[key]) : String(event2.attributes[key]);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);
      if (match) {
        this.trigger("data", {
          type: "tag",
          tagType: "independent-segments"
        });
        return;
      }
      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);
      if (match) {
        this.trigger("data", {
          type: "tag",
          tagType: "i-frames-only"
        });
        return;
      }
      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "content-steering"
        };
        event2.attributes = parseAttributes$1(match[1]);
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "i-frame-playlist"
        };
        event2.attributes = parseAttributes$1(match[1]);
        if (event2.attributes.URI) {
          event2.uri = event2.attributes.URI;
        }
        if (event2.attributes.BANDWIDTH) {
          event2.attributes.BANDWIDTH = parseInt(event2.attributes.BANDWIDTH, 10);
        }
        if (event2.attributes.RESOLUTION) {
          event2.attributes.RESOLUTION = parseResolution(event2.attributes.RESOLUTION);
        }
        if (event2.attributes["AVERAGE-BANDWIDTH"]) {
          event2.attributes["AVERAGE-BANDWIDTH"] = parseInt(event2.attributes["AVERAGE-BANDWIDTH"], 10);
        }
        if (event2.attributes["FRAME-RATE"]) {
          event2.attributes["FRAME-RATE"] = parseFloat(event2.attributes["FRAME-RATE"]);
        }
        this.trigger("data", event2);
        return;
      }
      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);
      if (match) {
        event2 = {
          type: "tag",
          tagType: "define"
        };
        event2.attributes = parseAttributes$1(match[1]);
        this.trigger("data", event2);
        return;
      }
      this.trigger("data", {
        type: "tag",
        data: newLine.slice(4)
      });
    });
  }
  /**
   * Add a parser for custom headers
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser({
    expression,
    customType,
    dataParser,
    segment
  }) {
    if (typeof dataParser !== "function") {
      dataParser = (line) => line;
    }
    this.customParsers.push((line) => {
      const match = expression.exec(line);
      if (match) {
        this.trigger("data", {
          type: "custom",
          data: dataParser(line),
          customType,
          segment
        });
        return true;
      }
    });
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper({
    expression,
    map: map2
  }) {
    const mapFn = (line) => {
      if (expression.test(line)) {
        return map2(line);
      }
      return line;
    };
    this.tagMappers.push(mapFn);
  }
}
const camelCase = (str) => str.toLowerCase().replace(/-(\w)/g, (a) => a[1].toUpperCase());
const camelCaseKeys = function(attributes) {
  const result = {};
  Object.keys(attributes).forEach(function(key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
};
const setHoldBack = function(manifest) {
  const {
    serverControl,
    targetDuration,
    partTargetDuration
  } = manifest;
  if (!serverControl) {
    return;
  }
  const tag = "#EXT-X-SERVER-CONTROL";
  const hb = "holdBack";
  const phb = "partHoldBack";
  const minTargetDuration = targetDuration && targetDuration * 3;
  const minPartDuration = partTargetDuration && partTargetDuration * 2;
  if (targetDuration && !serverControl.hasOwnProperty(hb)) {
    serverControl[hb] = minTargetDuration;
    this.trigger("info", {
      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`
    });
  }
  if (minTargetDuration && serverControl[hb] < minTargetDuration) {
    this.trigger("warn", {
      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`
    });
    serverControl[hb] = minTargetDuration;
  }
  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger("info", {
      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`
    });
  }
  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger("warn", {
      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`
    });
    serverControl[phb] = minPartDuration;
  }
};
class Parser3 extends Stream {
  constructor(opts = {}) {
    super();
    this.lineStream = new LineStream();
    this.parseStream = new ParseStream();
    this.lineStream.pipe(this.parseStream);
    this.mainDefinitions = opts.mainDefinitions || {};
    this.params = new URL(opts.uri, "https://a.com").searchParams;
    this.lastProgramDateTime = null;
    const self2 = this;
    const uris = [];
    let currentUri = {};
    let currentMap;
    let key;
    let hasParts = false;
    const noop2 = function() {
    };
    const defaultMediaGroups = {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    };
    const widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    let currentTimeline = 0;
    this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      dateRanges: [],
      iFramePlaylists: [],
      segments: []
    };
    let lastByterangeEnd = 0;
    let lastPartByterangeEnd = 0;
    const dateRangeTags = {};
    this.on("end", () => {
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }
      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }
      if (!currentUri.key && key) {
        currentUri.key = key;
      }
      if (!currentUri.timeline && typeof currentTimeline === "number") {
        currentUri.timeline = currentTimeline;
      }
      this.manifest.preloadSegment = currentUri;
    });
    this.parseStream.on("data", function(entry) {
      let mediaGroup;
      let rendition;
      if (self2.manifest.definitions) {
        for (const def in self2.manifest.definitions) {
          if (entry.uri) {
            entry.uri = entry.uri.replace(`{$${def}}`, self2.manifest.definitions[def]);
          }
          if (entry.attributes) {
            for (const attr in entry.attributes) {
              if (typeof entry.attributes[attr] === "string") {
                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self2.manifest.definitions[def]);
              }
            }
          }
        }
      }
      ({
        tag() {
          ({
            version() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            "allow-cache"() {
              this.manifest.allowCache = entry.allowed;
              if (!("allowed" in entry)) {
                this.trigger("info", {
                  message: "defaulting allowCache to YES"
                });
                this.manifest.allowCache = true;
              }
            },
            byterange() {
              const byterange = {};
              if ("length" in entry) {
                currentUri.byterange = byterange;
                byterange.length = entry.length;
                if (!("offset" in entry)) {
                  entry.offset = lastByterangeEnd;
                }
              }
              if ("offset" in entry) {
                currentUri.byterange = byterange;
                byterange.offset = entry.offset;
              }
              lastByterangeEnd = byterange.offset + byterange.length;
            },
            endlist() {
              this.manifest.endList = true;
            },
            inf() {
              if (!("mediaSequence" in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger("info", {
                  message: "defaulting media sequence to zero"
                });
              }
              if (!("discontinuitySequence" in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger("info", {
                  message: "defaulting discontinuity sequence to zero"
                });
              }
              if (entry.title) {
                currentUri.title = entry.title;
              }
              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }
              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger("info", {
                  message: "updating zero segment duration to a small value"
                });
              }
              this.manifest.segments = uris;
            },
            key() {
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (entry.attributes.METHOD === "NONE") {
                key = null;
                return;
              }
              if (!entry.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: entry.attributes
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: entry.attributes.URI
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === widevineUuid) {
                const VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                  this.trigger("warn", {
                    message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                  });
                }
                if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(",")[1])
                };
                return;
              }
              if (!entry.attributes.METHOD) {
                this.trigger("warn", {
                  message: "defaulting key method to AES-128"
                });
              }
              key = {
                method: entry.attributes.METHOD || "AES-128",
                uri: entry.attributes.URI
              };
              if (typeof entry.attributes.IV !== "undefined") {
                key.iv = entry.attributes.IV;
              }
            },
            "media-sequence"() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + entry.number
                });
                return;
              }
              this.manifest.mediaSequence = entry.number;
            },
            "discontinuity-sequence"() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + entry.number
                });
                return;
              }
              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            "playlist-type"() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + entry.playlist
                });
                return;
              }
              this.manifest.playlistType = entry.playlistType;
            },
            map() {
              currentMap = {};
              if (entry.uri) {
                currentMap.uri = entry.uri;
              }
              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }
              if (key) {
                currentMap.key = key;
              }
            },
            "stream-inf"() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }
              _extends$2(currentUri.attributes, entry.attributes);
            },
            media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
              mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };
              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }
              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }
              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }
              if (entry.attributes["INSTREAM-ID"]) {
                rendition.instreamId = entry.attributes["INSTREAM-ID"];
              }
              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }
              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              }
              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            "program-date-time"() {
              if (typeof this.manifest.dateTimeString === "undefined") {
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }
              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
              const {
                lastProgramDateTime
              } = this;
              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime();
              if (lastProgramDateTime === null) {
                this.manifest.segments.reduceRight((programDateTime, segment) => {
                  segment.programDateTime = programDateTime - segment.duration * 1e3;
                  return segment.programDateTime;
                }, this.lastProgramDateTime);
              }
            },
            targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + entry.duration
                });
                return;
              }
              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start() {
              if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: entry.attributes["TIME-OFFSET"],
                precise: entry.attributes.PRECISE
              };
            },
            "cue-out"() {
              currentUri.cueOut = entry.data;
            },
            "cue-out-cont"() {
              currentUri.cueOutCont = entry.data;
            },
            "cue-in"() {
              currentUri.cueIn = entry.data;
            },
            "skip"() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
            },
            "part"() {
              hasParts = true;
              const segmentIndex = this.manifest.segments.length;
              const part = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part);
              if (part.byterange) {
                if (!part.byterange.hasOwnProperty("offset")) {
                  part.byterange.offset = lastPartByterangeEnd;
                }
                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
              }
              const partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ["URI", "DURATION"]);
              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach((r, i) => {
                  if (!r.hasOwnProperty("lastPart")) {
                    this.trigger("warn", {
                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`
                    });
                  }
                });
              }
            },
            "server-control"() {
              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
              if (!attrs.hasOwnProperty("canBlockReload")) {
                attrs.canBlockReload = false;
                this.trigger("info", {
                  message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                });
              }
              setHoldBack.call(this, this.manifest);
              if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                this.trigger("warn", {
                  message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                });
              }
            },
            "preload-hint"() {
              const segmentIndex = this.manifest.segments.length;
              const hint = camelCaseKeys(entry.attributes);
              const isPart = hint.type && hint.type === "PART";
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);
              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty("offset")) {
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }
              const index = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ["TYPE", "URI"]);
              if (!hint.type) {
                return;
              }
              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {
                const otherHint = currentUri.preloadHints[i];
                if (!otherHint.type) {
                  continue;
                }
                if (otherHint.type === hint.type) {
                  this.trigger("warn", {
                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`
                  });
                }
              }
            },
            "rendition-report"() {
              const report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              const index = this.manifest.renditionReports.length - 1;
              const required = ["LAST-MSN", "URI"];
              if (hasParts) {
                required.push("LAST-PART");
              }
              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);
            },
            "part-inf"() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }
              setHoldBack.call(this, this.manifest);
            },
            "daterange"() {
              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));
              const index = this.manifest.dateRanges.length - 1;
              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ["ID", "START-DATE"]);
              const dateRange = this.manifest.dateRanges[index];
              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {
                this.trigger("warn", {
                  message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
                });
              }
              if (dateRange.duration && dateRange.duration < 0) {
                this.trigger("warn", {
                  message: "EXT-X-DATERANGE DURATION must not be negative"
                });
              }
              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {
                this.trigger("warn", {
                  message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
                });
              }
              const endOnNextYes = !!dateRange.endOnNext;
              if (endOnNextYes && !dateRange.class) {
                this.trigger("warn", {
                  message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
                });
              }
              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {
                this.trigger("warn", {
                  message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
                });
              }
              if (dateRange.duration && dateRange.endDate) {
                const startDate = dateRange.startDate;
                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1e3;
                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);
              }
              if (!dateRangeTags[dateRange.id]) {
                dateRangeTags[dateRange.id] = dateRange;
              } else {
                for (const attribute in dateRangeTags[dateRange.id]) {
                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {
                    this.trigger("warn", {
                      message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                    });
                    break;
                  }
                }
                const dateRangeWithSameId = this.manifest.dateRanges.findIndex((dateRangeToFind) => dateRangeToFind.id === dateRange.id);
                this.manifest.dateRanges[dateRangeWithSameId] = _extends$2(this.manifest.dateRanges[dateRangeWithSameId], dateRange);
                dateRangeTags[dateRange.id] = _extends$2(dateRangeTags[dateRange.id], dateRange);
                this.manifest.dateRanges.pop();
              }
            },
            "independent-segments"() {
              this.manifest.independentSegments = true;
            },
            "i-frames-only"() {
              this.manifest.iFramesOnly = true;
              this.requiredCompatibilityversion(this.manifest.version, 4);
            },
            "content-steering"() {
              this.manifest.contentSteering = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", entry.attributes, ["SERVER-URI"]);
            },
            /** @this {Parser} */
            define() {
              this.manifest.definitions = this.manifest.definitions || {};
              const addDef = (n, v) => {
                if (n in this.manifest.definitions) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: Duplicate name ${n}`
                  });
                  return;
                }
                this.manifest.definitions[n] = v;
              };
              if ("QUERYPARAM" in entry.attributes) {
                if ("NAME" in entry.attributes || "IMPORT" in entry.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                const val = this.params.get(entry.attributes.QUERYPARAM);
                if (!val) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`
                  });
                  return;
                }
                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));
                return;
              }
              if ("NAME" in entry.attributes) {
                if ("IMPORT" in entry.attributes) {
                  this.trigger("error", {
                    message: "EXT-X-DEFINE: Invalid attributes"
                  });
                  return;
                }
                if (!("VALUE" in entry.attributes) || typeof entry.attributes.VALUE !== "string") {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`
                  });
                  return;
                }
                addDef(entry.attributes.NAME, entry.attributes.VALUE);
                return;
              }
              if ("IMPORT" in entry.attributes) {
                if (!this.mainDefinitions[entry.attributes.IMPORT]) {
                  this.trigger("error", {
                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`
                  });
                  return;
                }
                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);
                return;
              }
              this.trigger("error", {
                message: "EXT-X-DEFINE: No attribute"
              });
            },
            "i-frame-playlist"() {
              this.manifest.iFramePlaylists.push({
                attributes: entry.attributes,
                uri: entry.uri,
                timeline: currentTimeline
              });
              this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF", entry.attributes, ["BANDWIDTH", "URI"]);
            }
          }[entry.tagType] || noop2).call(self2);
        },
        uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri);
          if (this.manifest.targetDuration && !("duration" in currentUri)) {
            this.trigger("warn", {
              message: "defaulting segment duration to the target duration"
            });
            currentUri.duration = this.manifest.targetDuration;
          }
          if (key) {
            currentUri.key = key;
          }
          currentUri.timeline = currentTimeline;
          if (currentMap) {
            currentUri.map = currentMap;
          }
          lastPartByterangeEnd = 0;
          if (this.lastProgramDateTime !== null) {
            currentUri.programDateTime = this.lastProgramDateTime;
            this.lastProgramDateTime += currentUri.duration * 1e3;
          }
          currentUri = {};
        },
        comment() {
        },
        custom() {
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data;
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self2);
    });
  }
  requiredCompatibilityversion(currentVersion, targetVersion) {
    if (currentVersion < targetVersion || !currentVersion) {
      this.trigger("warn", {
        message: `manifest must be at least version ${targetVersion}`
      });
    }
  }
  warnOnMissingAttributes_(identifier, attributes, required) {
    const missing = [];
    required.forEach(function(key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });
    if (missing.length) {
      this.trigger("warn", {
        message: `${identifier} lacks required attribute(s): ${missing.join(", ")}`
      });
    }
  }
  /**
   * Parse the input string and update the manifest object.
   *
   * @param {string} chunk a potentially incomplete portion of the manifest
   */
  push(chunk) {
    this.lineStream.push(chunk);
  }
  /**
   * Flush any remaining input. This can be handy if the last line of an M3U8
   * manifest did not contain a trailing newline but the file has been
   * completely received.
   */
  end() {
    this.lineStream.push("\n");
    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {
      this.trigger("warn", {
        message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
      });
    }
    this.lastProgramDateTime = null;
    this.trigger("end");
  }
  /**
   * Add an additional parser for non-standard tags
   *
   * @param {Object}   options              a map of options for the added parser
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {string}   options.customType   the custom type to register to the output
   * @param {Function} [options.dataParser] function to parse the line into an object
   * @param {boolean}  [options.segment]    should tag data be attached to the segment object
   */
  addParser(options) {
    this.parseStream.addParser(options);
  }
  /**
   * Add a custom header mapper
   *
   * @param {Object}   options
   * @param {RegExp}   options.expression   a regular expression to match the custom header
   * @param {Function} options.map          function to translate tag into a different tag
   */
  addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  }
}
var regexs = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
};
var mediaTypes = ["video", "audio", "text"];
var upperMediaTypes = ["Video", "Audio", "Text"];
var translateLegacyCodec = function translateLegacyCodec2(codec) {
  if (!codec) {
    return codec;
  }
  return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
    var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
    var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
    return "avc1." + profileHex + "00" + avcLevelHex;
  });
};
var parseCodecs = function parseCodecs2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  var codecs = codecString.split(",");
  var result = [];
  codecs.forEach(function(codec) {
    codec = codec.trim();
    var codecType;
    mediaTypes.forEach(function(name) {
      var match = regexs[name].exec(codec.toLowerCase());
      if (!match || match.length <= 1) {
        return;
      }
      codecType = name;
      var type = codec.substring(0, match[1].length);
      var details = codec.replace(type, "");
      result.push({
        type,
        details,
        mediaType: name
      });
    });
    if (!codecType) {
      result.push({
        type: codec,
        details: "",
        mediaType: "unknown"
      });
    }
  });
  return result;
};
var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
  if (!master.mediaGroups.AUDIO || !audioGroupId) {
    return null;
  }
  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
  if (!audioGroup) {
    return null;
  }
  for (var name in audioGroup) {
    var audioType = audioGroup[name];
    if (audioType.default && audioType.playlists) {
      return parseCodecs(audioType.playlists[0].attributes.CODECS);
    }
  }
  return null;
};
var isAudioCodec = function isAudioCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.audio.test(codec.trim().toLowerCase());
};
var isTextCodec = function isTextCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.text.test(codec.trim().toLowerCase());
};
var getMimeForCodec = function getMimeForCodec2(codecString) {
  if (!codecString || typeof codecString !== "string") {
    return;
  }
  var codecs = codecString.toLowerCase().split(",").map(function(c) {
    return translateLegacyCodec(c.trim());
  });
  var type = "video";
  if (codecs.length === 1 && isAudioCodec(codecs[0])) {
    type = "audio";
  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
    type = "application";
  }
  var container = "mp4";
  if (codecs.every(function(c) {
    return regexs.mp4.test(c);
  })) {
    container = "mp4";
  } else if (codecs.every(function(c) {
    return regexs.webm.test(c);
  })) {
    container = "webm";
  } else if (codecs.every(function(c) {
    return regexs.ogg.test(c);
  })) {
    container = "ogg";
  }
  return type + "/" + container + ';codecs="' + codecString + '"';
};
var browserSupportsCodec = function browserSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return window$1$1.MediaSource && window$1$1.MediaSource.isTypeSupported && window$1$1.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
};
var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return codecString.toLowerCase().split(",").every(function(codec) {
    codec = codec.trim();
    for (var i = 0; i < upperMediaTypes.length; i++) {
      var type = upperMediaTypes[i];
      if (regexs["muxer" + type].test(codec)) {
        return true;
      }
    }
    return false;
  });
};
var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
var DEFAULT_VIDEO_CODEC = "avc1.4d400d";
var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
var DASH_REGEX = /^application\/dash\+xml/i;
var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type) {
  if (MPEGURL_REGEX.test(type)) {
    return "hls";
  }
  if (DASH_REGEX.test(type)) {
    return "dash";
  }
  if (type === "application/vnd.videojs.vhs+json") {
    return "vhs-json";
  }
  return null;
};
var countBits = function countBits2(x) {
  return x.toString(2).length;
};
var countBytes = function countBytes2(x) {
  return Math.ceil(countBits(x) / 8);
};
var isArrayBufferView = function isArrayBufferView2(obj) {
  if (ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(obj);
  }
  return obj && obj.buffer instanceof ArrayBuffer;
};
var isTypedArray = function isTypedArray2(obj) {
  return isArrayBufferView(obj);
};
var toUint8 = function toUint82(bytes) {
  if (bytes instanceof Uint8Array) {
    return bytes;
  }
  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
    if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
      bytes = 0;
    } else {
      bytes = [bytes];
    }
  }
  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
};
var BigInt$1 = window$1$1.BigInt || Number;
var BYTE_TABLE = [BigInt$1("0x1"), BigInt$1("0x100"), BigInt$1("0x10000"), BigInt$1("0x1000000"), BigInt$1("0x100000000"), BigInt$1("0x10000000000"), BigInt$1("0x1000000000000"), BigInt$1("0x100000000000000"), BigInt$1("0x10000000000000000")];
(function() {
  var a = new Uint16Array([65484]);
  var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  if (b[0] === 255) {
    return "big";
  }
  if (b[0] === 204) {
    return "little";
  }
  return "unknown";
})();
var bytesToNumber = function bytesToNumber2(bytes, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
  bytes = toUint8(bytes);
  var fn2 = le ? "reduce" : "reduceRight";
  var obj = bytes[fn2] ? bytes[fn2] : Array.prototype[fn2];
  var number = obj.call(bytes, function(total, byte, i) {
    var exponent = le ? i : Math.abs(i + 1 - bytes.length);
    return total + BigInt$1(byte) * BYTE_TABLE[exponent];
  }, BigInt$1(0));
  if (signed) {
    var max2 = BYTE_TABLE[bytes.length] / BigInt$1(2) - BigInt$1(1);
    number = BigInt$1(number);
    if (number > max2) {
      number -= max2;
      number -= max2;
      number -= BigInt$1(2);
    }
  }
  return Number(number);
};
var numberToBytes = function numberToBytes2(number, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
  if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
    number = 0;
  }
  number = BigInt$1(number);
  var byteCount = countBytes(number);
  var bytes = new Uint8Array(new ArrayBuffer(byteCount));
  for (var i = 0; i < byteCount; i++) {
    var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt$1(255));
    if (number < 0) {
      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
      bytes[byteIndex] -= i === 0 ? 1 : 2;
    }
  }
  return bytes;
};
var stringToBytes = function stringToBytes2(string, stringIsBytes) {
  if (typeof string !== "string" && string && typeof string.toString === "function") {
    string = string.toString();
  }
  if (typeof string !== "string") {
    return new Uint8Array();
  }
  if (!stringIsBytes) {
    string = unescape(encodeURIComponent(string));
  }
  var view = new Uint8Array(string.length);
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view;
};
var concatTypedArrays = function concatTypedArrays2() {
  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
    buffers[_key] = arguments[_key];
  }
  buffers = buffers.filter(function(b) {
    return b && (b.byteLength || b.length) && typeof b !== "string";
  });
  if (buffers.length <= 1) {
    return toUint8(buffers[0]);
  }
  var totalLen = buffers.reduce(function(total, buf, i) {
    return total + (buf.byteLength || buf.length);
  }, 0);
  var tempBuffer = new Uint8Array(totalLen);
  var offset2 = 0;
  buffers.forEach(function(buf) {
    buf = toUint8(buf);
    tempBuffer.set(buf, offset2);
    offset2 += buf.byteLength;
  });
  return tempBuffer;
};
var bytesMatch = function bytesMatch2(a, b, _temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset2 = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
  a = toUint8(a);
  b = toUint8(b);
  var fn2 = b.every ? b.every : Array.prototype.every;
  return b.length && a.length - offset2 >= b.length && // ie 11 doesn't support every on uin8
  fn2.call(b, function(bByte, i) {
    var aByte = mask[i] ? mask[i] & a[offset2 + i] : a[offset2 + i];
    return bByte === aByte;
  });
};
var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {
  groups.forEach(function(mediaType) {
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
var atob2 = function atob3(s) {
  return window$1$1.atob ? window$1$1.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob2(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}
var dom$1 = {};
var conventions$2 = {};
function find$1(list, predicate, ac) {
  if (ac === void 0) {
    ac = Array.prototype;
  }
  if (list && typeof ac.find === "function") {
    return ac.find.call(list, predicate);
  }
  for (var i = 0; i < list.length; i++) {
    if (Object.prototype.hasOwnProperty.call(list, i)) {
      var item = list[i];
      if (predicate.call(void 0, item, i, list)) {
        return item;
      }
    }
  }
}
function freeze(object, oc) {
  if (oc === void 0) {
    oc = Object;
  }
  return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
}
function assign(target, source) {
  if (target === null || typeof target !== "object") {
    throw new TypeError("target is not an object");
  }
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
  return target;
}
var MIME_TYPE = freeze({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(value2) {
    return value2 === MIME_TYPE.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
});
var NAMESPACE$3 = freeze({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(uri) {
    return uri === NAMESPACE$3.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
conventions$2.assign = assign;
conventions$2.find = find$1;
conventions$2.freeze = freeze;
conventions$2.MIME_TYPE = MIME_TYPE;
conventions$2.NAMESPACE = NAMESPACE$3;
var conventions$1 = conventions$2;
var find = conventions$1.find;
var NAMESPACE$2 = conventions$1.NAMESPACE;
function notEmptyString(input) {
  return input !== "";
}
function splitOnASCIIWhitespace(input) {
  return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}
function orderedSetReducer(current, element) {
  if (!current.hasOwnProperty(element)) {
    current[element] = true;
  }
  return current;
}
function toOrderedSet(input) {
  if (!input)
    return [];
  var list = splitOnASCIIWhitespace(input);
  return Object.keys(list.reduce(orderedSetReducer, {}));
}
function arrayIncludes(list) {
  return function(element) {
    return list && list.indexOf(element) !== -1;
  };
}
function copy(src, dest) {
  for (var p in src) {
    if (Object.prototype.hasOwnProperty.call(src, p)) {
      dest[p] = src[p];
    }
  }
}
function _extends(Class, Super) {
  var pt = Class.prototype;
  if (!(pt instanceof Super)) {
    let t = function() {
    };
    t.prototype = Super.prototype;
    t = new t();
    copy(pt, t);
    Class.prototype = pt = t;
  }
  if (pt.constructor != Class) {
    if (typeof Class != "function") {
      console.error("unknown Class:" + Class);
    }
    pt.constructor = Class;
  }
}
var NodeType = {};
var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
var TEXT_NODE = NodeType.TEXT_NODE = 3;
var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
var ExceptionCode = {};
var ExceptionMessage = {};
ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
function DOMException(code, message) {
  if (message instanceof Error) {
    var error = message;
  } else {
    error = this;
    Error.call(this, ExceptionMessage[code]);
    this.message = ExceptionMessage[code];
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, DOMException);
  }
  error.code = code;
  if (message)
    this.message = this.message + ": " + message;
  return error;
}
DOMException.prototype = Error.prototype;
copy(ExceptionCode, DOMException);
function NodeList() {
}
NodeList.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(index) {
    return index >= 0 && index < this.length ? this[index] : null;
  },
  toString: function(isHTML, nodeFilter) {
    for (var buf = [], i = 0; i < this.length; i++) {
      serializeToString(this[i], buf, isHTML, nodeFilter);
    }
    return buf.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(predicate) {
    return Array.prototype.filter.call(this, predicate);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(item) {
    return Array.prototype.indexOf.call(this, item);
  }
};
function LiveNodeList(node, refresh) {
  this._node = node;
  this._refresh = refresh;
  _updateLiveList(this);
}
function _updateLiveList(list) {
  var inc = list._node._inc || list._node.ownerDocument._inc;
  if (list._inc !== inc) {
    var ls = list._refresh(list._node);
    __set__(list, "length", ls.length);
    if (!list.$$length || ls.length < list.$$length) {
      for (var i = ls.length; i in list; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          delete list[i];
        }
      }
    }
    copy(ls, list);
    list._inc = inc;
  }
}
LiveNodeList.prototype.item = function(i) {
  _updateLiveList(this);
  return this[i] || null;
};
_extends(LiveNodeList, NodeList);
function NamedNodeMap() {
}
function _findNodeIndex(list, node) {
  var i = list.length;
  while (i--) {
    if (list[i] === node) {
      return i;
    }
  }
}
function _addNamedNode(el, list, newAttr, oldAttr) {
  if (oldAttr) {
    list[_findNodeIndex(list, oldAttr)] = newAttr;
  } else {
    list[list.length++] = newAttr;
  }
  if (el) {
    newAttr.ownerElement = el;
    var doc = el.ownerDocument;
    if (doc) {
      oldAttr && _onRemoveAttribute(doc, el, oldAttr);
      _onAddAttribute(doc, el, newAttr);
    }
  }
}
function _removeNamedNode(el, list, attr) {
  var i = _findNodeIndex(list, attr);
  if (i >= 0) {
    var lastIndex = list.length - 1;
    while (i < lastIndex) {
      list[i] = list[++i];
    }
    list.length = lastIndex;
    if (el) {
      var doc = el.ownerDocument;
      if (doc) {
        _onRemoveAttribute(doc, el, attr);
        attr.ownerElement = null;
      }
    }
  } else {
    throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
  }
}
NamedNodeMap.prototype = {
  length: 0,
  item: NodeList.prototype.item,
  getNamedItem: function(key) {
    var i = this.length;
    while (i--) {
      var attr = this[i];
      if (attr.nodeName == key) {
        return attr;
      }
    }
  },
  setNamedItem: function(attr) {
    var el = attr.ownerElement;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    var oldAttr = this.getNamedItem(attr.nodeName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  setNamedItemNS: function(attr) {
    var el = attr.ownerElement, oldAttr;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  removeNamedItem: function(key) {
    var attr = this.getNamedItem(key);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(namespaceURI, localName) {
    var attr = this.getNamedItemNS(namespaceURI, localName);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  getNamedItemNS: function(namespaceURI, localName) {
    var i = this.length;
    while (i--) {
      var node = this[i];
      if (node.localName == localName && node.namespaceURI == namespaceURI) {
        return node;
      }
    }
    return null;
  }
};
function DOMImplementation$1() {
}
DOMImplementation$1.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(feature, version2) {
    return true;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(namespaceURI, qualifiedName, doctype) {
    var doc = new Document();
    doc.implementation = this;
    doc.childNodes = new NodeList();
    doc.doctype = doctype || null;
    if (doctype) {
      doc.appendChild(doctype);
    }
    if (qualifiedName) {
      var root2 = doc.createElementNS(namespaceURI, qualifiedName);
      doc.appendChild(root2);
    }
    return doc;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(qualifiedName, publicId, systemId) {
    var node = new DocumentType();
    node.name = qualifiedName;
    node.nodeName = qualifiedName;
    node.publicId = publicId || "";
    node.systemId = systemId || "";
    return node;
  }
};
function Node() {
}
Node.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(newChild, refChild) {
    return _insertBefore(this, newChild, refChild);
  },
  replaceChild: function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    if (oldChild) {
      this.removeChild(oldChild);
    }
  },
  removeChild: function(oldChild) {
    return _removeChild(this, oldChild);
  },
  appendChild: function(newChild) {
    return this.insertBefore(newChild, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(deep) {
    return cloneNode(this.ownerDocument || this, this, deep);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    var child = this.firstChild;
    while (child) {
      var next = child.nextSibling;
      if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
        this.removeChild(next);
        child.appendData(next.data);
      } else {
        child.normalize();
        child = next;
      }
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(feature, version2) {
    return this.ownerDocument.implementation.hasFeature(feature, version2);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(namespaceURI) {
    var el = this;
    while (el) {
      var map2 = el._nsMap;
      if (map2) {
        for (var n in map2) {
          if (Object.prototype.hasOwnProperty.call(map2, n) && map2[n] === namespaceURI) {
            return n;
          }
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(prefix) {
    var el = this;
    while (el) {
      var map2 = el._nsMap;
      if (map2) {
        if (Object.prototype.hasOwnProperty.call(map2, prefix)) {
          return map2[prefix];
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(namespaceURI) {
    var prefix = this.lookupPrefix(namespaceURI);
    return prefix == null;
  }
};
function _xmlEncoder(c) {
  return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
}
copy(NodeType, Node);
copy(NodeType, Node.prototype);
function _visitNode(node, callback) {
  if (callback(node)) {
    return true;
  }
  if (node = node.firstChild) {
    do {
      if (_visitNode(node, callback)) {
        return true;
      }
    } while (node = node.nextSibling);
  }
}
function Document() {
  this.ownerDocument = this;
}
function _onAddAttribute(doc, el, newAttr) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$2.XMLNS) {
    el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
  }
}
function _onRemoveAttribute(doc, el, newAttr, remove) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$2.XMLNS) {
    delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
  }
}
function _onUpdateChild(doc, el, newChild) {
  if (doc && doc._inc) {
    doc._inc++;
    var cs = el.childNodes;
    if (newChild) {
      cs[cs.length++] = newChild;
    } else {
      var child = el.firstChild;
      var i = 0;
      while (child) {
        cs[i++] = child;
        child = child.nextSibling;
      }
      cs.length = i;
      delete cs[cs.length];
    }
  }
}
function _removeChild(parentNode, child) {
  var previous = child.previousSibling;
  var next = child.nextSibling;
  if (previous) {
    previous.nextSibling = next;
  } else {
    parentNode.firstChild = next;
  }
  if (next) {
    next.previousSibling = previous;
  } else {
    parentNode.lastChild = previous;
  }
  child.parentNode = null;
  child.previousSibling = null;
  child.nextSibling = null;
  _onUpdateChild(parentNode.ownerDocument, parentNode);
  return child;
}
function hasValidParentNodeType(node) {
  return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
}
function hasInsertableNodeType(node) {
  return node && (isElementNode(node) || isTextNode$1(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
}
function isDocTypeNode(node) {
  return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}
function isElementNode(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}
function isTextNode$1(node) {
  return node && node.nodeType === Node.TEXT_NODE;
}
function isElementInsertionPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
    return false;
  }
  var docTypeNode = find(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}
function isElementReplacementPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  function hasElementChildThatIsNotChild(node) {
    return isElementNode(node) && node !== child;
  }
  if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
    return false;
  }
  var docTypeNode = find(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}
function assertPreInsertionValidity1to5(parent, node, child) {
  if (!hasValidParentNodeType(parent)) {
    throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
  }
  if (child && child.parentNode !== parent) {
    throw new DOMException(NOT_FOUND_ERR, "child not in parent");
  }
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
  ) {
    throw new DOMException(
      HIERARCHY_REQUEST_ERR,
      "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
    );
  }
}
function assertPreInsertionValidityInDocument(parent, node, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node.childNodes || [];
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode$1)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
    }
    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
  }
  if (isElementNode(node)) {
    if (!isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
  }
  if (isDocTypeNode(node)) {
    if (find(parentChildNodes, isDocTypeNode)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
    }
    var parentElementChild = find(parentChildNodes, isElementNode);
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
    if (!child && parentElementChild) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
    }
  }
}
function assertPreReplacementValidityInDocument(parent, node, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node.childNodes || [];
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode$1)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
    }
    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
  }
  if (isElementNode(node)) {
    if (!isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
  }
  if (isDocTypeNode(node)) {
    let hasDoctypeChildThatIsNotChild = function(node2) {
      return isDocTypeNode(node2) && node2 !== child;
    };
    if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
    }
    var parentElementChild = find(parentChildNodes, isElementNode);
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
  }
}
function _insertBefore(parent, node, child, _inDocumentAssertion) {
  assertPreInsertionValidity1to5(parent, node, child);
  if (parent.nodeType === Node.DOCUMENT_NODE) {
    (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
  }
  var cp = node.parentNode;
  if (cp) {
    cp.removeChild(node);
  }
  if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
    var newFirst = node.firstChild;
    if (newFirst == null) {
      return node;
    }
    var newLast = node.lastChild;
  } else {
    newFirst = newLast = node;
  }
  var pre = child ? child.previousSibling : parent.lastChild;
  newFirst.previousSibling = pre;
  newLast.nextSibling = child;
  if (pre) {
    pre.nextSibling = newFirst;
  } else {
    parent.firstChild = newFirst;
  }
  if (child == null) {
    parent.lastChild = newLast;
  } else {
    child.previousSibling = newLast;
  }
  do {
    newFirst.parentNode = parent;
  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
  _onUpdateChild(parent.ownerDocument || parent, parent);
  if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
    node.firstChild = node.lastChild = null;
  }
  return node;
}
function _appendSingleChild(parentNode, newChild) {
  if (newChild.parentNode) {
    newChild.parentNode.removeChild(newChild);
  }
  newChild.parentNode = parentNode;
  newChild.previousSibling = parentNode.lastChild;
  newChild.nextSibling = null;
  if (newChild.previousSibling) {
    newChild.previousSibling.nextSibling = newChild;
  } else {
    parentNode.firstChild = newChild;
  }
  parentNode.lastChild = newChild;
  _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
  return newChild;
}
Document.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: DOCUMENT_NODE,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(newChild, refChild) {
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      var child = newChild.firstChild;
      while (child) {
        var next = child.nextSibling;
        this.insertBefore(child, refChild);
        child = next;
      }
      return newChild;
    }
    _insertBefore(this, newChild, refChild);
    newChild.ownerDocument = this;
    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
      this.documentElement = newChild;
    }
    return newChild;
  },
  removeChild: function(oldChild) {
    if (this.documentElement == oldChild) {
      this.documentElement = null;
    }
    return _removeChild(this, oldChild);
  },
  replaceChild: function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    newChild.ownerDocument = this;
    if (oldChild) {
      this.removeChild(oldChild);
    }
    if (isElementNode(newChild)) {
      this.documentElement = newChild;
    }
  },
  // Introduced in DOM Level 2:
  importNode: function(importedNode, deep) {
    return importNode(this, importedNode, deep);
  },
  // Introduced in DOM Level 2:
  getElementById: function(id) {
    var rtv = null;
    _visitNode(this.documentElement, function(node) {
      if (node.nodeType == ELEMENT_NODE) {
        if (node.getAttribute("id") == id) {
          rtv = node;
          return true;
        }
      }
    });
    return rtv;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(classNames) {
    var classNamesSet = toOrderedSet(classNames);
    return new LiveNodeList(this, function(base) {
      var ls = [];
      if (classNamesSet.length > 0) {
        _visitNode(base.documentElement, function(node) {
          if (node !== base && node.nodeType === ELEMENT_NODE) {
            var nodeClassNames = node.getAttribute("class");
            if (nodeClassNames) {
              var matches = classNames === nodeClassNames;
              if (!matches) {
                var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
              }
              if (matches) {
                ls.push(node);
              }
            }
          }
        });
      }
      return ls;
    });
  },
  //document factory method:
  createElement: function(tagName) {
    var node = new Element$1();
    node.ownerDocument = this;
    node.nodeName = tagName;
    node.tagName = tagName;
    node.localName = tagName;
    node.childNodes = new NodeList();
    var attrs = node.attributes = new NamedNodeMap();
    attrs._ownerElement = node;
    return node;
  },
  createDocumentFragment: function() {
    var node = new DocumentFragment2();
    node.ownerDocument = this;
    node.childNodes = new NodeList();
    return node;
  },
  createTextNode: function(data) {
    var node = new Text();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createComment: function(data) {
    var node = new Comment();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createCDATASection: function(data) {
    var node = new CDATASection();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  },
  createProcessingInstruction: function(target, data) {
    var node = new ProcessingInstruction();
    node.ownerDocument = this;
    node.tagName = node.nodeName = node.target = target;
    node.nodeValue = node.data = data;
    return node;
  },
  createAttribute: function(name) {
    var node = new Attr();
    node.ownerDocument = this;
    node.name = name;
    node.nodeName = name;
    node.localName = name;
    node.specified = true;
    return node;
  },
  createEntityReference: function(name) {
    var node = new EntityReference();
    node.ownerDocument = this;
    node.nodeName = name;
    return node;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(namespaceURI, qualifiedName) {
    var node = new Element$1();
    var pl = qualifiedName.split(":");
    var attrs = node.attributes = new NamedNodeMap();
    node.childNodes = new NodeList();
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.tagName = qualifiedName;
    node.namespaceURI = namespaceURI;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      node.localName = qualifiedName;
    }
    attrs._ownerElement = node;
    return node;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(namespaceURI, qualifiedName) {
    var node = new Attr();
    var pl = qualifiedName.split(":");
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.name = qualifiedName;
    node.namespaceURI = namespaceURI;
    node.specified = true;
    if (pl.length == 2) {
      node.prefix = pl[0];
      node.localName = pl[1];
    } else {
      node.localName = qualifiedName;
    }
    return node;
  }
};
_extends(Document, Node);
function Element$1() {
  this._nsMap = {};
}
Element$1.prototype = {
  nodeType: ELEMENT_NODE,
  hasAttribute: function(name) {
    return this.getAttributeNode(name) != null;
  },
  getAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    return attr && attr.value || "";
  },
  getAttributeNode: function(name) {
    return this.attributes.getNamedItem(name);
  },
  setAttribute: function(name, value2) {
    var attr = this.ownerDocument.createAttribute(name);
    attr.value = attr.nodeValue = "" + value2;
    this.setAttributeNode(attr);
  },
  removeAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    attr && this.removeAttributeNode(attr);
  },
  //four real opeartion method
  appendChild: function(newChild) {
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return this.insertBefore(newChild, null);
    } else {
      return _appendSingleChild(this, newChild);
    }
  },
  setAttributeNode: function(newAttr) {
    return this.attributes.setNamedItem(newAttr);
  },
  setAttributeNodeNS: function(newAttr) {
    return this.attributes.setNamedItemNS(newAttr);
  },
  removeAttributeNode: function(oldAttr) {
    return this.attributes.removeNamedItem(oldAttr.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(namespaceURI, localName) {
    var old = this.getAttributeNodeNS(namespaceURI, localName);
    old && this.removeAttributeNode(old);
  },
  hasAttributeNS: function(namespaceURI, localName) {
    return this.getAttributeNodeNS(namespaceURI, localName) != null;
  },
  getAttributeNS: function(namespaceURI, localName) {
    var attr = this.getAttributeNodeNS(namespaceURI, localName);
    return attr && attr.value || "";
  },
  setAttributeNS: function(namespaceURI, qualifiedName, value2) {
    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
    attr.value = attr.nodeValue = "" + value2;
    this.setAttributeNode(attr);
  },
  getAttributeNodeNS: function(namespaceURI, localName) {
    return this.attributes.getNamedItemNS(namespaceURI, localName);
  },
  getElementsByTagName: function(tagName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  },
  getElementsByTagNameNS: function(namespaceURI, localName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
          ls.push(node);
        }
      });
      return ls;
    });
  }
};
Document.prototype.getElementsByTagName = Element$1.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element$1.prototype.getElementsByTagNameNS;
_extends(Element$1, Node);
function Attr() {
}
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr, Node);
function CharacterData() {
}
CharacterData.prototype = {
  data: "",
  substringData: function(offset2, count) {
    return this.data.substring(offset2, offset2 + count);
  },
  appendData: function(text2) {
    text2 = this.data + text2;
    this.nodeValue = this.data = text2;
    this.length = text2.length;
  },
  insertData: function(offset2, text2) {
    this.replaceData(offset2, 0, text2);
  },
  appendChild: function(newChild) {
    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
  },
  deleteData: function(offset2, count) {
    this.replaceData(offset2, count, "");
  },
  replaceData: function(offset2, count, text2) {
    var start2 = this.data.substring(0, offset2);
    var end2 = this.data.substring(offset2 + count);
    text2 = start2 + text2 + end2;
    this.nodeValue = this.data = text2;
    this.length = text2.length;
  }
};
_extends(CharacterData, Node);
function Text() {
}
Text.prototype = {
  nodeName: "#text",
  nodeType: TEXT_NODE,
  splitText: function(offset2) {
    var text2 = this.data;
    var newText = text2.substring(offset2);
    text2 = text2.substring(0, offset2);
    this.data = this.nodeValue = text2;
    this.length = text2.length;
    var newNode = this.ownerDocument.createTextNode(newText);
    if (this.parentNode) {
      this.parentNode.insertBefore(newNode, this.nextSibling);
    }
    return newNode;
  }
};
_extends(Text, CharacterData);
function Comment() {
}
Comment.prototype = {
  nodeName: "#comment",
  nodeType: COMMENT_NODE
};
_extends(Comment, CharacterData);
function CDATASection() {
}
CDATASection.prototype = {
  nodeName: "#cdata-section",
  nodeType: CDATA_SECTION_NODE
};
_extends(CDATASection, CharacterData);
function DocumentType() {
}
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType, Node);
function Notation() {
}
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation, Node);
function Entity() {
}
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity, Node);
function EntityReference() {
}
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference, Node);
function DocumentFragment2() {
}
DocumentFragment2.prototype.nodeName = "#document-fragment";
DocumentFragment2.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment2, Node);
function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction, Node);
function XMLSerializer() {
}
XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
  return nodeSerializeToString.call(node, isHtml, nodeFilter);
};
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml, nodeFilter) {
  var buf = [];
  var refNode = this.nodeType == 9 && this.documentElement || this;
  var prefix = refNode.prefix;
  var uri = refNode.namespaceURI;
  if (uri && prefix == null) {
    var prefix = refNode.lookupPrefix(uri);
    if (prefix == null) {
      var visibleNamespaces = [
        { namespace: uri, prefix: null }
        //{namespace:uri,prefix:''}
      ];
    }
  }
  serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
  return buf.join("");
}
function needNamespaceDefine(node, isHTML, visibleNamespaces) {
  var prefix = node.prefix || "";
  var uri = node.namespaceURI;
  if (!uri) {
    return false;
  }
  if (prefix === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
    return false;
  }
  var i = visibleNamespaces.length;
  while (i--) {
    var ns = visibleNamespaces[i];
    if (ns.prefix === prefix) {
      return ns.namespace !== uri;
    }
  }
  return true;
}
function addSerializedAttribute(buf, qualifiedName, value2) {
  buf.push(" ", qualifiedName, '="', value2.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
}
function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
  if (!visibleNamespaces) {
    visibleNamespaces = [];
  }
  if (nodeFilter) {
    node = nodeFilter(node);
    if (node) {
      if (typeof node == "string") {
        buf.push(node);
        return;
      }
    } else {
      return;
    }
  }
  switch (node.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var len = attrs.length;
      var child = node.firstChild;
      var nodeName = node.tagName;
      isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;
      var prefixedNodeName = nodeName;
      if (!isHTML && !node.prefix && node.namespaceURI) {
        var defaultNS;
        for (var ai = 0; ai < attrs.length; ai++) {
          if (attrs.item(ai).name === "xmlns") {
            defaultNS = attrs.item(ai).value;
            break;
          }
        }
        if (!defaultNS) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
              defaultNS = namespace.namespace;
              break;
            }
          }
        }
        if (defaultNS !== node.namespaceURI) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.namespace === node.namespaceURI) {
              if (namespace.prefix) {
                prefixedNodeName = namespace.prefix + ":" + nodeName;
              }
              break;
            }
          }
        }
      }
      buf.push("<", prefixedNodeName);
      for (var i = 0; i < len; i++) {
        var attr = attrs.item(i);
        if (attr.prefix == "xmlns") {
          visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
        } else if (attr.nodeName == "xmlns") {
          visibleNamespaces.push({ prefix: "", namespace: attr.value });
        }
      }
      for (var i = 0; i < len; i++) {
        var attr = attrs.item(i);
        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
          var prefix = attr.prefix || "";
          var uri = attr.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
          visibleNamespaces.push({ prefix, namespace: uri });
        }
        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
      }
      if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
        var prefix = node.prefix || "";
        var uri = node.namespaceURI;
        addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
        visibleNamespaces.push({ prefix, namespace: uri });
      }
      if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
        buf.push(">");
        if (isHTML && /^script$/i.test(nodeName)) {
          while (child) {
            if (child.data) {
              buf.push(child.data);
            } else {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            }
            child = child.nextSibling;
          }
        } else {
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
        }
        buf.push("</", prefixedNodeName, ">");
      } else {
        buf.push("/>");
      }
      return;
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      var child = node.firstChild;
      while (child) {
        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
        child = child.nextSibling;
      }
      return;
    case ATTRIBUTE_NODE:
      return addSerializedAttribute(buf, node.name, node.value);
    case TEXT_NODE:
      return buf.push(
        node.data.replace(/[<&>]/g, _xmlEncoder)
      );
    case CDATA_SECTION_NODE:
      return buf.push("<![CDATA[", node.data, "]]>");
    case COMMENT_NODE:
      return buf.push("<!--", node.data, "-->");
    case DOCUMENT_TYPE_NODE:
      var pubid = node.publicId;
      var sysid = node.systemId;
      buf.push("<!DOCTYPE ", node.name);
      if (pubid) {
        buf.push(" PUBLIC ", pubid);
        if (sysid && sysid != ".") {
          buf.push(" ", sysid);
        }
        buf.push(">");
      } else if (sysid && sysid != ".") {
        buf.push(" SYSTEM ", sysid, ">");
      } else {
        var sub2 = node.internalSubset;
        if (sub2) {
          buf.push(" [", sub2, "]");
        }
        buf.push(">");
      }
      return;
    case PROCESSING_INSTRUCTION_NODE:
      return buf.push("<?", node.target, " ", node.data, "?>");
    case ENTITY_REFERENCE_NODE:
      return buf.push("&", node.nodeName, ";");
    default:
      buf.push("??", node.nodeName);
  }
}
function importNode(doc, node, deep) {
  var node2;
  switch (node.nodeType) {
    case ELEMENT_NODE:
      node2 = node.cloneNode(false);
      node2.ownerDocument = doc;
    case DOCUMENT_FRAGMENT_NODE:
      break;
    case ATTRIBUTE_NODE:
      deep = true;
      break;
  }
  if (!node2) {
    node2 = node.cloneNode(false);
  }
  node2.ownerDocument = doc;
  node2.parentNode = null;
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(importNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
function cloneNode(doc, node, deep) {
  var node2 = new node.constructor();
  for (var n in node) {
    if (Object.prototype.hasOwnProperty.call(node, n)) {
      var v = node[n];
      if (typeof v != "object") {
        if (v != node2[n]) {
          node2[n] = v;
        }
      }
    }
  }
  if (node.childNodes) {
    node2.childNodes = new NodeList();
  }
  node2.ownerDocument = doc;
  switch (node2.nodeType) {
    case ELEMENT_NODE:
      var attrs = node.attributes;
      var attrs2 = node2.attributes = new NamedNodeMap();
      var len = attrs.length;
      attrs2._ownerElement = node2;
      for (var i = 0; i < len; i++) {
        node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
      }
      break;
    case ATTRIBUTE_NODE:
      deep = true;
  }
  if (deep) {
    var child = node.firstChild;
    while (child) {
      node2.appendChild(cloneNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node2;
}
function __set__(object, key, value2) {
  object[key] = value2;
}
try {
  if (Object.defineProperty) {
    let getTextContent = function(node) {
      switch (node.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var buf = [];
          node = node.firstChild;
          while (node) {
            if (node.nodeType !== 7 && node.nodeType !== 8) {
              buf.push(getTextContent(node));
            }
            node = node.nextSibling;
          }
          return buf.join("");
        default:
          return node.nodeValue;
      }
    };
    Object.defineProperty(LiveNodeList.prototype, "length", {
      get: function() {
        _updateLiveList(this);
        return this.$$length;
      }
    });
    Object.defineProperty(Node.prototype, "textContent", {
      get: function() {
        return getTextContent(this);
      },
      set: function(data) {
        switch (this.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            while (this.firstChild) {
              this.removeChild(this.firstChild);
            }
            if (data || String(data)) {
              this.appendChild(this.ownerDocument.createTextNode(data));
            }
            break;
          default:
            this.data = data;
            this.value = data;
            this.nodeValue = data;
        }
      }
    });
    __set__ = function(object, key, value2) {
      object["$$" + key] = value2;
    };
  }
} catch (e) {
}
dom$1.DocumentType = DocumentType;
dom$1.DOMException = DOMException;
dom$1.DOMImplementation = DOMImplementation$1;
dom$1.Element = Element$1;
dom$1.Node = Node;
dom$1.NodeList = NodeList;
dom$1.XMLSerializer = XMLSerializer;
var domParser = {};
var entities$1 = {};
(function(exports2) {
  var freeze2 = conventions$2.freeze;
  exports2.XML_ENTITIES = freeze2({
    amp: "&",
    apos: "'",
    gt: ">",
    lt: "<",
    quot: '"'
  });
  exports2.HTML_ENTITIES = freeze2({
    Aacute: "Á",
    aacute: "á",
    Abreve: "Ă",
    abreve: "ă",
    ac: "∾",
    acd: "∿",
    acE: "∾̳",
    Acirc: "Â",
    acirc: "â",
    acute: "´",
    Acy: "А",
    acy: "а",
    AElig: "Æ",
    aelig: "æ",
    af: "⁡",
    Afr: "𝔄",
    afr: "𝔞",
    Agrave: "À",
    agrave: "à",
    alefsym: "ℵ",
    aleph: "ℵ",
    Alpha: "Α",
    alpha: "α",
    Amacr: "Ā",
    amacr: "ā",
    amalg: "⨿",
    AMP: "&",
    amp: "&",
    And: "⩓",
    and: "∧",
    andand: "⩕",
    andd: "⩜",
    andslope: "⩘",
    andv: "⩚",
    ang: "∠",
    ange: "⦤",
    angle: "∠",
    angmsd: "∡",
    angmsdaa: "⦨",
    angmsdab: "⦩",
    angmsdac: "⦪",
    angmsdad: "⦫",
    angmsdae: "⦬",
    angmsdaf: "⦭",
    angmsdag: "⦮",
    angmsdah: "⦯",
    angrt: "∟",
    angrtvb: "⊾",
    angrtvbd: "⦝",
    angsph: "∢",
    angst: "Å",
    angzarr: "⍼",
    Aogon: "Ą",
    aogon: "ą",
    Aopf: "𝔸",
    aopf: "𝕒",
    ap: "≈",
    apacir: "⩯",
    apE: "⩰",
    ape: "≊",
    apid: "≋",
    apos: "'",
    ApplyFunction: "⁡",
    approx: "≈",
    approxeq: "≊",
    Aring: "Å",
    aring: "å",
    Ascr: "𝒜",
    ascr: "𝒶",
    Assign: "≔",
    ast: "*",
    asymp: "≈",
    asympeq: "≍",
    Atilde: "Ã",
    atilde: "ã",
    Auml: "Ä",
    auml: "ä",
    awconint: "∳",
    awint: "⨑",
    backcong: "≌",
    backepsilon: "϶",
    backprime: "‵",
    backsim: "∽",
    backsimeq: "⋍",
    Backslash: "∖",
    Barv: "⫧",
    barvee: "⊽",
    Barwed: "⌆",
    barwed: "⌅",
    barwedge: "⌅",
    bbrk: "⎵",
    bbrktbrk: "⎶",
    bcong: "≌",
    Bcy: "Б",
    bcy: "б",
    bdquo: "„",
    becaus: "∵",
    Because: "∵",
    because: "∵",
    bemptyv: "⦰",
    bepsi: "϶",
    bernou: "ℬ",
    Bernoullis: "ℬ",
    Beta: "Β",
    beta: "β",
    beth: "ℶ",
    between: "≬",
    Bfr: "𝔅",
    bfr: "𝔟",
    bigcap: "⋂",
    bigcirc: "◯",
    bigcup: "⋃",
    bigodot: "⨀",
    bigoplus: "⨁",
    bigotimes: "⨂",
    bigsqcup: "⨆",
    bigstar: "★",
    bigtriangledown: "▽",
    bigtriangleup: "△",
    biguplus: "⨄",
    bigvee: "⋁",
    bigwedge: "⋀",
    bkarow: "⤍",
    blacklozenge: "⧫",
    blacksquare: "▪",
    blacktriangle: "▴",
    blacktriangledown: "▾",
    blacktriangleleft: "◂",
    blacktriangleright: "▸",
    blank: "␣",
    blk12: "▒",
    blk14: "░",
    blk34: "▓",
    block: "█",
    bne: "=⃥",
    bnequiv: "≡⃥",
    bNot: "⫭",
    bnot: "⌐",
    Bopf: "𝔹",
    bopf: "𝕓",
    bot: "⊥",
    bottom: "⊥",
    bowtie: "⋈",
    boxbox: "⧉",
    boxDL: "╗",
    boxDl: "╖",
    boxdL: "╕",
    boxdl: "┐",
    boxDR: "╔",
    boxDr: "╓",
    boxdR: "╒",
    boxdr: "┌",
    boxH: "═",
    boxh: "─",
    boxHD: "╦",
    boxHd: "╤",
    boxhD: "╥",
    boxhd: "┬",
    boxHU: "╩",
    boxHu: "╧",
    boxhU: "╨",
    boxhu: "┴",
    boxminus: "⊟",
    boxplus: "⊞",
    boxtimes: "⊠",
    boxUL: "╝",
    boxUl: "╜",
    boxuL: "╛",
    boxul: "┘",
    boxUR: "╚",
    boxUr: "╙",
    boxuR: "╘",
    boxur: "└",
    boxV: "║",
    boxv: "│",
    boxVH: "╬",
    boxVh: "╫",
    boxvH: "╪",
    boxvh: "┼",
    boxVL: "╣",
    boxVl: "╢",
    boxvL: "╡",
    boxvl: "┤",
    boxVR: "╠",
    boxVr: "╟",
    boxvR: "╞",
    boxvr: "├",
    bprime: "‵",
    Breve: "˘",
    breve: "˘",
    brvbar: "¦",
    Bscr: "ℬ",
    bscr: "𝒷",
    bsemi: "⁏",
    bsim: "∽",
    bsime: "⋍",
    bsol: "\\",
    bsolb: "⧅",
    bsolhsub: "⟈",
    bull: "•",
    bullet: "•",
    bump: "≎",
    bumpE: "⪮",
    bumpe: "≏",
    Bumpeq: "≎",
    bumpeq: "≏",
    Cacute: "Ć",
    cacute: "ć",
    Cap: "⋒",
    cap: "∩",
    capand: "⩄",
    capbrcup: "⩉",
    capcap: "⩋",
    capcup: "⩇",
    capdot: "⩀",
    CapitalDifferentialD: "ⅅ",
    caps: "∩︀",
    caret: "⁁",
    caron: "ˇ",
    Cayleys: "ℭ",
    ccaps: "⩍",
    Ccaron: "Č",
    ccaron: "č",
    Ccedil: "Ç",
    ccedil: "ç",
    Ccirc: "Ĉ",
    ccirc: "ĉ",
    Cconint: "∰",
    ccups: "⩌",
    ccupssm: "⩐",
    Cdot: "Ċ",
    cdot: "ċ",
    cedil: "¸",
    Cedilla: "¸",
    cemptyv: "⦲",
    cent: "¢",
    CenterDot: "·",
    centerdot: "·",
    Cfr: "ℭ",
    cfr: "𝔠",
    CHcy: "Ч",
    chcy: "ч",
    check: "✓",
    checkmark: "✓",
    Chi: "Χ",
    chi: "χ",
    cir: "○",
    circ: "ˆ",
    circeq: "≗",
    circlearrowleft: "↺",
    circlearrowright: "↻",
    circledast: "⊛",
    circledcirc: "⊚",
    circleddash: "⊝",
    CircleDot: "⊙",
    circledR: "®",
    circledS: "Ⓢ",
    CircleMinus: "⊖",
    CirclePlus: "⊕",
    CircleTimes: "⊗",
    cirE: "⧃",
    cire: "≗",
    cirfnint: "⨐",
    cirmid: "⫯",
    cirscir: "⧂",
    ClockwiseContourIntegral: "∲",
    CloseCurlyDoubleQuote: "”",
    CloseCurlyQuote: "’",
    clubs: "♣",
    clubsuit: "♣",
    Colon: "∷",
    colon: ":",
    Colone: "⩴",
    colone: "≔",
    coloneq: "≔",
    comma: ",",
    commat: "@",
    comp: "∁",
    compfn: "∘",
    complement: "∁",
    complexes: "ℂ",
    cong: "≅",
    congdot: "⩭",
    Congruent: "≡",
    Conint: "∯",
    conint: "∮",
    ContourIntegral: "∮",
    Copf: "ℂ",
    copf: "𝕔",
    coprod: "∐",
    Coproduct: "∐",
    COPY: "©",
    copy: "©",
    copysr: "℗",
    CounterClockwiseContourIntegral: "∳",
    crarr: "↵",
    Cross: "⨯",
    cross: "✗",
    Cscr: "𝒞",
    cscr: "𝒸",
    csub: "⫏",
    csube: "⫑",
    csup: "⫐",
    csupe: "⫒",
    ctdot: "⋯",
    cudarrl: "⤸",
    cudarrr: "⤵",
    cuepr: "⋞",
    cuesc: "⋟",
    cularr: "↶",
    cularrp: "⤽",
    Cup: "⋓",
    cup: "∪",
    cupbrcap: "⩈",
    CupCap: "≍",
    cupcap: "⩆",
    cupcup: "⩊",
    cupdot: "⊍",
    cupor: "⩅",
    cups: "∪︀",
    curarr: "↷",
    curarrm: "⤼",
    curlyeqprec: "⋞",
    curlyeqsucc: "⋟",
    curlyvee: "⋎",
    curlywedge: "⋏",
    curren: "¤",
    curvearrowleft: "↶",
    curvearrowright: "↷",
    cuvee: "⋎",
    cuwed: "⋏",
    cwconint: "∲",
    cwint: "∱",
    cylcty: "⌭",
    Dagger: "‡",
    dagger: "†",
    daleth: "ℸ",
    Darr: "↡",
    dArr: "⇓",
    darr: "↓",
    dash: "‐",
    Dashv: "⫤",
    dashv: "⊣",
    dbkarow: "⤏",
    dblac: "˝",
    Dcaron: "Ď",
    dcaron: "ď",
    Dcy: "Д",
    dcy: "д",
    DD: "ⅅ",
    dd: "ⅆ",
    ddagger: "‡",
    ddarr: "⇊",
    DDotrahd: "⤑",
    ddotseq: "⩷",
    deg: "°",
    Del: "∇",
    Delta: "Δ",
    delta: "δ",
    demptyv: "⦱",
    dfisht: "⥿",
    Dfr: "𝔇",
    dfr: "𝔡",
    dHar: "⥥",
    dharl: "⇃",
    dharr: "⇂",
    DiacriticalAcute: "´",
    DiacriticalDot: "˙",
    DiacriticalDoubleAcute: "˝",
    DiacriticalGrave: "`",
    DiacriticalTilde: "˜",
    diam: "⋄",
    Diamond: "⋄",
    diamond: "⋄",
    diamondsuit: "♦",
    diams: "♦",
    die: "¨",
    DifferentialD: "ⅆ",
    digamma: "ϝ",
    disin: "⋲",
    div: "÷",
    divide: "÷",
    divideontimes: "⋇",
    divonx: "⋇",
    DJcy: "Ђ",
    djcy: "ђ",
    dlcorn: "⌞",
    dlcrop: "⌍",
    dollar: "$",
    Dopf: "𝔻",
    dopf: "𝕕",
    Dot: "¨",
    dot: "˙",
    DotDot: "⃜",
    doteq: "≐",
    doteqdot: "≑",
    DotEqual: "≐",
    dotminus: "∸",
    dotplus: "∔",
    dotsquare: "⊡",
    doublebarwedge: "⌆",
    DoubleContourIntegral: "∯",
    DoubleDot: "¨",
    DoubleDownArrow: "⇓",
    DoubleLeftArrow: "⇐",
    DoubleLeftRightArrow: "⇔",
    DoubleLeftTee: "⫤",
    DoubleLongLeftArrow: "⟸",
    DoubleLongLeftRightArrow: "⟺",
    DoubleLongRightArrow: "⟹",
    DoubleRightArrow: "⇒",
    DoubleRightTee: "⊨",
    DoubleUpArrow: "⇑",
    DoubleUpDownArrow: "⇕",
    DoubleVerticalBar: "∥",
    DownArrow: "↓",
    Downarrow: "⇓",
    downarrow: "↓",
    DownArrowBar: "⤓",
    DownArrowUpArrow: "⇵",
    DownBreve: "̑",
    downdownarrows: "⇊",
    downharpoonleft: "⇃",
    downharpoonright: "⇂",
    DownLeftRightVector: "⥐",
    DownLeftTeeVector: "⥞",
    DownLeftVector: "↽",
    DownLeftVectorBar: "⥖",
    DownRightTeeVector: "⥟",
    DownRightVector: "⇁",
    DownRightVectorBar: "⥗",
    DownTee: "⊤",
    DownTeeArrow: "↧",
    drbkarow: "⤐",
    drcorn: "⌟",
    drcrop: "⌌",
    Dscr: "𝒟",
    dscr: "𝒹",
    DScy: "Ѕ",
    dscy: "ѕ",
    dsol: "⧶",
    Dstrok: "Đ",
    dstrok: "đ",
    dtdot: "⋱",
    dtri: "▿",
    dtrif: "▾",
    duarr: "⇵",
    duhar: "⥯",
    dwangle: "⦦",
    DZcy: "Џ",
    dzcy: "џ",
    dzigrarr: "⟿",
    Eacute: "É",
    eacute: "é",
    easter: "⩮",
    Ecaron: "Ě",
    ecaron: "ě",
    ecir: "≖",
    Ecirc: "Ê",
    ecirc: "ê",
    ecolon: "≕",
    Ecy: "Э",
    ecy: "э",
    eDDot: "⩷",
    Edot: "Ė",
    eDot: "≑",
    edot: "ė",
    ee: "ⅇ",
    efDot: "≒",
    Efr: "𝔈",
    efr: "𝔢",
    eg: "⪚",
    Egrave: "È",
    egrave: "è",
    egs: "⪖",
    egsdot: "⪘",
    el: "⪙",
    Element: "∈",
    elinters: "⏧",
    ell: "ℓ",
    els: "⪕",
    elsdot: "⪗",
    Emacr: "Ē",
    emacr: "ē",
    empty: "∅",
    emptyset: "∅",
    EmptySmallSquare: "◻",
    emptyv: "∅",
    EmptyVerySmallSquare: "▫",
    emsp: " ",
    emsp13: " ",
    emsp14: " ",
    ENG: "Ŋ",
    eng: "ŋ",
    ensp: " ",
    Eogon: "Ę",
    eogon: "ę",
    Eopf: "𝔼",
    eopf: "𝕖",
    epar: "⋕",
    eparsl: "⧣",
    eplus: "⩱",
    epsi: "ε",
    Epsilon: "Ε",
    epsilon: "ε",
    epsiv: "ϵ",
    eqcirc: "≖",
    eqcolon: "≕",
    eqsim: "≂",
    eqslantgtr: "⪖",
    eqslantless: "⪕",
    Equal: "⩵",
    equals: "=",
    EqualTilde: "≂",
    equest: "≟",
    Equilibrium: "⇌",
    equiv: "≡",
    equivDD: "⩸",
    eqvparsl: "⧥",
    erarr: "⥱",
    erDot: "≓",
    Escr: "ℰ",
    escr: "ℯ",
    esdot: "≐",
    Esim: "⩳",
    esim: "≂",
    Eta: "Η",
    eta: "η",
    ETH: "Ð",
    eth: "ð",
    Euml: "Ë",
    euml: "ë",
    euro: "€",
    excl: "!",
    exist: "∃",
    Exists: "∃",
    expectation: "ℰ",
    ExponentialE: "ⅇ",
    exponentiale: "ⅇ",
    fallingdotseq: "≒",
    Fcy: "Ф",
    fcy: "ф",
    female: "♀",
    ffilig: "ﬃ",
    fflig: "ﬀ",
    ffllig: "ﬄ",
    Ffr: "𝔉",
    ffr: "𝔣",
    filig: "ﬁ",
    FilledSmallSquare: "◼",
    FilledVerySmallSquare: "▪",
    fjlig: "fj",
    flat: "♭",
    fllig: "ﬂ",
    fltns: "▱",
    fnof: "ƒ",
    Fopf: "𝔽",
    fopf: "𝕗",
    ForAll: "∀",
    forall: "∀",
    fork: "⋔",
    forkv: "⫙",
    Fouriertrf: "ℱ",
    fpartint: "⨍",
    frac12: "½",
    frac13: "⅓",
    frac14: "¼",
    frac15: "⅕",
    frac16: "⅙",
    frac18: "⅛",
    frac23: "⅔",
    frac25: "⅖",
    frac34: "¾",
    frac35: "⅗",
    frac38: "⅜",
    frac45: "⅘",
    frac56: "⅚",
    frac58: "⅝",
    frac78: "⅞",
    frasl: "⁄",
    frown: "⌢",
    Fscr: "ℱ",
    fscr: "𝒻",
    gacute: "ǵ",
    Gamma: "Γ",
    gamma: "γ",
    Gammad: "Ϝ",
    gammad: "ϝ",
    gap: "⪆",
    Gbreve: "Ğ",
    gbreve: "ğ",
    Gcedil: "Ģ",
    Gcirc: "Ĝ",
    gcirc: "ĝ",
    Gcy: "Г",
    gcy: "г",
    Gdot: "Ġ",
    gdot: "ġ",
    gE: "≧",
    ge: "≥",
    gEl: "⪌",
    gel: "⋛",
    geq: "≥",
    geqq: "≧",
    geqslant: "⩾",
    ges: "⩾",
    gescc: "⪩",
    gesdot: "⪀",
    gesdoto: "⪂",
    gesdotol: "⪄",
    gesl: "⋛︀",
    gesles: "⪔",
    Gfr: "𝔊",
    gfr: "𝔤",
    Gg: "⋙",
    gg: "≫",
    ggg: "⋙",
    gimel: "ℷ",
    GJcy: "Ѓ",
    gjcy: "ѓ",
    gl: "≷",
    gla: "⪥",
    glE: "⪒",
    glj: "⪤",
    gnap: "⪊",
    gnapprox: "⪊",
    gnE: "≩",
    gne: "⪈",
    gneq: "⪈",
    gneqq: "≩",
    gnsim: "⋧",
    Gopf: "𝔾",
    gopf: "𝕘",
    grave: "`",
    GreaterEqual: "≥",
    GreaterEqualLess: "⋛",
    GreaterFullEqual: "≧",
    GreaterGreater: "⪢",
    GreaterLess: "≷",
    GreaterSlantEqual: "⩾",
    GreaterTilde: "≳",
    Gscr: "𝒢",
    gscr: "ℊ",
    gsim: "≳",
    gsime: "⪎",
    gsiml: "⪐",
    Gt: "≫",
    GT: ">",
    gt: ">",
    gtcc: "⪧",
    gtcir: "⩺",
    gtdot: "⋗",
    gtlPar: "⦕",
    gtquest: "⩼",
    gtrapprox: "⪆",
    gtrarr: "⥸",
    gtrdot: "⋗",
    gtreqless: "⋛",
    gtreqqless: "⪌",
    gtrless: "≷",
    gtrsim: "≳",
    gvertneqq: "≩︀",
    gvnE: "≩︀",
    Hacek: "ˇ",
    hairsp: " ",
    half: "½",
    hamilt: "ℋ",
    HARDcy: "Ъ",
    hardcy: "ъ",
    hArr: "⇔",
    harr: "↔",
    harrcir: "⥈",
    harrw: "↭",
    Hat: "^",
    hbar: "ℏ",
    Hcirc: "Ĥ",
    hcirc: "ĥ",
    hearts: "♥",
    heartsuit: "♥",
    hellip: "…",
    hercon: "⊹",
    Hfr: "ℌ",
    hfr: "𝔥",
    HilbertSpace: "ℋ",
    hksearow: "⤥",
    hkswarow: "⤦",
    hoarr: "⇿",
    homtht: "∻",
    hookleftarrow: "↩",
    hookrightarrow: "↪",
    Hopf: "ℍ",
    hopf: "𝕙",
    horbar: "―",
    HorizontalLine: "─",
    Hscr: "ℋ",
    hscr: "𝒽",
    hslash: "ℏ",
    Hstrok: "Ħ",
    hstrok: "ħ",
    HumpDownHump: "≎",
    HumpEqual: "≏",
    hybull: "⁃",
    hyphen: "‐",
    Iacute: "Í",
    iacute: "í",
    ic: "⁣",
    Icirc: "Î",
    icirc: "î",
    Icy: "И",
    icy: "и",
    Idot: "İ",
    IEcy: "Е",
    iecy: "е",
    iexcl: "¡",
    iff: "⇔",
    Ifr: "ℑ",
    ifr: "𝔦",
    Igrave: "Ì",
    igrave: "ì",
    ii: "ⅈ",
    iiiint: "⨌",
    iiint: "∭",
    iinfin: "⧜",
    iiota: "℩",
    IJlig: "Ĳ",
    ijlig: "ĳ",
    Im: "ℑ",
    Imacr: "Ī",
    imacr: "ī",
    image: "ℑ",
    ImaginaryI: "ⅈ",
    imagline: "ℐ",
    imagpart: "ℑ",
    imath: "ı",
    imof: "⊷",
    imped: "Ƶ",
    Implies: "⇒",
    in: "∈",
    incare: "℅",
    infin: "∞",
    infintie: "⧝",
    inodot: "ı",
    Int: "∬",
    int: "∫",
    intcal: "⊺",
    integers: "ℤ",
    Integral: "∫",
    intercal: "⊺",
    Intersection: "⋂",
    intlarhk: "⨗",
    intprod: "⨼",
    InvisibleComma: "⁣",
    InvisibleTimes: "⁢",
    IOcy: "Ё",
    iocy: "ё",
    Iogon: "Į",
    iogon: "į",
    Iopf: "𝕀",
    iopf: "𝕚",
    Iota: "Ι",
    iota: "ι",
    iprod: "⨼",
    iquest: "¿",
    Iscr: "ℐ",
    iscr: "𝒾",
    isin: "∈",
    isindot: "⋵",
    isinE: "⋹",
    isins: "⋴",
    isinsv: "⋳",
    isinv: "∈",
    it: "⁢",
    Itilde: "Ĩ",
    itilde: "ĩ",
    Iukcy: "І",
    iukcy: "і",
    Iuml: "Ï",
    iuml: "ï",
    Jcirc: "Ĵ",
    jcirc: "ĵ",
    Jcy: "Й",
    jcy: "й",
    Jfr: "𝔍",
    jfr: "𝔧",
    jmath: "ȷ",
    Jopf: "𝕁",
    jopf: "𝕛",
    Jscr: "𝒥",
    jscr: "𝒿",
    Jsercy: "Ј",
    jsercy: "ј",
    Jukcy: "Є",
    jukcy: "є",
    Kappa: "Κ",
    kappa: "κ",
    kappav: "ϰ",
    Kcedil: "Ķ",
    kcedil: "ķ",
    Kcy: "К",
    kcy: "к",
    Kfr: "𝔎",
    kfr: "𝔨",
    kgreen: "ĸ",
    KHcy: "Х",
    khcy: "х",
    KJcy: "Ќ",
    kjcy: "ќ",
    Kopf: "𝕂",
    kopf: "𝕜",
    Kscr: "𝒦",
    kscr: "𝓀",
    lAarr: "⇚",
    Lacute: "Ĺ",
    lacute: "ĺ",
    laemptyv: "⦴",
    lagran: "ℒ",
    Lambda: "Λ",
    lambda: "λ",
    Lang: "⟪",
    lang: "⟨",
    langd: "⦑",
    langle: "⟨",
    lap: "⪅",
    Laplacetrf: "ℒ",
    laquo: "«",
    Larr: "↞",
    lArr: "⇐",
    larr: "←",
    larrb: "⇤",
    larrbfs: "⤟",
    larrfs: "⤝",
    larrhk: "↩",
    larrlp: "↫",
    larrpl: "⤹",
    larrsim: "⥳",
    larrtl: "↢",
    lat: "⪫",
    lAtail: "⤛",
    latail: "⤙",
    late: "⪭",
    lates: "⪭︀",
    lBarr: "⤎",
    lbarr: "⤌",
    lbbrk: "❲",
    lbrace: "{",
    lbrack: "[",
    lbrke: "⦋",
    lbrksld: "⦏",
    lbrkslu: "⦍",
    Lcaron: "Ľ",
    lcaron: "ľ",
    Lcedil: "Ļ",
    lcedil: "ļ",
    lceil: "⌈",
    lcub: "{",
    Lcy: "Л",
    lcy: "л",
    ldca: "⤶",
    ldquo: "“",
    ldquor: "„",
    ldrdhar: "⥧",
    ldrushar: "⥋",
    ldsh: "↲",
    lE: "≦",
    le: "≤",
    LeftAngleBracket: "⟨",
    LeftArrow: "←",
    Leftarrow: "⇐",
    leftarrow: "←",
    LeftArrowBar: "⇤",
    LeftArrowRightArrow: "⇆",
    leftarrowtail: "↢",
    LeftCeiling: "⌈",
    LeftDoubleBracket: "⟦",
    LeftDownTeeVector: "⥡",
    LeftDownVector: "⇃",
    LeftDownVectorBar: "⥙",
    LeftFloor: "⌊",
    leftharpoondown: "↽",
    leftharpoonup: "↼",
    leftleftarrows: "⇇",
    LeftRightArrow: "↔",
    Leftrightarrow: "⇔",
    leftrightarrow: "↔",
    leftrightarrows: "⇆",
    leftrightharpoons: "⇋",
    leftrightsquigarrow: "↭",
    LeftRightVector: "⥎",
    LeftTee: "⊣",
    LeftTeeArrow: "↤",
    LeftTeeVector: "⥚",
    leftthreetimes: "⋋",
    LeftTriangle: "⊲",
    LeftTriangleBar: "⧏",
    LeftTriangleEqual: "⊴",
    LeftUpDownVector: "⥑",
    LeftUpTeeVector: "⥠",
    LeftUpVector: "↿",
    LeftUpVectorBar: "⥘",
    LeftVector: "↼",
    LeftVectorBar: "⥒",
    lEg: "⪋",
    leg: "⋚",
    leq: "≤",
    leqq: "≦",
    leqslant: "⩽",
    les: "⩽",
    lescc: "⪨",
    lesdot: "⩿",
    lesdoto: "⪁",
    lesdotor: "⪃",
    lesg: "⋚︀",
    lesges: "⪓",
    lessapprox: "⪅",
    lessdot: "⋖",
    lesseqgtr: "⋚",
    lesseqqgtr: "⪋",
    LessEqualGreater: "⋚",
    LessFullEqual: "≦",
    LessGreater: "≶",
    lessgtr: "≶",
    LessLess: "⪡",
    lesssim: "≲",
    LessSlantEqual: "⩽",
    LessTilde: "≲",
    lfisht: "⥼",
    lfloor: "⌊",
    Lfr: "𝔏",
    lfr: "𝔩",
    lg: "≶",
    lgE: "⪑",
    lHar: "⥢",
    lhard: "↽",
    lharu: "↼",
    lharul: "⥪",
    lhblk: "▄",
    LJcy: "Љ",
    ljcy: "љ",
    Ll: "⋘",
    ll: "≪",
    llarr: "⇇",
    llcorner: "⌞",
    Lleftarrow: "⇚",
    llhard: "⥫",
    lltri: "◺",
    Lmidot: "Ŀ",
    lmidot: "ŀ",
    lmoust: "⎰",
    lmoustache: "⎰",
    lnap: "⪉",
    lnapprox: "⪉",
    lnE: "≨",
    lne: "⪇",
    lneq: "⪇",
    lneqq: "≨",
    lnsim: "⋦",
    loang: "⟬",
    loarr: "⇽",
    lobrk: "⟦",
    LongLeftArrow: "⟵",
    Longleftarrow: "⟸",
    longleftarrow: "⟵",
    LongLeftRightArrow: "⟷",
    Longleftrightarrow: "⟺",
    longleftrightarrow: "⟷",
    longmapsto: "⟼",
    LongRightArrow: "⟶",
    Longrightarrow: "⟹",
    longrightarrow: "⟶",
    looparrowleft: "↫",
    looparrowright: "↬",
    lopar: "⦅",
    Lopf: "𝕃",
    lopf: "𝕝",
    loplus: "⨭",
    lotimes: "⨴",
    lowast: "∗",
    lowbar: "_",
    LowerLeftArrow: "↙",
    LowerRightArrow: "↘",
    loz: "◊",
    lozenge: "◊",
    lozf: "⧫",
    lpar: "(",
    lparlt: "⦓",
    lrarr: "⇆",
    lrcorner: "⌟",
    lrhar: "⇋",
    lrhard: "⥭",
    lrm: "‎",
    lrtri: "⊿",
    lsaquo: "‹",
    Lscr: "ℒ",
    lscr: "𝓁",
    Lsh: "↰",
    lsh: "↰",
    lsim: "≲",
    lsime: "⪍",
    lsimg: "⪏",
    lsqb: "[",
    lsquo: "‘",
    lsquor: "‚",
    Lstrok: "Ł",
    lstrok: "ł",
    Lt: "≪",
    LT: "<",
    lt: "<",
    ltcc: "⪦",
    ltcir: "⩹",
    ltdot: "⋖",
    lthree: "⋋",
    ltimes: "⋉",
    ltlarr: "⥶",
    ltquest: "⩻",
    ltri: "◃",
    ltrie: "⊴",
    ltrif: "◂",
    ltrPar: "⦖",
    lurdshar: "⥊",
    luruhar: "⥦",
    lvertneqq: "≨︀",
    lvnE: "≨︀",
    macr: "¯",
    male: "♂",
    malt: "✠",
    maltese: "✠",
    Map: "⤅",
    map: "↦",
    mapsto: "↦",
    mapstodown: "↧",
    mapstoleft: "↤",
    mapstoup: "↥",
    marker: "▮",
    mcomma: "⨩",
    Mcy: "М",
    mcy: "м",
    mdash: "—",
    mDDot: "∺",
    measuredangle: "∡",
    MediumSpace: " ",
    Mellintrf: "ℳ",
    Mfr: "𝔐",
    mfr: "𝔪",
    mho: "℧",
    micro: "µ",
    mid: "∣",
    midast: "*",
    midcir: "⫰",
    middot: "·",
    minus: "−",
    minusb: "⊟",
    minusd: "∸",
    minusdu: "⨪",
    MinusPlus: "∓",
    mlcp: "⫛",
    mldr: "…",
    mnplus: "∓",
    models: "⊧",
    Mopf: "𝕄",
    mopf: "𝕞",
    mp: "∓",
    Mscr: "ℳ",
    mscr: "𝓂",
    mstpos: "∾",
    Mu: "Μ",
    mu: "μ",
    multimap: "⊸",
    mumap: "⊸",
    nabla: "∇",
    Nacute: "Ń",
    nacute: "ń",
    nang: "∠⃒",
    nap: "≉",
    napE: "⩰̸",
    napid: "≋̸",
    napos: "ŉ",
    napprox: "≉",
    natur: "♮",
    natural: "♮",
    naturals: "ℕ",
    nbsp: " ",
    nbump: "≎̸",
    nbumpe: "≏̸",
    ncap: "⩃",
    Ncaron: "Ň",
    ncaron: "ň",
    Ncedil: "Ņ",
    ncedil: "ņ",
    ncong: "≇",
    ncongdot: "⩭̸",
    ncup: "⩂",
    Ncy: "Н",
    ncy: "н",
    ndash: "–",
    ne: "≠",
    nearhk: "⤤",
    neArr: "⇗",
    nearr: "↗",
    nearrow: "↗",
    nedot: "≐̸",
    NegativeMediumSpace: "​",
    NegativeThickSpace: "​",
    NegativeThinSpace: "​",
    NegativeVeryThinSpace: "​",
    nequiv: "≢",
    nesear: "⤨",
    nesim: "≂̸",
    NestedGreaterGreater: "≫",
    NestedLessLess: "≪",
    NewLine: "\n",
    nexist: "∄",
    nexists: "∄",
    Nfr: "𝔑",
    nfr: "𝔫",
    ngE: "≧̸",
    nge: "≱",
    ngeq: "≱",
    ngeqq: "≧̸",
    ngeqslant: "⩾̸",
    nges: "⩾̸",
    nGg: "⋙̸",
    ngsim: "≵",
    nGt: "≫⃒",
    ngt: "≯",
    ngtr: "≯",
    nGtv: "≫̸",
    nhArr: "⇎",
    nharr: "↮",
    nhpar: "⫲",
    ni: "∋",
    nis: "⋼",
    nisd: "⋺",
    niv: "∋",
    NJcy: "Њ",
    njcy: "њ",
    nlArr: "⇍",
    nlarr: "↚",
    nldr: "‥",
    nlE: "≦̸",
    nle: "≰",
    nLeftarrow: "⇍",
    nleftarrow: "↚",
    nLeftrightarrow: "⇎",
    nleftrightarrow: "↮",
    nleq: "≰",
    nleqq: "≦̸",
    nleqslant: "⩽̸",
    nles: "⩽̸",
    nless: "≮",
    nLl: "⋘̸",
    nlsim: "≴",
    nLt: "≪⃒",
    nlt: "≮",
    nltri: "⋪",
    nltrie: "⋬",
    nLtv: "≪̸",
    nmid: "∤",
    NoBreak: "⁠",
    NonBreakingSpace: " ",
    Nopf: "ℕ",
    nopf: "𝕟",
    Not: "⫬",
    not: "¬",
    NotCongruent: "≢",
    NotCupCap: "≭",
    NotDoubleVerticalBar: "∦",
    NotElement: "∉",
    NotEqual: "≠",
    NotEqualTilde: "≂̸",
    NotExists: "∄",
    NotGreater: "≯",
    NotGreaterEqual: "≱",
    NotGreaterFullEqual: "≧̸",
    NotGreaterGreater: "≫̸",
    NotGreaterLess: "≹",
    NotGreaterSlantEqual: "⩾̸",
    NotGreaterTilde: "≵",
    NotHumpDownHump: "≎̸",
    NotHumpEqual: "≏̸",
    notin: "∉",
    notindot: "⋵̸",
    notinE: "⋹̸",
    notinva: "∉",
    notinvb: "⋷",
    notinvc: "⋶",
    NotLeftTriangle: "⋪",
    NotLeftTriangleBar: "⧏̸",
    NotLeftTriangleEqual: "⋬",
    NotLess: "≮",
    NotLessEqual: "≰",
    NotLessGreater: "≸",
    NotLessLess: "≪̸",
    NotLessSlantEqual: "⩽̸",
    NotLessTilde: "≴",
    NotNestedGreaterGreater: "⪢̸",
    NotNestedLessLess: "⪡̸",
    notni: "∌",
    notniva: "∌",
    notnivb: "⋾",
    notnivc: "⋽",
    NotPrecedes: "⊀",
    NotPrecedesEqual: "⪯̸",
    NotPrecedesSlantEqual: "⋠",
    NotReverseElement: "∌",
    NotRightTriangle: "⋫",
    NotRightTriangleBar: "⧐̸",
    NotRightTriangleEqual: "⋭",
    NotSquareSubset: "⊏̸",
    NotSquareSubsetEqual: "⋢",
    NotSquareSuperset: "⊐̸",
    NotSquareSupersetEqual: "⋣",
    NotSubset: "⊂⃒",
    NotSubsetEqual: "⊈",
    NotSucceeds: "⊁",
    NotSucceedsEqual: "⪰̸",
    NotSucceedsSlantEqual: "⋡",
    NotSucceedsTilde: "≿̸",
    NotSuperset: "⊃⃒",
    NotSupersetEqual: "⊉",
    NotTilde: "≁",
    NotTildeEqual: "≄",
    NotTildeFullEqual: "≇",
    NotTildeTilde: "≉",
    NotVerticalBar: "∤",
    npar: "∦",
    nparallel: "∦",
    nparsl: "⫽⃥",
    npart: "∂̸",
    npolint: "⨔",
    npr: "⊀",
    nprcue: "⋠",
    npre: "⪯̸",
    nprec: "⊀",
    npreceq: "⪯̸",
    nrArr: "⇏",
    nrarr: "↛",
    nrarrc: "⤳̸",
    nrarrw: "↝̸",
    nRightarrow: "⇏",
    nrightarrow: "↛",
    nrtri: "⋫",
    nrtrie: "⋭",
    nsc: "⊁",
    nsccue: "⋡",
    nsce: "⪰̸",
    Nscr: "𝒩",
    nscr: "𝓃",
    nshortmid: "∤",
    nshortparallel: "∦",
    nsim: "≁",
    nsime: "≄",
    nsimeq: "≄",
    nsmid: "∤",
    nspar: "∦",
    nsqsube: "⋢",
    nsqsupe: "⋣",
    nsub: "⊄",
    nsubE: "⫅̸",
    nsube: "⊈",
    nsubset: "⊂⃒",
    nsubseteq: "⊈",
    nsubseteqq: "⫅̸",
    nsucc: "⊁",
    nsucceq: "⪰̸",
    nsup: "⊅",
    nsupE: "⫆̸",
    nsupe: "⊉",
    nsupset: "⊃⃒",
    nsupseteq: "⊉",
    nsupseteqq: "⫆̸",
    ntgl: "≹",
    Ntilde: "Ñ",
    ntilde: "ñ",
    ntlg: "≸",
    ntriangleleft: "⋪",
    ntrianglelefteq: "⋬",
    ntriangleright: "⋫",
    ntrianglerighteq: "⋭",
    Nu: "Ν",
    nu: "ν",
    num: "#",
    numero: "№",
    numsp: " ",
    nvap: "≍⃒",
    nVDash: "⊯",
    nVdash: "⊮",
    nvDash: "⊭",
    nvdash: "⊬",
    nvge: "≥⃒",
    nvgt: ">⃒",
    nvHarr: "⤄",
    nvinfin: "⧞",
    nvlArr: "⤂",
    nvle: "≤⃒",
    nvlt: "<⃒",
    nvltrie: "⊴⃒",
    nvrArr: "⤃",
    nvrtrie: "⊵⃒",
    nvsim: "∼⃒",
    nwarhk: "⤣",
    nwArr: "⇖",
    nwarr: "↖",
    nwarrow: "↖",
    nwnear: "⤧",
    Oacute: "Ó",
    oacute: "ó",
    oast: "⊛",
    ocir: "⊚",
    Ocirc: "Ô",
    ocirc: "ô",
    Ocy: "О",
    ocy: "о",
    odash: "⊝",
    Odblac: "Ő",
    odblac: "ő",
    odiv: "⨸",
    odot: "⊙",
    odsold: "⦼",
    OElig: "Œ",
    oelig: "œ",
    ofcir: "⦿",
    Ofr: "𝔒",
    ofr: "𝔬",
    ogon: "˛",
    Ograve: "Ò",
    ograve: "ò",
    ogt: "⧁",
    ohbar: "⦵",
    ohm: "Ω",
    oint: "∮",
    olarr: "↺",
    olcir: "⦾",
    olcross: "⦻",
    oline: "‾",
    olt: "⧀",
    Omacr: "Ō",
    omacr: "ō",
    Omega: "Ω",
    omega: "ω",
    Omicron: "Ο",
    omicron: "ο",
    omid: "⦶",
    ominus: "⊖",
    Oopf: "𝕆",
    oopf: "𝕠",
    opar: "⦷",
    OpenCurlyDoubleQuote: "“",
    OpenCurlyQuote: "‘",
    operp: "⦹",
    oplus: "⊕",
    Or: "⩔",
    or: "∨",
    orarr: "↻",
    ord: "⩝",
    order: "ℴ",
    orderof: "ℴ",
    ordf: "ª",
    ordm: "º",
    origof: "⊶",
    oror: "⩖",
    orslope: "⩗",
    orv: "⩛",
    oS: "Ⓢ",
    Oscr: "𝒪",
    oscr: "ℴ",
    Oslash: "Ø",
    oslash: "ø",
    osol: "⊘",
    Otilde: "Õ",
    otilde: "õ",
    Otimes: "⨷",
    otimes: "⊗",
    otimesas: "⨶",
    Ouml: "Ö",
    ouml: "ö",
    ovbar: "⌽",
    OverBar: "‾",
    OverBrace: "⏞",
    OverBracket: "⎴",
    OverParenthesis: "⏜",
    par: "∥",
    para: "¶",
    parallel: "∥",
    parsim: "⫳",
    parsl: "⫽",
    part: "∂",
    PartialD: "∂",
    Pcy: "П",
    pcy: "п",
    percnt: "%",
    period: ".",
    permil: "‰",
    perp: "⊥",
    pertenk: "‱",
    Pfr: "𝔓",
    pfr: "𝔭",
    Phi: "Φ",
    phi: "φ",
    phiv: "ϕ",
    phmmat: "ℳ",
    phone: "☎",
    Pi: "Π",
    pi: "π",
    pitchfork: "⋔",
    piv: "ϖ",
    planck: "ℏ",
    planckh: "ℎ",
    plankv: "ℏ",
    plus: "+",
    plusacir: "⨣",
    plusb: "⊞",
    pluscir: "⨢",
    plusdo: "∔",
    plusdu: "⨥",
    pluse: "⩲",
    PlusMinus: "±",
    plusmn: "±",
    plussim: "⨦",
    plustwo: "⨧",
    pm: "±",
    Poincareplane: "ℌ",
    pointint: "⨕",
    Popf: "ℙ",
    popf: "𝕡",
    pound: "£",
    Pr: "⪻",
    pr: "≺",
    prap: "⪷",
    prcue: "≼",
    prE: "⪳",
    pre: "⪯",
    prec: "≺",
    precapprox: "⪷",
    preccurlyeq: "≼",
    Precedes: "≺",
    PrecedesEqual: "⪯",
    PrecedesSlantEqual: "≼",
    PrecedesTilde: "≾",
    preceq: "⪯",
    precnapprox: "⪹",
    precneqq: "⪵",
    precnsim: "⋨",
    precsim: "≾",
    Prime: "″",
    prime: "′",
    primes: "ℙ",
    prnap: "⪹",
    prnE: "⪵",
    prnsim: "⋨",
    prod: "∏",
    Product: "∏",
    profalar: "⌮",
    profline: "⌒",
    profsurf: "⌓",
    prop: "∝",
    Proportion: "∷",
    Proportional: "∝",
    propto: "∝",
    prsim: "≾",
    prurel: "⊰",
    Pscr: "𝒫",
    pscr: "𝓅",
    Psi: "Ψ",
    psi: "ψ",
    puncsp: " ",
    Qfr: "𝔔",
    qfr: "𝔮",
    qint: "⨌",
    Qopf: "ℚ",
    qopf: "𝕢",
    qprime: "⁗",
    Qscr: "𝒬",
    qscr: "𝓆",
    quaternions: "ℍ",
    quatint: "⨖",
    quest: "?",
    questeq: "≟",
    QUOT: '"',
    quot: '"',
    rAarr: "⇛",
    race: "∽̱",
    Racute: "Ŕ",
    racute: "ŕ",
    radic: "√",
    raemptyv: "⦳",
    Rang: "⟫",
    rang: "⟩",
    rangd: "⦒",
    range: "⦥",
    rangle: "⟩",
    raquo: "»",
    Rarr: "↠",
    rArr: "⇒",
    rarr: "→",
    rarrap: "⥵",
    rarrb: "⇥",
    rarrbfs: "⤠",
    rarrc: "⤳",
    rarrfs: "⤞",
    rarrhk: "↪",
    rarrlp: "↬",
    rarrpl: "⥅",
    rarrsim: "⥴",
    Rarrtl: "⤖",
    rarrtl: "↣",
    rarrw: "↝",
    rAtail: "⤜",
    ratail: "⤚",
    ratio: "∶",
    rationals: "ℚ",
    RBarr: "⤐",
    rBarr: "⤏",
    rbarr: "⤍",
    rbbrk: "❳",
    rbrace: "}",
    rbrack: "]",
    rbrke: "⦌",
    rbrksld: "⦎",
    rbrkslu: "⦐",
    Rcaron: "Ř",
    rcaron: "ř",
    Rcedil: "Ŗ",
    rcedil: "ŗ",
    rceil: "⌉",
    rcub: "}",
    Rcy: "Р",
    rcy: "р",
    rdca: "⤷",
    rdldhar: "⥩",
    rdquo: "”",
    rdquor: "”",
    rdsh: "↳",
    Re: "ℜ",
    real: "ℜ",
    realine: "ℛ",
    realpart: "ℜ",
    reals: "ℝ",
    rect: "▭",
    REG: "®",
    reg: "®",
    ReverseElement: "∋",
    ReverseEquilibrium: "⇋",
    ReverseUpEquilibrium: "⥯",
    rfisht: "⥽",
    rfloor: "⌋",
    Rfr: "ℜ",
    rfr: "𝔯",
    rHar: "⥤",
    rhard: "⇁",
    rharu: "⇀",
    rharul: "⥬",
    Rho: "Ρ",
    rho: "ρ",
    rhov: "ϱ",
    RightAngleBracket: "⟩",
    RightArrow: "→",
    Rightarrow: "⇒",
    rightarrow: "→",
    RightArrowBar: "⇥",
    RightArrowLeftArrow: "⇄",
    rightarrowtail: "↣",
    RightCeiling: "⌉",
    RightDoubleBracket: "⟧",
    RightDownTeeVector: "⥝",
    RightDownVector: "⇂",
    RightDownVectorBar: "⥕",
    RightFloor: "⌋",
    rightharpoondown: "⇁",
    rightharpoonup: "⇀",
    rightleftarrows: "⇄",
    rightleftharpoons: "⇌",
    rightrightarrows: "⇉",
    rightsquigarrow: "↝",
    RightTee: "⊢",
    RightTeeArrow: "↦",
    RightTeeVector: "⥛",
    rightthreetimes: "⋌",
    RightTriangle: "⊳",
    RightTriangleBar: "⧐",
    RightTriangleEqual: "⊵",
    RightUpDownVector: "⥏",
    RightUpTeeVector: "⥜",
    RightUpVector: "↾",
    RightUpVectorBar: "⥔",
    RightVector: "⇀",
    RightVectorBar: "⥓",
    ring: "˚",
    risingdotseq: "≓",
    rlarr: "⇄",
    rlhar: "⇌",
    rlm: "‏",
    rmoust: "⎱",
    rmoustache: "⎱",
    rnmid: "⫮",
    roang: "⟭",
    roarr: "⇾",
    robrk: "⟧",
    ropar: "⦆",
    Ropf: "ℝ",
    ropf: "𝕣",
    roplus: "⨮",
    rotimes: "⨵",
    RoundImplies: "⥰",
    rpar: ")",
    rpargt: "⦔",
    rppolint: "⨒",
    rrarr: "⇉",
    Rrightarrow: "⇛",
    rsaquo: "›",
    Rscr: "ℛ",
    rscr: "𝓇",
    Rsh: "↱",
    rsh: "↱",
    rsqb: "]",
    rsquo: "’",
    rsquor: "’",
    rthree: "⋌",
    rtimes: "⋊",
    rtri: "▹",
    rtrie: "⊵",
    rtrif: "▸",
    rtriltri: "⧎",
    RuleDelayed: "⧴",
    ruluhar: "⥨",
    rx: "℞",
    Sacute: "Ś",
    sacute: "ś",
    sbquo: "‚",
    Sc: "⪼",
    sc: "≻",
    scap: "⪸",
    Scaron: "Š",
    scaron: "š",
    sccue: "≽",
    scE: "⪴",
    sce: "⪰",
    Scedil: "Ş",
    scedil: "ş",
    Scirc: "Ŝ",
    scirc: "ŝ",
    scnap: "⪺",
    scnE: "⪶",
    scnsim: "⋩",
    scpolint: "⨓",
    scsim: "≿",
    Scy: "С",
    scy: "с",
    sdot: "⋅",
    sdotb: "⊡",
    sdote: "⩦",
    searhk: "⤥",
    seArr: "⇘",
    searr: "↘",
    searrow: "↘",
    sect: "§",
    semi: ";",
    seswar: "⤩",
    setminus: "∖",
    setmn: "∖",
    sext: "✶",
    Sfr: "𝔖",
    sfr: "𝔰",
    sfrown: "⌢",
    sharp: "♯",
    SHCHcy: "Щ",
    shchcy: "щ",
    SHcy: "Ш",
    shcy: "ш",
    ShortDownArrow: "↓",
    ShortLeftArrow: "←",
    shortmid: "∣",
    shortparallel: "∥",
    ShortRightArrow: "→",
    ShortUpArrow: "↑",
    shy: "­",
    Sigma: "Σ",
    sigma: "σ",
    sigmaf: "ς",
    sigmav: "ς",
    sim: "∼",
    simdot: "⩪",
    sime: "≃",
    simeq: "≃",
    simg: "⪞",
    simgE: "⪠",
    siml: "⪝",
    simlE: "⪟",
    simne: "≆",
    simplus: "⨤",
    simrarr: "⥲",
    slarr: "←",
    SmallCircle: "∘",
    smallsetminus: "∖",
    smashp: "⨳",
    smeparsl: "⧤",
    smid: "∣",
    smile: "⌣",
    smt: "⪪",
    smte: "⪬",
    smtes: "⪬︀",
    SOFTcy: "Ь",
    softcy: "ь",
    sol: "/",
    solb: "⧄",
    solbar: "⌿",
    Sopf: "𝕊",
    sopf: "𝕤",
    spades: "♠",
    spadesuit: "♠",
    spar: "∥",
    sqcap: "⊓",
    sqcaps: "⊓︀",
    sqcup: "⊔",
    sqcups: "⊔︀",
    Sqrt: "√",
    sqsub: "⊏",
    sqsube: "⊑",
    sqsubset: "⊏",
    sqsubseteq: "⊑",
    sqsup: "⊐",
    sqsupe: "⊒",
    sqsupset: "⊐",
    sqsupseteq: "⊒",
    squ: "□",
    Square: "□",
    square: "□",
    SquareIntersection: "⊓",
    SquareSubset: "⊏",
    SquareSubsetEqual: "⊑",
    SquareSuperset: "⊐",
    SquareSupersetEqual: "⊒",
    SquareUnion: "⊔",
    squarf: "▪",
    squf: "▪",
    srarr: "→",
    Sscr: "𝒮",
    sscr: "𝓈",
    ssetmn: "∖",
    ssmile: "⌣",
    sstarf: "⋆",
    Star: "⋆",
    star: "☆",
    starf: "★",
    straightepsilon: "ϵ",
    straightphi: "ϕ",
    strns: "¯",
    Sub: "⋐",
    sub: "⊂",
    subdot: "⪽",
    subE: "⫅",
    sube: "⊆",
    subedot: "⫃",
    submult: "⫁",
    subnE: "⫋",
    subne: "⊊",
    subplus: "⪿",
    subrarr: "⥹",
    Subset: "⋐",
    subset: "⊂",
    subseteq: "⊆",
    subseteqq: "⫅",
    SubsetEqual: "⊆",
    subsetneq: "⊊",
    subsetneqq: "⫋",
    subsim: "⫇",
    subsub: "⫕",
    subsup: "⫓",
    succ: "≻",
    succapprox: "⪸",
    succcurlyeq: "≽",
    Succeeds: "≻",
    SucceedsEqual: "⪰",
    SucceedsSlantEqual: "≽",
    SucceedsTilde: "≿",
    succeq: "⪰",
    succnapprox: "⪺",
    succneqq: "⪶",
    succnsim: "⋩",
    succsim: "≿",
    SuchThat: "∋",
    Sum: "∑",
    sum: "∑",
    sung: "♪",
    Sup: "⋑",
    sup: "⊃",
    sup1: "¹",
    sup2: "²",
    sup3: "³",
    supdot: "⪾",
    supdsub: "⫘",
    supE: "⫆",
    supe: "⊇",
    supedot: "⫄",
    Superset: "⊃",
    SupersetEqual: "⊇",
    suphsol: "⟉",
    suphsub: "⫗",
    suplarr: "⥻",
    supmult: "⫂",
    supnE: "⫌",
    supne: "⊋",
    supplus: "⫀",
    Supset: "⋑",
    supset: "⊃",
    supseteq: "⊇",
    supseteqq: "⫆",
    supsetneq: "⊋",
    supsetneqq: "⫌",
    supsim: "⫈",
    supsub: "⫔",
    supsup: "⫖",
    swarhk: "⤦",
    swArr: "⇙",
    swarr: "↙",
    swarrow: "↙",
    swnwar: "⤪",
    szlig: "ß",
    Tab: "	",
    target: "⌖",
    Tau: "Τ",
    tau: "τ",
    tbrk: "⎴",
    Tcaron: "Ť",
    tcaron: "ť",
    Tcedil: "Ţ",
    tcedil: "ţ",
    Tcy: "Т",
    tcy: "т",
    tdot: "⃛",
    telrec: "⌕",
    Tfr: "𝔗",
    tfr: "𝔱",
    there4: "∴",
    Therefore: "∴",
    therefore: "∴",
    Theta: "Θ",
    theta: "θ",
    thetasym: "ϑ",
    thetav: "ϑ",
    thickapprox: "≈",
    thicksim: "∼",
    ThickSpace: "  ",
    thinsp: " ",
    ThinSpace: " ",
    thkap: "≈",
    thksim: "∼",
    THORN: "Þ",
    thorn: "þ",
    Tilde: "∼",
    tilde: "˜",
    TildeEqual: "≃",
    TildeFullEqual: "≅",
    TildeTilde: "≈",
    times: "×",
    timesb: "⊠",
    timesbar: "⨱",
    timesd: "⨰",
    tint: "∭",
    toea: "⤨",
    top: "⊤",
    topbot: "⌶",
    topcir: "⫱",
    Topf: "𝕋",
    topf: "𝕥",
    topfork: "⫚",
    tosa: "⤩",
    tprime: "‴",
    TRADE: "™",
    trade: "™",
    triangle: "▵",
    triangledown: "▿",
    triangleleft: "◃",
    trianglelefteq: "⊴",
    triangleq: "≜",
    triangleright: "▹",
    trianglerighteq: "⊵",
    tridot: "◬",
    trie: "≜",
    triminus: "⨺",
    TripleDot: "⃛",
    triplus: "⨹",
    trisb: "⧍",
    tritime: "⨻",
    trpezium: "⏢",
    Tscr: "𝒯",
    tscr: "𝓉",
    TScy: "Ц",
    tscy: "ц",
    TSHcy: "Ћ",
    tshcy: "ћ",
    Tstrok: "Ŧ",
    tstrok: "ŧ",
    twixt: "≬",
    twoheadleftarrow: "↞",
    twoheadrightarrow: "↠",
    Uacute: "Ú",
    uacute: "ú",
    Uarr: "↟",
    uArr: "⇑",
    uarr: "↑",
    Uarrocir: "⥉",
    Ubrcy: "Ў",
    ubrcy: "ў",
    Ubreve: "Ŭ",
    ubreve: "ŭ",
    Ucirc: "Û",
    ucirc: "û",
    Ucy: "У",
    ucy: "у",
    udarr: "⇅",
    Udblac: "Ű",
    udblac: "ű",
    udhar: "⥮",
    ufisht: "⥾",
    Ufr: "𝔘",
    ufr: "𝔲",
    Ugrave: "Ù",
    ugrave: "ù",
    uHar: "⥣",
    uharl: "↿",
    uharr: "↾",
    uhblk: "▀",
    ulcorn: "⌜",
    ulcorner: "⌜",
    ulcrop: "⌏",
    ultri: "◸",
    Umacr: "Ū",
    umacr: "ū",
    uml: "¨",
    UnderBar: "_",
    UnderBrace: "⏟",
    UnderBracket: "⎵",
    UnderParenthesis: "⏝",
    Union: "⋃",
    UnionPlus: "⊎",
    Uogon: "Ų",
    uogon: "ų",
    Uopf: "𝕌",
    uopf: "𝕦",
    UpArrow: "↑",
    Uparrow: "⇑",
    uparrow: "↑",
    UpArrowBar: "⤒",
    UpArrowDownArrow: "⇅",
    UpDownArrow: "↕",
    Updownarrow: "⇕",
    updownarrow: "↕",
    UpEquilibrium: "⥮",
    upharpoonleft: "↿",
    upharpoonright: "↾",
    uplus: "⊎",
    UpperLeftArrow: "↖",
    UpperRightArrow: "↗",
    Upsi: "ϒ",
    upsi: "υ",
    upsih: "ϒ",
    Upsilon: "Υ",
    upsilon: "υ",
    UpTee: "⊥",
    UpTeeArrow: "↥",
    upuparrows: "⇈",
    urcorn: "⌝",
    urcorner: "⌝",
    urcrop: "⌎",
    Uring: "Ů",
    uring: "ů",
    urtri: "◹",
    Uscr: "𝒰",
    uscr: "𝓊",
    utdot: "⋰",
    Utilde: "Ũ",
    utilde: "ũ",
    utri: "▵",
    utrif: "▴",
    uuarr: "⇈",
    Uuml: "Ü",
    uuml: "ü",
    uwangle: "⦧",
    vangrt: "⦜",
    varepsilon: "ϵ",
    varkappa: "ϰ",
    varnothing: "∅",
    varphi: "ϕ",
    varpi: "ϖ",
    varpropto: "∝",
    vArr: "⇕",
    varr: "↕",
    varrho: "ϱ",
    varsigma: "ς",
    varsubsetneq: "⊊︀",
    varsubsetneqq: "⫋︀",
    varsupsetneq: "⊋︀",
    varsupsetneqq: "⫌︀",
    vartheta: "ϑ",
    vartriangleleft: "⊲",
    vartriangleright: "⊳",
    Vbar: "⫫",
    vBar: "⫨",
    vBarv: "⫩",
    Vcy: "В",
    vcy: "в",
    VDash: "⊫",
    Vdash: "⊩",
    vDash: "⊨",
    vdash: "⊢",
    Vdashl: "⫦",
    Vee: "⋁",
    vee: "∨",
    veebar: "⊻",
    veeeq: "≚",
    vellip: "⋮",
    Verbar: "‖",
    verbar: "|",
    Vert: "‖",
    vert: "|",
    VerticalBar: "∣",
    VerticalLine: "|",
    VerticalSeparator: "❘",
    VerticalTilde: "≀",
    VeryThinSpace: " ",
    Vfr: "𝔙",
    vfr: "𝔳",
    vltri: "⊲",
    vnsub: "⊂⃒",
    vnsup: "⊃⃒",
    Vopf: "𝕍",
    vopf: "𝕧",
    vprop: "∝",
    vrtri: "⊳",
    Vscr: "𝒱",
    vscr: "𝓋",
    vsubnE: "⫋︀",
    vsubne: "⊊︀",
    vsupnE: "⫌︀",
    vsupne: "⊋︀",
    Vvdash: "⊪",
    vzigzag: "⦚",
    Wcirc: "Ŵ",
    wcirc: "ŵ",
    wedbar: "⩟",
    Wedge: "⋀",
    wedge: "∧",
    wedgeq: "≙",
    weierp: "℘",
    Wfr: "𝔚",
    wfr: "𝔴",
    Wopf: "𝕎",
    wopf: "𝕨",
    wp: "℘",
    wr: "≀",
    wreath: "≀",
    Wscr: "𝒲",
    wscr: "𝓌",
    xcap: "⋂",
    xcirc: "◯",
    xcup: "⋃",
    xdtri: "▽",
    Xfr: "𝔛",
    xfr: "𝔵",
    xhArr: "⟺",
    xharr: "⟷",
    Xi: "Ξ",
    xi: "ξ",
    xlArr: "⟸",
    xlarr: "⟵",
    xmap: "⟼",
    xnis: "⋻",
    xodot: "⨀",
    Xopf: "𝕏",
    xopf: "𝕩",
    xoplus: "⨁",
    xotime: "⨂",
    xrArr: "⟹",
    xrarr: "⟶",
    Xscr: "𝒳",
    xscr: "𝓍",
    xsqcup: "⨆",
    xuplus: "⨄",
    xutri: "△",
    xvee: "⋁",
    xwedge: "⋀",
    Yacute: "Ý",
    yacute: "ý",
    YAcy: "Я",
    yacy: "я",
    Ycirc: "Ŷ",
    ycirc: "ŷ",
    Ycy: "Ы",
    ycy: "ы",
    yen: "¥",
    Yfr: "𝔜",
    yfr: "𝔶",
    YIcy: "Ї",
    yicy: "ї",
    Yopf: "𝕐",
    yopf: "𝕪",
    Yscr: "𝒴",
    yscr: "𝓎",
    YUcy: "Ю",
    yucy: "ю",
    Yuml: "Ÿ",
    yuml: "ÿ",
    Zacute: "Ź",
    zacute: "ź",
    Zcaron: "Ž",
    zcaron: "ž",
    Zcy: "З",
    zcy: "з",
    Zdot: "Ż",
    zdot: "ż",
    zeetrf: "ℨ",
    ZeroWidthSpace: "​",
    Zeta: "Ζ",
    zeta: "ζ",
    Zfr: "ℨ",
    zfr: "𝔷",
    ZHcy: "Ж",
    zhcy: "ж",
    zigrarr: "⇝",
    Zopf: "ℤ",
    zopf: "𝕫",
    Zscr: "𝒵",
    zscr: "𝓏",
    zwj: "‍",
    zwnj: "‌"
  });
  exports2.entityMap = exports2.HTML_ENTITIES;
})(entities$1);
var sax$1 = {};
var NAMESPACE$1 = conventions$2.NAMESPACE;
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
var S_TAG = 0;
var S_ATTR = 1;
var S_ATTR_SPACE = 2;
var S_EQ = 3;
var S_ATTR_NOQUOT_VALUE = 4;
var S_ATTR_END = 5;
var S_TAG_SPACE = 6;
var S_TAG_CLOSE = 7;
function ParseError$1(message, locator) {
  this.message = message;
  this.locator = locator;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ParseError$1);
}
ParseError$1.prototype = new Error();
ParseError$1.prototype.name = ParseError$1.name;
function XMLReader$1() {
}
XMLReader$1.prototype = {
  parse: function(source, defaultNSMap, entityMap) {
    var domBuilder = this.domBuilder;
    domBuilder.startDocument();
    _copy(defaultNSMap, defaultNSMap = {});
    parse$1(
      source,
      defaultNSMap,
      entityMap,
      domBuilder,
      this.errorHandler
    );
    domBuilder.endDocument();
  }
};
function parse$1(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
  function fixedFromCharCode(code) {
    if (code > 65535) {
      code -= 65536;
      var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    } else {
      return String.fromCharCode(code);
    }
  }
  function entityReplacer(a2) {
    var k = a2.slice(1, -1);
    if (Object.hasOwnProperty.call(entityMap, k)) {
      return entityMap[k];
    } else if (k.charAt(0) === "#") {
      return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
    } else {
      errorHandler.error("entity not found:" + a2);
      return a2;
    }
  }
  function appendText(end3) {
    if (end3 > start2) {
      var xt = source.substring(start2, end3).replace(/&#?\w+;/g, entityReplacer);
      locator && position2(start2);
      domBuilder.characters(xt, 0, end3 - start2);
      start2 = end3;
    }
  }
  function position2(p, m) {
    while (p >= lineEnd && (m = linePattern.exec(source))) {
      lineStart = m.index;
      lineEnd = lineStart + m[0].length;
      locator.lineNumber++;
    }
    locator.columnNumber = p - lineStart + 1;
  }
  var lineStart = 0;
  var lineEnd = 0;
  var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  var locator = domBuilder.locator;
  var parseStack = [{ currentNSMap: defaultNSMapCopy }];
  var closeMap = {};
  var start2 = 0;
  while (true) {
    try {
      var tagStart = source.indexOf("<", start2);
      if (tagStart < 0) {
        if (!source.substr(start2).match(/^\s*$/)) {
          var doc = domBuilder.doc;
          var text2 = doc.createTextNode(source.substr(start2));
          doc.appendChild(text2);
          domBuilder.currentElement = text2;
        }
        return;
      }
      if (tagStart > start2) {
        appendText(tagStart);
      }
      switch (source.charAt(tagStart + 1)) {
        case "/":
          var end2 = source.indexOf(">", tagStart + 3);
          var tagName = source.substring(tagStart + 2, end2).replace(/[ \t\n\r]+$/g, "");
          var config = parseStack.pop();
          if (end2 < 0) {
            tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
            end2 = tagStart + 1 + tagName.length;
          } else if (tagName.match(/\s</)) {
            tagName = tagName.replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " maybe not complete");
            end2 = tagStart + 1 + tagName.length;
          }
          var localNSMap = config.localNSMap;
          var endMatch = config.tagName == tagName;
          var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
          if (endIgnoreCaseMach) {
            domBuilder.endElement(config.uri, config.localName, tagName);
            if (localNSMap) {
              for (var prefix in localNSMap) {
                if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                  domBuilder.endPrefixMapping(prefix);
                }
              }
            }
            if (!endMatch) {
              errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
            }
          } else {
            parseStack.push(config);
          }
          end2++;
          break;
        case "?":
          locator && position2(tagStart);
          end2 = parseInstruction(source, tagStart, domBuilder);
          break;
        case "!":
          locator && position2(tagStart);
          end2 = parseDCC(source, tagStart, domBuilder, errorHandler);
          break;
        default:
          locator && position2(tagStart);
          var el = new ElementAttributes();
          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
          var end2 = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
          var len = el.length;
          if (!el.closed && fixSelfClosed(source, end2, el.tagName, closeMap)) {
            el.closed = true;
            if (!entityMap.nbsp) {
              errorHandler.warning("unclosed xml attribute");
            }
          }
          if (locator && len) {
            var locator2 = copyLocator(locator, {});
            for (var i = 0; i < len; i++) {
              var a = el[i];
              position2(a.offset);
              a.locator = copyLocator(locator, {});
            }
            domBuilder.locator = locator2;
            if (appendElement$1(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
            domBuilder.locator = locator;
          } else {
            if (appendElement$1(el, domBuilder, currentNSMap)) {
              parseStack.push(el);
            }
          }
          if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {
            end2 = parseHtmlSpecialContent(source, end2, el.tagName, entityReplacer, domBuilder);
          } else {
            end2++;
          }
      }
    } catch (e) {
      if (e instanceof ParseError$1) {
        throw e;
      }
      errorHandler.error("element parse error: " + e);
      end2 = -1;
    }
    if (end2 > start2) {
      start2 = end2;
    } else {
      appendText(Math.max(tagStart, start2) + 1);
    }
  }
}
function copyLocator(f, t) {
  t.lineNumber = f.lineNumber;
  t.columnNumber = f.columnNumber;
  return t;
}
function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler) {
  function addAttribute(qname, value22, startIndex) {
    if (el.attributeNames.hasOwnProperty(qname)) {
      errorHandler.fatalError("Attribute " + qname + " redefined");
    }
    el.addValue(
      qname,
      // @see https://www.w3.org/TR/xml/#AVNormalize
      // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
      // - recursive replacement of (DTD) entity references
      // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
      value22.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
      startIndex
    );
  }
  var attrName;
  var value2;
  var p = ++start2;
  var s = S_TAG;
  while (true) {
    var c = source.charAt(p);
    switch (c) {
      case "=":
        if (s === S_ATTR) {
          attrName = source.slice(start2, p);
          s = S_EQ;
        } else if (s === S_ATTR_SPACE) {
          s = S_EQ;
        } else {
          throw new Error("attribute equal must after attrName");
        }
        break;
      case "'":
      case '"':
        if (s === S_EQ || s === S_ATTR) {
          if (s === S_ATTR) {
            errorHandler.warning('attribute value must after "="');
            attrName = source.slice(start2, p);
          }
          start2 = p + 1;
          p = source.indexOf(c, start2);
          if (p > 0) {
            value2 = source.slice(start2, p);
            addAttribute(attrName, value2, start2 - 1);
            s = S_ATTR_END;
          } else {
            throw new Error("attribute value no end '" + c + "' match");
          }
        } else if (s == S_ATTR_NOQUOT_VALUE) {
          value2 = source.slice(start2, p);
          addAttribute(attrName, value2, start2);
          errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
          start2 = p + 1;
          s = S_ATTR_END;
        } else {
          throw new Error('attribute value must after "="');
        }
        break;
      case "/":
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start2, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            s = S_TAG_CLOSE;
            el.closed = true;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
            break;
          case S_ATTR_SPACE:
            el.closed = true;
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        errorHandler.error("unexpected end of input");
        if (s == S_TAG) {
          el.setTagName(source.slice(start2, p));
        }
        return p;
      case ">":
        switch (s) {
          case S_TAG:
            el.setTagName(source.slice(start2, p));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            break;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
            value2 = source.slice(start2, p);
            if (value2.slice(-1) === "/") {
              el.closed = true;
              value2 = value2.slice(0, -1);
            }
          case S_ATTR_SPACE:
            if (s === S_ATTR_SPACE) {
              value2 = attrName;
            }
            if (s == S_ATTR_NOQUOT_VALUE) {
              errorHandler.warning('attribute "' + value2 + '" missed quot(")!');
              addAttribute(attrName, value2, start2);
            } else {
              if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !value2.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + value2 + '" missed value!! "' + value2 + '" instead!!');
              }
              addAttribute(value2, value2, start2);
            }
            break;
          case S_EQ:
            throw new Error("attribute value missed!!");
        }
        return p;
      case "":
        c = " ";
      default:
        if (c <= " ") {
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start2, p));
              s = S_TAG_SPACE;
              break;
            case S_ATTR:
              attrName = source.slice(start2, p);
              s = S_ATTR_SPACE;
              break;
            case S_ATTR_NOQUOT_VALUE:
              var value2 = source.slice(start2, p);
              errorHandler.warning('attribute "' + value2 + '" missed quot(")!!');
              addAttribute(attrName, value2, start2);
            case S_ATTR_END:
              s = S_TAG_SPACE;
              break;
          }
        } else {
          switch (s) {
            case S_ATTR_SPACE:
              el.tagName;
              if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
              }
              addAttribute(attrName, attrName, start2);
              start2 = p;
              s = S_ATTR;
              break;
            case S_ATTR_END:
              errorHandler.warning('attribute space is required"' + attrName + '"!!');
            case S_TAG_SPACE:
              s = S_ATTR;
              start2 = p;
              break;
            case S_EQ:
              s = S_ATTR_NOQUOT_VALUE;
              start2 = p;
              break;
            case S_TAG_CLOSE:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
        }
    }
    p++;
  }
}
function appendElement$1(el, domBuilder, currentNSMap) {
  var tagName = el.tagName;
  var localNSMap = null;
  var i = el.length;
  while (i--) {
    var a = el[i];
    var qName = a.qName;
    var value2 = a.value;
    var nsp = qName.indexOf(":");
    if (nsp > 0) {
      var prefix = a.prefix = qName.slice(0, nsp);
      var localName = qName.slice(nsp + 1);
      var nsPrefix = prefix === "xmlns" && localName;
    } else {
      localName = qName;
      prefix = null;
      nsPrefix = qName === "xmlns" && "";
    }
    a.localName = localName;
    if (nsPrefix !== false) {
      if (localNSMap == null) {
        localNSMap = {};
        _copy(currentNSMap, currentNSMap = {});
      }
      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value2;
      a.uri = NAMESPACE$1.XMLNS;
      domBuilder.startPrefixMapping(nsPrefix, value2);
    }
  }
  var i = el.length;
  while (i--) {
    a = el[i];
    var prefix = a.prefix;
    if (prefix) {
      if (prefix === "xml") {
        a.uri = NAMESPACE$1.XML;
      }
      if (prefix !== "xmlns") {
        a.uri = currentNSMap[prefix || ""];
      }
    }
  }
  var nsp = tagName.indexOf(":");
  if (nsp > 0) {
    prefix = el.prefix = tagName.slice(0, nsp);
    localName = el.localName = tagName.slice(nsp + 1);
  } else {
    prefix = null;
    localName = el.localName = tagName;
  }
  var ns = el.uri = currentNSMap[prefix || ""];
  domBuilder.startElement(ns, localName, tagName, el);
  if (el.closed) {
    domBuilder.endElement(ns, localName, tagName);
    if (localNSMap) {
      for (prefix in localNSMap) {
        if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
          domBuilder.endPrefixMapping(prefix);
        }
      }
    }
  } else {
    el.currentNSMap = currentNSMap;
    el.localNSMap = localNSMap;
    return true;
  }
}
function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
  if (/^(?:script|textarea)$/i.test(tagName)) {
    var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
    var text2 = source.substring(elStartEnd + 1, elEndStart);
    if (/[&<]/.test(text2)) {
      if (/^script$/i.test(tagName)) {
        domBuilder.characters(text2, 0, text2.length);
        return elEndStart;
      }
      text2 = text2.replace(/&#?\w+;/g, entityReplacer);
      domBuilder.characters(text2, 0, text2.length);
      return elEndStart;
    }
  }
  return elStartEnd + 1;
}
function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
  var pos = closeMap[tagName];
  if (pos == null) {
    pos = source.lastIndexOf("</" + tagName + ">");
    if (pos < elStartEnd) {
      pos = source.lastIndexOf("</" + tagName);
    }
    closeMap[tagName] = pos;
  }
  return pos < elStartEnd;
}
function _copy(source, target) {
  for (var n in source) {
    if (Object.prototype.hasOwnProperty.call(source, n)) {
      target[n] = source[n];
    }
  }
}
function parseDCC(source, start2, domBuilder, errorHandler) {
  var next = source.charAt(start2 + 2);
  switch (next) {
    case "-":
      if (source.charAt(start2 + 3) === "-") {
        var end2 = source.indexOf("-->", start2 + 4);
        if (end2 > start2) {
          domBuilder.comment(source, start2 + 4, end2 - start2 - 4);
          return end2 + 3;
        } else {
          errorHandler.error("Unclosed comment");
          return -1;
        }
      } else {
        return -1;
      }
    default:
      if (source.substr(start2 + 3, 6) == "CDATA[") {
        var end2 = source.indexOf("]]>", start2 + 9);
        domBuilder.startCDATA();
        domBuilder.characters(source, start2 + 9, end2 - start2 - 9);
        domBuilder.endCDATA();
        return end2 + 3;
      }
      var matchs = split(source, start2);
      var len = matchs.length;
      if (len > 1 && /!doctype/i.test(matchs[0][0])) {
        var name = matchs[1][0];
        var pubid = false;
        var sysid = false;
        if (len > 3) {
          if (/^public$/i.test(matchs[2][0])) {
            pubid = matchs[3][0];
            sysid = len > 4 && matchs[4][0];
          } else if (/^system$/i.test(matchs[2][0])) {
            sysid = matchs[3][0];
          }
        }
        var lastMatch = matchs[len - 1];
        domBuilder.startDTD(name, pubid, sysid);
        domBuilder.endDTD();
        return lastMatch.index + lastMatch[0].length;
      }
  }
  return -1;
}
function parseInstruction(source, start2, domBuilder) {
  var end2 = source.indexOf("?>", start2);
  if (end2) {
    var match = source.substring(start2, end2).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    if (match) {
      match[0].length;
      domBuilder.processingInstruction(match[1], match[2]);
      return end2 + 2;
    } else {
      return -1;
    }
  }
  return -1;
}
function ElementAttributes() {
  this.attributeNames = {};
}
ElementAttributes.prototype = {
  setTagName: function(tagName) {
    if (!tagNamePattern.test(tagName)) {
      throw new Error("invalid tagName:" + tagName);
    }
    this.tagName = tagName;
  },
  addValue: function(qName, value2, offset2) {
    if (!tagNamePattern.test(qName)) {
      throw new Error("invalid attribute:" + qName);
    }
    this.attributeNames[qName] = this.length;
    this[this.length++] = { qName, value: value2, offset: offset2 };
  },
  length: 0,
  getLocalName: function(i) {
    return this[i].localName;
  },
  getLocator: function(i) {
    return this[i].locator;
  },
  getQName: function(i) {
    return this[i].qName;
  },
  getURI: function(i) {
    return this[i].uri;
  },
  getValue: function(i) {
    return this[i].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function split(source, start2) {
  var match;
  var buf = [];
  var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  reg.lastIndex = start2;
  reg.exec(source);
  while (match = reg.exec(source)) {
    buf.push(match);
    if (match[1])
      return buf;
  }
}
sax$1.XMLReader = XMLReader$1;
sax$1.ParseError = ParseError$1;
var conventions = conventions$2;
var dom = dom$1;
var entities = entities$1;
var sax = sax$1;
var DOMImplementation = dom.DOMImplementation;
var NAMESPACE = conventions.NAMESPACE;
var ParseError2 = sax.ParseError;
var XMLReader = sax.XMLReader;
function normalizeLineEndings(input) {
  return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
}
function DOMParser$1(options) {
  this.options = options || { locator: {} };
}
DOMParser$1.prototype.parseFromString = function(source, mimeType) {
  var options = this.options;
  var sax2 = new XMLReader();
  var domBuilder = options.domBuilder || new DOMHandler();
  var errorHandler = options.errorHandler;
  var locator = options.locator;
  var defaultNSMap = options.xmlns || {};
  var isHTML = /\/x?html?$/.test(mimeType);
  var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
  if (locator) {
    domBuilder.setDocumentLocator(locator);
  }
  sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
  sax2.domBuilder = options.domBuilder || domBuilder;
  if (isHTML) {
    defaultNSMap[""] = NAMESPACE.HTML;
  }
  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
  var normalize = options.normalizeLineEndings || normalizeLineEndings;
  if (source && typeof source === "string") {
    sax2.parse(
      normalize(source),
      defaultNSMap,
      entityMap
    );
  } else {
    sax2.errorHandler.error("invalid doc source");
  }
  return domBuilder.doc;
};
function buildErrorHandler(errorImpl, domBuilder, locator) {
  if (!errorImpl) {
    if (domBuilder instanceof DOMHandler) {
      return domBuilder;
    }
    errorImpl = domBuilder;
  }
  var errorHandler = {};
  var isCallback = errorImpl instanceof Function;
  locator = locator || {};
  function build(key) {
    var fn2 = errorImpl[key];
    if (!fn2 && isCallback) {
      fn2 = errorImpl.length == 2 ? function(msg) {
        errorImpl(key, msg);
      } : errorImpl;
    }
    errorHandler[key] = fn2 && function(msg) {
      fn2("[xmldom " + key + "]	" + msg + _locator(locator));
    } || function() {
    };
  }
  build("warning");
  build("error");
  build("fatalError");
  return errorHandler;
}
function DOMHandler() {
  this.cdata = false;
}
function position(locator, node) {
  node.lineNumber = locator.lineNumber;
  node.columnNumber = locator.columnNumber;
}
DOMHandler.prototype = {
  startDocument: function() {
    this.doc = new DOMImplementation().createDocument(null, null, null);
    if (this.locator) {
      this.doc.documentURI = this.locator.systemId;
    }
  },
  startElement: function(namespaceURI, localName, qName, attrs) {
    var doc = this.doc;
    var el = doc.createElementNS(namespaceURI, qName || localName);
    var len = attrs.length;
    appendElement(this, el);
    this.currentElement = el;
    this.locator && position(this.locator, el);
    for (var i = 0; i < len; i++) {
      var namespaceURI = attrs.getURI(i);
      var value2 = attrs.getValue(i);
      var qName = attrs.getQName(i);
      var attr = doc.createAttributeNS(namespaceURI, qName);
      this.locator && position(attrs.getLocator(i), attr);
      attr.value = attr.nodeValue = value2;
      el.setAttributeNode(attr);
    }
  },
  endElement: function(namespaceURI, localName, qName) {
    var current = this.currentElement;
    current.tagName;
    this.currentElement = current.parentNode;
  },
  startPrefixMapping: function(prefix, uri) {
  },
  endPrefixMapping: function(prefix) {
  },
  processingInstruction: function(target, data) {
    var ins = this.doc.createProcessingInstruction(target, data);
    this.locator && position(this.locator, ins);
    appendElement(this, ins);
  },
  ignorableWhitespace: function(ch, start2, length2) {
  },
  characters: function(chars2, start2, length2) {
    chars2 = _toString.apply(this, arguments);
    if (chars2) {
      if (this.cdata) {
        var charNode = this.doc.createCDATASection(chars2);
      } else {
        var charNode = this.doc.createTextNode(chars2);
      }
      if (this.currentElement) {
        this.currentElement.appendChild(charNode);
      } else if (/^\s*$/.test(chars2)) {
        this.doc.appendChild(charNode);
      }
      this.locator && position(this.locator, charNode);
    }
  },
  skippedEntity: function(name) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(locator) {
    if (this.locator = locator) {
      locator.lineNumber = 0;
    }
  },
  //LexicalHandler
  comment: function(chars2, start2, length2) {
    chars2 = _toString.apply(this, arguments);
    var comm = this.doc.createComment(chars2);
    this.locator && position(this.locator, comm);
    appendElement(this, comm);
  },
  startCDATA: function() {
    this.cdata = true;
  },
  endCDATA: function() {
    this.cdata = false;
  },
  startDTD: function(name, publicId, systemId) {
    var impl = this.doc.implementation;
    if (impl && impl.createDocumentType) {
      var dt = impl.createDocumentType(name, publicId, systemId);
      this.locator && position(this.locator, dt);
      appendElement(this, dt);
      this.doc.doctype = dt;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(error) {
    console.warn("[xmldom warning]	" + error, _locator(this.locator));
  },
  error: function(error) {
    console.error("[xmldom error]	" + error, _locator(this.locator));
  },
  fatalError: function(error) {
    throw new ParseError2(error, this.locator);
  }
};
function _locator(l) {
  if (l) {
    return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
  }
}
function _toString(chars2, start2, length2) {
  if (typeof chars2 == "string") {
    return chars2.substr(start2, length2);
  } else {
    if (chars2.length >= start2 + length2 || start2) {
      return new java.lang.String(chars2, start2, length2) + "";
    }
    return chars2;
  }
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
  DOMHandler.prototype[key] = function() {
    return null;
  };
});
function appendElement(hander, node) {
  if (!hander.currentElement) {
    hander.doc.appendChild(node);
  } else {
    hander.currentElement.appendChild(node);
  }
}
domParser.__DOMHandler = DOMHandler;
domParser.normalizeLineEndings = normalizeLineEndings;
domParser.DOMParser = DOMParser$1;
var DOMParser = domParser.DOMParser;
/*! @name mpd-parser @version 1.3.0 @license Apache-2.0 */
const isObject$5 = (obj) => {
  return !!obj && typeof obj === "object";
};
const merge$2 = (...objects) => {
  return objects.reduce((result, source) => {
    if (typeof source !== "object") {
      return result;
    }
    Object.keys(source).forEach((key) => {
      if (Array.isArray(result[key]) && Array.isArray(source[key])) {
        result[key] = result[key].concat(source[key]);
      } else if (isObject$5(result[key]) && isObject$5(source[key])) {
        result[key] = merge$2(result[key], source[key]);
      } else {
        result[key] = source[key];
      }
    });
    return result;
  }, {});
};
const values$1 = (o) => Object.keys(o).map((k) => o[k]);
const range = (start2, end2) => {
  const result = [];
  for (let i = start2; i < end2; i++) {
    result.push(i);
  }
  return result;
};
const flatten = (lists) => lists.reduce((x, y) => x.concat(y), []);
const from = (list) => {
  if (!list.length) {
    return [];
  }
  const result = [];
  for (let i = 0; i < list.length; i++) {
    result.push(list[i]);
  }
  return result;
};
const findIndexes = (l, key) => l.reduce((a, e, i) => {
  if (e[key]) {
    a.push(i);
  }
  return a;
}, []);
const union = (lists, keyFunction) => {
  return values$1(lists.reduce((acc, list) => {
    list.forEach((el) => {
      acc[keyFunction(el)] = el;
    });
    return acc;
  }, {}));
};
var errors = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  INVALID_NUMBER_OF_CONTENT_STEERING: "INVALID_NUMBER_OF_CONTENT_STEERING",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
const urlTypeToSegment = ({
  baseUrl = "",
  source = "",
  range: range2 = "",
  indexRange = ""
}) => {
  const segment = {
    uri: source,
    resolvedUri: resolveUrl$1(baseUrl || "", source)
  };
  if (range2 || indexRange) {
    const rangeStr = range2 ? range2 : indexRange;
    const ranges = rangeStr.split("-");
    let startRange = window$1$1.BigInt ? window$1$1.BigInt(ranges[0]) : parseInt(ranges[0], 10);
    let endRange = window$1$1.BigInt ? window$1$1.BigInt(ranges[1]) : parseInt(ranges[1], 10);
    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
      startRange = Number(startRange);
    }
    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
      endRange = Number(endRange);
    }
    let length2;
    if (typeof endRange === "bigint" || typeof startRange === "bigint") {
      length2 = window$1$1.BigInt(endRange) - window$1$1.BigInt(startRange) + window$1$1.BigInt(1);
    } else {
      length2 = endRange - startRange + 1;
    }
    if (typeof length2 === "bigint" && length2 < Number.MAX_SAFE_INTEGER) {
      length2 = Number(length2);
    }
    segment.byterange = {
      length: length2,
      offset: startRange
    };
  }
  return segment;
};
const byteRangeToString = (byterange) => {
  let endRange;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    endRange = window$1$1.BigInt(byterange.offset) + window$1$1.BigInt(byterange.length) - window$1$1.BigInt(1);
  } else {
    endRange = byterange.offset + byterange.length - 1;
  }
  return `${byterange.offset}-${endRange}`;
};
const parseEndNumber = (endNumber) => {
  if (endNumber && typeof endNumber !== "number") {
    endNumber = parseInt(endNumber, 10);
  }
  if (isNaN(endNumber)) {
    return null;
  }
  return endNumber;
};
const segmentRange = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static(attributes) {
    const {
      duration: duration2,
      timescale = 1,
      sourceDuration,
      periodDuration
    } = attributes;
    const endNumber = parseEndNumber(attributes.endNumber);
    const segmentDuration = duration2 / timescale;
    if (typeof endNumber === "number") {
      return {
        start: 0,
        end: endNumber
      };
    }
    if (typeof periodDuration === "number") {
      return {
        start: 0,
        end: periodDuration / segmentDuration
      };
    }
    return {
      start: 0,
      end: sourceDuration / segmentDuration
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic(attributes) {
    const {
      NOW,
      clientOffset,
      availabilityStartTime,
      timescale = 1,
      duration: duration2,
      periodStart = 0,
      minimumUpdatePeriod = 0,
      timeShiftBufferDepth = Infinity
    } = attributes;
    const endNumber = parseEndNumber(attributes.endNumber);
    const now2 = (NOW + clientOffset) / 1e3;
    const periodStartWC = availabilityStartTime + periodStart;
    const periodEndWC = now2 + minimumUpdatePeriod;
    const periodDuration = periodEndWC - periodStartWC;
    const segmentCount = Math.ceil(periodDuration * timescale / duration2);
    const availableStart = Math.floor((now2 - periodStartWC - timeShiftBufferDepth) * timescale / duration2);
    const availableEnd = Math.floor((now2 - periodStartWC) * timescale / duration2);
    return {
      start: Math.max(0, availableStart),
      end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
    };
  }
};
const toSegments = (attributes) => (number) => {
  const {
    duration: duration2,
    timescale = 1,
    periodStart,
    startNumber = 1
  } = attributes;
  return {
    number: startNumber + number,
    duration: duration2 / timescale,
    timeline: periodStart,
    time: number * duration2
  };
};
const parseByDuration = (attributes) => {
  const {
    type,
    duration: duration2,
    timescale = 1,
    periodDuration,
    sourceDuration
  } = attributes;
  const {
    start: start2,
    end: end2
  } = segmentRange[type](attributes);
  const segments = range(start2, end2).map(toSegments(attributes));
  if (type === "static") {
    const index = segments.length - 1;
    const sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
    segments[index].duration = sectionDuration - duration2 / timescale * index;
  }
  return segments;
};
const segmentsFromBase = (attributes) => {
  const {
    baseUrl,
    initialization = {},
    sourceDuration,
    indexRange = "",
    periodStart,
    presentationTime,
    number = 0,
    duration: duration2
  } = attributes;
  if (!baseUrl) {
    throw new Error(errors.NO_BASE_URL);
  }
  const initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  const segment = urlTypeToSegment({
    baseUrl,
    source: baseUrl,
    indexRange
  });
  segment.map = initSegment;
  if (duration2) {
    const segmentTimeInfo = parseByDuration(attributes);
    if (segmentTimeInfo.length) {
      segment.duration = segmentTimeInfo[0].duration;
      segment.timeline = segmentTimeInfo[0].timeline;
    }
  } else if (sourceDuration) {
    segment.duration = sourceDuration;
    segment.timeline = periodStart;
  }
  segment.presentationTime = presentationTime || periodStart;
  segment.number = number;
  return [segment];
};
const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {
  const initSegment = playlist.sidx.map ? playlist.sidx.map : null;
  const sourceDuration = playlist.sidx.duration;
  const timeline = playlist.timeline || 0;
  const sidxByteRange = playlist.sidx.byterange;
  const sidxEnd = sidxByteRange.offset + sidxByteRange.length;
  const timescale = sidx.timescale;
  const mediaReferences = sidx.references.filter((r) => r.referenceType !== 1);
  const segments = [];
  const type = playlist.endList ? "static" : "dynamic";
  const periodStart = playlist.sidx.timeline;
  let presentationTime = periodStart;
  let number = playlist.mediaSequence || 0;
  let startIndex;
  if (typeof sidx.firstOffset === "bigint") {
    startIndex = window$1$1.BigInt(sidxEnd) + sidx.firstOffset;
  } else {
    startIndex = sidxEnd + sidx.firstOffset;
  }
  for (let i = 0; i < mediaReferences.length; i++) {
    const reference2 = sidx.references[i];
    const size = reference2.referencedSize;
    const duration2 = reference2.subsegmentDuration;
    let endIndex;
    if (typeof startIndex === "bigint") {
      endIndex = startIndex + window$1$1.BigInt(size) - window$1$1.BigInt(1);
    } else {
      endIndex = startIndex + size - 1;
    }
    const indexRange = `${startIndex}-${endIndex}`;
    const attributes = {
      baseUrl,
      timescale,
      timeline,
      periodStart,
      presentationTime,
      number,
      duration: duration2,
      sourceDuration,
      indexRange,
      type
    };
    const segment = segmentsFromBase(attributes)[0];
    if (initSegment) {
      segment.map = initSegment;
    }
    segments.push(segment);
    if (typeof startIndex === "bigint") {
      startIndex += window$1$1.BigInt(size);
    } else {
      startIndex += size;
    }
    presentationTime += duration2 / timescale;
    number++;
  }
  playlist.segments = segments;
  return playlist;
};
const SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
const TIME_FUDGE = 1 / 60;
const getUniqueTimelineStarts = (timelineStarts) => {
  return union(timelineStarts, ({
    timeline
  }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);
};
const findPlaylistWithName = (playlists, name) => {
  for (let i = 0; i < playlists.length; i++) {
    if (playlists[i].attributes.NAME === name) {
      return playlists[i];
    }
  }
  return null;
};
const getMediaGroupPlaylists = (manifest) => {
  let mediaGroupPlaylists = [];
  forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {
    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
  });
  return mediaGroupPlaylists;
};
const updateMediaSequenceForPlaylist = ({
  playlist,
  mediaSequence
}) => {
  playlist.mediaSequence = mediaSequence;
  playlist.segments.forEach((segment, index) => {
    segment.number = playlist.mediaSequence + index;
  });
};
const updateSequenceNumbers = ({
  oldPlaylists,
  newPlaylists,
  timelineStarts
}) => {
  newPlaylists.forEach((playlist) => {
    playlist.discontinuitySequence = timelineStarts.findIndex(function({
      timeline
    }) {
      return timeline === playlist.timeline;
    });
    const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
    if (!oldPlaylist) {
      return;
    }
    if (playlist.sidx) {
      return;
    }
    const firstNewSegment = playlist.segments[0];
    const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function(oldSegment) {
      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
    });
    if (oldMatchingSegmentIndex === -1) {
      updateMediaSequenceForPlaylist({
        playlist,
        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
      });
      playlist.segments[0].discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
        playlist.discontinuitySequence--;
      }
      return;
    }
    const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
      firstNewSegment.discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      playlist.discontinuitySequence--;
    }
    updateMediaSequenceForPlaylist({
      playlist,
      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
    });
  });
};
const positionManifestOnTimeline = ({
  oldManifest,
  newManifest
}) => {
  const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
  const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
  updateSequenceNumbers({
    oldPlaylists,
    newPlaylists,
    timelineStarts: newManifest.timelineStarts
  });
  return newManifest;
};
const generateSidxKey = (sidx) => sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
const mergeDiscontiguousPlaylists = (playlists) => {
  const playlistsByBaseUrl = playlists.reduce(function(acc, cur) {
    if (!acc[cur.attributes.baseUrl]) {
      acc[cur.attributes.baseUrl] = [];
    }
    acc[cur.attributes.baseUrl].push(cur);
    return acc;
  }, {});
  let allPlaylists = [];
  Object.values(playlistsByBaseUrl).forEach((playlistGroup) => {
    const mergedPlaylists = values$1(playlistGroup.reduce((acc, playlist) => {
      const name = playlist.attributes.id + (playlist.attributes.lang || "");
      if (!acc[name]) {
        acc[name] = playlist;
        acc[name].attributes.timelineStarts = [];
      } else {
        if (playlist.segments) {
          if (playlist.segments[0]) {
            playlist.segments[0].discontinuity = true;
          }
          acc[name].segments.push(...playlist.segments);
        }
        if (playlist.attributes.contentProtection) {
          acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
        }
      }
      acc[name].attributes.timelineStarts.push({
        // Although they represent the same number, it's important to have both to make it
        // compatible with HLS potentially having a similar attribute.
        start: playlist.attributes.periodStart,
        timeline: playlist.attributes.periodStart
      });
      return acc;
    }, {}));
    allPlaylists = allPlaylists.concat(mergedPlaylists);
  });
  return allPlaylists.map((playlist) => {
    playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
    return playlist;
  });
};
const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {
  const sidxKey = generateSidxKey(playlist.sidx);
  const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
  if (sidxMatch) {
    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
  }
  return playlist;
};
const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {
  if (!Object.keys(sidxMapping).length) {
    return playlists;
  }
  for (const i in playlists) {
    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
  }
  return playlists;
};
const formatAudioPlaylist = ({
  attributes,
  segments,
  sidx,
  mediaSequence,
  discontinuitySequence,
  discontinuityStarts
}, isAudioOnly2) => {
  const playlist = {
    attributes: {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth,
      CODECS: attributes.codecs,
      ["PROGRAM-ID"]: 1
    },
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    discontinuitySequence,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    mediaSequence,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (attributes.serviceLocation) {
    playlist.attributes.serviceLocation = attributes.serviceLocation;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  if (isAudioOnly2) {
    playlist.attributes.AUDIO = "audio";
    playlist.attributes.SUBTITLES = "subs";
  }
  return playlist;
};
const formatVttPlaylist = ({
  attributes,
  segments,
  mediaSequence,
  discontinuityStarts,
  discontinuitySequence
}) => {
  if (typeof segments === "undefined") {
    segments = [{
      uri: attributes.baseUrl,
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      duration: attributes.sourceDuration,
      number: 0
    }];
    attributes.duration = attributes.sourceDuration;
  }
  const m3u8Attributes = {
    NAME: attributes.id,
    BANDWIDTH: attributes.bandwidth,
    ["PROGRAM-ID"]: 1
  };
  if (attributes.codecs) {
    m3u8Attributes.CODECS = attributes.codecs;
  }
  const vttPlaylist = {
    attributes: m3u8Attributes,
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    timelineStarts: attributes.timelineStarts,
    discontinuityStarts,
    discontinuitySequence,
    mediaSequence,
    segments
  };
  if (attributes.serviceLocation) {
    vttPlaylist.attributes.serviceLocation = attributes.serviceLocation;
  }
  return vttPlaylist;
};
const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly2 = false) => {
  let mainPlaylist;
  const formattedPlaylists = playlists.reduce((a, playlist) => {
    const role = playlist.attributes.role && playlist.attributes.role.value || "";
    const language = playlist.attributes.lang || "";
    let label = playlist.attributes.label || "main";
    if (language && !playlist.attributes.label) {
      const roleLabel = role ? ` (${role})` : "";
      label = `${playlist.attributes.lang}${roleLabel}`;
    }
    if (!a[label]) {
      a[label] = {
        language,
        autoselect: true,
        default: role === "main",
        playlists: [],
        uri: ""
      };
    }
    const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly2), sidxMapping);
    a[label].playlists.push(formatted);
    if (typeof mainPlaylist === "undefined" && role === "main") {
      mainPlaylist = playlist;
      mainPlaylist.default = true;
    }
    return a;
  }, {});
  if (!mainPlaylist) {
    const firstLabel = Object.keys(formattedPlaylists)[0];
    formattedPlaylists[firstLabel].default = true;
  }
  return formattedPlaylists;
};
const organizeVttPlaylists = (playlists, sidxMapping = {}) => {
  return playlists.reduce((a, playlist) => {
    const label = playlist.attributes.label || playlist.attributes.lang || "text";
    if (!a[label]) {
      a[label] = {
        language: label,
        default: false,
        autoselect: false,
        playlists: [],
        uri: ""
      };
    }
    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));
    return a;
  }, {});
};
const organizeCaptionServices = (captionServices) => captionServices.reduce((svcObj, svc) => {
  if (!svc) {
    return svcObj;
  }
  svc.forEach((service) => {
    const {
      channel,
      language
    } = service;
    svcObj[language] = {
      autoselect: false,
      default: false,
      instreamId: channel,
      language
    };
    if (service.hasOwnProperty("aspectRatio")) {
      svcObj[language].aspectRatio = service.aspectRatio;
    }
    if (service.hasOwnProperty("easyReader")) {
      svcObj[language].easyReader = service.easyReader;
    }
    if (service.hasOwnProperty("3D")) {
      svcObj[language]["3D"] = service["3D"];
    }
  });
  return svcObj;
}, {});
const formatVideoPlaylist = ({
  attributes,
  segments,
  sidx,
  discontinuityStarts
}) => {
  const playlist = {
    attributes: {
      NAME: attributes.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: attributes.width,
        height: attributes.height
      },
      CODECS: attributes.codecs,
      BANDWIDTH: attributes.bandwidth,
      ["PROGRAM-ID"]: 1
    },
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    segments
  };
  if (attributes.frameRate) {
    playlist.attributes["FRAME-RATE"] = attributes.frameRate;
  }
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (attributes.serviceLocation) {
    playlist.attributes.serviceLocation = attributes.serviceLocation;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  return playlist;
};
const videoOnly = ({
  attributes
}) => attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
const audioOnly = ({
  attributes
}) => attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
const vttOnly = ({
  attributes
}) => attributes.mimeType === "text/vtt" || attributes.contentType === "text";
const addMediaSequenceValues = (playlists, timelineStarts) => {
  playlists.forEach((playlist) => {
    playlist.mediaSequence = 0;
    playlist.discontinuitySequence = timelineStarts.findIndex(function({
      timeline
    }) {
      return timeline === playlist.timeline;
    });
    if (!playlist.segments) {
      return;
    }
    playlist.segments.forEach((segment, index) => {
      segment.number = index;
    });
  });
};
const flattenMediaGroupPlaylists = (mediaGroupObject) => {
  if (!mediaGroupObject) {
    return [];
  }
  return Object.keys(mediaGroupObject).reduce((acc, label) => {
    const labelContents = mediaGroupObject[label];
    return acc.concat(labelContents.playlists);
  }, []);
};
const toM3u8 = ({
  dashPlaylists,
  locations,
  contentSteering,
  sidxMapping = {},
  previousManifest,
  eventStream
}) => {
  if (!dashPlaylists.length) {
    return {};
  }
  const {
    sourceDuration: duration2,
    type,
    suggestedPresentationDelay,
    minimumUpdatePeriod
  } = dashPlaylists[0].attributes;
  const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
  const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
  const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
  const captions = dashPlaylists.map((playlist) => playlist.attributes.captionServices).filter(Boolean);
  const manifest = {
    allowCache: true,
    discontinuityStarts: [],
    segments: [],
    endList: true,
    mediaGroups: {
      AUDIO: {},
      VIDEO: {},
      ["CLOSED-CAPTIONS"]: {},
      SUBTITLES: {}
    },
    uri: "",
    duration: duration2,
    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
  };
  if (minimumUpdatePeriod >= 0) {
    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1e3;
  }
  if (locations) {
    manifest.locations = locations;
  }
  if (contentSteering) {
    manifest.contentSteering = contentSteering;
  }
  if (type === "dynamic") {
    manifest.suggestedPresentationDelay = suggestedPresentationDelay;
  }
  if (eventStream && eventStream.length > 0) {
    manifest.eventStream = eventStream;
  }
  const isAudioOnly2 = manifest.playlists.length === 0;
  const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly2) : null;
  const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
  const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
  const playlistTimelineStarts = formattedPlaylists.map(({
    timelineStarts
  }) => timelineStarts);
  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
  if (organizedAudioGroup) {
    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
  }
  if (organizedVttGroup) {
    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
  }
  if (captions.length) {
    manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
  }
  if (previousManifest) {
    return positionManifestOnTimeline({
      oldManifest: previousManifest,
      newManifest: manifest
    });
  }
  return manifest;
};
const getLiveRValue = (attributes, time, duration2) => {
  const {
    NOW,
    clientOffset,
    availabilityStartTime,
    timescale = 1,
    periodStart = 0,
    minimumUpdatePeriod = 0
  } = attributes;
  const now2 = (NOW + clientOffset) / 1e3;
  const periodStartWC = availabilityStartTime + periodStart;
  const periodEndWC = now2 + minimumUpdatePeriod;
  const periodDuration = periodEndWC - periodStartWC;
  return Math.ceil((periodDuration * timescale - time) / duration2);
};
const parseByTimeline = (attributes, segmentTimeline) => {
  const {
    type,
    minimumUpdatePeriod = 0,
    media = "",
    sourceDuration,
    timescale = 1,
    startNumber = 1,
    periodStart: timeline
  } = attributes;
  const segments = [];
  let time = -1;
  for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
    const S2 = segmentTimeline[sIndex];
    const duration2 = S2.d;
    const repeat = S2.r || 0;
    const segmentTime = S2.t || 0;
    if (time < 0) {
      time = segmentTime;
    }
    if (segmentTime && segmentTime > time) {
      time = segmentTime;
    }
    let count;
    if (repeat < 0) {
      const nextS = sIndex + 1;
      if (nextS === segmentTimeline.length) {
        if (type === "dynamic" && minimumUpdatePeriod > 0 && media.indexOf("$Number$") > 0) {
          count = getLiveRValue(attributes, time, duration2);
        } else {
          count = (sourceDuration * timescale - time) / duration2;
        }
      } else {
        count = (segmentTimeline[nextS].t - time) / duration2;
      }
    } else {
      count = repeat + 1;
    }
    const end2 = startNumber + segments.length + count;
    let number = startNumber + segments.length;
    while (number < end2) {
      segments.push({
        number,
        duration: duration2 / timescale,
        time,
        timeline
      });
      time += duration2;
      number++;
    }
  }
  return segments;
};
const identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
const identifierReplacement = (values2) => (match, identifier, format, width) => {
  if (match === "$$") {
    return "$";
  }
  if (typeof values2[identifier] === "undefined") {
    return match;
  }
  const value2 = "" + values2[identifier];
  if (identifier === "RepresentationID") {
    return value2;
  }
  if (!format) {
    width = 1;
  } else {
    width = parseInt(width, 10);
  }
  if (value2.length >= width) {
    return value2;
  }
  return `${new Array(width - value2.length + 1).join("0")}${value2}`;
};
const constructTemplateUrl = (url2, values2) => url2.replace(identifierPattern, identifierReplacement(values2));
const parseTemplateInfo = (attributes, segmentTimeline) => {
  if (!attributes.duration && !segmentTimeline) {
    return [{
      number: attributes.startNumber || 1,
      duration: attributes.sourceDuration,
      time: 0,
      timeline: attributes.periodStart
    }];
  }
  if (attributes.duration) {
    return parseByDuration(attributes);
  }
  return parseByTimeline(attributes, segmentTimeline);
};
const segmentsFromTemplate = (attributes, segmentTimeline) => {
  const templateValues = {
    RepresentationID: attributes.id,
    Bandwidth: attributes.bandwidth || 0
  };
  const {
    initialization = {
      sourceURL: "",
      range: ""
    }
  } = attributes;
  const mapSegment = urlTypeToSegment({
    baseUrl: attributes.baseUrl,
    source: constructTemplateUrl(initialization.sourceURL, templateValues),
    range: initialization.range
  });
  const segments = parseTemplateInfo(attributes, segmentTimeline);
  return segments.map((segment) => {
    templateValues.Number = segment.number;
    templateValues.Time = segment.time;
    const uri = constructTemplateUrl(attributes.media || "", templateValues);
    const timescale = attributes.timescale || 1;
    const presentationTimeOffset = attributes.presentationTimeOffset || 0;
    const presentationTime = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      attributes.periodStart + (segment.time - presentationTimeOffset) / timescale
    );
    const map2 = {
      uri,
      timeline: segment.timeline,
      duration: segment.duration,
      resolvedUri: resolveUrl$1(attributes.baseUrl || "", uri),
      map: mapSegment,
      number: segment.number,
      presentationTime
    };
    return map2;
  });
};
const SegmentURLToSegmentObject = (attributes, segmentUrl) => {
  const {
    baseUrl,
    initialization = {}
  } = attributes;
  const initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  const segment = urlTypeToSegment({
    baseUrl,
    source: segmentUrl.media,
    range: segmentUrl.mediaRange
  });
  segment.map = initSegment;
  return segment;
};
const segmentsFromList = (attributes, segmentTimeline) => {
  const {
    duration: duration2,
    segmentUrls = [],
    periodStart
  } = attributes;
  if (!duration2 && !segmentTimeline || duration2 && segmentTimeline) {
    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
  }
  const segmentUrlMap = segmentUrls.map((segmentUrlObject) => SegmentURLToSegmentObject(attributes, segmentUrlObject));
  let segmentTimeInfo;
  if (duration2) {
    segmentTimeInfo = parseByDuration(attributes);
  }
  if (segmentTimeline) {
    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
  }
  const segments = segmentTimeInfo.map((segmentTime, index) => {
    if (segmentUrlMap[index]) {
      const segment = segmentUrlMap[index];
      const timescale = attributes.timescale || 1;
      const presentationTimeOffset = attributes.presentationTimeOffset || 0;
      segment.timeline = segmentTime.timeline;
      segment.duration = segmentTime.duration;
      segment.number = segmentTime.number;
      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
      return segment;
    }
  }).filter((segment) => segment);
  return segments;
};
const generateSegments = ({
  attributes,
  segmentInfo
}) => {
  let segmentAttributes;
  let segmentsFn;
  if (segmentInfo.template) {
    segmentsFn = segmentsFromTemplate;
    segmentAttributes = merge$2(attributes, segmentInfo.template);
  } else if (segmentInfo.base) {
    segmentsFn = segmentsFromBase;
    segmentAttributes = merge$2(attributes, segmentInfo.base);
  } else if (segmentInfo.list) {
    segmentsFn = segmentsFromList;
    segmentAttributes = merge$2(attributes, segmentInfo.list);
  }
  const segmentsInfo = {
    attributes
  };
  if (!segmentsFn) {
    return segmentsInfo;
  }
  const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
  if (segmentAttributes.duration) {
    const {
      duration: duration2,
      timescale = 1
    } = segmentAttributes;
    segmentAttributes.duration = duration2 / timescale;
  } else if (segments.length) {
    segmentAttributes.duration = segments.reduce((max2, segment) => {
      return Math.max(max2, Math.ceil(segment.duration));
    }, 0);
  } else {
    segmentAttributes.duration = 0;
  }
  segmentsInfo.attributes = segmentAttributes;
  segmentsInfo.segments = segments;
  if (segmentInfo.base && segmentAttributes.indexRange) {
    segmentsInfo.sidx = segments[0];
    segmentsInfo.segments = [];
  }
  return segmentsInfo;
};
const toPlaylists = (representations) => representations.map(generateSegments);
const findChildren = (element, name) => from(element.childNodes).filter(({
  tagName
}) => tagName === name);
const getContent = (element) => element.textContent.trim();
const parseDivisionValue = (value2) => {
  return parseFloat(value2.split("/").reduce((prev2, current) => prev2 / current));
};
const parseDuration = (str) => {
  const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
  const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
  const SECONDS_IN_DAY = 24 * 60 * 60;
  const SECONDS_IN_HOUR = 60 * 60;
  const SECONDS_IN_MIN = 60;
  const durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
  const match = durationRegex.exec(str);
  if (!match) {
    return 0;
  }
  const [year, month, day, hour, minute, second] = match.slice(1);
  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
};
const parseDate = (str) => {
  const dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  if (dateRegex.test(str)) {
    str += "Z";
  }
  return Date.parse(str);
};
const parsers = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration(value2) {
    return parseDuration(value2);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime(value2) {
    return parseDate(value2) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod(value2) {
    return parseDuration(value2);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay(value2) {
    return parseDuration(value2);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type(value2) {
    return value2;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth(value2) {
    return parseDuration(value2);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start(value2) {
    return parseDuration(value2);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the frame rate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed frame rate
   */
  frameRate(value2) {
    return parseDivisionValue(value2);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration(value2) {
    const parsedValue = parseInt(value2, 10);
    if (isNaN(parsedValue)) {
      return parseDuration(value2);
    }
    return parsedValue;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Specifies the presentationTime.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTime
   */
  presentationTime(value2) {
    return parseInt(value2, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT(value2) {
    return value2;
  }
};
const parseAttributes = (el) => {
  if (!(el && el.attributes)) {
    return {};
  }
  return from(el.attributes).reduce((a, e) => {
    const parseFn = parsers[e.name] || parsers.DEFAULT;
    a[e.name] = parseFn(e.value);
    return a;
  }, {});
};
const keySystemsMap = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
  // ISO_IEC 23009-1_2022 5.8.5.2.2 The mp4 Protection Scheme
  "urn:mpeg:dash:mp4protection:2011": "mp4protection"
};
const buildBaseUrls = (references, baseUrlElements) => {
  if (!baseUrlElements.length) {
    return references;
  }
  return flatten(references.map(function(reference2) {
    return baseUrlElements.map(function(baseUrlElement) {
      const initialBaseUrl = getContent(baseUrlElement);
      const resolvedBaseUrl = resolveUrl$1(reference2.baseUrl, initialBaseUrl);
      const finalBaseUrl = merge$2(parseAttributes(baseUrlElement), {
        baseUrl: resolvedBaseUrl
      });
      if (resolvedBaseUrl !== initialBaseUrl && !finalBaseUrl.serviceLocation && reference2.serviceLocation) {
        finalBaseUrl.serviceLocation = reference2.serviceLocation;
      }
      return finalBaseUrl;
    });
  }));
};
const getSegmentInformation = (adaptationSet) => {
  const segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
  const segmentList = findChildren(adaptationSet, "SegmentList")[0];
  const segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map((s) => merge$2({
    tag: "SegmentURL"
  }, parseAttributes(s)));
  const segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
  const segmentTimelineParentNode = segmentList || segmentTemplate;
  const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
  const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
  const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
  const template = segmentTemplate && parseAttributes(segmentTemplate);
  if (template && segmentInitialization) {
    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);
  } else if (template && template.initialization) {
    template.initialization = {
      sourceURL: template.initialization
    };
  }
  const segmentInfo = {
    template,
    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map((s) => parseAttributes(s)),
    list: segmentList && merge$2(parseAttributes(segmentList), {
      segmentUrls,
      initialization: parseAttributes(segmentInitialization)
    }),
    base: segmentBase && merge$2(parseAttributes(segmentBase), {
      initialization: parseAttributes(segmentInitialization)
    })
  };
  Object.keys(segmentInfo).forEach((key) => {
    if (!segmentInfo[key]) {
      delete segmentInfo[key];
    }
  });
  return segmentInfo;
};
const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => (representation) => {
  const repBaseUrlElements = findChildren(representation, "BaseURL");
  const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
  const attributes = merge$2(adaptationSetAttributes, parseAttributes(representation));
  const representationSegmentInfo = getSegmentInformation(representation);
  return repBaseUrls.map((baseUrl) => {
    return {
      segmentInfo: merge$2(adaptationSetSegmentInfo, representationSegmentInfo),
      attributes: merge$2(attributes, baseUrl)
    };
  });
};
const generateKeySystemInformation = (contentProtectionNodes) => {
  return contentProtectionNodes.reduce((acc, node) => {
    const attributes = parseAttributes(node);
    if (attributes.schemeIdUri) {
      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
    }
    const keySystem = keySystemsMap[attributes.schemeIdUri];
    if (keySystem) {
      acc[keySystem] = {
        attributes
      };
      const psshNode = findChildren(node, "cenc:pssh")[0];
      if (psshNode) {
        const pssh = getContent(psshNode);
        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);
      }
    }
    return acc;
  }, {});
};
const parseCaptionServiceMetadata = (service) => {
  if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    const values2 = typeof service.value !== "string" ? [] : service.value.split(";");
    return values2.map((value2) => {
      let channel;
      let language;
      language = value2;
      if (/^CC\d=/.test(value2)) {
        [channel, language] = value2.split("=");
      } else if (/^CC\d$/.test(value2)) {
        channel = value2;
      }
      return {
        channel,
        language
      };
    });
  } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    const values2 = typeof service.value !== "string" ? [] : service.value.split(";");
    return values2.map((value2) => {
      const flags = {
        // service or channel number 1-63
        "channel": void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        "language": void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        "aspectRatio": 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        "easyReader": 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(value2)) {
        const [channel, opts = ""] = value2.split("=");
        flags.channel = channel;
        flags.language = value2;
        opts.split(",").forEach((opt) => {
          const [name, val] = opt.split(":");
          if (name === "lang") {
            flags.language = val;
          } else if (name === "er") {
            flags.easyReader = Number(val);
          } else if (name === "war") {
            flags.aspectRatio = Number(val);
          } else if (name === "3D") {
            flags["3D"] = Number(val);
          }
        });
      } else {
        flags.language = value2;
      }
      if (flags.channel) {
        flags.channel = "SERVICE" + flags.channel;
      }
      return flags;
    });
  }
};
const toEventStream = (period) => {
  return flatten(findChildren(period.node, "EventStream").map((eventStream) => {
    const eventStreamAttributes = parseAttributes(eventStream);
    const schemeIdUri = eventStreamAttributes.schemeIdUri;
    return findChildren(eventStream, "Event").map((event2) => {
      const eventAttributes = parseAttributes(event2);
      const presentationTime = eventAttributes.presentationTime || 0;
      const timescale = eventStreamAttributes.timescale || 1;
      const duration2 = eventAttributes.duration || 0;
      const start2 = presentationTime / timescale + period.attributes.start;
      return {
        schemeIdUri,
        value: eventStreamAttributes.value,
        id: eventAttributes.id,
        start: start2,
        end: start2 + duration2 / timescale,
        messageData: getContent(event2) || eventAttributes.messageData,
        contentEncoding: eventStreamAttributes.contentEncoding,
        presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0
      };
    });
  }));
};
const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => (adaptationSet) => {
  const adaptationSetAttributes = parseAttributes(adaptationSet);
  const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
  const role = findChildren(adaptationSet, "Role")[0];
  const roleAttributes = {
    role: parseAttributes(role)
  };
  let attrs = merge$2(periodAttributes, adaptationSetAttributes, roleAttributes);
  const accessibility = findChildren(adaptationSet, "Accessibility")[0];
  const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));
  if (captionServices) {
    attrs = merge$2(attrs, {
      captionServices
    });
  }
  const label = findChildren(adaptationSet, "Label")[0];
  if (label && label.childNodes.length) {
    const labelVal = label.childNodes[0].nodeValue.trim();
    attrs = merge$2(attrs, {
      label: labelVal
    });
  }
  const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
  if (Object.keys(contentProtection).length) {
    attrs = merge$2(attrs, {
      contentProtection
    });
  }
  const segmentInfo = getSegmentInformation(adaptationSet);
  const representations = findChildren(adaptationSet, "Representation");
  const adaptationSetSegmentInfo = merge$2(periodSegmentInfo, segmentInfo);
  return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
};
const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {
  const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
  const periodAttributes = merge$2(mpdAttributes, {
    periodStart: period.attributes.start
  });
  if (typeof period.attributes.duration === "number") {
    periodAttributes.periodDuration = period.attributes.duration;
  }
  const adaptationSets = findChildren(period.node, "AdaptationSet");
  const periodSegmentInfo = getSegmentInformation(period.node);
  return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
};
const generateContentSteeringInformation = (contentSteeringNodes, eventHandler) => {
  if (contentSteeringNodes.length > 1) {
    eventHandler({
      type: "warn",
      message: "The MPD manifest should contain no more than one ContentSteering tag"
    });
  }
  if (!contentSteeringNodes.length) {
    return null;
  }
  const infoFromContentSteeringTag = merge$2({
    serverURL: getContent(contentSteeringNodes[0])
  }, parseAttributes(contentSteeringNodes[0]));
  infoFromContentSteeringTag.queryBeforeStart = infoFromContentSteeringTag.queryBeforeStart === "true";
  return infoFromContentSteeringTag;
};
const getPeriodStart = ({
  attributes,
  priorPeriodAttributes,
  mpdType
}) => {
  if (typeof attributes.start === "number") {
    return attributes.start;
  }
  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
    return priorPeriodAttributes.start + priorPeriodAttributes.duration;
  }
  if (!priorPeriodAttributes && mpdType === "static") {
    return 0;
  }
  return null;
};
const inheritAttributes = (mpd, options = {}) => {
  const {
    manifestUri = "",
    NOW = Date.now(),
    clientOffset = 0,
    // TODO: For now, we are expecting an eventHandler callback function
    // to be passed into the mpd parser as an option.
    // In the future, we should enable stream parsing by using the Stream class from vhs-utils.
    // This will support new features including a standardized event handler.
    // See the m3u8 parser for examples of how stream parsing is currently used for HLS parsing.
    // https://github.com/videojs/vhs-utils/blob/88d6e10c631e57a5af02c5a62bc7376cd456b4f5/src/stream.js#L9
    eventHandler = function() {
    }
  } = options;
  const periodNodes = findChildren(mpd, "Period");
  if (!periodNodes.length) {
    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
  }
  const locations = findChildren(mpd, "Location");
  const mpdAttributes = parseAttributes(mpd);
  const mpdBaseUrls = buildBaseUrls([{
    baseUrl: manifestUri
  }], findChildren(mpd, "BaseURL"));
  const contentSteeringNodes = findChildren(mpd, "ContentSteering");
  mpdAttributes.type = mpdAttributes.type || "static";
  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
  mpdAttributes.NOW = NOW;
  mpdAttributes.clientOffset = clientOffset;
  if (locations.length) {
    mpdAttributes.locations = locations.map(getContent);
  }
  const periods = [];
  periodNodes.forEach((node, index) => {
    const attributes = parseAttributes(node);
    const priorPeriod = periods[index - 1];
    attributes.start = getPeriodStart({
      attributes,
      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
      mpdType: mpdAttributes.type
    });
    periods.push({
      node,
      attributes
    });
  });
  return {
    locations: mpdAttributes.locations,
    contentSteeringInfo: generateContentSteeringInformation(contentSteeringNodes, eventHandler),
    // TODO: There are occurences where this `representationInfo` array contains undesired
    // duplicates. This generally occurs when there are multiple BaseURL nodes that are
    // direct children of the MPD node. When we attempt to resolve URLs from a combination of the
    // parent BaseURL and a child BaseURL, and the value does not resolve,
    // we end up returning the child BaseURL multiple times.
    // We need to determine a way to remove these duplicates in a safe way.
    // See: https://github.com/videojs/mpd-parser/pull/17#discussion_r162750527
    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),
    eventStream: flatten(periods.map(toEventStream))
  };
};
const stringToMpdXml = (manifestString) => {
  if (manifestString === "") {
    throw new Error(errors.DASH_EMPTY_MANIFEST);
  }
  const parser2 = new DOMParser();
  let xml;
  let mpd;
  try {
    xml = parser2.parseFromString(manifestString, "application/xml");
    mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
  } catch (e) {
  }
  if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
    throw new Error(errors.DASH_INVALID_XML);
  }
  return mpd;
};
const parseUTCTimingScheme = (mpd) => {
  const UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
  if (!UTCTimingNode) {
    return null;
  }
  const attributes = parseAttributes(UTCTimingNode);
  switch (attributes.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      attributes.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      attributes.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      attributes.method = "DIRECT";
      attributes.value = Date.parse(attributes.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return attributes;
};
const parse = (manifestString, options = {}) => {
  const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
  const playlists = toPlaylists(parsedManifestInfo.representationInfo);
  return toM3u8({
    dashPlaylists: playlists,
    locations: parsedManifestInfo.locations,
    contentSteering: parsedManifestInfo.contentSteeringInfo,
    sidxMapping: options.sidxMapping,
    previousManifest: options.previousManifest,
    eventStream: parsedManifestInfo.eventStream
  });
};
const parseUTCTiming = (manifestString) => parseUTCTimingScheme(stringToMpdXml(manifestString));
var MAX_UINT32 = Math.pow(2, 32);
var getUint64$1 = function(uint8) {
  var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
  var value2;
  if (dv.getBigUint64) {
    value2 = dv.getBigUint64(0);
    if (value2 < Number.MAX_SAFE_INTEGER) {
      return Number(value2);
    }
    return value2;
  }
  return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
};
var numbers = {
  getUint64: getUint64$1,
  MAX_UINT32
};
var getUint64 = numbers.getUint64;
var parseSidx = function(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
    version: data[0],
    flags: new Uint8Array(data.subarray(1, 4)),
    references: [],
    referenceId: view.getUint32(4),
    timescale: view.getUint32(8)
  }, i = 12;
  if (result.version === 0) {
    result.earliestPresentationTime = view.getUint32(i);
    result.firstOffset = view.getUint32(i + 4);
    i += 8;
  } else {
    result.earliestPresentationTime = getUint64(data.subarray(i));
    result.firstOffset = getUint64(data.subarray(i + 8));
    i += 16;
  }
  i += 2;
  var referenceCount = view.getUint16(i);
  i += 2;
  for (; referenceCount > 0; i += 12, referenceCount--) {
    result.references.push({
      referenceType: (data[i] & 128) >>> 7,
      referencedSize: view.getUint32(i) & 2147483647,
      subsegmentDuration: view.getUint32(i + 4),
      startsWithSap: !!(data[i + 8] & 128),
      sapType: (data[i + 8] & 112) >>> 4,
      sapDeltaTime: view.getUint32(i + 8) & 268435455
    });
  }
  return result;
};
var parseSidx_1 = parseSidx;
const parseSidx$1 = /* @__PURE__ */ getDefaultExportFromCjs(parseSidx_1);
var ID3 = toUint8([73, 68, 51]);
var getId3Size = function getId3Size2(bytes, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  bytes = toUint8(bytes);
  var flags = bytes[offset2 + 5];
  var returnSize = bytes[offset2 + 6] << 21 | bytes[offset2 + 7] << 14 | bytes[offset2 + 8] << 7 | bytes[offset2 + 9];
  var footerPresent = (flags & 16) >> 4;
  if (footerPresent) {
    return returnSize + 20;
  }
  return returnSize + 10;
};
var getId3Offset = function getId3Offset2(bytes, offset2) {
  if (offset2 === void 0) {
    offset2 = 0;
  }
  bytes = toUint8(bytes);
  if (bytes.length - offset2 < 10 || !bytesMatch(bytes, ID3, {
    offset: offset2
  })) {
    return offset2;
  }
  offset2 += getId3Size(bytes, offset2);
  return getId3Offset2(bytes, offset2);
};
var normalizePath$1 = function normalizePath(path2) {
  if (typeof path2 === "string") {
    return stringToBytes(path2);
  }
  if (typeof path2 === "number") {
    return path2;
  }
  return path2;
};
var normalizePaths$1 = function normalizePaths(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath$1(paths)];
  }
  return paths.map(function(p) {
    return normalizePath$1(p);
  });
};
var findBox = function findBox2(bytes, paths, complete) {
  if (complete === void 0) {
    complete = false;
  }
  paths = normalizePaths$1(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
    var type = bytes.subarray(i + 4, i + 8);
    if (size === 0) {
      break;
    }
    var end2 = i + size;
    if (end2 > bytes.length) {
      if (complete) {
        break;
      }
      end2 = bytes.length;
    }
    var data = bytes.subarray(i + 8, end2);
    if (bytesMatch(type, paths[0])) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results.push.apply(results, findBox2(data, paths.slice(1), complete));
      }
    }
    i = end2;
  }
  return results;
};
var EBML_TAGS = {
  EBML: toUint8([26, 69, 223, 163]),
  DocType: toUint8([66, 130]),
  Segment: toUint8([24, 83, 128, 103]),
  SegmentInfo: toUint8([21, 73, 169, 102]),
  Tracks: toUint8([22, 84, 174, 107]),
  Track: toUint8([174]),
  TrackNumber: toUint8([215]),
  DefaultDuration: toUint8([35, 227, 131]),
  TrackEntry: toUint8([174]),
  TrackType: toUint8([131]),
  FlagDefault: toUint8([136]),
  CodecID: toUint8([134]),
  CodecPrivate: toUint8([99, 162]),
  VideoTrack: toUint8([224]),
  AudioTrack: toUint8([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: toUint8([31, 67, 182, 117]),
  Timestamp: toUint8([231]),
  TimestampScale: toUint8([42, 215, 177]),
  BlockGroup: toUint8([160]),
  BlockDuration: toUint8([155]),
  Block: toUint8([161]),
  SimpleBlock: toUint8([163])
};
var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
var getLength = function getLength2(byte) {
  var len = 1;
  for (var i = 0; i < LENGTH_TABLE.length; i++) {
    if (byte & LENGTH_TABLE[i]) {
      break;
    }
    len++;
  }
  return len;
};
var getvint = function getvint2(bytes, offset2, removeLength, signed) {
  if (removeLength === void 0) {
    removeLength = true;
  }
  if (signed === void 0) {
    signed = false;
  }
  var length2 = getLength(bytes[offset2]);
  var valueBytes = bytes.subarray(offset2, offset2 + length2);
  if (removeLength) {
    valueBytes = Array.prototype.slice.call(bytes, offset2, offset2 + length2);
    valueBytes[0] ^= LENGTH_TABLE[length2 - 1];
  }
  return {
    length: length2,
    value: bytesToNumber(valueBytes, {
      signed
    }),
    bytes: valueBytes
  };
};
var normalizePath2 = function normalizePath3(path2) {
  if (typeof path2 === "string") {
    return path2.match(/.{1,2}/g).map(function(p) {
      return normalizePath3(p);
    });
  }
  if (typeof path2 === "number") {
    return numberToBytes(path2);
  }
  return path2;
};
var normalizePaths2 = function normalizePaths3(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath2(paths)];
  }
  return paths.map(function(p) {
    return normalizePath2(p);
  });
};
var getInfinityDataSize = function getInfinityDataSize2(id, bytes, offset2) {
  if (offset2 >= bytes.length) {
    return bytes.length;
  }
  var innerid = getvint(bytes, offset2, false);
  if (bytesMatch(id.bytes, innerid.bytes)) {
    return offset2;
  }
  var dataHeader = getvint(bytes, offset2 + innerid.length);
  return getInfinityDataSize2(id, bytes, offset2 + dataHeader.length + dataHeader.value + innerid.length);
};
var findEbml = function findEbml2(bytes, paths) {
  paths = normalizePaths2(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var id = getvint(bytes, i, false);
    var dataHeader = getvint(bytes, i + id.length);
    var dataStart = i + id.length + dataHeader.length;
    if (dataHeader.value === 127) {
      dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
      if (dataHeader.value !== bytes.length) {
        dataHeader.value -= dataStart;
      }
    }
    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
    var data = bytes.subarray(dataStart, dataEnd);
    if (bytesMatch(paths[0], id.bytes)) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results = results.concat(findEbml2(data, paths.slice(1)));
      }
    }
    var totalLength2 = id.length + dataHeader.length + data.length;
    i += totalLength2;
  }
  return results;
};
var NAL_TYPE_ONE = toUint8([0, 0, 0, 1]);
var NAL_TYPE_TWO = toUint8([0, 0, 1]);
var EMULATION_PREVENTION = toUint8([0, 0, 3]);
var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
  var positions = [];
  var i = 1;
  while (i < bytes.length - 2) {
    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
      positions.push(i + 2);
      i++;
    }
    i++;
  }
  if (positions.length === 0) {
    return bytes;
  }
  var newLength = bytes.length - positions.length;
  var newData = new Uint8Array(newLength);
  var sourceIndex = 0;
  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === positions[0]) {
      sourceIndex++;
      positions.shift();
    }
    newData[i] = bytes[sourceIndex];
  }
  return newData;
};
var findNal = function findNal2(bytes, dataType, types, nalLimit) {
  if (nalLimit === void 0) {
    nalLimit = Infinity;
  }
  bytes = toUint8(bytes);
  types = [].concat(types);
  var i = 0;
  var nalStart;
  var nalsFound = 0;
  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
    var nalOffset = void 0;
    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
      nalOffset = 4;
    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
      nalOffset = 3;
    }
    if (!nalOffset) {
      i++;
      continue;
    }
    nalsFound++;
    if (nalStart) {
      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
    }
    var nalType = void 0;
    if (dataType === "h264") {
      nalType = bytes[i + nalOffset] & 31;
    } else if (dataType === "h265") {
      nalType = bytes[i + nalOffset] >> 1 & 63;
    }
    if (types.indexOf(nalType) !== -1) {
      nalStart = i + nalOffset;
    }
    i += nalOffset + (dataType === "h264" ? 1 : 2);
  }
  return bytes.subarray(0, 0);
};
var findH264Nal = function findH264Nal2(bytes, type, nalLimit) {
  return findNal(bytes, "h264", type, nalLimit);
};
var findH265Nal = function findH265Nal2(bytes, type, nalLimit) {
  return findNal(bytes, "h265", type, nalLimit);
};
var CONSTANTS = {
  // "webm" string literal in hex
  "webm": toUint8([119, 101, 98, 109]),
  // "matroska" string literal in hex
  "matroska": toUint8([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  "flac": toUint8([102, 76, 97, 67]),
  // "OggS" string literal in hex
  "ogg": toUint8([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  "ac3": toUint8([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  "riff": toUint8([82, 73, 70, 70]),
  // "AVI" string literal in hex
  "avi": toUint8([65, 86, 73]),
  // "WAVE" string literal in hex
  "wav": toUint8([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": toUint8([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  "mp4": toUint8([102, 116, 121, 112]),
  // "styp" string literal in hex
  "fmp4": toUint8([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  "mov": toUint8([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  "moov": toUint8([109, 111, 111, 118]),
  // moof string literal in hex
  "moof": toUint8([109, 111, 111, 102])
};
var _isLikely = {
  aac: function aac(bytes) {
    var offset2 = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 16], {
      offset: offset2,
      mask: [255, 22]
    });
  },
  mp3: function mp3(bytes) {
    var offset2 = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 2], {
      offset: offset2,
      mask: [255, 6]
    });
  },
  webm: function webm(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.webm);
  },
  mkv: function mkv(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.matroska);
  },
  mp4: function mp4(bytes) {
    if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
      return false;
    }
    if (bytesMatch(bytes, CONSTANTS.mp4, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.fmp4, {
      offset: 4
    })) {
      return true;
    }
    if (bytesMatch(bytes, CONSTANTS.moof, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.moov, {
      offset: 4
    })) {
      return true;
    }
  },
  mov: function mov(bytes) {
    return bytesMatch(bytes, CONSTANTS.mov, {
      offset: 4
    });
  },
  "3gp": function gp(bytes) {
    return bytesMatch(bytes, CONSTANTS["3gp"], {
      offset: 4
    });
  },
  ac3: function ac3(bytes) {
    var offset2 = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.ac3, {
      offset: offset2
    });
  },
  ts: function ts(bytes) {
    if (bytes.length < 189 && bytes.length >= 1) {
      return bytes[0] === 71;
    }
    var i = 0;
    while (i + 188 < bytes.length && i < 188) {
      if (bytes[i] === 71 && bytes[i + 188] === 71) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  flac: function flac(bytes) {
    var offset2 = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.flac, {
      offset: offset2
    });
  },
  ogg: function ogg(bytes) {
    return bytesMatch(bytes, CONSTANTS.ogg);
  },
  avi: function avi(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
      offset: 8
    });
  },
  wav: function wav(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
      offset: 8
    });
  },
  "h264": function h264(bytes) {
    return findH264Nal(bytes, 7, 3).length;
  },
  "h265": function h265(bytes) {
    return findH265Nal(bytes, [32, 33], 3).length;
  }
};
var isLikelyTypes = Object.keys(_isLikely).filter(function(t) {
  return t !== "ts" && t !== "h264" && t !== "h265";
}).concat(["ts", "h264", "h265"]);
isLikelyTypes.forEach(function(type) {
  var isLikelyFn = _isLikely[type];
  _isLikely[type] = function(bytes) {
    return isLikelyFn(toUint8(bytes));
  };
});
var isLikely = _isLikely;
var detectContainerForBytes = function detectContainerForBytes2(bytes) {
  bytes = toUint8(bytes);
  for (var i = 0; i < isLikelyTypes.length; i++) {
    var type = isLikelyTypes[i];
    if (isLikely[type](bytes)) {
      return type;
    }
  }
  return "";
};
var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
  return findBox(bytes, ["moof"]).length > 0;
};
var ONE_SECOND_IN_TS = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
secondsToVideoTs = function(seconds) {
  return seconds * ONE_SECOND_IN_TS;
};
secondsToAudioTs = function(seconds, sampleRate) {
  return seconds * sampleRate;
};
videoTsToSeconds = function(timestamp) {
  return timestamp / ONE_SECOND_IN_TS;
};
audioTsToSeconds = function(timestamp, sampleRate) {
  return timestamp / sampleRate;
};
audioTsToVideoTs = function(timestamp, sampleRate) {
  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
};
videoTsToAudioTs = function(timestamp, sampleRate) {
  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
};
metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
  return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
};
var clock = {
  ONE_SECOND_IN_TS,
  secondsToVideoTs,
  secondsToAudioTs,
  videoTsToSeconds,
  audioTsToSeconds,
  audioTsToVideoTs,
  videoTsToAudioTs,
  metadataTsToSeconds
};
/**
 * @license
 * Video.js 8.17.3 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var version$6 = "8.17.3";
const hooks_ = {};
const hooks = function(type, fn2) {
  hooks_[type] = hooks_[type] || [];
  if (fn2) {
    hooks_[type] = hooks_[type].concat(fn2);
  }
  return hooks_[type];
};
const hook = function(type, fn2) {
  hooks(type, fn2);
};
const removeHook = function(type, fn2) {
  const index = hooks(type).indexOf(fn2);
  if (index <= -1) {
    return false;
  }
  hooks_[type] = hooks_[type].slice();
  hooks_[type].splice(index, 1);
  return true;
};
const hookOnce = function(type, fn2) {
  hooks(type, [].concat(fn2).map((original) => {
    const wrapper = (...args) => {
      removeHook(type, wrapper);
      return original(...args);
    };
    return wrapper;
  }));
};
const FullscreenApi = {
  prefixed: true
};
const apiMap = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]
];
const specApi = apiMap[0];
let browserApi;
for (let i = 0; i < apiMap.length; i++) {
  if (apiMap[i][1] in document$1$1) {
    browserApi = apiMap[i];
    break;
  }
}
if (browserApi) {
  for (let i = 0; i < browserApi.length; i++) {
    FullscreenApi[specApi[i]] = browserApi[i];
  }
  FullscreenApi.prefixed = browserApi[0] !== specApi[0];
}
let history = [];
const LogByTypeFactory = (name, log2, styles2) => (type, level, args) => {
  const lvl = log2.levels[level];
  const lvlRegExp = new RegExp(`^(${lvl})$`);
  let resultName = name;
  if (type !== "log") {
    args.unshift(type.toUpperCase() + ":");
  }
  if (styles2) {
    resultName = `%c${name}`;
    args.unshift(styles2);
  }
  args.unshift(resultName + ":");
  if (history) {
    history.push([].concat(args));
    const splice = history.length - 1e3;
    history.splice(0, splice > 0 ? splice : 0);
  }
  if (!window$1$1.console) {
    return;
  }
  let fn2 = window$1$1.console[type];
  if (!fn2 && type === "debug") {
    fn2 = window$1$1.console.info || window$1$1.console.log;
  }
  if (!fn2 || !lvl || !lvlRegExp.test(type)) {
    return;
  }
  fn2[Array.isArray(args) ? "apply" : "call"](window$1$1.console, args);
};
function createLogger$1(name, delimiter2 = ":", styles2 = "") {
  let level = "info";
  let logByType;
  function log2(...args) {
    logByType("log", level, args);
  }
  logByType = LogByTypeFactory(name, log2, styles2);
  log2.createLogger = (subName, subDelimiter, subStyles) => {
    const resultDelimiter = subDelimiter !== void 0 ? subDelimiter : delimiter2;
    const resultStyles = subStyles !== void 0 ? subStyles : styles2;
    const resultName = `${name} ${resultDelimiter} ${subName}`;
    return createLogger$1(resultName, resultDelimiter, resultStyles);
  };
  log2.createNewLogger = (newName, newDelimiter, newStyles) => {
    return createLogger$1(newName, newDelimiter, newStyles);
  };
  log2.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: level
  };
  log2.level = (lvl) => {
    if (typeof lvl === "string") {
      if (!log2.levels.hasOwnProperty(lvl)) {
        throw new Error(`"${lvl}" in not a valid log level`);
      }
      level = lvl;
    }
    return level;
  };
  log2.history = () => history ? [].concat(history) : [];
  log2.history.filter = (fname) => {
    return (history || []).filter((historyItem) => {
      return new RegExp(`.*${fname}.*`).test(historyItem[0]);
    });
  };
  log2.history.clear = () => {
    if (history) {
      history.length = 0;
    }
  };
  log2.history.disable = () => {
    if (history !== null) {
      history.length = 0;
      history = null;
    }
  };
  log2.history.enable = () => {
    if (history === null) {
      history = [];
    }
  };
  log2.error = (...args) => logByType("error", level, args);
  log2.warn = (...args) => logByType("warn", level, args);
  log2.debug = (...args) => logByType("debug", level, args);
  return log2;
}
const log$1 = createLogger$1("VIDEOJS");
const createLogger = log$1.createLogger;
const toString = Object.prototype.toString;
const keys = function(object) {
  return isObject$4(object) ? Object.keys(object) : [];
};
function each(object, fn2) {
  keys(object).forEach((key) => fn2(object[key], key));
}
function reduce(object, fn2, initial = 0) {
  return keys(object).reduce((accum, key) => fn2(accum, object[key], key), initial);
}
function isObject$4(value2) {
  return !!value2 && typeof value2 === "object";
}
function isPlain(value2) {
  return isObject$4(value2) && toString.call(value2) === "[object Object]" && value2.constructor === Object;
}
function merge$1(...sources) {
  const result = {};
  sources.forEach((source) => {
    if (!source) {
      return;
    }
    each(source, (value2, key) => {
      if (!isPlain(value2)) {
        result[key] = value2;
        return;
      }
      if (!isPlain(result[key])) {
        result[key] = {};
      }
      result[key] = merge$1(result[key], value2);
    });
  });
  return result;
}
function values(source = {}) {
  const result = [];
  for (const key in source) {
    if (source.hasOwnProperty(key)) {
      const value2 = source[key];
      result.push(value2);
    }
  }
  return result;
}
function defineLazyProperty(obj, key, getValue, setter = true) {
  const set2 = (value2) => Object.defineProperty(obj, key, {
    value: value2,
    enumerable: true,
    writable: true
  });
  const options = {
    configurable: true,
    enumerable: true,
    get() {
      const value2 = getValue();
      set2(value2);
      return value2;
    }
  };
  if (setter) {
    options.set = set2;
  }
  return Object.defineProperty(obj, key, options);
}
var Obj = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  each,
  reduce,
  isObject: isObject$4,
  isPlain,
  merge: merge$1,
  values,
  defineLazyProperty
});
let IS_IPOD = false;
let IOS_VERSION = null;
let IS_ANDROID = false;
let ANDROID_VERSION;
let IS_FIREFOX = false;
let IS_EDGE = false;
let IS_CHROMIUM = false;
let IS_CHROME = false;
let CHROMIUM_VERSION = null;
let CHROME_VERSION = null;
const IS_CHROMECAST_RECEIVER = Boolean(window$1$1.cast && window$1$1.cast.framework && window$1$1.cast.framework.CastReceiverContext);
let IE_VERSION = null;
let IS_SAFARI = false;
let IS_WINDOWS = false;
let IS_IPAD = false;
let IS_IPHONE = false;
let IS_TIZEN = false;
let IS_WEBOS = false;
let IS_SMART_TV = false;
const TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in window$1$1 || window$1$1.navigator.maxTouchPoints || window$1$1.DocumentTouch && window$1$1.document instanceof window$1$1.DocumentTouch));
const UAD = window$1$1.navigator && window$1$1.navigator.userAgentData;
if (UAD && UAD.platform && UAD.brands) {
  IS_ANDROID = UAD.platform === "Android";
  IS_EDGE = Boolean(UAD.brands.find((b) => b.brand === "Microsoft Edge"));
  IS_CHROMIUM = Boolean(UAD.brands.find((b) => b.brand === "Chromium"));
  IS_CHROME = !IS_EDGE && IS_CHROMIUM;
  CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find((b) => b.brand === "Chromium") || {}).version || null;
  IS_WINDOWS = UAD.platform === "Windows";
}
if (!IS_CHROMIUM) {
  const USER_AGENT = window$1$1.navigator && window$1$1.navigator.userAgent || "";
  IS_IPOD = /iPod/i.test(USER_AGENT);
  IOS_VERSION = function() {
    const match = USER_AGENT.match(/OS (\d+)_/i);
    if (match && match[1]) {
      return match[1];
    }
    return null;
  }();
  IS_ANDROID = /Android/i.test(USER_AGENT);
  ANDROID_VERSION = function() {
    const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
    if (!match) {
      return null;
    }
    const major = match[1] && parseFloat(match[1]);
    const minor = match[2] && parseFloat(match[2]);
    if (major && minor) {
      return parseFloat(match[1] + "." + match[2]);
    } else if (major) {
      return major;
    }
    return null;
  }();
  IS_FIREFOX = /Firefox/i.test(USER_AGENT);
  IS_EDGE = /Edg/i.test(USER_AGENT);
  IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);
  IS_CHROME = !IS_EDGE && IS_CHROMIUM;
  CHROMIUM_VERSION = CHROME_VERSION = function() {
    const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
    if (match && match[2]) {
      return parseFloat(match[2]);
    }
    return null;
  }();
  IE_VERSION = function() {
    const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
    let version2 = result && parseFloat(result[1]);
    if (!version2 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
      version2 = 11;
    }
    return version2;
  }();
  IS_TIZEN = /Tizen/i.test(USER_AGENT);
  IS_WEBOS = /Web0S/i.test(USER_AGENT);
  IS_SMART_TV = IS_TIZEN || IS_WEBOS;
  IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE && !IS_SMART_TV;
  IS_WINDOWS = /Windows/i.test(USER_AGENT);
  IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
  IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
}
const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
var browser$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get IS_IPOD() {
    return IS_IPOD;
  },
  get IOS_VERSION() {
    return IOS_VERSION;
  },
  get IS_ANDROID() {
    return IS_ANDROID;
  },
  get ANDROID_VERSION() {
    return ANDROID_VERSION;
  },
  get IS_FIREFOX() {
    return IS_FIREFOX;
  },
  get IS_EDGE() {
    return IS_EDGE;
  },
  get IS_CHROMIUM() {
    return IS_CHROMIUM;
  },
  get IS_CHROME() {
    return IS_CHROME;
  },
  get CHROMIUM_VERSION() {
    return CHROMIUM_VERSION;
  },
  get CHROME_VERSION() {
    return CHROME_VERSION;
  },
  IS_CHROMECAST_RECEIVER,
  get IE_VERSION() {
    return IE_VERSION;
  },
  get IS_SAFARI() {
    return IS_SAFARI;
  },
  get IS_WINDOWS() {
    return IS_WINDOWS;
  },
  get IS_IPAD() {
    return IS_IPAD;
  },
  get IS_IPHONE() {
    return IS_IPHONE;
  },
  get IS_TIZEN() {
    return IS_TIZEN;
  },
  get IS_WEBOS() {
    return IS_WEBOS;
  },
  get IS_SMART_TV() {
    return IS_SMART_TV;
  },
  TOUCH_ENABLED,
  IS_IOS,
  IS_ANY_SAFARI
});
function isNonBlankString(str) {
  return typeof str === "string" && Boolean(str.trim());
}
function throwIfWhitespace(str) {
  if (str.indexOf(" ") >= 0) {
    throw new Error("class has illegal whitespace characters");
  }
}
function isReal() {
  return document$1$1 === window$1$1.document;
}
function isEl(value2) {
  return isObject$4(value2) && value2.nodeType === 1;
}
function isInFrame() {
  try {
    return window$1$1.parent !== window$1$1.self;
  } catch (x) {
    return true;
  }
}
function createQuerier(method) {
  return function(selector, context) {
    if (!isNonBlankString(selector)) {
      return document$1$1[method](null);
    }
    if (isNonBlankString(context)) {
      context = document$1$1.querySelector(context);
    }
    const ctx = isEl(context) ? context : document$1$1;
    return ctx[method] && ctx[method](selector);
  };
}
function createEl(tagName = "div", properties = {}, attributes = {}, content) {
  const el = document$1$1.createElement(tagName);
  Object.getOwnPropertyNames(properties).forEach(function(propName) {
    const val = properties[propName];
    if (propName === "textContent") {
      textContent(el, val);
    } else if (el[propName] !== val || propName === "tabIndex") {
      el[propName] = val;
    }
  });
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });
  if (content) {
    appendContent(el, content);
  }
  return el;
}
function textContent(el, text2) {
  if (typeof el.textContent === "undefined") {
    el.innerText = text2;
  } else {
    el.textContent = text2;
  }
  return el;
}
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  return element.classList.contains(classToCheck);
}
function addClass(element, ...classesToAdd) {
  element.classList.add(...classesToAdd.reduce((prev2, current) => prev2.concat(current.split(/\s+/)), []));
  return element;
}
function removeClass(element, ...classesToRemove) {
  if (!element) {
    log$1.warn("removeClass was called with an element that doesn't exist");
    return null;
  }
  element.classList.remove(...classesToRemove.reduce((prev2, current) => prev2.concat(current.split(/\s+/)), []));
  return element;
}
function toggleClass(element, classToToggle, predicate) {
  if (typeof predicate === "function") {
    predicate = predicate(element, classToToggle);
  }
  if (typeof predicate !== "boolean") {
    predicate = void 0;
  }
  classToToggle.split(/\s+/).forEach((className) => element.classList.toggle(className, predicate));
  return element;
}
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    const attrValue = attributes[attrName];
    if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? "" : attrValue);
    }
  });
}
function getAttributes(tag) {
  const obj = {};
  const knownBooleans = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"];
  if (tag && tag.attributes && tag.attributes.length > 0) {
    const attrs = tag.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attrName = attrs[i].name;
      let attrVal = attrs[i].value;
      if (knownBooleans.includes(attrName)) {
        attrVal = attrVal !== null ? true : false;
      }
      obj[attrName] = attrVal;
    }
  }
  return obj;
}
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}
function setAttribute(el, attribute, value2) {
  el.setAttribute(attribute, value2);
}
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}
function blockTextSelection() {
  document$1$1.body.focus();
  document$1$1.onselectstart = function() {
    return false;
  };
}
function unblockTextSelection() {
  document$1$1.onselectstart = function() {
    return true;
  };
}
function getBoundingClientRect$1(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    const rect = el.getBoundingClientRect();
    const result = {};
    ["bottom", "height", "left", "right", "top", "width"].forEach((k) => {
      if (rect[k] !== void 0) {
        result[k] = rect[k];
      }
    });
    if (!result.height) {
      result.height = parseFloat(computedStyle(el, "height"));
    }
    if (!result.width) {
      result.width = parseFloat(computedStyle(el, "width"));
    }
    return result;
  }
}
function findPosition(el) {
  if (!el || el && !el.offsetParent) {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
  const width = el.offsetWidth;
  const height = el.offsetHeight;
  let left2 = 0;
  let top2 = 0;
  while (el.offsetParent && el !== document$1$1[FullscreenApi.fullscreenElement]) {
    left2 += el.offsetLeft;
    top2 += el.offsetTop;
    el = el.offsetParent;
  }
  return {
    left: left2,
    top: top2,
    width,
    height
  };
}
function getPointerPosition(el, event2) {
  const translated = {
    x: 0,
    y: 0
  };
  if (IS_IOS) {
    let item = el;
    while (item && item.nodeName.toLowerCase() !== "html") {
      const transform2 = computedStyle(item, "transform");
      if (/^matrix/.test(transform2)) {
        const values2 = transform2.slice(7, -1).split(/,\s/).map(Number);
        translated.x += values2[4];
        translated.y += values2[5];
      } else if (/^matrix3d/.test(transform2)) {
        const values2 = transform2.slice(9, -1).split(/,\s/).map(Number);
        translated.x += values2[12];
        translated.y += values2[13];
      }
      if (item.assignedSlot && item.assignedSlot.parentElement && window$1$1.WebKitCSSMatrix) {
        const transformValue = window$1$1.getComputedStyle(item.assignedSlot.parentElement).transform;
        const matrix = new window$1$1.WebKitCSSMatrix(transformValue);
        translated.x += matrix.m41;
        translated.y += matrix.m42;
      }
      item = item.parentNode || item.host;
    }
  }
  const position2 = {};
  const boxTarget = findPosition(event2.target);
  const box = findPosition(el);
  const boxW = box.width;
  const boxH = box.height;
  let offsetY = event2.offsetY - (box.top - boxTarget.top);
  let offsetX = event2.offsetX - (box.left - boxTarget.left);
  if (event2.changedTouches) {
    offsetX = event2.changedTouches[0].pageX - box.left;
    offsetY = event2.changedTouches[0].pageY + box.top;
    if (IS_IOS) {
      offsetX -= translated.x;
      offsetY -= translated.y;
    }
  }
  position2.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
  position2.x = Math.max(0, Math.min(1, offsetX / boxW));
  return position2;
}
function isTextNode(value2) {
  return isObject$4(value2) && value2.nodeType === 3;
}
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}
function normalizeContent(content) {
  if (typeof content === "function") {
    content = content();
  }
  return (Array.isArray(content) ? content : [content]).map((value2) => {
    if (typeof value2 === "function") {
      value2 = value2();
    }
    if (isEl(value2) || isTextNode(value2)) {
      return value2;
    }
    if (typeof value2 === "string" && /\S/.test(value2)) {
      return document$1$1.createTextNode(value2);
    }
  }).filter((value2) => value2);
}
function appendContent(el, content) {
  normalizeContent(content).forEach((node) => el.appendChild(node));
  return el;
}
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}
function isSingleLeftClick(event2) {
  if (event2.button === void 0 && event2.buttons === void 0) {
    return true;
  }
  if (event2.button === 0 && event2.buttons === void 0) {
    return true;
  }
  if (event2.type === "mouseup" && event2.button === 0 && event2.buttons === 0) {
    return true;
  }
  if (event2.type === "mousedown" && event2.button === 0 && event2.buttons === 0) {
    return true;
  }
  if (event2.button !== 0 || event2.buttons !== 1) {
    return false;
  }
  return true;
}
const $ = createQuerier("querySelector");
const $$ = createQuerier("querySelectorAll");
function computedStyle(el, prop) {
  if (!el || !prop) {
    return "";
  }
  if (typeof window$1$1.getComputedStyle === "function") {
    let computedStyleValue;
    try {
      computedStyleValue = window$1$1.getComputedStyle(el);
    } catch (e) {
      return "";
    }
    return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
  }
  return "";
}
function copyStyleSheetsToWindow(win2) {
  [...document$1$1.styleSheets].forEach((styleSheet) => {
    try {
      const cssRules = [...styleSheet.cssRules].map((rule) => rule.cssText).join("");
      const style2 = document$1$1.createElement("style");
      style2.textContent = cssRules;
      win2.document.head.appendChild(style2);
    } catch (e) {
      const link = document$1$1.createElement("link");
      link.rel = "stylesheet";
      link.type = styleSheet.type;
      link.media = styleSheet.media.mediaText;
      link.href = styleSheet.href;
      win2.document.head.appendChild(link);
    }
  });
}
var Dom = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isReal,
  isEl,
  isInFrame,
  createEl,
  textContent,
  prependTo,
  hasClass,
  addClass,
  removeClass,
  toggleClass,
  setAttributes,
  getAttributes,
  getAttribute,
  setAttribute,
  removeAttribute,
  blockTextSelection,
  unblockTextSelection,
  getBoundingClientRect: getBoundingClientRect$1,
  findPosition,
  getPointerPosition,
  isTextNode,
  emptyEl,
  normalizeContent,
  appendContent,
  insertContent,
  isSingleLeftClick,
  $,
  $$,
  computedStyle,
  copyStyleSheetsToWindow
});
let _windowLoaded = false;
let videojs$1;
const autoSetup = function() {
  if (videojs$1.options.autoSetup === false) {
    return;
  }
  const vids = Array.prototype.slice.call(document$1$1.getElementsByTagName("video"));
  const audios = Array.prototype.slice.call(document$1$1.getElementsByTagName("audio"));
  const divs = Array.prototype.slice.call(document$1$1.getElementsByTagName("video-js"));
  const mediaEls = vids.concat(audios, divs);
  if (mediaEls && mediaEls.length > 0) {
    for (let i = 0, e = mediaEls.length; i < e; i++) {
      const mediaEl = mediaEls[i];
      if (mediaEl && mediaEl.getAttribute) {
        if (mediaEl.player === void 0) {
          const options = mediaEl.getAttribute("data-setup");
          if (options !== null) {
            videojs$1(mediaEl);
          }
        }
      } else {
        autoSetupTimeout(1);
        break;
      }
    }
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};
function autoSetupTimeout(wait, vjs) {
  if (!isReal()) {
    return;
  }
  if (vjs) {
    videojs$1 = vjs;
  }
  window$1$1.setTimeout(autoSetup, wait);
}
function setWindowLoaded() {
  _windowLoaded = true;
  window$1$1.removeEventListener("load", setWindowLoaded);
}
if (isReal()) {
  if (document$1$1.readyState === "complete") {
    setWindowLoaded();
  } else {
    window$1$1.addEventListener("load", setWindowLoaded);
  }
}
const createStyleElement = function(className) {
  const style2 = document$1$1.createElement("style");
  style2.className = className;
  return style2;
};
const setTextContent = function(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};
var DomData = /* @__PURE__ */ new WeakMap();
const _initialGuid = 3;
let _guid = _initialGuid;
function newGUID() {
  return _guid++;
}
function _cleanUpEvents(elem, type) {
  if (!DomData.has(elem)) {
    return;
  }
  const data = DomData.get(elem);
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + type, data.dispatcher);
    }
  }
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }
  if (Object.getOwnPropertyNames(data).length === 0) {
    DomData.delete(elem);
  }
}
function _handleMultipleEvents(fn2, elem, types, callback) {
  types.forEach(function(type) {
    fn2(elem, type, callback);
  });
}
function fixEvent(event2) {
  if (event2.fixed_) {
    return event2;
  }
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  if (!event2 || !event2.isPropagationStopped || !event2.isImmediatePropagationStopped) {
    const old = event2 || window$1$1.event;
    event2 = {};
    const deprecatedProps = ["layerX", "layerY", "keyLocation", "path", "webkitMovementX", "webkitMovementY", "mozPressure", "mozInputSource"];
    for (const key in old) {
      if (!deprecatedProps.includes(key)) {
        if (!(key === "returnValue" && old.preventDefault)) {
          event2[key] = old[key];
        }
      }
    }
    if (!event2.target) {
      event2.target = event2.srcElement || document$1$1;
    }
    if (!event2.relatedTarget) {
      event2.relatedTarget = event2.fromElement === event2.target ? event2.toElement : event2.fromElement;
    }
    event2.preventDefault = function() {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event2.returnValue = false;
      old.returnValue = false;
      event2.defaultPrevented = true;
    };
    event2.defaultPrevented = false;
    event2.stopPropagation = function() {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event2.cancelBubble = true;
      old.cancelBubble = true;
      event2.isPropagationStopped = returnTrue;
    };
    event2.isPropagationStopped = returnFalse;
    event2.stopImmediatePropagation = function() {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event2.isImmediatePropagationStopped = returnTrue;
      event2.stopPropagation();
    };
    event2.isImmediatePropagationStopped = returnFalse;
    if (event2.clientX !== null && event2.clientX !== void 0) {
      const doc = document$1$1.documentElement;
      const body = document$1$1.body;
      event2.pageX = event2.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event2.pageY = event2.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }
    event2.which = event2.charCode || event2.keyCode;
    if (event2.button !== null && event2.button !== void 0) {
      event2.button = event2.button & 1 ? 0 : event2.button & 4 ? 1 : event2.button & 2 ? 2 : 0;
    }
  }
  event2.fixed_ = true;
  return event2;
}
let _supportsPassive;
const supportsPassive = function() {
  if (typeof _supportsPassive !== "boolean") {
    _supportsPassive = false;
    try {
      const opts = Object.defineProperty({}, "passive", {
        get() {
          _supportsPassive = true;
        }
      });
      window$1$1.addEventListener("test", null, opts);
      window$1$1.removeEventListener("test", null, opts);
    } catch (e) {
    }
  }
  return _supportsPassive;
};
const passiveEvents = ["touchstart", "touchmove"];
function on(elem, type, fn2) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn2);
  }
  if (!DomData.has(elem)) {
    DomData.set(elem, {});
  }
  const data = DomData.get(elem);
  if (!data.handlers) {
    data.handlers = {};
  }
  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }
  if (!fn2.guid) {
    fn2.guid = newGUID();
  }
  data.handlers[type].push(fn2);
  if (!data.dispatcher) {
    data.disabled = false;
    data.dispatcher = function(event2, hash2) {
      if (data.disabled) {
        return;
      }
      event2 = fixEvent(event2);
      const handlers = data.handlers[event2.type];
      if (handlers) {
        const handlersCopy = handlers.slice(0);
        for (let m = 0, n = handlersCopy.length; m < n; m++) {
          if (event2.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event2, hash2);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }
  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      let options = false;
      if (supportsPassive() && passiveEvents.indexOf(type) > -1) {
        options = {
          passive: true
        };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + type, data.dispatcher);
    }
  }
}
function off(elem, type, fn2) {
  if (!DomData.has(elem)) {
    return;
  }
  const data = DomData.get(elem);
  if (!data.handlers) {
    return;
  }
  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn2);
  }
  const removeType = function(el, t) {
    data.handlers[t] = [];
    _cleanUpEvents(el, t);
  };
  if (type === void 0) {
    for (const t in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {
        removeType(elem, t);
      }
    }
    return;
  }
  const handlers = data.handlers[type];
  if (!handlers) {
    return;
  }
  if (!fn2) {
    removeType(elem, type);
    return;
  }
  if (fn2.guid) {
    for (let n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn2.guid) {
        handlers.splice(n--, 1);
      }
    }
  }
  _cleanUpEvents(elem, type);
}
function trigger(elem, event2, hash2) {
  const elemData = DomData.has(elem) ? DomData.get(elem) : {};
  const parent = elem.parentNode || elem.ownerDocument;
  if (typeof event2 === "string") {
    event2 = {
      type: event2,
      target: elem
    };
  } else if (!event2.target) {
    event2.target = elem;
  }
  event2 = fixEvent(event2);
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event2, hash2);
  }
  if (parent && !event2.isPropagationStopped() && event2.bubbles === true) {
    trigger.call(null, parent, event2, hash2);
  } else if (!parent && !event2.defaultPrevented && event2.target && event2.target[event2.type]) {
    if (!DomData.has(event2.target)) {
      DomData.set(event2.target, {});
    }
    const targetData = DomData.get(event2.target);
    if (event2.target[event2.type]) {
      targetData.disabled = true;
      if (typeof event2.target[event2.type] === "function") {
        event2.target[event2.type]();
      }
      targetData.disabled = false;
    }
  }
  return !event2.defaultPrevented;
}
function one(elem, type, fn2) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn2);
  }
  const func = function() {
    off(elem, type, func);
    fn2.apply(this, arguments);
  };
  func.guid = fn2.guid = fn2.guid || newGUID();
  on(elem, type, func);
}
function any(elem, type, fn2) {
  const func = function() {
    off(elem, type, func);
    fn2.apply(this, arguments);
  };
  func.guid = fn2.guid = fn2.guid || newGUID();
  on(elem, type, func);
}
var Events = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixEvent,
  on,
  off,
  trigger,
  one,
  any
});
const UPDATE_REFRESH_INTERVAL = 30;
const bind_ = function(context, fn2, uid) {
  if (!fn2.guid) {
    fn2.guid = newGUID();
  }
  const bound = fn2.bind(context);
  bound.guid = uid ? uid + "_" + fn2.guid : fn2.guid;
  return bound;
};
const throttle = function(fn2, wait) {
  let last = window$1$1.performance.now();
  const throttled = function(...args) {
    const now2 = window$1$1.performance.now();
    if (now2 - last >= wait) {
      fn2(...args);
      last = now2;
    }
  };
  return throttled;
};
const debounce$4 = function(func, wait, immediate, context = window$1$1) {
  let timeout;
  const cancel = () => {
    context.clearTimeout(timeout);
    timeout = null;
  };
  const debounced = function() {
    const self2 = this;
    const args = arguments;
    let later = function() {
      timeout = null;
      later = null;
      if (!immediate) {
        func.apply(self2, args);
      }
    };
    if (!timeout && immediate) {
      func.apply(self2, args);
    }
    context.clearTimeout(timeout);
    timeout = context.setTimeout(later, wait);
  };
  debounced.cancel = cancel;
  return debounced;
};
var Fn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  UPDATE_REFRESH_INTERVAL,
  bind_,
  throttle,
  debounce: debounce$4
});
let EVENT_MAP;
class EventTarget$2 {
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  on(type, fn2) {
    const ael = this.addEventListener;
    this.addEventListener = () => {
    };
    on(this, type, fn2);
    this.addEventListener = ael;
  }
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to remove.
   */
  off(type, fn2) {
    off(this, type, fn2);
  }
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  one(type, fn2) {
    const ael = this.addEventListener;
    this.addEventListener = () => {
    };
    one(this, type, fn2);
    this.addEventListener = ael;
  }
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  any(type, fn2) {
    const ael = this.addEventListener;
    this.addEventListener = () => {
    };
    any(this, type, fn2);
    this.addEventListener = ael;
  }
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|EventTarget~Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   */
  trigger(event2) {
    const type = event2.type || event2;
    if (typeof event2 === "string") {
      event2 = {
        type
      };
    }
    event2 = fixEvent(event2);
    if (this.allowedEvents_[type] && this["on" + type]) {
      this["on" + type](event2);
    }
    trigger(this, event2);
  }
  queueTrigger(event2) {
    if (!EVENT_MAP) {
      EVENT_MAP = /* @__PURE__ */ new Map();
    }
    const type = event2.type || event2;
    let map2 = EVENT_MAP.get(this);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      EVENT_MAP.set(this, map2);
    }
    const oldTimeout = map2.get(type);
    map2.delete(type);
    window$1$1.clearTimeout(oldTimeout);
    const timeout = window$1$1.setTimeout(() => {
      map2.delete(type);
      if (map2.size === 0) {
        map2 = null;
        EVENT_MAP.delete(this);
      }
      this.trigger(event2);
    }, 0);
    map2.set(type, timeout);
  }
}
EventTarget$2.prototype.allowedEvents_ = {};
EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
const objName = (obj) => {
  if (typeof obj.name === "function") {
    return obj.name();
  }
  if (typeof obj.name === "string") {
    return obj.name;
  }
  if (obj.name_) {
    return obj.name_;
  }
  if (obj.constructor && obj.constructor.name) {
    return obj.constructor.name;
  }
  return typeof obj;
};
const isEvented = (object) => object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every((k) => typeof object[k] === "function");
const addEventedCallback = (target, callback) => {
  if (isEvented(target)) {
    callback();
  } else {
    if (!target.eventedCallbacks) {
      target.eventedCallbacks = [];
    }
    target.eventedCallbacks.push(callback);
  }
};
const isValidEventType = (type) => (
  // The regex here verifies that the `type` contains at least one non-
  // whitespace character.
  typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length
);
const validateTarget = (target, obj, fnName) => {
  if (!target || !target.nodeName && !isEvented(target)) {
    throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);
  }
};
const validateEventType = (type, obj, fnName) => {
  if (!isValidEventType(type)) {
    throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);
  }
};
const validateListener = (listener, obj, fnName) => {
  if (typeof listener !== "function") {
    throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);
  }
};
const normalizeListenArgs = (self2, args, fnName) => {
  const isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
  let target;
  let type;
  let listener;
  if (isTargetingSelf) {
    target = self2.eventBusEl_;
    if (args.length >= 3) {
      args.shift();
    }
    [type, listener] = args;
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }
  validateTarget(target, self2, fnName);
  validateEventType(type, self2, fnName);
  validateListener(listener, self2, fnName);
  listener = bind_(self2, listener);
  return {
    isTargetingSelf,
    target,
    type,
    listener
  };
};
const listen = (target, method, type, listener) => {
  validateTarget(target, target, method);
  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};
const EventedMixin = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on(...args) {
    const {
      isTargetingSelf,
      target,
      type,
      listener
    } = normalizeListenArgs(this, args, "on");
    listen(target, "on", type, listener);
    if (!isTargetingSelf) {
      const removeListenerOnDispose = () => this.off(target, type, listener);
      removeListenerOnDispose.guid = listener.guid;
      const removeRemoverOnTargetDispose = () => this.off("dispose", removeListenerOnDispose);
      removeRemoverOnTargetDispose.guid = listener.guid;
      listen(this, "on", "dispose", removeListenerOnDispose);
      listen(target, "on", "dispose", removeRemoverOnTargetDispose);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one(...args) {
    const {
      isTargetingSelf,
      target,
      type,
      listener
    } = normalizeListenArgs(this, args, "one");
    if (isTargetingSelf) {
      listen(target, "one", type, listener);
    } else {
      const wrapper = (...largs) => {
        this.off(target, type, wrapper);
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "one", type, wrapper);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any(...args) {
    const {
      isTargetingSelf,
      target,
      type,
      listener
    } = normalizeListenArgs(this, args, "any");
    if (isTargetingSelf) {
      listen(target, "any", type, listener);
    } else {
      const wrapper = (...largs) => {
        this.off(target, type, wrapper);
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "any", type, wrapper);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off(targetOrType, typeOrListener, listener) {
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);
    } else {
      const target = targetOrType;
      const type = typeOrListener;
      validateTarget(target, this, "off");
      validateEventType(type, this, "off");
      validateListener(listener, this, "off");
      listener = bind_(this, listener);
      this.off("dispose", listener);
      if (target.nodeName) {
        off(target, type, listener);
        off(target, "dispose", listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off("dispose", listener);
      }
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger(event2, hash2) {
    validateTarget(this.eventBusEl_, this, "trigger");
    const type = event2 && typeof event2 !== "string" ? event2.type : event2;
    if (!isValidEventType(type)) {
      throw new Error(`Invalid event type for ${objName(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
    }
    return trigger(this.eventBusEl_, event2, hash2);
  }
};
function evented(target, options = {}) {
  const {
    eventBusKey
  } = options;
  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error(`The eventBusKey "${eventBusKey}" does not refer to an element.`);
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl("span", {
      className: "vjs-event-bus"
    });
  }
  Object.assign(target, EventedMixin);
  if (target.eventedCallbacks) {
    target.eventedCallbacks.forEach((callback) => {
      callback();
    });
  }
  target.on("dispose", () => {
    target.off();
    [target, target.el_, target.eventBusEl_].forEach(function(val) {
      if (val && DomData.has(val)) {
        DomData.delete(val);
      }
    });
    window$1$1.setTimeout(() => {
      target.eventBusEl_ = null;
    }, 0);
  });
  return target;
}
const StatefulMixin = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState(stateUpdates) {
    if (typeof stateUpdates === "function") {
      stateUpdates = stateUpdates();
    }
    let changes;
    each(stateUpdates, (value2, key) => {
      if (this.state[key] !== value2) {
        changes = changes || {};
        changes[key] = {
          from: this.state[key],
          to: value2
        };
      }
      this.state[key] = value2;
    });
    if (changes && isEvented(this)) {
      this.trigger({
        changes,
        type: "statechanged"
      });
    }
    return changes;
  }
};
function stateful(target, defaultState) {
  Object.assign(target, StatefulMixin);
  target.state = Object.assign({}, target.state, defaultState);
  if (typeof target.handleStateChanged === "function" && isEvented(target)) {
    target.on("statechanged", target.handleStateChanged);
  }
  return target;
}
const toLowerCase = function(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, (w) => w.toLowerCase());
};
const toTitleCase$1 = function(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, (w) => w.toUpperCase());
};
const titleCaseEquals = function(str1, str2) {
  return toTitleCase$1(str1) === toTitleCase$1(str2);
};
var Str = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toLowerCase,
  toTitleCase: toTitleCase$1,
  titleCaseEquals
});
class Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of component options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to initialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   * @param {ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  constructor(player, options, ready) {
    if (!player && this.play) {
      this.player_ = player = this;
    } else {
      this.player_ = player;
    }
    this.isDisposed_ = false;
    this.parentComponent_ = null;
    this.options_ = merge$1({}, this.options_);
    options = this.options_ = merge$1(this.options_, options);
    this.id_ = options.id || options.el && options.el.id;
    if (!this.id_) {
      const id = player && player.id && player.id() || "no_player";
      this.id_ = `${id}_component_${newGUID()}`;
    }
    this.name_ = options.name || null;
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }
    if (options.className && this.el_) {
      options.className.split(" ").forEach((c) => this.addClass(c));
    }
    ["on", "off", "one", "any", "trigger"].forEach((fn2) => {
      this[fn2] = void 0;
    });
    if (options.evented !== false) {
      evented(this, {
        eventBusKey: this.el_ ? "el_" : null
      });
      this.handleLanguagechange = this.handleLanguagechange.bind(this);
      this.on(this.player_, "languagechange", this.handleLanguagechange);
    }
    stateful(this, this.constructor.defaultState);
    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};
    this.setTimeoutIds_ = /* @__PURE__ */ new Set();
    this.setIntervalIds_ = /* @__PURE__ */ new Set();
    this.rafIds_ = /* @__PURE__ */ new Set();
    this.namedRafs_ = /* @__PURE__ */ new Map();
    this.clearingTimersOnDispose_ = false;
    if (options.initChildren !== false) {
      this.initChildren();
    }
    this.ready(ready);
    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
  // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.
  // They are replaced or removed in the constructor
  /**
   * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
   * function that will get called when an event with a certain name gets triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to call with `EventTarget`s
   */
  on(type, fn2) {
  }
  /**
   * Removes an `event listener` for a specific event from an instance of `EventTarget`.
   * This makes it so that the `event listener` will no longer get called when the
   * named event happens.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} [fn]
   *        The function to remove. If not specified, all listeners managed by Video.js will be removed.
   */
  off(type, fn2) {
  }
  /**
   * This function will add an `event listener` that gets triggered only once. After the
   * first trigger it will get removed. This is like adding an `event listener`
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  one(type, fn2) {
  }
  /**
   * This function will add an `event listener` that gets triggered only once and is
   * removed from all events. This is like adding an array of `event listener`s
   * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the
   * first time it is triggered.
   *
   * @param {string|string[]} type
   *        An event name or an array of event names.
   *
   * @param {Function} fn
   *        The function to be called once for each event name.
   */
  any(type, fn2) {
  }
  /**
   * This function causes an event to happen. This will then cause any `event listeners`
   * that are waiting for that event, to get called. If there are no `event listeners`
   * for an event then nothing will happen.
   *
   * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
   * Trigger will also call the `on` + `uppercaseEventName` function.
   *
   * Example:
   * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
   * `onClick` if it exists.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * @param {Object} [hash]
   *        Optionally extra argument to pass through to an event listener
   */
  trigger(event2, hash2) {
  }
  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   *
   * @param {Object} options
   * @param {Element} options.originalEl element with which to replace player element
   */
  dispose(options = {}) {
    if (this.isDisposed_) {
      return;
    }
    if (this.readyQueue_) {
      this.readyQueue_.length = 0;
    }
    this.trigger({
      type: "dispose",
      bubbles: false
    });
    this.isDisposed_ = true;
    if (this.children_) {
      for (let i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;
    this.parentComponent_ = null;
    if (this.el_) {
      if (this.el_.parentNode) {
        if (options.restoreEl) {
          this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
        } else {
          this.el_.parentNode.removeChild(this.el_);
        }
      }
      this.el_ = null;
    }
    this.player_ = null;
  }
  /**
   * Determine whether or not this component has been disposed.
   *
   * @return {boolean}
   *         If the component has been disposed, will be `true`. Otherwise, `false`.
   */
  isDisposed() {
    return Boolean(this.isDisposed_);
  }
  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */
  player() {
    return this.player_;
  }
  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:obj.merge}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   */
  options(obj) {
    if (!obj) {
      return this.options_;
    }
    this.options_ = merge$1(this.options_, obj);
    return this.options_;
  }
  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */
  el() {
    return this.el_;
  }
  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  }
  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */
  localize(string, tokens, defaultValue = string) {
    const code = this.player_.language && this.player_.language();
    const languages = this.player_.languages && this.player_.languages();
    const language = languages && languages[code];
    const primaryCode = code && code.split("-")[0];
    const primaryLang = languages && languages[primaryCode];
    let localizedString = defaultValue;
    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }
    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function(match, index) {
        const value2 = tokens[index - 1];
        let ret = value2;
        if (typeof value2 === "undefined") {
          ret = match;
        }
        return ret;
      });
    }
    return localizedString;
  }
  /**
   * Handles language change for the player in components. Should be overridden by sub-components.
   *
   * @abstract
   */
  handleLanguagechange() {
  }
  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */
  contentEl() {
    return this.contentEl_ || this.el_;
  }
  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */
  id() {
    return this.id_;
  }
  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */
  name() {
    return this.name_;
  }
  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */
  children() {
    return this.children_;
  }
  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */
  getChildById(id) {
    return this.childIndex_[id];
  }
  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */
  getChild(name) {
    if (!name) {
      return;
    }
    return this.childNameIndex_[name];
  }
  /**
   * Returns the descendant `Component` following the givent
   * descendant `names`. For instance ['foo', 'bar', 'baz'] would
   * try to get 'foo' on the current component, 'bar' on the 'foo'
   * component and 'baz' on the 'bar' component and return undefined
   * if any of those don't exist.
   *
   * @param {...string[]|...string} names
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The descendant `Component` following the given descendant
   *         `names` or undefined.
   */
  getDescendant(...names) {
    names = names.reduce((acc, n) => acc.concat(n), []);
    let currentChild = this;
    for (let i = 0; i < names.length; i++) {
      currentChild = currentChild.getChild(names[i]);
      if (!currentChild || !currentChild.getChild) {
        return;
      }
    }
    return currentChild;
  }
  /**
   * Adds an SVG icon element to another element or component.
   *
   * @param {string} iconName
   *        The name of icon. A list of all the icon names can be found at 'sandbox/svg-icons.html'
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on. Defaults to the current Component's element.
   *
   * @return {Element}
   *        The newly created icon element.
   */
  setIcon(iconName, el = this.el()) {
    if (!this.player_.options_.experimentalSvgIcons) {
      return;
    }
    const xmlnsURL = "http://www.w3.org/2000/svg";
    const iconContainer = createEl("span", {
      className: "vjs-icon-placeholder vjs-svg-icon"
    }, {
      "aria-hidden": "true"
    });
    const svgEl = document$1$1.createElementNS(xmlnsURL, "svg");
    svgEl.setAttributeNS(null, "viewBox", "0 0 512 512");
    const useEl = document$1$1.createElementNS(xmlnsURL, "use");
    svgEl.appendChild(useEl);
    useEl.setAttributeNS(null, "href", `#vjs-icon-${iconName}`);
    iconContainer.appendChild(svgEl);
    if (this.iconIsSet_) {
      el.replaceChild(iconContainer, el.querySelector(".vjs-icon-placeholder"));
    } else {
      el.appendChild(iconContainer);
    }
    this.iconIsSet_ = true;
    return iconContainer;
  }
  /**
   * Add a child `Component` inside the current `Component`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */
  addChild(child, options = {}, index = this.children_.length) {
    let component;
    let componentName;
    if (typeof child === "string") {
      componentName = toTitleCase$1(child);
      const componentClassName = options.componentClass || componentName;
      options.name = componentName;
      const ComponentClass = Component$1.getComponent(componentClassName);
      if (!ComponentClass) {
        throw new Error(`Component ${componentClassName} does not exist`);
      }
      if (typeof ComponentClass !== "function") {
        return null;
      }
      component = new ComponentClass(this.player_ || this, options);
    } else {
      component = child;
    }
    if (component.parentComponent_) {
      component.parentComponent_.removeChild(component);
    }
    this.children_.splice(index, 0, component);
    component.parentComponent_ = this;
    if (typeof component.id === "function") {
      this.childIndex_[component.id()] = component;
    }
    componentName = componentName || component.name && toTitleCase$1(component.name());
    if (componentName) {
      this.childNameIndex_[componentName] = component;
      this.childNameIndex_[toLowerCase(componentName)] = component;
    }
    if (typeof component.el === "function" && component.el()) {
      let refNode = null;
      if (this.children_[index + 1]) {
        if (this.children_[index + 1].el_) {
          refNode = this.children_[index + 1].el_;
        } else if (isEl(this.children_[index + 1])) {
          refNode = this.children_[index + 1];
        }
      }
      this.contentEl().insertBefore(component.el(), refNode);
    }
    return component;
  }
  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */
  removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    if (!component || !this.children_) {
      return;
    }
    let childFound = false;
    for (let i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }
    if (!childFound) {
      return;
    }
    component.parentComponent_ = null;
    this.childIndex_[component.id()] = null;
    this.childNameIndex_[toTitleCase$1(component.name())] = null;
    this.childNameIndex_[toLowerCase(component.name())] = null;
    const compEl = component.el();
    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  }
  /**
   * Add and initialize default child `Component`s based upon options.
   */
  initChildren() {
    const children = this.options_.children;
    if (children) {
      const parentOptions = this.options_;
      const handleAdd = (child) => {
        const name = child.name;
        let opts = child.opts;
        if (parentOptions[name] !== void 0) {
          opts = parentOptions[name];
        }
        if (opts === false) {
          return;
        }
        if (opts === true) {
          opts = {};
        }
        opts.playerOptions = this.options_.playerOptions;
        const newChild = this.addChild(name, opts);
        if (newChild) {
          this[name] = newChild;
        }
      };
      let workingChildren;
      const Tech2 = Component$1.getComponent("Tech");
      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }
      workingChildren.concat(Object.keys(this.options_).filter(function(child) {
        return !workingChildren.some(function(wchild) {
          if (typeof wchild === "string") {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map((child) => {
        let name;
        let opts;
        if (typeof child === "string") {
          name = child;
          opts = children[name] || this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }
        return {
          name,
          opts
        };
      }).filter((child) => {
        const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
        return c && !Tech2.isTech(c);
      }).forEach(handleAdd);
    }
  }
  /**
   * Builds the default DOM class name. Should be overridden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */
  buildCSSClass() {
    return "";
  }
  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @param {ReadyCallback} fn
   *        Function that gets called when the `Component` is ready.
   */
  ready(fn2, sync = false) {
    if (!fn2) {
      return;
    }
    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn2);
      return;
    }
    if (sync) {
      fn2.call(this);
    } else {
      this.setTimeout(fn2, 1);
    }
  }
  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */
  triggerReady() {
    this.isReady_ = true;
    this.setTimeout(function() {
      const readyQueue = this.readyQueue_;
      this.readyQueue_ = [];
      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function(fn2) {
          fn2.call(this);
        }, this);
      }
      this.trigger("ready");
    }, 1);
  }
  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $(selector, context) {
    return $(selector, context || this.contentEl());
  }
  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */
  $$(selector, context) {
    return $$(selector, context || this.contentEl());
  }
  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */
  hasClass(classToCheck) {
    return hasClass(this.el_, classToCheck);
  }
  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {...string} classesToAdd
   *        One or more CSS class name to add.
   */
  addClass(...classesToAdd) {
    addClass(this.el_, ...classesToAdd);
  }
  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {...string} classesToRemove
   *        One or more CSS class name to remove.
   */
  removeClass(...classesToRemove) {
    removeClass(this.el_, ...classesToRemove);
  }
  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */
  toggleClass(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */
  show() {
    this.removeClass("vjs-hidden");
  }
  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */
  hide() {
    this.addClass("vjs-hidden");
  }
  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  lockShowing() {
    this.addClass("vjs-lock-showing");
  }
  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */
  unlockShowing() {
    this.removeClass("vjs-lock-showing");
  }
  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attribute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */
  getAttribute(attribute) {
    return getAttribute(this.el_, attribute);
  }
  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */
  setAttribute(attribute, value2) {
    setAttribute(this.el_, attribute, value2);
  }
  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */
  removeAttribute(attribute) {
    removeAttribute(this.el_, attribute);
  }
  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The width when getting, zero if there is no width
   */
  width(num, skipListeners) {
    return this.dimension("width", num, skipListeners);
  }
  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|undefined}
   *         The height when getting, zero if there is no height
   */
  height(num, skipListeners) {
    return this.dimension("height", num, skipListeners);
  }
  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */
  dimensions(width, height) {
    this.width(width, true);
    this.height(height);
  }
  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number|undefined}
   *         The dimension when getting or 0 if unset
   */
  dimension(widthOrHeight, num, skipListeners) {
    if (num !== void 0) {
      if (num === null || num !== num) {
        num = 0;
      }
      if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === "auto") {
        this.el_.style[widthOrHeight] = "";
      } else {
        this.el_.style[widthOrHeight] = num + "px";
      }
      if (!skipListeners) {
        this.trigger("componentresize");
      }
      return;
    }
    if (!this.el_) {
      return 0;
    }
    const val = this.el_.style[widthOrHeight];
    const pxIndex = val.indexOf("px");
    if (pxIndex !== -1) {
      return parseInt(val.slice(0, pxIndex), 10);
    }
    return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
  }
  /**
   * Get the computed width or the height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */
  currentDimension(widthOrHeight) {
    let computedWidthOrHeight = 0;
    if (widthOrHeight !== "width" && widthOrHeight !== "height") {
      throw new Error("currentDimension only accepts width or height value");
    }
    computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);
    if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
      const rule = `offset${toTitleCase$1(widthOrHeight)}`;
      computedWidthOrHeight = this.el_[rule];
    }
    return computedWidthOrHeight;
  }
  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */
  /**
   * Get an object that contains computed width and height values of the
   * component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {Component~DimensionObject}
   *         The computed dimensions of the component's element.
   */
  currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  }
  /**
   * Get the computed width of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed width of the component's element.
   */
  currentWidth() {
    return this.currentDimension("width");
  }
  /**
   * Get the computed height of the component's element.
   *
   * Uses `window.getComputedStyle`.
   *
   * @return {number}
   *         The computed height of the component's element.
   */
  currentHeight() {
    return this.currentDimension("height");
  }
  /**
   * Retrieves the position and size information of the component's element.
   *
   * @return {Object} An object with `boundingClientRect` and `center` properties.
   *         - `boundingClientRect`: An object with properties `x`, `y`, `width`,
   *           `height`, `top`, `right`, `bottom`, and `left`, representing
   *           the bounding rectangle of the element.
   *         - `center`: An object with properties `x` and `y`, representing
   *           the center point of the element. `width` and `height` are set to 0.
   */
  getPositions() {
    const rect = this.el_.getBoundingClientRect();
    const boundingClientRect = {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left
    };
    const center = {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2,
      width: 0,
      height: 0,
      top: rect.top + rect.height / 2,
      right: rect.left + rect.width / 2,
      bottom: rect.top + rect.height / 2,
      left: rect.left + rect.width / 2
    };
    return {
      boundingClientRect,
      center
    };
  }
  /**
   * Set the focus to this component
   */
  focus() {
    this.el_.focus();
  }
  /**
   * Remove the focus from this component
   */
  blur() {
    this.el_.blur();
  }
  /**
   * When this Component receives a `keydown` event which it does not process,
   *  it passes the event to the Player for handling.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   */
  handleKeyDown(event2) {
    if (this.player_) {
      if (event2.key !== "Tab" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) {
        event2.stopPropagation();
      }
      this.player_.handleKeyDown(event2);
    }
  }
  /**
   * Many components used to have a `handleKeyPress` method, which was poorly
   * named because it listened to a `keydown` event. This method name now
   * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`
   * will not see their method calls stop working.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to be called.
   */
  handleKeyPress(event2) {
    this.handleKeyDown(event2);
  }
  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @protected
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */
  emitTapEvents() {
    let touchStart = 0;
    let firstTouch = null;
    const tapMovementThreshold = 10;
    const touchTimeThreshold = 200;
    let couldBeTap;
    this.on("touchstart", function(event2) {
      if (event2.touches.length === 1) {
        firstTouch = {
          pageX: event2.touches[0].pageX,
          pageY: event2.touches[0].pageY
        };
        touchStart = window$1$1.performance.now();
        couldBeTap = true;
      }
    });
    this.on("touchmove", function(event2) {
      if (event2.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        const xdiff = event2.touches[0].pageX - firstTouch.pageX;
        const ydiff = event2.touches[0].pageY - firstTouch.pageY;
        const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });
    const noTap = function() {
      couldBeTap = false;
    };
    this.on("touchleave", noTap);
    this.on("touchcancel", noTap);
    this.on("touchend", function(event2) {
      firstTouch = null;
      if (couldBeTap === true) {
        const touchTime = window$1$1.performance.now() - touchStart;
        if (touchTime < touchTimeThreshold) {
          event2.preventDefault();
          this.trigger("tap");
        }
      }
    });
  }
  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */
  enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }
    const report = bind_(this.player(), this.player().reportUserActivity);
    let touchHolding;
    this.on("touchstart", function() {
      report();
      this.clearInterval(touchHolding);
      touchHolding = this.setInterval(report, 250);
    });
    const touchEnd = function(event2) {
      report();
      this.clearInterval(touchHolding);
    };
    this.on("touchmove", report);
    this.on("touchend", touchEnd);
    this.on("touchcancel", touchEnd);
  }
  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */
  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can't use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose} instead.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */
  setTimeout(fn2, timeout) {
    var timeoutId;
    fn2 = bind_(this, fn2);
    this.clearTimersOnDispose_();
    timeoutId = window$1$1.setTimeout(() => {
      if (this.setTimeoutIds_.has(timeoutId)) {
        this.setTimeoutIds_.delete(timeoutId);
      }
      fn2();
    }, timeout);
    this.setTimeoutIds_.add(timeoutId);
    return timeoutId;
  }
  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */
  clearTimeout(timeoutId) {
    if (this.setTimeoutIds_.has(timeoutId)) {
      this.setTimeoutIds_.delete(timeoutId);
      window$1$1.clearTimeout(timeoutId);
    }
    return timeoutId;
  }
  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */
  setInterval(fn2, interval) {
    fn2 = bind_(this, fn2);
    this.clearTimersOnDispose_();
    const intervalId = window$1$1.setInterval(fn2, interval);
    this.setIntervalIds_.add(intervalId);
    return intervalId;
  }
  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */
  clearInterval(intervalId) {
    if (this.setIntervalIds_.has(intervalId)) {
      this.setIntervalIds_.delete(intervalId);
      window$1$1.clearInterval(intervalId);
    }
    return intervalId;
  }
  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */
  requestAnimationFrame(fn2) {
    this.clearTimersOnDispose_();
    var id;
    fn2 = bind_(this, fn2);
    id = window$1$1.requestAnimationFrame(() => {
      if (this.rafIds_.has(id)) {
        this.rafIds_.delete(id);
      }
      fn2();
    });
    this.rafIds_.add(id);
    return id;
  }
  /**
   * Request an animation frame, but only one named animation
   * frame will be queued. Another will never be added until
   * the previous one finishes.
   *
   * @param {string} name
   *        The name to give this requestAnimationFrame
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   */
  requestNamedAnimationFrame(name, fn2) {
    if (this.namedRafs_.has(name)) {
      return;
    }
    this.clearTimersOnDispose_();
    fn2 = bind_(this, fn2);
    const id = this.requestAnimationFrame(() => {
      fn2();
      if (this.namedRafs_.has(name)) {
        this.namedRafs_.delete(name);
      }
    });
    this.namedRafs_.set(name, id);
    return name;
  }
  /**
   * Cancels a current named animation frame if it exists.
   *
   * @param {string} name
   *        The name of the requestAnimationFrame to cancel.
   */
  cancelNamedAnimationFrame(name) {
    if (!this.namedRafs_.has(name)) {
      return;
    }
    this.cancelAnimationFrame(this.namedRafs_.get(name));
    this.namedRafs_.delete(name);
  }
  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */
  cancelAnimationFrame(id) {
    if (this.rafIds_.has(id)) {
      this.rafIds_.delete(id);
      window$1$1.cancelAnimationFrame(id);
    }
    return id;
  }
  /**
   * A function to setup `requestAnimationFrame`, `setTimeout`,
   * and `setInterval`, clearing on dispose.
   *
   * > Previously each timer added and removed dispose listeners on it's own.
   * For better performance it was decided to batch them all, and use `Set`s
   * to track outstanding timer ids.
   *
   * @private
   */
  clearTimersOnDispose_() {
    if (this.clearingTimersOnDispose_) {
      return;
    }
    this.clearingTimersOnDispose_ = true;
    this.one("dispose", () => {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([idName, cancelName]) => {
        this[idName].forEach((val, key) => this[cancelName](key));
      });
      this.clearingTimersOnDispose_ = false;
    });
  }
  /**
    * Decide whether an element is actually disabled or not.
    *
    * @function isActuallyDisabled
    * @param element {Node}
    * @return {boolean}
    *
    * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
    */
  getIsDisabled() {
    return Boolean(this.el_.disabled);
  }
  /**
    * Decide whether the element is expressly inert or not.
    *
    * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
    * @function isExpresslyInert
    * @param element {Node}
    * @return {boolean}
    */
  getIsExpresslyInert() {
    return this.el_.inert && !this.el_.ownerDocument.documentElement.inert;
  }
  /**
   * Determine whether or not this component can be considered as focusable component.
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can be focused, will be `true`. Otherwise, `false`.
   */
  getIsFocusable(el) {
    const element = el || this.el_;
    return element.tabIndex >= 0 && !(this.getIsDisabled() || this.getIsExpresslyInert());
  }
  /**
   * Determine whether or not this component is currently visible/enabled/etc...
   *
   * @param {HTMLElement} el - The HTML element representing the component.
   * @return {boolean}
   *         If the component can is currently visible & enabled, will be `true`. Otherwise, `false`.
   */
  getIsAvailableToBeFocused(el) {
    function isVisibleStyleProperty(element) {
      const elementStyle2 = window$1$1.getComputedStyle(element, null);
      const thisVisibility = elementStyle2.getPropertyValue("visibility");
      const thisDisplay = elementStyle2.getPropertyValue("display");
      const invisibleStyle = ["hidden", "collapse"];
      return thisDisplay !== "none" && !invisibleStyle.includes(thisVisibility);
    }
    function isBeingRendered(element) {
      if (!isVisibleStyleProperty(element.parentElement)) {
        return false;
      }
      if (!isVisibleStyleProperty(element) || element.style.opacity === "0" || window$1$1.getComputedStyle(element).height === "0px" || window$1$1.getComputedStyle(element).width === "0px") {
        return false;
      }
      return true;
    }
    function isVisible(element) {
      if (element.offsetWidth + element.offsetHeight + element.getBoundingClientRect().height + element.getBoundingClientRect().width === 0) {
        return false;
      }
      const elementCenter = {
        x: element.getBoundingClientRect().left + element.offsetWidth / 2,
        y: element.getBoundingClientRect().top + element.offsetHeight / 2
      };
      if (elementCenter.x < 0) {
        return false;
      }
      if (elementCenter.x > (document$1$1.documentElement.clientWidth || window$1$1.innerWidth)) {
        return false;
      }
      if (elementCenter.y < 0) {
        return false;
      }
      if (elementCenter.y > (document$1$1.documentElement.clientHeight || window$1$1.innerHeight)) {
        return false;
      }
      let pointContainer = document$1$1.elementFromPoint(elementCenter.x, elementCenter.y);
      while (pointContainer) {
        if (pointContainer === element) {
          return true;
        }
        if (pointContainer.parentNode) {
          pointContainer = pointContainer.parentNode;
        } else {
          return false;
        }
      }
    }
    if (!el) {
      el = this.el();
    }
    if (isVisible(el) && isBeingRendered(el) && (!el.parentElement || el.tabIndex >= 0)) {
      return true;
    }
    return false;
  }
  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */
  static registerComponent(name, ComponentToRegister) {
    if (typeof name !== "string" || !name) {
      throw new Error(`Illegal component name, "${name}"; must be a non-empty string.`);
    }
    const Tech2 = Component$1.getComponent("Tech");
    const isTech = Tech2 && Tech2.isTech(ComponentToRegister);
    const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);
    if (isTech || !isComp) {
      let reason;
      if (isTech) {
        reason = "techs must be registered using Tech.registerTech()";
      } else {
        reason = "must be a Component subclass";
      }
      throw new Error(`Illegal component, "${name}"; ${reason}.`);
    }
    name = toTitleCase$1(name);
    if (!Component$1.components_) {
      Component$1.components_ = {};
    }
    const Player2 = Component$1.getComponent("Player");
    if (name === "Player" && Player2 && Player2.players) {
      const players = Player2.players;
      const playerNames = Object.keys(players);
      if (players && playerNames.length > 0 && playerNames.map((pname) => players[pname]).every(Boolean)) {
        throw new Error("Can not register Player component after player has been created.");
      }
    }
    Component$1.components_[name] = ComponentToRegister;
    Component$1.components_[toLowerCase(name)] = ComponentToRegister;
    return ComponentToRegister;
  }
  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {typeof Component}
   *         The `Component` that got registered under the given name.
   */
  static getComponent(name) {
    if (!name || !Component$1.components_) {
      return;
    }
    return Component$1.components_[name];
  }
}
Component$1.registerComponent("Component", Component$1);
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== "number" || index < 0 || index > maxIndex) {
    throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);
  }
}
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}
function createTimeRangesObj(ranges) {
  let timeRangesObj;
  if (ranges === void 0 || ranges.length === 0) {
    timeRangesObj = {
      length: 0,
      start() {
        throw new Error("This TimeRanges object is empty");
      },
      end() {
        throw new Error("This TimeRanges object is empty");
      }
    };
  } else {
    timeRangesObj = {
      length: ranges.length,
      start: getRange.bind(null, "start", 0, ranges),
      end: getRange.bind(null, "end", 1, ranges)
    };
  }
  if (window$1$1.Symbol && window$1$1.Symbol.iterator) {
    timeRangesObj[window$1$1.Symbol.iterator] = () => (ranges || []).values();
  }
  return timeRangesObj;
}
function createTimeRanges$1(start2, end2) {
  if (Array.isArray(start2)) {
    return createTimeRangesObj(start2);
  } else if (start2 === void 0 || end2 === void 0) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start2, end2]]);
}
const defaultImplementation = function(seconds, guide) {
  seconds = seconds < 0 ? 0 : seconds;
  let s = Math.floor(seconds % 60);
  let m = Math.floor(seconds / 60 % 60);
  let h2 = Math.floor(seconds / 3600);
  const gm = Math.floor(guide / 60 % 60);
  const gh = Math.floor(guide / 3600);
  if (isNaN(seconds) || seconds === Infinity) {
    h2 = m = s = "-";
  }
  h2 = h2 > 0 || gh > 0 ? h2 + ":" : "";
  m = ((h2 || gm >= 10) && m < 10 ? "0" + m : m) + ":";
  s = s < 10 ? "0" + s : s;
  return h2 + m + s;
};
let implementation = defaultImplementation;
function setFormatTime(customImplementation) {
  implementation = customImplementation;
}
function resetFormatTime() {
  implementation = defaultImplementation;
}
function formatTime(seconds, guide = seconds) {
  return implementation(seconds, guide);
}
var Time = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTimeRanges: createTimeRanges$1,
  createTimeRange: createTimeRanges$1,
  setFormatTime,
  resetFormatTime,
  formatTime
});
function bufferedPercent(buffered, duration2) {
  let bufferedDuration = 0;
  let start2;
  let end2;
  if (!duration2) {
    return 0;
  }
  if (!buffered || !buffered.length) {
    buffered = createTimeRanges$1(0, 0);
  }
  for (let i = 0; i < buffered.length; i++) {
    start2 = buffered.start(i);
    end2 = buffered.end(i);
    if (end2 > duration2) {
      end2 = duration2;
    }
    bufferedDuration += end2 - start2;
  }
  return bufferedDuration / duration2;
}
function MediaError(value2) {
  if (value2 instanceof MediaError) {
    return value2;
  }
  if (typeof value2 === "number") {
    this.code = value2;
  } else if (typeof value2 === "string") {
    this.message = value2;
  } else if (isObject$4(value2)) {
    if (typeof value2.code === "number") {
      this.code = value2.code;
    }
    Object.assign(this, value2);
  }
  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || "";
  }
}
MediaError.prototype.code = 0;
MediaError.prototype.message = "";
MediaError.prototype.status = null;
MediaError.prototype.metadata = null;
MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
MediaError.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
MediaError.MEDIA_ERR_CUSTOM = 0;
MediaError.prototype.MEDIA_ERR_CUSTOM = 0;
MediaError.MEDIA_ERR_ABORTED = 1;
MediaError.prototype.MEDIA_ERR_ABORTED = 1;
MediaError.MEDIA_ERR_NETWORK = 2;
MediaError.prototype.MEDIA_ERR_NETWORK = 2;
MediaError.MEDIA_ERR_DECODE = 3;
MediaError.prototype.MEDIA_ERR_DECODE = 3;
MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
MediaError.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
MediaError.MEDIA_ERR_ENCRYPTED = 5;
MediaError.prototype.MEDIA_ERR_ENCRYPTED = 5;
function isPromise(value2) {
  return value2 !== void 0 && value2 !== null && typeof value2.then === "function";
}
function silencePromise(value2) {
  if (isPromise(value2)) {
    value2.then(null, (e) => {
    });
  }
}
const trackToJson_ = function(track) {
  const ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((acc, prop, i) => {
    if (track[prop]) {
      acc[prop] = track[prop];
    }
    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });
  return ret;
};
const textTracksToJson = function(tech) {
  const trackEls = tech.$$("track");
  const trackObjs = Array.prototype.map.call(trackEls, (t) => t.track);
  const tracks = Array.prototype.map.call(trackEls, function(trackEl) {
    const json = trackToJson_(trackEl.track);
    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });
  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};
const jsonToTextTracks = function(json, tech) {
  json.forEach(function(track) {
    const addedTrack = tech.addRemoteTextTrack(track).track;
    if (!track.src && track.cues) {
      track.cues.forEach((cue) => addedTrack.addCue(cue));
    }
  });
  return tech.textTracks();
};
var textTrackConverter = {
  textTracksToJson,
  jsonToTextTracks,
  trackToJson_
};
const MODAL_CLASS_NAME = "vjs-modal-dialog";
class ModalDialog extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.pauseOnOpen=true]
   *        If `true`, playback will will be paused if playing when
   *        the modal opens, and resumed when it closes.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  constructor(player, options) {
    super(player, options);
    this.handleKeyDown_ = (e) => this.handleKeyDown(e);
    this.close_ = (e) => this.close(e);
    this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
    this.closeable(!this.options_.uncloseable);
    this.content(this.options_.content);
    this.contentEl_ = createEl("div", {
      className: `${MODAL_CLASS_NAME}-content`
    }, {
      role: "document"
    });
    this.descEl_ = createEl("p", {
      className: `${MODAL_CLASS_NAME}-description vjs-control-text`,
      id: this.el().getAttribute("aria-describedby")
    });
    textContent(this.descEl_, this.description());
    this.el_.appendChild(this.descEl_);
    this.el_.appendChild(this.contentEl_);
  }
  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": `${this.id()}_description`,
      "aria-hidden": "true",
      "aria-label": this.label(),
      "role": "dialog",
      "aria-live": "polite"
    });
  }
  dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;
    super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */
  label() {
    return this.localize(this.options_.label || "Modal Window");
  }
  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */
  description() {
    let desc = this.options_.description || this.localize("This is a modal window.");
    if (this.closeable()) {
      desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
    }
    return desc;
  }
  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */
  open() {
    if (this.opened_) {
      if (this.options_.fillAlways) {
        this.fill();
      }
      return;
    }
    const player = this.player();
    this.trigger("beforemodalopen");
    this.opened_ = true;
    if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
      this.fill();
    }
    this.wasPlaying_ = !player.paused();
    if (this.options_.pauseOnOpen && this.wasPlaying_) {
      player.pause();
    }
    this.on("keydown", this.handleKeyDown_);
    this.hadControls_ = player.controls();
    player.controls(false);
    this.show();
    this.conditionalFocus_();
    this.el().setAttribute("aria-hidden", "false");
    this.trigger("modalopen");
    this.hasBeenOpened_ = true;
  }
  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */
  opened(value2) {
    if (typeof value2 === "boolean") {
      this[value2 ? "open" : "close"]();
    }
    return this.opened_;
  }
  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */
  close() {
    if (!this.opened_) {
      return;
    }
    const player = this.player();
    this.trigger("beforemodalclose");
    this.opened_ = false;
    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }
    this.off("keydown", this.handleKeyDown_);
    if (this.hadControls_) {
      player.controls(true);
    }
    this.hide();
    this.el().setAttribute("aria-hidden", "true");
    this.trigger({
      type: "modalclose",
      bubbles: true
    });
    this.conditionalBlur_();
    if (this.options_.temporary) {
      this.dispose();
    }
  }
  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */
  closeable(value2) {
    if (typeof value2 === "boolean") {
      const closeable = this.closeable_ = !!value2;
      let close2 = this.getChild("closeButton");
      if (closeable && !close2) {
        const temp = this.contentEl_;
        this.contentEl_ = this.el_;
        close2 = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        });
        this.contentEl_ = temp;
        this.on(close2, "close", this.close_);
      }
      if (!closeable && close2) {
        this.off(close2, "close", this.close_);
        this.removeChild(close2);
        close2.dispose();
      }
    }
    return this.closeable_;
  }
  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */
  fill() {
    this.fillWith(this.content());
  }
  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {ContentDescriptor} [content]
   *        The same rules apply to this as apply to the `content` option.
   */
  fillWith(content) {
    const contentEl = this.contentEl();
    const parentEl = contentEl.parentNode;
    const nextSiblingEl = contentEl.nextSibling;
    this.trigger("beforemodalfill");
    this.hasBeenFilled_ = true;
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    this.trigger("modalfill");
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }
    const closeButton = this.getChild("closeButton");
    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
    this.trigger("aftermodalfill");
  }
  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */
  empty() {
    this.trigger("beforemodalempty");
    emptyEl(this.contentEl());
    this.trigger("modalempty");
  }
  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {ContentDescriptor} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {ContentDescriptor}
   *         The current content of the modal dialog
   */
  content(value2) {
    if (typeof value2 !== "undefined") {
      this.content_ = value2;
    }
    return this.content_;
  }
  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */
  conditionalFocus_() {
    const activeEl = document$1$1.activeElement;
    const playerEl = this.player_.el_;
    this.previouslyActiveEl_ = null;
    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;
      this.focus();
    }
  }
  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */
  conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }
  }
  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    this.trigger({
      type: "modalKeydown",
      originalEvent: event2,
      target: this,
      bubbles: true
    });
    event2.stopPropagation();
    if (event2.key === "Escape" && this.closeable()) {
      event2.preventDefault();
      this.close();
      return;
    }
    if (event2.key !== "Tab") {
      return;
    }
    const focusableEls = this.focusableEls_();
    const activeEl = this.el_.querySelector(":focus");
    let focusIndex;
    for (let i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }
    if (document$1$1.activeElement === this.el_) {
      focusIndex = 0;
    }
    if (event2.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event2.preventDefault();
    } else if (!event2.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event2.preventDefault();
    }
  }
  /**
   * get all focusable elements
   *
   * @private
   */
  focusableEls_() {
    const allChildren = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(allChildren, (child) => {
      return (child instanceof window$1$1.HTMLAnchorElement || child instanceof window$1$1.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window$1$1.HTMLInputElement || child instanceof window$1$1.HTMLSelectElement || child instanceof window$1$1.HTMLTextAreaElement || child instanceof window$1$1.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window$1$1.HTMLIFrameElement || child instanceof window$1$1.HTMLObjectElement || child instanceof window$1$1.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
    });
  }
}
ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};
Component$1.registerComponent("ModalDialog", ModalDialog);
class TrackList extends EventTarget$2 {
  /**
   * Create an instance of this class
   *
   * @param { Track[] } tracks
   *        A list of tracks to initialize the list with.
   *
   * @abstract
   */
  constructor(tracks = []) {
    super();
    this.tracks_ = [];
    Object.defineProperty(this, "length", {
      get() {
        return this.tracks_.length;
      }
    });
    for (let i = 0; i < tracks.length; i++) {
      this.addTrack(tracks[i]);
    }
  }
  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(track) {
    const index = this.tracks_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this.tracks_[index];
        }
      });
    }
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      this.trigger({
        track,
        type: "addtrack",
        target: this
      });
    }
    track.labelchange_ = () => {
      this.trigger({
        track,
        type: "labelchange",
        target: this
      });
    };
    if (isEvented(track)) {
      track.addEventListener("labelchange", track.labelchange_);
    }
  }
  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */
  removeTrack(rtrack) {
    let track;
    for (let i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }
        this.tracks_.splice(i, 1);
        break;
      }
    }
    if (!track) {
      return;
    }
    this.trigger({
      track,
      type: "removetrack",
      target: this
    });
  }
  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {string} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */
  getTrackById(id) {
    let result = null;
    for (let i = 0, l = this.length; i < l; i++) {
      const track = this[i];
      if (track.id === id) {
        result = track;
        break;
      }
    }
    return result;
  }
}
TrackList.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (const event2 in TrackList.prototype.allowedEvents_) {
  TrackList.prototype["on" + event2] = null;
}
const disableOthers$1 = function(list, track) {
  for (let i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].enabled = false;
  }
};
class AudioTrackList extends TrackList {
  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  constructor(tracks = []) {
    for (let i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }
    super(tracks);
    this.changing_ = false;
  }
  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(track) {
    if (track.enabled) {
      disableOthers$1(this, track);
    }
    super.addTrack(track);
    if (!track.addEventListener) {
      return;
    }
    track.enabledChange_ = () => {
      if (this.changing_) {
        return;
      }
      this.changing_ = true;
      disableOthers$1(this, track);
      this.changing_ = false;
      this.trigger("change");
    };
    track.addEventListener("enabledchange", track.enabledChange_);
  }
  removeTrack(rtrack) {
    super.removeTrack(rtrack);
    if (rtrack.removeEventListener && rtrack.enabledChange_) {
      rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
      rtrack.enabledChange_ = null;
    }
  }
}
const disableOthers = function(list, track) {
  for (let i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].selected = false;
  }
};
class VideoTrackList extends TrackList {
  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  constructor(tracks = []) {
    for (let i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }
    super(tracks);
    this.changing_ = false;
    Object.defineProperty(this, "selectedIndex", {
      get() {
        for (let i = 0; i < this.length; i++) {
          if (this[i].selected) {
            return i;
          }
        }
        return -1;
      },
      set() {
      }
    });
  }
  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */
  addTrack(track) {
    if (track.selected) {
      disableOthers(this, track);
    }
    super.addTrack(track);
    if (!track.addEventListener) {
      return;
    }
    track.selectedChange_ = () => {
      if (this.changing_) {
        return;
      }
      this.changing_ = true;
      disableOthers(this, track);
      this.changing_ = false;
      this.trigger("change");
    };
    track.addEventListener("selectedchange", track.selectedChange_);
  }
  removeTrack(rtrack) {
    super.removeTrack(rtrack);
    if (rtrack.removeEventListener && rtrack.selectedChange_) {
      rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
      rtrack.selectedChange_ = null;
    }
  }
}
class TextTrackList extends TrackList {
  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */
  addTrack(track) {
    super.addTrack(track);
    if (!this.queueChange_) {
      this.queueChange_ = () => this.queueTrigger("change");
    }
    if (!this.triggerSelectedlanguagechange) {
      this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange");
    }
    track.addEventListener("modechange", this.queueChange_);
    const nonLanguageTextTrackKind = ["metadata", "chapters"];
    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
    }
  }
  removeTrack(rtrack) {
    super.removeTrack(rtrack);
    if (rtrack.removeEventListener) {
      if (this.queueChange_) {
        rtrack.removeEventListener("modechange", this.queueChange_);
      }
      if (this.selectedlanguagechange_) {
        rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
      }
    }
  }
}
class HtmlTrackElementList {
  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  constructor(trackElements = []) {
    this.trackElements_ = [];
    Object.defineProperty(this, "length", {
      get() {
        return this.trackElements_.length;
      }
    });
    for (let i = 0, length2 = trackElements.length; i < length2; i++) {
      this.addTrackElement_(trackElements[i]);
    }
  }
  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */
  addTrackElement_(trackElement) {
    const index = this.trackElements_.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this.trackElements_[index];
        }
      });
    }
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  }
  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */
  getTrackElementByTrack_(track) {
    let trackElement_;
    for (let i = 0, length2 = this.trackElements_.length; i < length2; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];
        break;
      }
    }
    return trackElement_;
  }
  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */
  removeTrackElement_(trackElement) {
    for (let i = 0, length2 = this.trackElements_.length; i < length2; i++) {
      if (trackElement === this.trackElements_[i]) {
        if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") {
          this.trackElements_[i].track.off();
        }
        if (typeof this.trackElements_[i].off === "function") {
          this.trackElements_[i].off();
        }
        this.trackElements_.splice(i, 1);
        break;
      }
    }
  }
}
class TextTrackCueList {
  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  constructor(cues) {
    TextTrackCueList.prototype.setCues_.call(this, cues);
    Object.defineProperty(this, "length", {
      get() {
        return this.length_;
      }
    });
  }
  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */
  setCues_(cues) {
    const oldLength = this.length || 0;
    let i = 0;
    const l = cues.length;
    this.cues_ = cues;
    this.length_ = cues.length;
    const defineProp = function(index) {
      if (!("" + index in this)) {
        Object.defineProperty(this, "" + index, {
          get() {
            return this.cues_[index];
          }
        });
      }
    };
    if (oldLength < l) {
      i = oldLength;
      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  }
  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */
  getCueById(id) {
    let result = null;
    for (let i = 0, l = this.length; i < l; i++) {
      const cue = this[i];
      if (cue.id === id) {
        result = cue;
        break;
      }
    }
    return result;
  }
}
const VideoTrackKind = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
};
const AudioTrackKind = {
  "alternative": "alternative",
  "descriptions": "descriptions",
  "main": "main",
  "main-desc": "main-desc",
  "translation": "translation",
  "commentary": "commentary"
};
const TextTrackKind = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
};
const TextTrackMode = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
class Track extends EventTarget$2 {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  constructor(options = {}) {
    super();
    const trackProps = {
      id: options.id || "vjs_track_" + newGUID(),
      kind: options.kind || "",
      language: options.language || ""
    };
    let label = options.label || "";
    for (const key in trackProps) {
      Object.defineProperty(this, key, {
        get() {
          return trackProps[key];
        },
        set() {
        }
      });
    }
    Object.defineProperty(this, "label", {
      get() {
        return label;
      },
      set(newLabel) {
        if (newLabel !== label) {
          label = newLabel;
          this.trigger("labelchange");
        }
      }
    });
  }
}
const parseUrl = function(url2) {
  return new URL(url2, document$1$1.baseURI);
};
const getAbsoluteURL = function(url2) {
  return new URL(url2, document$1$1.baseURI).href;
};
const getFileExtension = function(path2) {
  if (typeof path2 === "string") {
    const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
    const pathParts = splitPathRe.exec(path2);
    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }
  return "";
};
const isCrossOrigin = function(url2, winLoc = window$1$1.location) {
  return parseUrl(url2).origin !== winLoc.origin;
};
var Url = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseUrl,
  getAbsoluteURL,
  getFileExtension,
  isCrossOrigin
});
const parseCues = function(srcContent, track) {
  const parser2 = new window$1$1.WebVTT.Parser(window$1$1, window$1$1.vttjs, window$1$1.WebVTT.StringDecoder());
  const errors2 = [];
  parser2.oncue = function(cue) {
    track.addCue(cue);
  };
  parser2.onparsingerror = function(error) {
    errors2.push(error);
  };
  parser2.onflush = function() {
    track.trigger({
      type: "loadeddata",
      target: track
    });
  };
  parser2.parse(srcContent);
  if (errors2.length > 0) {
    if (window$1$1.console && window$1$1.console.groupCollapsed) {
      window$1$1.console.groupCollapsed(`Text Track parsing errors for ${track.src}`);
    }
    errors2.forEach((error) => log$1.error(error));
    if (window$1$1.console && window$1$1.console.groupEnd) {
      window$1$1.console.groupEnd();
    }
  }
  parser2.flush();
};
const loadTrack = function(src, track) {
  const opts = {
    uri: src
  };
  const crossOrigin = isCrossOrigin(src);
  if (crossOrigin) {
    opts.cors = crossOrigin;
  }
  const withCredentials = track.tech_.crossOrigin() === "use-credentials";
  if (withCredentials) {
    opts.withCredentials = withCredentials;
  }
  XHR(opts, bind_(this, function(err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }
    track.loaded_ = true;
    if (typeof window$1$1.WebVTT !== "function") {
      if (track.tech_) {
        track.tech_.any(["vttjsloaded", "vttjserror"], (event2) => {
          if (event2.type === "vttjserror") {
            log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);
            return;
          }
          return parseCues(responseBody, track);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};
class TextTrack extends Track {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(options = {}) {
    if (!options.tech) {
      throw new Error("A tech was not provided.");
    }
    const settings = merge$1(options, {
      kind: TextTrackKind[options.kind] || "subtitles",
      language: options.language || options.srclang || ""
    });
    let mode = TextTrackMode[settings.mode] || "disabled";
    const default_ = settings.default;
    if (settings.kind === "metadata" || settings.kind === "chapters") {
      mode = "hidden";
    }
    super(settings);
    this.tech_ = settings.tech;
    this.cues_ = [];
    this.activeCues_ = [];
    this.preload_ = this.tech_.preloadTextTracks !== false;
    const cues = new TextTrackCueList(this.cues_);
    const activeCues = new TextTrackCueList(this.activeCues_);
    let changed = false;
    this.timeupdateHandler = bind_(this, function(event2 = {}) {
      if (this.tech_.isDisposed()) {
        return;
      }
      if (!this.tech_.isReady_) {
        if (event2.type !== "timeupdate") {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
        return;
      }
      this.activeCues = this.activeCues;
      if (changed) {
        this.trigger("cuechange");
        changed = false;
      }
      if (event2.type !== "timeupdate") {
        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      }
    });
    const disposeHandler = () => {
      this.stopTracking();
    };
    this.tech_.one("dispose", disposeHandler);
    if (mode !== "disabled") {
      this.startTracking();
    }
    Object.defineProperties(this, {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      default: {
        get() {
          return default_;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get() {
          return mode;
        },
        set(newMode) {
          if (!TextTrackMode[newMode]) {
            return;
          }
          if (mode === newMode) {
            return;
          }
          mode = newMode;
          if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
            loadTrack(this.src, this);
          }
          this.stopTracking();
          if (mode !== "disabled") {
            this.startTracking();
          }
          this.trigger("modechange");
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get() {
          if (!this.loaded_) {
            return null;
          }
          return cues;
        },
        set() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get() {
          if (!this.loaded_) {
            return null;
          }
          if (this.cues.length === 0) {
            return activeCues;
          }
          const ct = this.tech_.currentTime();
          const active = [];
          for (let i = 0, l = this.cues.length; i < l; i++) {
            const cue = this.cues[i];
            if (cue.startTime <= ct && cue.endTime >= ct) {
              active.push(cue);
            }
          }
          changed = false;
          if (active.length !== this.activeCues_.length) {
            changed = true;
          } else {
            for (let i = 0; i < active.length; i++) {
              if (this.activeCues_.indexOf(active[i]) === -1) {
                changed = true;
              }
            }
          }
          this.activeCues_ = active;
          activeCues.setCues_(this.activeCues_);
          return activeCues;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set() {
        }
      }
    });
    if (settings.src) {
      this.src = settings.src;
      if (!this.preload_) {
        this.loaded_ = true;
      }
      if (this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") {
        loadTrack(this.src, this);
      }
    } else {
      this.loaded_ = true;
    }
  }
  startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
    this.tech_.on("timeupdate", this.timeupdateHandler);
  }
  stopTracking() {
    if (this.rvf_) {
      this.tech_.cancelVideoFrameCallback(this.rvf_);
      this.rvf_ = void 0;
    }
    this.tech_.off("timeupdate", this.timeupdateHandler);
  }
  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */
  addCue(originalCue) {
    let cue = originalCue;
    if (!("getCueAsHTML" in cue)) {
      cue = new window$1$1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
      for (const prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }
    const tracks = this.tech_.textTracks();
    for (let i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  }
  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */
  removeCue(removeCue) {
    let i = this.cues_.length;
    while (i--) {
      const cue = this.cues_[i];
      if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  }
}
TextTrack.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
class AudioTrack extends Track {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  constructor(options = {}) {
    const settings = merge$1(options, {
      kind: AudioTrackKind[options.kind] || ""
    });
    super(settings);
    let enabled = false;
    Object.defineProperty(this, "enabled", {
      get() {
        return enabled;
      },
      set(newEnabled) {
        if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;
        this.trigger("enabledchange");
      }
    });
    if (settings.enabled) {
      this.enabled = settings.enabled;
    }
    this.loaded_ = true;
  }
}
class VideoTrack extends Track {
  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  constructor(options = {}) {
    const settings = merge$1(options, {
      kind: VideoTrackKind[options.kind] || ""
    });
    super(settings);
    let selected = false;
    Object.defineProperty(this, "selected", {
      get() {
        return selected;
      },
      set(newSelected) {
        if (typeof newSelected !== "boolean" || newSelected === selected) {
          return;
        }
        selected = newSelected;
        this.trigger("selectedchange");
      }
    });
    if (settings.selected) {
      this.selected = settings.selected;
    }
  }
}
class HTMLTrackElement extends EventTarget$2 {
  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        version of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  constructor(options = {}) {
    super();
    let readyState;
    const track = new TextTrack(options);
    this.kind = track.kind;
    this.src = track.src;
    this.srclang = track.language;
    this.label = track.label;
    this.default = track.default;
    Object.defineProperties(this, {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get() {
          return readyState;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get() {
          return track;
        }
      }
    });
    readyState = HTMLTrackElement.NONE;
    track.addEventListener("loadeddata", () => {
      readyState = HTMLTrackElement.LOADED;
      this.trigger({
        type: "load",
        target: this
      });
    });
  }
}
HTMLTrackElement.prototype.allowedEvents_ = {
  load: "load"
};
HTMLTrackElement.NONE = 0;
HTMLTrackElement.LOADING = 1;
HTMLTrackElement.LOADED = 2;
HTMLTrackElement.ERROR = 3;
const NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: "Audio"
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: "Video"
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "Text"
  }
};
Object.keys(NORMAL).forEach(function(type) {
  NORMAL[type].getterName = `${type}Tracks`;
  NORMAL[type].privateName = `${type}Tracks_`;
});
const REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
};
const ALL = Object.assign({}, NORMAL, REMOTE);
REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
function createTrackHelper(self2, kind, label, language, options = {}) {
  const tracks = self2.textTracks();
  options.kind = kind;
  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self2;
  const track = new ALL.text.TrackClass(options);
  tracks.addTrack(track);
  return track;
}
class Tech extends Component$1 {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(options = {}, ready = function() {
  }) {
    options.reportTouchActivity = false;
    super(null, options, ready);
    this.onDurationChange_ = (e) => this.onDurationChange(e);
    this.trackProgress_ = (e) => this.trackProgress(e);
    this.trackCurrentTime_ = (e) => this.trackCurrentTime(e);
    this.stopTrackingCurrentTime_ = (e) => this.stopTrackingCurrentTime(e);
    this.disposeSourceHandler_ = (e) => this.disposeSourceHandler(e);
    this.queuedHanders_ = /* @__PURE__ */ new Set();
    this.hasStarted_ = false;
    this.on("playing", function() {
      this.hasStarted_ = true;
    });
    this.on("loadstart", function() {
      this.hasStarted_ = false;
    });
    ALL.names.forEach((name) => {
      const props = ALL[name];
      if (options && options[props.getterName]) {
        this[props.privateName] = options[props.getterName];
      }
    });
    if (!this.featuresProgressEvents) {
      this.manualProgressOn();
    }
    if (!this.featuresTimeupdateEvents) {
      this.manualTimeUpdatesOn();
    }
    ["Text", "Audio", "Video"].forEach((track) => {
      if (options[`native${track}Tracks`] === false) {
        this[`featuresNative${track}Tracks`] = false;
      }
    });
    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      this.featuresNativeTextTracks = true;
    }
    if (!this.featuresNativeTextTracks) {
      this.emulateTextTracks();
    }
    this.preloadTextTracks = options.preloadTextTracks !== false;
    this.autoRemoteTextTracks_ = new ALL.text.ListClass();
    this.initTrackListeners();
    if (!options.nativeControlsForTouch) {
      this.emitTapEvents();
    }
    if (this.constructor) {
      this.name_ = this.constructor.name || "Unknown Tech";
    }
  }
  /**
   * A special function to trigger source set in a way that will allow player
   * to re-trigger if the player or tech are not ready yet.
   *
   * @fires Tech#sourceset
   * @param {string} src The source string at the time of the source changing.
   */
  triggerSourceset(src) {
    if (!this.isReady_) {
      this.one("ready", () => this.setTimeout(() => this.triggerSourceset(src), 1));
    }
    this.trigger({
      src,
      type: "sourceset"
    });
  }
  /* Fallbacks for unsupported event types
  ================================================================================ */
  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */
  manualProgressOn() {
    this.on("durationchange", this.onDurationChange_);
    this.manualProgress = true;
    this.one("ready", this.trackProgress_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */
  manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();
    this.off("durationchange", this.onDurationChange_);
  }
  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */
  trackProgress(event2) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind_(this, function() {
      const numBufferedPercent = this.bufferedPercent();
      if (this.bufferedPercent_ !== numBufferedPercent) {
        this.trigger("progress");
      }
      this.bufferedPercent_ = numBufferedPercent;
      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  }
  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */
  onDurationChange(event2) {
    this.duration_ = this.duration();
  }
  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */
  buffered() {
    return createTimeRanges$1(0, 0);
  }
  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */
  bufferedPercent() {
    return bufferedPercent(this.buffered(), this.duration_);
  }
  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */
  stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  }
  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */
  manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;
    this.on("play", this.trackCurrentTime_);
    this.on("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */
  manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off("play", this.trackCurrentTime_);
    this.off("pause", this.stopTrackingCurrentTime_);
  }
  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */
  trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }, 250);
  }
  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */
  stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);
    this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
  }
  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */
  dispose() {
    this.clearTracks(NORMAL.names);
    if (this.manualProgress) {
      this.manualProgressOff();
    }
    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }
    super.dispose();
  }
  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */
  clearTracks(types) {
    types = [].concat(types);
    types.forEach((type) => {
      const list = this[`${type}Tracks`]() || [];
      let i = list.length;
      while (i--) {
        const track = list[i];
        if (type === "text") {
          this.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  }
  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */
  cleanupAutoTextTracks() {
    const list = this.autoRemoteTextTracks_ || [];
    let i = list.length;
    while (i--) {
      const track = list[i];
      this.removeRemoteTextTrack(track);
    }
  }
  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */
  reset() {
  }
  /**
   * Get the value of `crossOrigin` from the tech.
   *
   * @abstract
   *
   * @see {Html5#crossOrigin}
   */
  crossOrigin() {
  }
  /**
   * Set the value of `crossOrigin` on the tech.
   *
   * @abstract
   *
   * @param {string} crossOrigin the crossOrigin value
   * @see {Html5#setCrossOrigin}
   */
  setCrossOrigin() {
  }
  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */
  error(err) {
    if (err !== void 0) {
      this.error_ = new MediaError(err);
      this.trigger("error");
    }
    return this.error_;
  }
  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks whether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */
  played() {
    if (this.hasStarted_) {
      return createTimeRanges$1(0, 0);
    }
    return createTimeRanges$1();
  }
  /**
   * Start playback
   *
   * @abstract
   *
   * @see {Html5#play}
   */
  play() {
  }
  /**
   * Set whether we are scrubbing or not
   *
   * @abstract
   * @param {boolean} _isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   *
   * @see {Html5#setScrubbing}
   */
  setScrubbing(_isScrubbing) {
  }
  /**
   * Get whether we are scrubbing or not
   *
   * @abstract
   *
   * @see {Html5#scrubbing}
   */
  scrubbing() {
  }
  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @param {number} _seconds
   *        Set the current time of the media to this.
   * @fires Tech#timeupdate
   */
  setCurrentTime(_seconds) {
    if (this.manualTimeUpdates) {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }
  }
  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */
  initTrackListeners() {
    NORMAL.names.forEach((name) => {
      const props = NORMAL[name];
      const trackListChanges = () => {
        this.trigger(`${name}trackchange`);
      };
      const tracks = this[props.getterName]();
      tracks.addEventListener("removetrack", trackListChanges);
      tracks.addEventListener("addtrack", trackListChanges);
      this.on("dispose", () => {
        tracks.removeEventListener("removetrack", trackListChanges);
        tracks.removeEventListener("addtrack", trackListChanges);
      });
    });
  }
  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */
  addWebVttScript_() {
    if (window$1$1.WebVTT) {
      return;
    }
    if (document$1$1.body.contains(this.el())) {
      if (!this.options_["vtt.js"] && isPlain(vtt) && Object.keys(vtt).length > 0) {
        this.trigger("vttjsloaded");
        return;
      }
      const script2 = document$1$1.createElement("script");
      script2.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
      script2.onload = () => {
        this.trigger("vttjsloaded");
      };
      script2.onerror = () => {
        this.trigger("vttjserror");
      };
      this.on("dispose", () => {
        script2.onload = null;
        script2.onerror = null;
      });
      window$1$1.WebVTT = true;
      this.el().parentNode.appendChild(script2);
    } else {
      this.ready(this.addWebVttScript_);
    }
  }
  /**
   * Emulate texttracks
   *
   */
  emulateTextTracks() {
    const tracks = this.textTracks();
    const remoteTracks = this.remoteTextTracks();
    const handleAddTrack = (e) => tracks.addTrack(e.track);
    const handleRemoveTrack = (e) => tracks.removeTrack(e.track);
    remoteTracks.on("addtrack", handleAddTrack);
    remoteTracks.on("removetrack", handleRemoveTrack);
    this.addWebVttScript_();
    const updateDisplay = () => this.trigger("texttrackchange");
    const textTracksChanges = () => {
      updateDisplay();
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
        if (track.mode === "showing") {
          track.addEventListener("cuechange", updateDisplay);
        }
      }
    };
    textTracksChanges();
    tracks.addEventListener("change", textTracksChanges);
    tracks.addEventListener("addtrack", textTracksChanges);
    tracks.addEventListener("removetrack", textTracksChanges);
    this.on("dispose", function() {
      remoteTracks.off("addtrack", handleAddTrack);
      remoteTracks.off("removetrack", handleRemoveTrack);
      tracks.removeEventListener("change", textTracksChanges);
      tracks.removeEventListener("addtrack", textTracksChanges);
      tracks.removeEventListener("removetrack", textTracksChanges);
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
      }
    });
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error("TextTrack kind is required but was not provided");
    }
    return createTrackHelper(this, kind, label, language);
  }
  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(options) {
    const track = merge$1(options, {
      tech: this
    });
    return new REMOTE.remoteTextEl.TrackClass(track);
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=false]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   */
  addRemoteTextTrack(options = {}, manualCleanup) {
    const htmlTrackElement = this.createRemoteTextTrack(options);
    if (typeof manualCleanup !== "boolean") {
      manualCleanup = false;
    }
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);
    if (manualCleanup === false) {
      this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));
    }
    return htmlTrackElement;
  }
  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */
  removeRemoteTextTrack(track) {
    const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */
  getVideoPlaybackQuality() {
    return {};
  }
  /**
   * Attempt to create a floating video window always on top of other windows
   * so that users may continue consuming media while they interact with other
   * content sites, or applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise|undefined}
   *         A promise with a Picture-in-Picture window if the browser supports
   *         Promises (or one was passed in as an option). It returns undefined
   *         otherwise.
   *
   * @abstract
   */
  requestPictureInPicture() {
    return Promise.reject();
  }
  /**
   * A method to check for the value of the 'disablePictureInPicture' <video> property.
   * Defaults to true, as it should be considered disabled if the tech does not support pip
   *
   * @abstract
   */
  disablePictureInPicture() {
    return true;
  }
  /**
   * A method to set or unset the 'disablePictureInPicture' <video> property.
   *
   * @abstract
   */
  setDisablePictureInPicture() {
  }
  /**
   * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame
   *
   * @param {function} cb
   * @return {number} request id
   */
  requestVideoFrameCallback(cb) {
    const id = newGUID();
    if (!this.isReady_ || this.paused()) {
      this.queuedHanders_.add(id);
      this.one("playing", () => {
        if (this.queuedHanders_.has(id)) {
          this.queuedHanders_.delete(id);
          cb();
        }
      });
    } else {
      this.requestNamedAnimationFrame(id, cb);
    }
    return id;
  }
  /**
   * A fallback implementation of cancelVideoFrameCallback
   *
   * @param {number} id id of callback to be cancelled
   */
  cancelVideoFrameCallback(id) {
    if (this.queuedHanders_.has(id)) {
      this.queuedHanders_.delete(id);
    } else {
      this.cancelNamedAnimationFrame(id);
    }
  }
  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */
  setPoster() {
  }
  /**
   * A method to check for the presence of the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  playsinline() {
  }
  /**
   * A method to set or unset the 'playsinline' <video> attribute.
   *
   * @abstract
   */
  setPlaysinline() {
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   *
   * @abstract
   */
  overrideNativeAudioTracks(override) {
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   *
   * @abstract
   */
  overrideNativeVideoTracks(override) {
  }
  /**
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} _type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */
  canPlayType(_type) {
    return "";
  }
  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} _type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */
  static canPlayType(_type) {
    return "";
  }
  /**
   * Check if the tech can support the given source
   *
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */
  static canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  }
  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */
  static isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  }
  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */
  static registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }
    if (!Tech.isTech(tech)) {
      throw new Error(`Tech ${name} must be a Tech`);
    }
    if (!Tech.canPlayType) {
      throw new Error("Techs must have a static canPlayType method on them");
    }
    if (!Tech.canPlaySource) {
      throw new Error("Techs must have a static canPlaySource method on them");
    }
    name = toTitleCase$1(name);
    Tech.techs_[name] = tech;
    Tech.techs_[toLowerCase(name)] = tech;
    if (name !== "Tech") {
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  }
  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requested.
   */
  static getTech(name) {
    if (!name) {
      return;
    }
    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }
    name = toTitleCase$1(name);
    if (window$1$1 && window$1$1.videojs && window$1$1.videojs[name]) {
      log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
      return window$1$1.videojs[name];
    }
  }
}
ALL.names.forEach(function(name) {
  const props = ALL[name];
  Tech.prototype[props.getterName] = function() {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Tech.prototype.featuresVolumeControl = true;
Tech.prototype.featuresMuteControl = true;
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresSourceset = false;
Tech.prototype.featuresTimeupdateEvents = false;
Tech.prototype.featuresNativeTextTracks = false;
Tech.prototype.featuresVideoFrameCallback = false;
Tech.withSourceHandlers = function(_Tech) {
  _Tech.registerSourceHandler = function(handler, index) {
    let handlers = _Tech.sourceHandlers;
    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }
    if (index === void 0) {
      index = handlers.length;
    }
    handlers.splice(index, 0, handler);
  };
  _Tech.canPlayType = function(type) {
    const handlers = _Tech.sourceHandlers || [];
    let can;
    for (let i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);
      if (can) {
        return can;
      }
    }
    return "";
  };
  _Tech.selectSourceHandler = function(source, options) {
    const handlers = _Tech.sourceHandlers || [];
    let can;
    for (let i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);
      if (can) {
        return handlers[i];
      }
    }
    return null;
  };
  _Tech.canPlaySource = function(srcObj, options) {
    const sh = _Tech.selectSourceHandler(srcObj, options);
    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }
    return "";
  };
  const deferrable = ["seekable", "seeking", "duration"];
  deferrable.forEach(function(fnName) {
    const originalFn = this[fnName];
    if (typeof originalFn !== "function") {
      return;
    }
    this[fnName] = function() {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);
  _Tech.prototype.setSource = function(source) {
    let sh = _Tech.selectSourceHandler(source, this.options_);
    if (!sh) {
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error("No source handler found for the current source.");
      }
    }
    this.disposeSourceHandler();
    this.off("dispose", this.disposeSourceHandler_);
    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }
    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.one("dispose", this.disposeSourceHandler_);
  };
  _Tech.prototype.disposeSourceHandler = function() {
    if (this.currentSource_) {
      this.clearTracks(["audio", "video"]);
      this.currentSource_ = null;
    }
    this.cleanupAutoTextTracks();
    if (this.sourceHandler_) {
      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }
      this.sourceHandler_ = null;
    }
  };
};
Component$1.registerComponent("Tech", Tech);
Tech.registerTech("Tech", Tech);
Tech.defaultTechOrder_ = [];
const middlewares = {};
const middlewareInstances = {};
const TERMINATOR = {};
function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}
function setSource(player, src, next) {
  player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);
}
function setTech(middleware, tech) {
  middleware.forEach((mw) => mw.setTech && mw.setTech(tech));
}
function get(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}
function set(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}
function mediate(middleware, tech, method, arg = null) {
  const callMethod = "call" + toTitleCase$1(method);
  const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
  const terminated = middlewareValue === TERMINATOR;
  const returnValue = terminated ? null : tech[method](middlewareValue);
  executeRight(middleware, method, returnValue, terminated);
  return returnValue;
}
const allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
};
const allowedSetters = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
};
const allowedMediators = {
  play: 1,
  pause: 1
};
function middlewareIterator(method) {
  return (value2, mw) => {
    if (value2 === TERMINATOR) {
      return TERMINATOR;
    }
    if (mw[method]) {
      return mw[method](value2);
    }
    return value2;
  };
}
function executeRight(mws, method, value2, terminated) {
  for (let i = mws.length - 1; i >= 0; i--) {
    const mw = mws[i];
    if (mw[method]) {
      mw[method](terminated, value2);
    }
  }
}
function clearCacheForPlayer(player) {
  if (middlewareInstances.hasOwnProperty(player.id())) {
    delete middlewareInstances[player.id()];
  }
}
function getOrCreateFactory(player, mwFactory) {
  const mws = middlewareInstances[player.id()];
  let mw = null;
  if (mws === void 0 || mws === null) {
    mw = mwFactory(player);
    middlewareInstances[player.id()] = [[mwFactory, mw]];
    return mw;
  }
  for (let i = 0; i < mws.length; i++) {
    const [mwf, mwi] = mws[i];
    if (mwf !== mwFactory) {
      continue;
    }
    mw = mwi;
  }
  if (mw === null) {
    mw = mwFactory(player);
    mws.push([mwFactory, mw]);
  }
  return mw;
}
function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
  const [mwFactory, ...mwrest] = middleware;
  if (typeof mwFactory === "string") {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);
  } else if (mwFactory) {
    const mw = getOrCreateFactory(player, mwFactory);
    if (!mw.setSource) {
      acc.push(mw);
      return setSourceHelper(src, mwrest, next, player, acc, lastRun);
    }
    mw.setSource(Object.assign({}, src), function(err, _src) {
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }
      acc.push(mw);
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares["*"], next, player, acc, true);
  }
}
const MimetypesKind = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
};
const getMimetype = function(src = "") {
  const ext = getFileExtension(src);
  const mimetype = MimetypesKind[ext.toLowerCase()];
  return mimetype || "";
};
const findMimetype = (player, src) => {
  if (!src) {
    return "";
  }
  if (player.cache_.source.src === src && player.cache_.source.type) {
    return player.cache_.source.type;
  }
  const matchingSources = player.cache_.sources.filter((s) => s.src === src);
  if (matchingSources.length) {
    return matchingSources[0].type;
  }
  const sources = player.$$("source");
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    if (s.type && s.src && s.src === src) {
      return s.type;
    }
  }
  return getMimetype(src);
};
const filterSource = function(src) {
  if (Array.isArray(src)) {
    let newsrc = [];
    src.forEach(function(srcobj) {
      srcobj = filterSource(srcobj);
      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject$4(srcobj)) {
        newsrc.push(srcobj);
      }
    });
    src = newsrc;
  } else if (typeof src === "string" && src.trim()) {
    src = [fixSource({
      src
    })];
  } else if (isObject$4(src) && typeof src.src === "string" && src.src && src.src.trim()) {
    src = [fixSource(src)];
  } else {
    src = [];
  }
  return src;
};
function fixSource(src) {
  if (!src.type) {
    const mimetype = getMimetype(src.src);
    if (mimetype) {
      src.type = mimetype;
    }
  }
  return src;
}
var icons = '<svg xmlns="http://www.w3.org/2000/svg">\n  <defs>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play">\n      <path d="M16 10v28l22-14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">\n      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">\n      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">\n      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">\n      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">\n      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">\n      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">\n      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">\n      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">\n      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">\n      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">\n      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">\n      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>\n    </symbol>\n    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">\n      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">\n      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>\n    </symbol>\n    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">\n      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">\n      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">\n      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">\n      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-share">\n      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">\n      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-square">\n      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">\n      <circle cx="24" cy="24" r="20"></circle>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">\n      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">\n      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">\n      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">\n      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">\n      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">\n      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">\n      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">\n      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">\n      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>\n    </symbol>\n    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">\n      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>\n    </symbol>\n    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">\n      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">\n      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">\n      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">\n      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">\n      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>\n    </symbol>\n    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">\n      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">\n      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>\n      <path fill="none" d="M-1-3h24v24H-1z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">\n      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">\n      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1200 1227" id="vjs-icon-twitter">\n      <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"/>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">\n      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>\n    </symbol>\n    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">\n      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>\n    </symbol>\n  </defs>\n</svg>';
const backKeyCode = IS_TIZEN ? 10009 : IS_WEBOS ? 461 : 8;
const SpatialNavKeyCodes = {
  codes: {
    play: 415,
    pause: 19,
    ff: 417,
    rw: 412,
    back: backKeyCode
  },
  names: {
    415: "play",
    19: "pause",
    417: "ff",
    412: "rw",
    [backKeyCode]: "back"
  },
  isEventKey(event2, keyName) {
    keyName = keyName.toLowerCase();
    if (this.names[event2.keyCode] && this.names[event2.keyCode] === keyName) {
      return true;
    }
    return false;
  },
  getEventName(event2) {
    if (this.names[event2.keyCode]) {
      return this.names[event2.keyCode];
    } else if (this.codes[event2.code]) {
      const code = this.codes[event2.code];
      return this.names[code];
    }
    return null;
  }
};
const STEP_SECONDS$1 = 5;
class SpatialNavigation extends EventTarget$2 {
  /**
   * Constructs a SpatialNavigation instance with initial settings.
   * Sets up the player instance, and prepares the spatial navigation system.
   *
   * @class
   * @param {Player} player - The Video.js player instance to which the spatial navigation is attached.
   */
  constructor(player) {
    super();
    this.player_ = player;
    this.focusableComponents = [];
    this.isListening_ = false;
    this.isPaused_ = false;
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.lastFocusedComponent_ = null;
  }
  /**
   * Starts the spatial navigation by adding a keydown event listener to the video container.
   * This method ensures that the event listener is added only once.
   */
  start() {
    if (this.isListening_) {
      return;
    }
    this.player_.on("keydown", this.onKeyDown_);
    this.player_.on("modalKeydown", this.onKeyDown_);
    this.player_.on("loadedmetadata", () => {
      this.focus(this.updateFocusableComponents()[0]);
    });
    this.player_.on("modalclose", () => {
      this.refocusComponent();
    });
    this.player_.on("focusin", this.handlePlayerFocus_.bind(this));
    this.player_.on("focusout", this.handlePlayerBlur_.bind(this));
    this.isListening_ = true;
    this.player_.errorDisplay.on("aftermodalfill", () => {
      this.updateFocusableComponents();
      if (this.focusableComponents.length) {
        if (this.focusableComponents.length > 1) {
          this.focusableComponents[1].focus();
        } else {
          this.focusableComponents[0].focus();
        }
      }
    });
  }
  /**
   * Stops the spatial navigation by removing the keydown event listener from the video container.
   * Also sets the `isListening_` flag to false.
   */
  stop() {
    this.player_.off("keydown", this.onKeyDown_);
    this.isListening_ = false;
  }
  /**
   * Responds to keydown events for spatial navigation and media control.
   *
   * Determines if spatial navigation or media control is active and handles key inputs accordingly.
   *
   * @param {KeyboardEvent} event - The keydown event to be handled.
   */
  onKeyDown_(event2) {
    const actualEvent = event2.originalEvent ? event2.originalEvent : event2;
    if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(actualEvent.key)) {
      if (this.isPaused_) {
        return;
      }
      actualEvent.preventDefault();
      const direction = actualEvent.key.substring(5).toLowerCase();
      this.move(direction);
    } else if (SpatialNavKeyCodes.isEventKey(actualEvent, "play") || SpatialNavKeyCodes.isEventKey(actualEvent, "pause") || SpatialNavKeyCodes.isEventKey(actualEvent, "ff") || SpatialNavKeyCodes.isEventKey(actualEvent, "rw")) {
      actualEvent.preventDefault();
      const action = SpatialNavKeyCodes.getEventName(actualEvent);
      this.performMediaAction_(action);
    } else if (SpatialNavKeyCodes.isEventKey(actualEvent, "Back") && event2.target && event2.target.closeable()) {
      actualEvent.preventDefault();
      event2.target.close();
    }
  }
  /**
   * Performs media control actions based on the given key input.
   *
   * Controls the playback and seeking functionalities of the media player.
   *
   * @param {string} key - The key representing the media action to be performed.
   *   Accepted keys: 'play', 'pause', 'ff' (fast-forward), 'rw' (rewind).
   */
  performMediaAction_(key) {
    if (this.player_) {
      switch (key) {
        case "play":
          if (this.player_.paused()) {
            this.player_.play();
          }
          break;
        case "pause":
          if (!this.player_.paused()) {
            this.player_.pause();
          }
          break;
        case "ff":
          this.userSeek_(this.player_.currentTime() + STEP_SECONDS$1);
          break;
        case "rw":
          this.userSeek_(this.player_.currentTime() - STEP_SECONDS$1);
          break;
      }
    }
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(ct) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
      this.player_.liveTracker.nextSeekedFromUser();
    }
    this.player_.currentTime(ct);
  }
  /**
   * Pauses the spatial navigation functionality.
   * This method sets a flag that can be used to temporarily disable the navigation logic.
   */
  pause() {
    this.isPaused_ = true;
  }
  /**
   * Resumes the spatial navigation functionality if it has been paused.
   * This method resets the pause flag, re-enabling the navigation logic.
   */
  resume() {
    this.isPaused_ = false;
  }
  /**
   * Handles Player Blur.
   *
   * @param {string|Event|Object} event
   *        The name of the event, an `Event`, or an object with a key of type set to
   *        an event name.
   *
   * Calls for handling of the Player Blur if:
   * *The next focused element is not a child of current focused element &
   * The next focused element is not a child of the Player.
   * *There is no next focused element
   */
  handlePlayerBlur_(event2) {
    const nextFocusedElement = event2.relatedTarget;
    let isChildrenOfPlayer = null;
    const currentComponent = this.getCurrentComponent(event2.target);
    if (nextFocusedElement) {
      isChildrenOfPlayer = Boolean(nextFocusedElement.closest(".video-js"));
      if (nextFocusedElement.classList.contains("vjs-text-track-settings") && !this.isPaused_) {
        this.searchForTrackSelect_();
      }
    }
    if (!event2.currentTarget.contains(event2.relatedTarget) && !isChildrenOfPlayer || !nextFocusedElement) {
      if (currentComponent && currentComponent.name() === "CloseButton") {
        this.refocusComponent();
      } else {
        this.pause();
        if (currentComponent && currentComponent.el()) {
          this.lastFocusedComponent_ = currentComponent;
        }
      }
    }
  }
  /**
   * Handles the Player focus event.
   *
   * Calls for handling of the Player Focus if current element is focusable.
   */
  handlePlayerFocus_() {
    if (this.getCurrentComponent() && this.getCurrentComponent().getIsFocusable()) {
      this.resume();
    }
  }
  /**
   * Gets a set of focusable components.
   *
   * @return {Array}
   *         Returns an array of focusable components.
   */
  updateFocusableComponents() {
    const player = this.player_;
    const focusableComponents = [];
    function searchForChildrenCandidates(componentsArray) {
      for (const i of componentsArray) {
        if (i.hasOwnProperty("el_") && i.getIsFocusable() && i.getIsAvailableToBeFocused(i.el())) {
          focusableComponents.push(i);
        }
        if (i.hasOwnProperty("children_") && i.children_.length > 0) {
          searchForChildrenCandidates(i.children_);
        }
      }
    }
    player.children_.forEach((value2) => {
      if (value2.hasOwnProperty("el_")) {
        if (value2.getIsFocusable && value2.getIsAvailableToBeFocused && value2.getIsFocusable() && value2.getIsAvailableToBeFocused(value2.el())) {
          focusableComponents.push(value2);
          return;
        } else if (value2.hasOwnProperty("children_") && value2.children_.length > 0) {
          searchForChildrenCandidates(value2.children_);
        } else if (value2.hasOwnProperty("items") && value2.items.length > 0) {
          searchForChildrenCandidates(value2.items);
        } else if (this.findSuitableDOMChild(value2)) {
          focusableComponents.push(value2);
        }
      }
      if (value2.name_ === "ErrorDisplay" && value2.opened_) {
        const buttonContainer = value2.el_.querySelector(".vjs-errors-ok-button-container");
        if (buttonContainer) {
          const modalButtons = buttonContainer.querySelectorAll("button");
          modalButtons.forEach((element, index) => {
            focusableComponents.push({
              name: () => {
                return "ModalButton" + (index + 1);
              },
              el: () => element,
              getPositions: () => {
                const rect = element.getBoundingClientRect();
                const boundingClientRect = {
                  x: rect.x,
                  y: rect.y,
                  width: rect.width,
                  height: rect.height,
                  top: rect.top,
                  right: rect.right,
                  bottom: rect.bottom,
                  left: rect.left
                };
                const center = {
                  x: rect.left + rect.width / 2,
                  y: rect.top + rect.height / 2,
                  width: 0,
                  height: 0,
                  top: rect.top + rect.height / 2,
                  right: rect.left + rect.width / 2,
                  bottom: rect.top + rect.height / 2,
                  left: rect.left + rect.width / 2
                };
                return {
                  boundingClientRect,
                  center
                };
              },
              // Asume that the following are always focusable
              getIsAvailableToBeFocused: () => true,
              getIsFocusable: (el) => true,
              focus: () => element.focus()
            });
          });
        }
      }
    });
    this.focusableComponents = focusableComponents;
    return this.focusableComponents;
  }
  /**
   * Finds a suitable child element within the provided component's DOM element.
   *
   * @param {Object} component - The component containing the DOM element to search within.
   * @return {HTMLElement|null} Returns the suitable child element if found, or null if not found.
   */
  findSuitableDOMChild(component) {
    function searchForSuitableChild(node) {
      if (component.getIsFocusable(node) && component.getIsAvailableToBeFocused(node)) {
        return node;
      }
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const suitableChild = searchForSuitableChild(child);
        if (suitableChild) {
          return suitableChild;
        }
      }
      return null;
    }
    if (component.el()) {
      return searchForSuitableChild(component.el());
    }
    return null;
  }
  /**
   * Gets the currently focused component from the list of focusable components.
   * If a target element is provided, it uses that element to find the corresponding
   * component. If no target is provided, it defaults to using the document's currently
   * active element.
   *
   * @param {HTMLElement} [target] - The DOM element to check against the focusable components.
   *                                 If not provided, `document.activeElement` is used.
   * @return {Component|null} - Returns the focused component if found among the focusable components,
   *                            otherwise returns null if no matching component is found.
   */
  getCurrentComponent(target) {
    this.updateFocusableComponents();
    const curComp = target || document.activeElement;
    if (this.focusableComponents.length) {
      for (const i of this.focusableComponents) {
        if (i.el() === curComp) {
          return i;
        }
      }
    }
  }
  /**
   * Adds a component to the array of focusable components.
   *
   * @param {Component} component
   *        The `Component` to be added.
   */
  add(component) {
    const focusableComponents = [...this.focusableComponents];
    if (component.hasOwnProperty("el_") && component.getIsFocusable() && component.getIsAvailableToBeFocused(component.el())) {
      focusableComponents.push(component);
    }
    this.focusableComponents = focusableComponents;
    this.trigger({
      type: "focusableComponentsChanged",
      focusableComponents: this.focusableComponents
    });
  }
  /**
   * Removes component from the array of focusable components.
   *
   * @param {Component} component - The component to be removed from the focusable components array.
   */
  remove(component) {
    for (let i = 0; i < this.focusableComponents.length; i++) {
      if (this.focusableComponents[i].name() === component.name()) {
        this.focusableComponents.splice(i, 1);
        this.trigger({
          type: "focusableComponentsChanged",
          focusableComponents: this.focusableComponents
        });
        return;
      }
    }
  }
  /**
   * Clears array of focusable components.
   */
  clear() {
    if (this.focusableComponents.length > 0) {
      this.focusableComponents = [];
      this.trigger({
        type: "focusableComponentsChanged",
        focusableComponents: this.focusableComponents
      });
    }
  }
  /**
   * Navigates to the next focusable component based on the specified direction.
   *
   * @param {string} direction 'up', 'down', 'left', 'right'
   */
  move(direction) {
    const currentFocusedComponent = this.getCurrentComponent();
    if (!currentFocusedComponent) {
      return;
    }
    const currentPositions = currentFocusedComponent.getPositions();
    const candidates = this.focusableComponents.filter((component) => component !== currentFocusedComponent && this.isInDirection_(currentPositions.boundingClientRect, component.getPositions().boundingClientRect, direction));
    const bestCandidate = this.findBestCandidate_(currentPositions.center, candidates, direction);
    if (bestCandidate) {
      this.focus(bestCandidate);
    } else {
      this.trigger({
        type: "endOfFocusableComponents",
        direction,
        focusedComponent: currentFocusedComponent
      });
    }
  }
  /**
   * Finds the best candidate on the current center position,
   * the list of candidates, and the specified navigation direction.
   *
   * @param {Object} currentCenter The center position of the current focused component element.
   * @param {Array} candidates An array of candidate components to receive focus.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {Object|null} The component that is the best candidate for receiving focus.
   */
  findBestCandidate_(currentCenter, candidates, direction) {
    let minDistance = Infinity;
    let bestCandidate = null;
    for (const candidate of candidates) {
      const candidateCenter = candidate.getPositions().center;
      const distance = this.calculateDistance_(currentCenter, candidateCenter, direction);
      if (distance < minDistance) {
        minDistance = distance;
        bestCandidate = candidate;
      }
    }
    return bestCandidate;
  }
  /**
   * Determines if a target rectangle is in the specified navigation direction
   * relative to a source rectangle.
   *
   * @param {Object} srcRect The bounding rectangle of the source element.
   * @param {Object} targetRect The bounding rectangle of the target element.
   * @param {string} direction The navigation direction ('up', 'down', 'left', 'right').
   * @return {boolean} True if the target is in the specified direction relative to the source.
   */
  isInDirection_(srcRect, targetRect, direction) {
    switch (direction) {
      case "right":
        return targetRect.left >= srcRect.right;
      case "left":
        return targetRect.right <= srcRect.left;
      case "down":
        return targetRect.top >= srcRect.bottom;
      case "up":
        return targetRect.bottom <= srcRect.top;
      default:
        return false;
    }
  }
  /**
   * Focus the last focused component saved before blur on player.
   */
  refocusComponent() {
    if (this.lastFocusedComponent_) {
      if (!this.player_.userActive()) {
        this.player_.userActive(true);
      }
      this.updateFocusableComponents();
      for (let i = 0; i < this.focusableComponents.length; i++) {
        if (this.focusableComponents[i].name() === this.lastFocusedComponent_.name()) {
          this.focus(this.focusableComponents[i]);
          return;
        }
      }
    } else {
      this.focus(this.updateFocusableComponents()[0]);
    }
  }
  /**
   * Focuses on a given component.
   * If the component is available to be focused, it focuses on the component.
   * If not, it attempts to find a suitable DOM child within the component and focuses on it.
   *
   * @param {Component} component - The component to be focused.
   */
  focus(component) {
    if (typeof component !== "object") {
      return;
    }
    if (component.getIsAvailableToBeFocused(component.el())) {
      component.focus();
    } else if (this.findSuitableDOMChild(component)) {
      this.findSuitableDOMChild(component).focus();
    }
  }
  /**
   * Calculates the distance between two points, adjusting the calculation based on
   * the specified navigation direction.
   *
   * @param {Object} center1 The center point of the first element.
   * @param {Object} center2 The center point of the second element.
   * @param {string} direction The direction of navigation ('up', 'down', 'left', 'right').
   * @return {number} The calculated distance between the two centers.
   */
  calculateDistance_(center1, center2, direction) {
    const dx = Math.abs(center1.x - center2.x);
    const dy = Math.abs(center1.y - center2.y);
    let distance;
    switch (direction) {
      case "right":
      case "left":
        distance = dx + dy * 100;
        break;
      case "up":
        distance = dy * 2 + dx * 0.5;
        break;
      case "down":
        distance = dy * 5 + dx;
        break;
      default:
        distance = dx + dy;
    }
    return distance;
  }
  /**
   * This gets called by 'handlePlayerBlur_' if 'spatialNavigation' is enabled.
   * Searches for the first 'TextTrackSelect' inside of modal to focus.
   *
   * @private
   */
  searchForTrackSelect_() {
    const spatialNavigation = this;
    for (const component of spatialNavigation.updateFocusableComponents()) {
      if (component.constructor.name === "TextTrackSelect") {
        spatialNavigation.focus(component);
        break;
      }
    }
  }
}
class MediaLoader extends Component$1 {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function that is run when this component is ready.
   */
  constructor(player, options, ready) {
    const options_ = merge$1({
      createEl: false
    }, options);
    super(player, options_, ready);
    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        const techName = toTitleCase$1(j[i]);
        let tech = Tech.getTech(techName);
        if (!techName) {
          tech = Component$1.getComponent(techName);
        }
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      player.src(options.playerOptions.sources);
    }
  }
}
Component$1.registerComponent("MediaLoader", MediaLoader);
class ClickableComponent extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of component options.
   *
   * @param  {function} [options.clickHandler]
   *         The function to call when the button is clicked / activated
   *
   * @param  {string} [options.controlText]
   *         The text to set on the button
   *
   * @param  {string} [options.className]
   *         A class or space separated list of classes to add the component
   *
   */
  constructor(player, options) {
    super(player, options);
    if (this.options_.controlText) {
      this.controlText(this.options_.controlText);
    }
    this.handleMouseOver_ = (e) => this.handleMouseOver(e);
    this.handleMouseOut_ = (e) => this.handleMouseOut(e);
    this.handleClick_ = (e) => this.handleClick(e);
    this.handleKeyDown_ = (e) => this.handleKeyDown(e);
    this.emitTapEvents();
    this.enable();
  }
  /**
   * Create the `ClickableComponent`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(tag = "div", props = {}, attributes = {}) {
    props = Object.assign({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);
    if (tag === "button") {
      log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);
    }
    attributes = Object.assign({
      role: "button"
    }, attributes);
    this.tabIndex_ = props.tabIndex;
    const el = createEl(tag, props, attributes);
    if (!this.player_.options_.experimentalSvgIcons) {
      el.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
    }
    this.createControlTextEl(el);
    return el;
  }
  dispose() {
    this.controlTextEl_ = null;
    super.dispose();
  }
  /**
   * Create a control text element on this `ClickableComponent`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */
  createControlTextEl(el) {
    this.controlTextEl_ = createEl("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    });
    if (el) {
      el.appendChild(this.controlTextEl_);
    }
    this.controlText(this.controlText_, el);
    return this.controlTextEl_;
  }
  /**
   * Get or set the localize text to use for the controls on the `ClickableComponent`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(text2, el = this.el()) {
    if (text2 === void 0) {
      return this.controlText_ || "Need Text";
    }
    const localizedText = this.localize(text2);
    this.controlText_ = text2;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
      el.setAttribute("title", localizedText);
    }
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-control vjs-button ${super.buildCSSClass()}`;
  }
  /**
   * Enable this `ClickableComponent`
   */
  enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass("vjs-disabled");
      this.el_.setAttribute("aria-disabled", "false");
      if (typeof this.tabIndex_ !== "undefined") {
        this.el_.setAttribute("tabIndex", this.tabIndex_);
      }
      this.on(["tap", "click"], this.handleClick_);
      this.on("keydown", this.handleKeyDown_);
    }
  }
  /**
   * Disable this `ClickableComponent`
   */
  disable() {
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.el_.setAttribute("aria-disabled", "true");
    if (typeof this.tabIndex_ !== "undefined") {
      this.el_.removeAttribute("tabIndex");
    }
    this.off("mouseover", this.handleMouseOver_);
    this.off("mouseout", this.handleMouseOut_);
    this.off(["tap", "click"], this.handleClick_);
    this.off("keydown", this.handleKeyDown_);
  }
  /**
   * Handles language change in ClickableComponent for the player in components
   *
   *
   */
  handleLanguagechange() {
    this.controlText(this.controlText_);
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `click` or `tap` event.
   *
   * @param {Event} event
   *        The `tap` or `click` event that caused this function to be called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */
  handleClick(event2) {
    if (this.options_.clickHandler) {
      this.options_.clickHandler.call(this, arguments);
    }
  }
  /**
   * Event handler that is called when a `ClickableComponent` receives a
   * `keydown` event.
   *
   * By default, if the key is Space or Enter, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (event2.key === " " || event2.key === "Enter") {
      event2.preventDefault();
      event2.stopPropagation();
      this.trigger("click");
    } else {
      super.handleKeyDown(event2);
    }
  }
}
Component$1.registerComponent("ClickableComponent", ClickableComponent);
class PosterImage extends ClickableComponent {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.update();
    this.update_ = (e) => this.update(e);
    player.on("posterchange", this.update_);
  }
  /**
   * Clean up and dispose of the `PosterImage`.
   */
  dispose() {
    this.player().off("posterchange", this.update_);
    super.dispose();
  }
  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return createEl("div", {
      className: "vjs-poster"
    });
  }
  /**
   * Get or set the `PosterImage`'s crossOrigin option.
   *
   * @param {string|null} [value]
   *        The value to set the crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(value2) {
    if (typeof value2 === "undefined") {
      if (this.$("img")) {
        return this.$("img").crossOrigin;
      } else if (this.player_.tech_ && this.player_.tech_.isReady_) {
        return this.player_.crossOrigin();
      }
      return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
    }
    if (value2 !== null && value2 !== "anonymous" && value2 !== "use-credentials") {
      this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value2}"`);
      return;
    }
    if (this.$("img")) {
      this.$("img").crossOrigin = value2;
    }
    return;
  }
  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */
  update(event2) {
    const url2 = this.player().poster();
    this.setSrc(url2);
    if (url2) {
      this.show();
    } else {
      this.hide();
    }
  }
  /**
   * Set the source of the `PosterImage` depending on the display method. (Re)creates
   * the inner picture and img elementss when needed.
   *
   * @param {string} [url]
   *        The URL to the source for the `PosterImage`. If not specified or falsy,
   *        any source and ant inner picture/img are removed.
   */
  setSrc(url2) {
    if (!url2) {
      this.el_.textContent = "";
      return;
    }
    if (!this.$("img")) {
      this.el_.appendChild(createEl("picture", {
        className: "vjs-poster",
        // Don't want poster to be tabbable.
        tabIndex: -1
      }, {}, createEl("img", {
        loading: "lazy",
        crossOrigin: this.crossOrigin()
      }, {
        alt: ""
      })));
    }
    this.$("img").src = url2;
  }
  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */
  handleClick(event2) {
    if (!this.player_.controls()) {
      return;
    }
    if (this.player_.tech(true)) {
      this.player_.tech(true).focus();
    }
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  }
}
PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;
Component$1.registerComponent("PosterImage", PosterImage);
const darkGray = "#222";
const lightGray = "#ccc";
const fontMap = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function constructColor(color, opacity) {
  let hex;
  if (color.length === 4) {
    hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
  } else if (color.length === 7) {
    hex = color.slice(1);
  } else {
    throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
  }
  return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
}
function tryUpdateStyle(el, style2, rule) {
  try {
    el.style[style2] = rule;
  } catch (e) {
    return;
  }
}
function getCSSPositionValue(position2) {
  return position2 ? `${position2}px` : "";
}
class TextTrackDisplay extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  constructor(player, options, ready) {
    super(player, options, ready);
    const updateDisplayTextHandler = (e) => this.updateDisplay(e);
    const updateDisplayHandler = (e) => {
      this.updateDisplayOverlay();
      this.updateDisplay(e);
    };
    player.on("loadstart", (e) => this.toggleDisplay(e));
    player.on("texttrackchange", updateDisplayTextHandler);
    player.on("loadedmetadata", (e) => {
      this.updateDisplayOverlay();
      this.preselectTrack(e);
    });
    player.ready(bind_(this, function() {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      player.on("fullscreenchange", updateDisplayHandler);
      player.on("playerresize", updateDisplayHandler);
      const screenOrientation = window$1$1.screen.orientation || window$1$1;
      const changeOrientationEvent = window$1$1.screen.orientation ? "change" : "orientationchange";
      screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);
      player.on("dispose", () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));
      const tracks = this.options_.playerOptions.tracks || [];
      for (let i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }
      this.preselectTrack();
    }));
  }
  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */
  preselectTrack() {
    const modes = {
      captions: 1,
      subtitles: 1
    };
    const trackList = this.player_.textTracks();
    const userPref = this.player_.cache_.selectedLanguage;
    let firstDesc;
    let firstCaptions;
    let preferredTrack;
    for (let i = 0; i < trackList.length; i++) {
      const track = trackList[i];
      if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
        if (track.kind === userPref.kind) {
          preferredTrack = track;
        } else if (!preferredTrack) {
          preferredTrack = track;
        }
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track.default) {
        if (track.kind === "descriptions" && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }
    if (preferredTrack) {
      preferredTrack.mode = "showing";
    } else if (firstCaptions) {
      firstCaptions.mode = "showing";
    } else if (firstDesc) {
      firstDesc.mode = "showing";
    }
  }
  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */
  toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-text-track-display"
    }, {
      "translate": "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  }
  /**
   * Clear all displayed {@link TextTrack}s.
   */
  clearDisplay() {
    if (typeof window$1$1.WebVTT === "function") {
      window$1$1.WebVTT.processCues(window$1$1, [], this.el_);
    }
  }
  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */
  updateDisplay() {
    const tracks = this.player_.textTracks();
    const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
    this.clearDisplay();
    if (allowMultipleShowingTracks) {
      const showingTracks = [];
      for (let i2 = 0; i2 < tracks.length; ++i2) {
        const track = tracks[i2];
        if (track.mode !== "showing") {
          continue;
        }
        showingTracks.push(track);
      }
      this.updateForTrack(showingTracks);
      return;
    }
    let descriptionsTrack = null;
    let captionsSubtitlesTrack = null;
    let i = tracks.length;
    while (i--) {
      const track = tracks[i];
      if (track.mode === "showing") {
        if (track.kind === "descriptions") {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }
    if (captionsSubtitlesTrack) {
      if (this.getAttribute("aria-live") !== "off") {
        this.setAttribute("aria-live", "off");
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute("aria-live") !== "assertive") {
        this.setAttribute("aria-live", "assertive");
      }
      this.updateForTrack(descriptionsTrack);
    }
  }
  /**
   * Updates the displayed TextTrack to be sure it overlays the video when a either
   * a {@link Player#texttrackchange} or a {@link Player#fullscreenchange} is fired.
   */
  updateDisplayOverlay() {
    if (!this.player_.videoHeight() || !window$1$1.CSS.supports("inset-inline: 10px")) {
      return;
    }
    const playerWidth = this.player_.currentWidth();
    const playerHeight = this.player_.currentHeight();
    const playerAspectRatio = playerWidth / playerHeight;
    const videoAspectRatio = this.player_.videoWidth() / this.player_.videoHeight();
    let insetInlineMatch = 0;
    let insetBlockMatch = 0;
    if (Math.abs(playerAspectRatio - videoAspectRatio) > 0.1) {
      if (playerAspectRatio > videoAspectRatio) {
        insetInlineMatch = Math.round((playerWidth - playerHeight * videoAspectRatio) / 2);
      } else {
        insetBlockMatch = Math.round((playerHeight - playerWidth / videoAspectRatio) / 2);
      }
    }
    tryUpdateStyle(this.el_, "insetInline", getCSSPositionValue(insetInlineMatch));
    tryUpdateStyle(this.el_, "insetBlock", getCSSPositionValue(insetBlockMatch));
  }
  /**
   * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.
   *
   * @param {TextTrack} track
   *        Text track object containing active cues to style.
   */
  updateDisplayState(track) {
    const overrides = this.player_.textTrackSettings.getValues();
    const cues = track.activeCues;
    let i = cues.length;
    while (i--) {
      const cue = cues[i];
      if (!cue) {
        continue;
      }
      const cueDiv = cue.displayState;
      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === "dropshadow") {
          cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;
        } else if (overrides.edgeStyle === "raised") {
          cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;
        } else if (overrides.edgeStyle === "depressed") {
          cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;
        } else if (overrides.edgeStyle === "uniform") {
          cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        const fontSize = window$1$1.parseFloat(cueDiv.style.fontSize);
        cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
        cueDiv.style.height = "auto";
        cueDiv.style.top = "auto";
      }
      if (overrides.fontFamily && overrides.fontFamily !== "default") {
        if (overrides.fontFamily === "small-caps") {
          cueDiv.firstChild.style.fontVariant = "small-caps";
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  }
  /**
   * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack|TextTrack[]} tracks
   *        Text track object or text track array to be added to the list.
   */
  updateForTrack(tracks) {
    if (!Array.isArray(tracks)) {
      tracks = [tracks];
    }
    if (typeof window$1$1.WebVTT !== "function" || tracks.every((track) => {
      return !track.activeCues;
    })) {
      return;
    }
    const cues = [];
    for (let i = 0; i < tracks.length; ++i) {
      const track = tracks[i];
      for (let j = 0; j < track.activeCues.length; ++j) {
        cues.push(track.activeCues[j]);
      }
    }
    window$1$1.WebVTT.processCues(window$1$1, cues, this.el_);
    for (let i = 0; i < tracks.length; ++i) {
      const track = tracks[i];
      for (let j = 0; j < track.activeCues.length; ++j) {
        const cueEl = track.activeCues[j].displayState;
        addClass(cueEl, "vjs-text-track-cue", "vjs-text-track-cue-" + (track.language ? track.language : i));
        if (track.language) {
          setAttribute(cueEl, "lang", track.language);
        }
      }
      if (this.player_.textTrackSettings) {
        this.updateDisplayState(track);
      }
    }
  }
}
Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
class LoadingSpinner extends Component$1 {
  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  createEl() {
    const isAudio = this.player_.isAudio();
    const playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
    const controlText = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [playerType])
    });
    const el = super.createEl("div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    el.appendChild(controlText);
    return el;
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"]);
  }
}
Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
class Button extends ClickableComponent {
  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(tag, props = {}, attributes = {}) {
    tag = "button";
    props = Object.assign({
      className: this.buildCSSClass()
    }, props);
    attributes = Object.assign({
      // Necessary since the default button type is "submit"
      type: "button"
    }, attributes);
    const el = createEl(tag, props, attributes);
    if (!this.player_.options_.experimentalSvgIcons) {
      el.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
    }
    this.createControlTextEl(el);
    return el;
  }
  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */
  addChild(child, options = {}) {
    const className = this.constructor.name;
    log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);
    return Component$1.prototype.addChild.call(this, child, options);
  }
  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */
  enable() {
    super.enable();
    this.el_.removeAttribute("disabled");
  }
  /**
   * Disable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */
  disable() {
    super.disable();
    this.el_.setAttribute("disabled", "disabled");
  }
  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {KeyboardEvent} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (event2.key === " " || event2.key === "Enter") {
      event2.stopPropagation();
      return;
    }
    super.handleKeyDown(event2);
  }
}
Component$1.registerComponent("Button", Button);
class BigPlayButton extends Button {
  constructor(player, options) {
    super(player, options);
    this.mouseused_ = false;
    this.setIcon("play");
    this.on("mousedown", (e) => this.handleMouseDown(e));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */
  buildCSSClass() {
    return "vjs-big-play-button";
  }
  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {KeyboardEvent|MouseEvent|TouchEvent} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    const playPromise = this.player_.play();
    if (this.mouseused_ && "clientX" in event2 && "clientY" in event2) {
      silencePromise(playPromise);
      if (this.player_.tech(true)) {
        this.player_.tech(true).focus();
      }
      return;
    }
    const cb = this.player_.getChild("controlBar");
    const playToggle = cb && cb.getChild("playToggle");
    if (!playToggle) {
      this.player_.tech(true).focus();
      return;
    }
    const playFocus = () => playToggle.focus();
    if (isPromise(playPromise)) {
      playPromise.then(playFocus, () => {
      });
    } else {
      this.setTimeout(playFocus, 1);
    }
  }
  /**
   * Event handler that is called when a `BigPlayButton` receives a
   * `keydown` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    this.mouseused_ = false;
    super.handleKeyDown(event2);
  }
  /**
   * Handle `mousedown` events on the `BigPlayButton`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   */
  handleMouseDown(event2) {
    this.mouseused_ = true;
  }
}
BigPlayButton.prototype.controlText_ = "Play Video";
Component$1.registerComponent("BigPlayButton", BigPlayButton);
class CloseButton extends Button {
  /**
  * Creates an instance of the this class.
  *
  * @param  {Player} player
  *         The `Player` that this class should be attached to.
  *
  * @param  {Object} [options]
  *         The key/value store of player options.
  */
  constructor(player, options) {
    super(player, options);
    this.setIcon("cancel");
    this.controlText(options && options.controlText || this.localize("Close"));
  }
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-close-button ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when
   * this will be triggered
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */
  handleClick(event2) {
    this.trigger({
      type: "close",
      bubbles: false
    });
  }
  /**
   * Event handler that is called when a `CloseButton` receives a
   * `keydown` event.
   *
   * By default, if the key is Esc, it will trigger a `click` event.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (event2.key === "Escape") {
      event2.preventDefault();
      event2.stopPropagation();
      this.trigger("click");
    } else {
      super.handleKeyDown(event2);
    }
  }
}
Component$1.registerComponent("CloseButton", CloseButton);
class PlayToggle extends Button {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    super(player, options);
    options.replay = options.replay === void 0 || options.replay;
    this.setIcon("play");
    this.on(player, "play", (e) => this.handlePlay(e));
    this.on(player, "pause", (e) => this.handlePause(e));
    if (options.replay) {
      this.on(player, "ended", (e) => this.handleEnded(e));
    }
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-play-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  }
  /**
   * This gets called once after the video has ended and the user seeks so that
   * we can change the replay button back to a play button.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#seeked
   */
  handleSeeked(event2) {
    this.removeClass("vjs-ended");
    if (this.player_.paused()) {
      this.handlePause(event2);
    } else {
      this.handlePlay(event2);
    }
  }
  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */
  handlePlay(event2) {
    this.removeClass("vjs-ended", "vjs-paused");
    this.addClass("vjs-playing");
    this.setIcon("pause");
    this.controlText("Pause");
  }
  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */
  handlePause(event2) {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.setIcon("play");
    this.controlText("Play");
  }
  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ended
   */
  handleEnded(event2) {
    this.removeClass("vjs-playing");
    this.addClass("vjs-ended");
    this.setIcon("replay");
    this.controlText("Replay");
    this.one(this.player_, "seeked", (e) => this.handleSeeked(e));
  }
}
PlayToggle.prototype.controlText_ = "Play";
Component$1.registerComponent("PlayToggle", PlayToggle);
class TimeDisplay extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.on(player, ["timeupdate", "ended", "seeking"], (e) => this.update(e));
    this.updateTextNode_();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const className = this.buildCSSClass();
    const el = super.createEl("div", {
      className: `${className} vjs-time-control vjs-control`
    });
    const span = createEl("span", {
      className: "vjs-control-text",
      textContent: `${this.localize(this.labelText_)} `
    }, {
      role: "presentation"
    });
    el.appendChild(span);
    this.contentEl_ = createEl("span", {
      className: `${className}-display`
    }, {
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      role: "presentation"
    });
    el.appendChild(this.contentEl_);
    return el;
  }
  dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;
    super.dispose();
  }
  /**
   * Updates the displayed time according to the `updateContent` function which is defined in the child class.
   *
   * @param {Event} [event]
   *          The `timeupdate`, `ended` or `seeking` (if enableSmoothSeeking is true) event that caused this function to be called.
   */
  update(event2) {
    if (!this.player_.options_.enableSmoothSeeking && event2.type === "seeking") {
      return;
    }
    this.updateContent(event2);
  }
  /**
   * Updates the time display text node with a new time
   *
   * @param {number} [time=0] the time to update to
   *
   * @private
   */
  updateTextNode_(time = 0) {
    time = formatTime(time);
    if (this.formattedTime_ === time) {
      return;
    }
    this.formattedTime_ = time;
    this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => {
      if (!this.contentEl_) {
        return;
      }
      let oldNode = this.textNode_;
      if (oldNode && this.contentEl_.firstChild !== oldNode) {
        oldNode = null;
        log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
      }
      this.textNode_ = document$1$1.createTextNode(this.formattedTime_);
      if (!this.textNode_) {
        return;
      }
      if (oldNode) {
        this.contentEl_.replaceChild(this.textNode_, oldNode);
      } else {
        this.contentEl_.appendChild(this.textNode_);
      }
    });
  }
  /**
   * To be filled out in the child class, should update the displayed time
   * in accordance with the fact that the current time has changed.
   *
   * @param {Event} [event]
   *        The `timeupdate`  event that caused this to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(event2) {
  }
}
TimeDisplay.prototype.labelText_ = "Time";
TimeDisplay.prototype.controlText_ = "Time";
Component$1.registerComponent("TimeDisplay", TimeDisplay);
class CurrentTimeDisplay extends TimeDisplay {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-current-time";
  }
  /**
   * Update current time display
   *
   * @param {Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */
  updateContent(event2) {
    let time;
    if (this.player_.ended()) {
      time = this.player_.duration();
    } else {
      time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    this.updateTextNode_(time);
  }
}
CurrentTimeDisplay.prototype.labelText_ = "Current Time";
CurrentTimeDisplay.prototype.controlText_ = "Current Time";
Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
class DurationDisplay extends TimeDisplay {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    const updateContent = (e) => this.updateContent(e);
    this.on(player, "durationchange", updateContent);
    this.on(player, "loadstart", updateContent);
    this.on(player, "loadedmetadata", updateContent);
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-duration";
  }
  /**
   * Update duration time display.
   *
   * @param {Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */
  updateContent(event2) {
    const duration2 = this.player_.duration();
    this.updateTextNode_(duration2);
  }
}
DurationDisplay.prototype.labelText_ = "Duration";
DurationDisplay.prototype.controlText_ = "Duration";
Component$1.registerComponent("DurationDisplay", DurationDisplay);
class TimeDivider extends Component$1 {
  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl("div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": true
    });
    const div = super.createEl("div");
    const span = super.createEl("span", {
      textContent: "/"
    });
    div.appendChild(span);
    el.appendChild(div);
    return el;
  }
}
Component$1.registerComponent("TimeDivider", TimeDivider);
class RemainingTimeDisplay extends TimeDisplay {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.on(player, "durationchange", (e) => this.updateContent(e));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return "vjs-remaining-time";
  }
  /**
   * Create the `Component`'s DOM element with the "minus" character prepend to the time
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl();
    if (this.options_.displayNegative !== false) {
      el.insertBefore(createEl("span", {}, {
        "aria-hidden": true
      }, "-"), this.contentEl_);
    }
    return el;
  }
  /**
   * Update remaining time display.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */
  updateContent(event2) {
    if (typeof this.player_.duration() !== "number") {
      return;
    }
    let time;
    if (this.player_.ended()) {
      time = 0;
    } else if (this.player_.remainingTimeDisplay) {
      time = this.player_.remainingTimeDisplay();
    } else {
      time = this.player_.remainingTime();
    }
    this.updateTextNode_(time);
  }
}
RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
class LiveDisplay extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.updateShowing();
    this.on(this.player(), "durationchange", (e) => this.updateShowing(e));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl("div", {
      className: "vjs-live-control vjs-control"
    });
    this.contentEl_ = createEl("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    });
    this.contentEl_.appendChild(createEl("span", {
      className: "vjs-control-text",
      textContent: `${this.localize("Stream Type")} `
    }));
    this.contentEl_.appendChild(document$1$1.createTextNode(this.localize("LIVE")));
    el.appendChild(this.contentEl_);
    return el;
  }
  dispose() {
    this.contentEl_ = null;
    super.dispose();
  }
  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */
  updateShowing(event2) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  }
}
Component$1.registerComponent("LiveDisplay", LiveDisplay);
class SeekToLive extends Button {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.updateLiveEdgeStatus();
    if (this.player_.liveTracker) {
      this.updateLiveEdgeStatusHandler_ = (e) => this.updateLiveEdgeStatus(e);
      this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
    }
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl("button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    this.setIcon("circle", el);
    this.textEl_ = createEl("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    });
    el.appendChild(this.textEl_);
    return el;
  }
  /**
   * Update the state of this button if we are at the live edge
   * or not
   */
  updateLiveEdgeStatus() {
    if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
      this.setAttribute("aria-disabled", true);
      this.addClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently playing live");
    } else {
      this.setAttribute("aria-disabled", false);
      this.removeClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently behind live");
    }
  }
  /**
   * On click bring us as near to the live point as possible.
   * This requires that we wait for the next `live-seekable-change`
   * event which will happen every segment length seconds.
   */
  handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  }
  /**
   * Dispose of the element and stop tracking
   */
  dispose() {
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
    }
    this.textEl_ = null;
    super.dispose();
  }
}
SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
Component$1.registerComponent("SeekToLive", SeekToLive);
function clamp(number, min2, max2) {
  number = Number(number);
  return Math.min(max2, Math.max(min2, isNaN(number) ? min2 : number));
}
var Num = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clamp
});
class Slider extends Component$1 {
  /**
  * Create an instance of this class
  *
  * @param {Player} player
  *        The `Player` that this class should be attached to.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  */
  constructor(player, options) {
    super(player, options);
    this.handleMouseDown_ = (e) => this.handleMouseDown(e);
    this.handleMouseUp_ = (e) => this.handleMouseUp(e);
    this.handleKeyDown_ = (e) => this.handleKeyDown(e);
    this.handleClick_ = (e) => this.handleClick(e);
    this.handleMouseMove_ = (e) => this.handleMouseMove(e);
    this.update_ = (e) => this.update(e);
    this.bar = this.getChild(this.options_.barName);
    this.vertical(!!this.options_.vertical);
    this.enable();
  }
  /**
   * Are controls are currently enabled for this slider or not.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Enable controls for this slider if they are disabled
   */
  enable() {
    if (this.enabled()) {
      return;
    }
    this.on("mousedown", this.handleMouseDown_);
    this.on("touchstart", this.handleMouseDown_);
    this.on("keydown", this.handleKeyDown_);
    this.on("click", this.handleClick_);
    this.on(this.player_, "controlsvisible", this.update);
    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }
    this.removeClass("disabled");
    this.setAttribute("tabindex", 0);
    this.enabled_ = true;
  }
  /**
   * Disable controls for this slider if they are enabled
   */
  disable() {
    if (!this.enabled()) {
      return;
    }
    const doc = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_);
    this.off("touchstart", this.handleMouseDown_);
    this.off("keydown", this.handleKeyDown_);
    this.off("click", this.handleClick_);
    this.off(this.player_, "controlsvisible", this.update_);
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.removeAttribute("tabindex");
    this.addClass("disabled");
    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  }
  /**
   * Create the `Slider`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(type, props = {}, attributes = {}) {
    props.className = props.className + " vjs-slider";
    props = Object.assign({
      tabIndex: 0
    }, props);
    attributes = Object.assign({
      "role": "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100
    }, attributes);
    return super.createEl(type, props, attributes);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */
  handleMouseDown(event2) {
    const doc = this.bar.el_.ownerDocument;
    if (event2.type === "mousedown") {
      event2.preventDefault();
    }
    if (event2.type === "touchstart" && !IS_CHROME) {
      event2.preventDefault();
    }
    blockTextSelection();
    this.addClass("vjs-sliding");
    this.trigger("slideractive");
    this.on(doc, "mousemove", this.handleMouseMove_);
    this.on(doc, "mouseup", this.handleMouseUp_);
    this.on(doc, "touchmove", this.handleMouseMove_);
    this.on(doc, "touchend", this.handleMouseUp_);
    this.handleMouseMove(event2, true);
  }
  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {MouseEvent} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseMove(event2) {
  }
  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {MouseEvent} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */
  handleMouseUp(event2) {
    const doc = this.bar.el_.ownerDocument;
    unblockTextSelection();
    this.removeClass("vjs-sliding");
    this.trigger("sliderinactive");
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.update();
  }
  /**
   * Update the progress bar of the `Slider`.
   *
   * @return {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */
  update() {
    if (!this.el_ || !this.bar) {
      return;
    }
    const progress = this.getProgress();
    if (progress === this.progress_) {
      return progress;
    }
    this.progress_ = progress;
    this.requestNamedAnimationFrame("Slider#update", () => {
      const sizeKey = this.vertical() ? "height" : "width";
      this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
    });
    return progress;
  }
  /**
   * Get the percentage of the bar that should be filled
   * but clamped and rounded.
   *
   * @return {number}
   *         percentage filled that the slider is
   */
  getProgress() {
    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
  }
  /**
   * Calculate distance for slider
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - position.x for vertical `Slider`s
   *         - position.y for horizontal `Slider`s
   */
  calculateDistance(event2) {
    const position2 = getPointerPosition(this.el_, event2);
    if (this.vertical()) {
      return position2.y;
    }
    return position2.x;
  }
  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {KeyboardEvent} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    const spatialNavOptions = this.options_.playerOptions.spatialNavigation;
    const spatialNavEnabled = spatialNavOptions && spatialNavOptions.enabled;
    const horizontalSeek = spatialNavOptions && spatialNavOptions.horizontalSeek;
    if (spatialNavEnabled) {
      if (horizontalSeek && event2.key === "ArrowLeft" || !horizontalSeek && event2.key === "ArrowDown") {
        event2.preventDefault();
        event2.stopPropagation();
        this.stepBack();
      } else if (horizontalSeek && event2.key === "ArrowRight" || !horizontalSeek && event2.key === "ArrowUp") {
        event2.preventDefault();
        event2.stopPropagation();
        this.stepForward();
      } else {
        super.handleKeyDown(event2);
      }
    } else if (event2.key === "ArrowLeft" || event2.key === "ArrowDown") {
      event2.preventDefault();
      event2.stopPropagation();
      this.stepBack();
    } else if (event2.key === "ArrowUp" || event2.key === "ArrowRight") {
      event2.preventDefault();
      event2.stopPropagation();
      this.stepForward();
    } else {
      super.handleKeyDown(event2);
    }
  }
  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */
  handleClick(event2) {
    event2.stopPropagation();
    event2.preventDefault();
  }
  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */
  vertical(bool) {
    if (bool === void 0) {
      return this.vertical_ || false;
    }
    this.vertical_ = !!bool;
    if (this.vertical_) {
      this.addClass("vjs-slider-vertical");
    } else {
      this.addClass("vjs-slider-horizontal");
    }
  }
}
Component$1.registerComponent("Slider", Slider);
const percentify = (time, end2) => clamp(time / end2 * 100, 0, 100).toFixed(2) + "%";
class LoadProgressBar extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.partEls_ = [];
    this.on(player, "progress", (e) => this.update(e));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl("div", {
      className: "vjs-load-progress"
    });
    const wrapper = createEl("span", {
      className: "vjs-control-text"
    });
    const loadedText = createEl("span", {
      textContent: this.localize("Loaded")
    });
    const separator = document$1$1.createTextNode(": ");
    this.percentageEl_ = createEl("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    });
    el.appendChild(wrapper);
    wrapper.appendChild(loadedText);
    wrapper.appendChild(separator);
    wrapper.appendChild(this.percentageEl_);
    return el;
  }
  dispose() {
    this.partEls_ = null;
    this.percentageEl_ = null;
    super.dispose();
  }
  /**
   * Update progress bar
   *
   * @param {Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */
  update(event2) {
    this.requestNamedAnimationFrame("LoadProgressBar#update", () => {
      const liveTracker = this.player_.liveTracker;
      const buffered = this.player_.buffered();
      const duration2 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
      const bufferedEnd = this.player_.bufferedEnd();
      const children = this.partEls_;
      const percent = percentify(bufferedEnd, duration2);
      if (this.percent_ !== percent) {
        this.el_.style.width = percent;
        textContent(this.percentageEl_, percent);
        this.percent_ = percent;
      }
      for (let i = 0; i < buffered.length; i++) {
        const start2 = buffered.start(i);
        const end2 = buffered.end(i);
        let part = children[i];
        if (!part) {
          part = this.el_.appendChild(createEl());
          children[i] = part;
        }
        if (part.dataset.start === start2 && part.dataset.end === end2) {
          continue;
        }
        part.dataset.start = start2;
        part.dataset.end = end2;
        part.style.left = percentify(start2, bufferedEnd);
        part.style.width = percentify(end2 - start2, bufferedEnd);
      }
      for (let i = children.length; i > buffered.length; i--) {
        this.el_.removeChild(children[i - 1]);
      }
      children.length = buffered.length;
    });
  }
}
Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
class TimeTooltip extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
  }
  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(seekBarRect, seekBarPoint, content) {
    const tooltipRect = findPosition(this.el_);
    const playerRect = getBoundingClientRect$1(this.player_.el());
    const seekBarPointPx = seekBarRect.width * seekBarPoint;
    if (!playerRect || !tooltipRect) {
      return;
    }
    let spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
    let spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
    if (!spaceRightOfPoint) {
      spaceRightOfPoint = seekBarRect.width - seekBarPointPx;
      spaceLeftOfPoint = seekBarPointPx;
    }
    let pullTooltipBy = tooltipRect.width / 2;
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }
    pullTooltipBy = Math.round(pullTooltipBy);
    this.el_.style.right = `-${pullTooltipBy}px`;
    this.write(content);
  }
  /**
   * Write the time to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted time for the tooltip.
   */
  write(content) {
    textContent(this.el_, content);
  }
  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   *
   * @param {number} time
   *        The time to update the tooltip to, not used during live playback
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateTime(seekBarRect, seekBarPoint, time, cb) {
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => {
      let content;
      const duration2 = this.player_.duration();
      if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
        const liveWindow = this.player_.liveTracker.liveWindow();
        const secondsBehind = liveWindow - seekBarPoint * liveWindow;
        content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
      } else {
        content = formatTime(time, duration2);
      }
      this.update(seekBarRect, seekBarPoint, content);
      if (cb) {
        cb();
      }
    });
  }
}
Component$1.registerComponent("TimeTooltip", TimeTooltip);
class PlayProgressBar extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.setIcon("circle");
    this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
  }
  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(seekBarRect, seekBarPoint) {
    const timeTooltip = this.getChild("timeTooltip");
    if (!timeTooltip) {
      return;
    }
    const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
  }
}
PlayProgressBar.prototype.options_ = {
  children: []
};
if (!IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push("timeTooltip");
}
Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
class MouseTimeDisplay extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */
  update(seekBarRect, seekBarPoint) {
    const time = seekBarPoint * this.player_.duration();
    this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, () => {
      this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;
    });
  }
}
MouseTimeDisplay.prototype.options_ = {
  children: ["timeTooltip"]
};
Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
const STEP_SECONDS = 5;
const PAGE_KEY_MULTIPLIER = 12;
class SeekBar extends Slider {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.setEventHandlers_();
  }
  /**
   * Sets the event handlers
   *
   * @private
   */
  setEventHandlers_() {
    this.update_ = bind_(this, this.update);
    this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
    this.on(this.player_, ["durationchange", "timeupdate"], this.update);
    this.on(this.player_, ["ended"], this.update_);
    if (this.player_.liveTracker) {
      this.on(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.updateInterval = null;
    this.enableIntervalHandler_ = (e) => this.enableInterval_(e);
    this.disableIntervalHandler_ = (e) => this.disableInterval_(e);
    this.on(this.player_, ["playing"], this.enableIntervalHandler_);
    this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in document$1$1 && "visibilityState" in document$1$1) {
      this.on(document$1$1, "visibilitychange", this.toggleVisibility_);
    }
  }
  toggleVisibility_(e) {
    if (document$1$1.visibilityState === "hidden") {
      this.cancelNamedAnimationFrame("SeekBar#update");
      this.cancelNamedAnimationFrame("Slider#update");
      this.disableInterval_(e);
    } else {
      if (!this.player_.ended() && !this.player_.paused()) {
        this.enableInterval_();
      }
      this.update();
    }
  }
  enableInterval_() {
    if (this.updateInterval) {
      return;
    }
    this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
  }
  disableInterval_(e) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") {
      return;
    }
    if (!this.updateInterval) {
      return;
    }
    this.clearInterval(this.updateInterval);
    this.updateInterval = null;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  }
  /**
   * This function updates the play progress bar and accessibility
   * attributes to whatever is passed in.
   *
   * @param {Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   *
   * @return {number}
   *          The current percent at a number from 0-1
   */
  update(event2) {
    if (document$1$1.visibilityState === "hidden") {
      return;
    }
    const percent = super.update();
    this.requestNamedAnimationFrame("SeekBar#update", () => {
      const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
      const liveTracker = this.player_.liveTracker;
      let duration2 = this.player_.duration();
      if (liveTracker && liveTracker.isLive()) {
        duration2 = this.player_.liveTracker.liveCurrentTime();
      }
      if (this.percent_ !== percent) {
        this.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
        this.percent_ = percent;
      }
      if (this.currentTime_ !== currentTime || this.duration_ !== duration2) {
        this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration2), formatTime(duration2, duration2)], "{1} of {2}"));
        this.currentTime_ = currentTime;
        this.duration_ = duration2;
      }
      if (this.bar) {
        this.bar.update(getBoundingClientRect$1(this.el()), this.getProgress());
      }
    });
    return percent;
  }
  /**
   * Prevent liveThreshold from causing seeks to seem like they
   * are not happening from a user perspective.
   *
   * @param {number} ct
   *        current time to seek to
   */
  userSeek_(ct) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
      this.player_.liveTracker.nextSeekedFromUser();
    }
    this.player_.currentTime(ct);
  }
  /**
   * Get the value of current time but allows for smooth scrubbing,
   * when player can't keep up.
   *
   * @return {number}
   *         The current time value to display
   *
   * @private
   */
  getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  }
  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */
  getPercent() {
    const currentTime = this.getCurrentTime_();
    let percent;
    const liveTracker = this.player_.liveTracker;
    if (liveTracker && liveTracker.isLive()) {
      percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
      if (liveTracker.atLiveEdge()) {
        percent = 1;
      }
    } else {
      percent = currentTime / this.player_.duration();
    }
    return percent;
  }
  /**
   * Handle mouse down on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(event2) {
    if (!isSingleLeftClick(event2)) {
      return;
    }
    event2.stopPropagation();
    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();
    super.handleMouseDown(event2);
  }
  /**
   * Handle mouse move on seek bar
   *
   * @param {MouseEvent} event
   *        The `mousemove` event that caused this to run.
   * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false
   *
   * @listens mousemove
   */
  handleMouseMove(event2, mouseDown = false) {
    if (!isSingleLeftClick(event2) || isNaN(this.player_.duration())) {
      return;
    }
    if (!mouseDown && !this.player_.scrubbing()) {
      this.player_.scrubbing(true);
    }
    let newTime;
    const distance = this.calculateDistance(event2);
    const liveTracker = this.player_.liveTracker;
    if (!liveTracker || !liveTracker.isLive()) {
      newTime = distance * this.player_.duration();
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }
    } else {
      if (distance >= 0.99) {
        liveTracker.seekToLiveEdge();
        return;
      }
      const seekableStart = liveTracker.seekableStart();
      const seekableEnd = liveTracker.liveCurrentTime();
      newTime = seekableStart + distance * liveTracker.liveWindow();
      if (newTime >= seekableEnd) {
        newTime = seekableEnd;
      }
      if (newTime <= seekableStart) {
        newTime = seekableStart + 0.1;
      }
      if (newTime === Infinity) {
        return;
      }
    }
    this.userSeek_(newTime);
    if (this.player_.options_.enableSmoothSeeking) {
      this.update();
    }
  }
  enable() {
    super.enable();
    const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.show();
  }
  disable() {
    super.disable();
    const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.hide();
  }
  /**
   * Handle mouse up on seek bar
   *
   * @param {MouseEvent} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */
  handleMouseUp(event2) {
    super.handleMouseUp(event2);
    if (event2) {
      event2.stopPropagation();
    }
    this.player_.scrubbing(false);
    this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    } else {
      this.update_();
    }
  }
  /**
   * Move more quickly fast forward for keyboard-only users
   */
  stepForward() {
    this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
  }
  /**
   * Move more quickly rewind for keyboard-only users
   */
  stepBack() {
    this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
  }
  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called
   *
   */
  handleAction(event2) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  }
  /**
   * Called when this SeekBar has focus and a key gets pressed down.
   * Supports the following keys:
   *
   *   Space or Enter key fire a click event
   *   Home key moves to start of the timeline
   *   End key moves to end of the timeline
   *   Digit "0" through "9" keys move to 0%, 10% ... 80%, 90% of the timeline
   *   PageDown key moves back a larger step than ArrowDown
   *   PageUp key moves forward a large step
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    const liveTracker = this.player_.liveTracker;
    if (event2.key === " " || event2.key === "Enter") {
      event2.preventDefault();
      event2.stopPropagation();
      this.handleAction(event2);
    } else if (event2.key === "Home") {
      event2.preventDefault();
      event2.stopPropagation();
      this.userSeek_(0);
    } else if (event2.key === "End") {
      event2.preventDefault();
      event2.stopPropagation();
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.liveCurrentTime());
      } else {
        this.userSeek_(this.player_.duration());
      }
    } else if (/^[0-9]$/.test(event2.key)) {
      event2.preventDefault();
      event2.stopPropagation();
      const gotoFraction = parseInt(event2.key, 10) * 0.1;
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
      } else {
        this.userSeek_(this.player_.duration() * gotoFraction);
      }
    } else if (event2.key === "PageDown") {
      event2.preventDefault();
      event2.stopPropagation();
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else if (event2.key === "PageUp") {
      event2.preventDefault();
      event2.stopPropagation();
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else {
      super.handleKeyDown(event2);
    }
  }
  dispose() {
    this.disableInterval_();
    this.off(this.player_, ["durationchange", "timeupdate"], this.update);
    this.off(this.player_, ["ended"], this.update_);
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.off(this.player_, ["playing"], this.enableIntervalHandler_);
    this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in document$1$1 && "visibilityState" in document$1$1) {
      this.off(document$1$1, "visibilitychange", this.toggleVisibility_);
    }
    super.dispose();
  }
}
SeekBar.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar"
};
if (!IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
}
Component$1.registerComponent("SeekBar", SeekBar);
class ProgressControl extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
    this.handleMouseUpHandler_ = (e) => this.handleMouseUp(e);
    this.handleMouseDownHandler_ = (e) => this.handleMouseDown(e);
    this.enable();
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-progress-control vjs-control"
    });
  }
  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */
  handleMouseMove(event2) {
    const seekBar = this.getChild("seekBar");
    if (!seekBar) {
      return;
    }
    const playProgressBar = seekBar.getChild("playProgressBar");
    const mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
    if (!playProgressBar && !mouseTimeDisplay) {
      return;
    }
    const seekBarEl = seekBar.el();
    const seekBarRect = findPosition(seekBarEl);
    let seekBarPoint = getPointerPosition(seekBarEl, event2).x;
    seekBarPoint = clamp(seekBarPoint, 0, 1);
    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
    if (playProgressBar) {
      playProgressBar.update(seekBarRect, seekBar.getProgress());
    }
  }
  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */
  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */
  handleMouseSeek(event2) {
    const seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseMove(event2);
    }
  }
  /**
   * Are controls are currently enabled for this progress control.
   *
   * @return {boolean}
   *         true if controls are enabled, false otherwise
   */
  enabled() {
    return this.enabled_;
  }
  /**
   * Disable all controls on the progress control and its children
   */
  disable() {
    this.children().forEach((child) => child.disable && child.disable());
    if (!this.enabled()) {
      return;
    }
    this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.off(this.el_, "mousemove", this.handleMouseMove);
    this.removeListenersAddedOnMousedownAndTouchstart();
    this.addClass("disabled");
    this.enabled_ = false;
    if (this.player_.scrubbing()) {
      const seekBar = this.getChild("seekBar");
      this.player_.scrubbing(false);
      if (seekBar.videoWasPlaying) {
        silencePromise(this.player_.play());
      }
    }
  }
  /**
   * Enable all controls on the progress control and its children
   */
  enable() {
    this.children().forEach((child) => child.enable && child.enable());
    if (this.enabled()) {
      return;
    }
    this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.on(this.el_, "mousemove", this.handleMouseMove);
    this.removeClass("disabled");
    this.enabled_ = true;
  }
  /**
   * Cleanup listeners after the user finishes interacting with the progress controls
   */
  removeListenersAddedOnMousedownAndTouchstart() {
    const doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseSeek);
    this.off(doc, "touchmove", this.throttledHandleMouseSeek);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(event2) {
    const doc = this.el_.ownerDocument;
    const seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseDown(event2);
    }
    this.on(doc, "mousemove", this.throttledHandleMouseSeek);
    this.on(doc, "touchmove", this.throttledHandleMouseSeek);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(event2) {
    const seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseUp(event2);
    }
    this.removeListenersAddedOnMousedownAndTouchstart();
  }
}
ProgressControl.prototype.options_ = {
  children: ["seekBar"]
};
Component$1.registerComponent("ProgressControl", ProgressControl);
class PictureInPictureToggle extends Button {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  constructor(player, options) {
    super(player, options);
    this.setIcon("picture-in-picture-enter");
    this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], (e) => this.handlePictureInPictureChange(e));
    this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], (e) => this.handlePictureInPictureEnabledChange(e));
    this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange());
    this.disable();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`;
  }
  /**
   * Displays or hides the button depending on the audio mode detection.
   * Exits picture-in-picture if it is enabled when switching to audio mode.
   */
  handlePictureInPictureAudioModeChange() {
    const isSourceAudio = this.player_.currentType().substring(0, 5) === "audio";
    const isAudioMode = isSourceAudio || this.player_.audioPosterMode() || this.player_.audioOnlyMode();
    if (!isAudioMode) {
      this.show();
      return;
    }
    if (this.player_.isInPictureInPicture()) {
      this.player_.exitPictureInPicture();
    }
    this.hide();
  }
  /**
   * Enables or disables button based on availability of a Picture-In-Picture mode.
   *
   * Enabled if
   * - `player.options().enableDocumentPictureInPicture` is true and
   *   window.documentPictureInPicture is available; or
   * - `player.disablePictureInPicture()` is false and
   *   element.requestPictureInPicture is available
   */
  handlePictureInPictureEnabledChange() {
    if (document$1$1.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in window$1$1) {
      this.enable();
    } else {
      this.disable();
    }
  }
  /**
   * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be
   *        called.
   *
   * @listens Player#enterpictureinpicture
   * @listens Player#leavepictureinpicture
   */
  handlePictureInPictureChange(event2) {
    if (this.player_.isInPictureInPicture()) {
      this.setIcon("picture-in-picture-exit");
      this.controlText("Exit Picture-in-Picture");
    } else {
      this.setIcon("picture-in-picture-enter");
      this.controlText("Picture-in-Picture");
    }
    this.handlePictureInPictureEnabledChange();
  }
  /**
   * This gets called when an `PictureInPictureToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    if (!this.player_.isInPictureInPicture()) {
      this.player_.requestPictureInPicture();
    } else {
      this.player_.exitPictureInPicture();
    }
  }
  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it only in browsers that support the Picture-in-Picture API.
   */
  show() {
    if (typeof document$1$1.exitPictureInPicture !== "function") {
      return;
    }
    super.show();
  }
}
PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
class FullscreenToggle extends Button {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.setIcon("fullscreen-enter");
    this.on(player, "fullscreenchange", (e) => this.handleFullscreenChange(e));
    if (document$1$1[player.fsApi_.fullscreenEnabled] === false) {
      this.disable();
    }
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-fullscreen-control ${super.buildCSSClass()}`;
  }
  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */
  handleFullscreenChange(event2) {
    if (this.player_.isFullscreen()) {
      this.controlText("Exit Fullscreen");
      this.setIcon("fullscreen-exit");
    } else {
      this.controlText("Fullscreen");
      this.setIcon("fullscreen-enter");
    }
  }
  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  }
}
FullscreenToggle.prototype.controlText_ = "Fullscreen";
Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
const checkVolumeSupport = function(self2, player) {
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresVolumeControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
class VolumeLevel extends Component$1 {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl("div", {
      className: "vjs-volume-level"
    });
    this.setIcon("circle", el);
    el.appendChild(super.createEl("span", {
      className: "vjs-control-text"
    }));
    return el;
  }
}
Component$1.registerComponent("VolumeLevel", VolumeLevel);
class VolumeLevelTooltip extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
  }
  /**
   * Create the volume tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Updates the position of the tooltip relative to the `VolumeBar` and
   * its content text.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(rangeBarRect, rangeBarPoint, vertical, content) {
    if (!vertical) {
      const tooltipRect = getBoundingClientRect$1(this.el_);
      const playerRect = getBoundingClientRect$1(this.player_.el());
      const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
      const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
      let pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      this.el_.style.right = `-${pullTooltipBy}px`;
    }
    this.write(`${content}%`);
  }
  /**
   * Write the volume to the tooltip DOM element.
   *
   * @param {string} content
   *        The formatted volume for the tooltip.
   */
  write(content) {
    textContent(this.el_, content);
  }
  /**
   * Updates the position of the volume tooltip relative to the `VolumeBar`.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   * @param {number} volume
   *        The volume level to update the tooltip to
   *
   * @param {Function} cb
   *        A function that will be called during the request animation frame
   *        for tooltips that need to do additional animations from the default
   */
  updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => {
      this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
      if (cb) {
        cb();
      }
    });
  }
}
Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
class MouseVolumeLevelDisplay extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
  }
  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-mouse-display"
    });
  }
  /**
   * Enquires updates to its own DOM as well as the DOM of its
   * {@link VolumeLevelTooltip} child.
   *
   * @param {Object} rangeBarRect
   *        The `ClientRect` for the {@link VolumeBar} element.
   *
   * @param {number} rangeBarPoint
   *        A number from 0 to 1, representing a horizontal/vertical reference point
   *        from the left edge of the {@link VolumeBar}
   *
   * @param {boolean} vertical
   *        Referees to the Volume control position
   *        in the control bar{@link VolumeControl}
   *
   */
  update(rangeBarRect, rangeBarPoint, vertical) {
    const volume = 100 * rangeBarPoint;
    this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {
      if (vertical) {
        this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;
      } else {
        this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;
      }
    });
  }
}
MouseVolumeLevelDisplay.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
class VolumeBar extends Slider {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.on("slideractive", (e) => this.updateLastVolume_(e));
    this.on(player, "volumechange", (e) => this.updateARIAAttributes(e));
    player.ready(() => this.updateARIAAttributes());
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  }
  /**
   * Handle mouse down on volume bar
   *
   * @param {Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */
  handleMouseDown(event2) {
    if (!isSingleLeftClick(event2)) {
      return;
    }
    super.handleMouseDown(event2);
  }
  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */
  handleMouseMove(event2) {
    const mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
    if (mouseVolumeLevelDisplay) {
      const volumeBarEl = this.el();
      const volumeBarRect = getBoundingClientRect$1(volumeBarEl);
      const vertical = this.vertical();
      let volumeBarPoint = getPointerPosition(volumeBarEl, event2);
      volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
      volumeBarPoint = clamp(volumeBarPoint, 0, 1);
      mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
    }
    if (!isSingleLeftClick(event2)) {
      return;
    }
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event2));
  }
  /**
   * If the player is muted unmute it.
   */
  checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  }
  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */
  getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  }
  /**
   * Increase volume level for keyboard users
   */
  stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  }
  /**
   * Decrease volume level for keyboard users
   */
  stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  }
  /**
   * Update ARIA accessibility attributes
   *
   * @param {Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */
  updateARIAAttributes(event2) {
    const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", ariaValue);
    this.el_.setAttribute("aria-valuetext", ariaValue + "%");
  }
  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */
  volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  }
  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */
  updateLastVolume_() {
    const volumeBeforeDrag = this.player_.volume();
    this.one("sliderinactive", () => {
      if (this.player_.volume() === 0) {
        this.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  }
}
VolumeBar.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
if (!IS_IOS && !IS_ANDROID) {
  VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
}
VolumeBar.prototype.playerEvent = "volumechange";
Component$1.registerComponent("VolumeBar", VolumeBar);
class VolumeControl extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    options.vertical = options.vertical || false;
    if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }
    super(player, options);
    checkVolumeSupport(this, player);
    this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    this.handleMouseUpHandler_ = (e) => this.handleMouseUp(e);
    this.on("mousedown", (e) => this.handleMouseDown(e));
    this.on("touchstart", (e) => this.handleMouseDown(e));
    this.on("mousemove", (e) => this.handleMouseMove(e));
    this.on(this.volumeBar, ["focus", "slideractive"], () => {
      this.volumeBar.addClass("vjs-slider-active");
      this.addClass("vjs-slider-active");
      this.trigger("slideractive");
    });
    this.on(this.volumeBar, ["blur", "sliderinactive"], () => {
      this.volumeBar.removeClass("vjs-slider-active");
      this.removeClass("vjs-slider-active");
      this.trigger("sliderinactive");
    });
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let orientationClass = "vjs-volume-horizontal";
    if (this.options_.vertical) {
      orientationClass = "vjs-volume-vertical";
    }
    return super.createEl("div", {
      className: `vjs-volume-control vjs-control ${orientationClass}`
    });
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseDown(event2) {
    const doc = this.el_.ownerDocument;
    this.on(doc, "mousemove", this.throttledHandleMouseMove);
    this.on(doc, "touchmove", this.throttledHandleMouseMove);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */
  handleMouseUp(event2) {
    const doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseMove);
    this.off(doc, "touchmove", this.throttledHandleMouseMove);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  }
  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */
  handleMouseMove(event2) {
    this.volumeBar.handleMouseMove(event2);
  }
}
VolumeControl.prototype.options_ = {
  children: ["volumeBar"]
};
Component$1.registerComponent("VolumeControl", VolumeControl);
const checkMuteSupport = function(self2, player) {
  if (player.tech_ && !player.tech_.featuresMuteControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresMuteControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
class MuteToggle extends Button {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    checkMuteSupport(this, player);
    this.on(player, ["loadstart", "volumechange"], (e) => this.update(e));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-mute-control ${super.buildCSSClass()}`;
  }
  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    const vol = this.player_.volume();
    const lastVolume = this.player_.lastVolume_();
    if (vol === 0) {
      const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  }
  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */
  update(event2) {
    this.updateIcon_();
    this.updateControlText_();
  }
  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */
  updateIcon_() {
    const vol = this.player_.volume();
    let level = 3;
    this.setIcon("volume-high");
    if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
      this.player_.muted(this.player_.tech_.el_.muted);
    }
    if (vol === 0 || this.player_.muted()) {
      this.setIcon("volume-mute");
      level = 0;
    } else if (vol < 0.33) {
      this.setIcon("volume-low");
      level = 1;
    } else if (vol < 0.67) {
      this.setIcon("volume-medium");
      level = 2;
    }
    removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? " " : ""}vjs-vol-${i}`, ""));
    addClass(this.el_, `vjs-vol-${level}`);
  }
  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */
  updateControlText_() {
    const soundOff = this.player_.muted() || this.player_.volume() === 0;
    const text2 = soundOff ? "Unmute" : "Mute";
    if (this.controlText() !== text2) {
      this.controlText(text2);
    }
  }
}
MuteToggle.prototype.controlText_ = "Mute";
Component$1.registerComponent("MuteToggle", MuteToggle);
class VolumePanel extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    if (typeof options.inline !== "undefined") {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }
    if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }
    super(player, options);
    this.handleKeyPressHandler_ = (e) => this.handleKeyPress(e);
    this.on(player, ["loadstart"], (e) => this.volumePanelState_(e));
    this.on(this.muteToggle, "keyup", (e) => this.handleKeyPress(e));
    this.on(this.volumeControl, "keyup", (e) => this.handleVolumeControlKeyUp(e));
    this.on("keydown", (e) => this.handleKeyPress(e));
    this.on("mouseover", (e) => this.handleMouseOver(e));
    this.on("mouseout", (e) => this.handleMouseOut(e));
    this.on(this.volumeControl, ["slideractive"], this.sliderActive_);
    this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_);
  }
  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */
  sliderActive_() {
    this.addClass("vjs-slider-active");
  }
  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */
  sliderInactive_() {
    this.removeClass("vjs-slider-active");
  }
  /**
   * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel
   * depending on MuteToggle and VolumeControl state
   *
   * @listens Player#loadstart
   * @private
   */
  volumePanelState_() {
    if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-hidden");
    }
    if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-mute-toggle-only");
    }
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    let orientationClass = "vjs-volume-panel-horizontal";
    if (!this.options_.inline) {
      orientationClass = "vjs-volume-panel-vertical";
    }
    return super.createEl("div", {
      className: `vjs-volume-panel vjs-control ${orientationClass}`
    });
  }
  /**
   * Dispose of the `volume-panel` and all child components.
   */
  dispose() {
    this.handleMouseOut();
    super.dispose();
  }
  /**
   * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes
   * the volume panel and sets focus on `MuteToggle`.
   *
   * @param {Event} event
   *        The `keyup` event that caused this function to be called.
   *
   * @listens keyup
   */
  handleVolumeControlKeyUp(event2) {
    if (event2.key === "Escape") {
      this.muteToggle.focus();
    }
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseover` event.
   * Turns on listening for `mouseover` event. When they happen it
   * calls `this.handleMouseOver`.
   *
   * @param {Event} event
   *        The `mouseover` event that caused this function to be called.
   *
   * @listens mouseover
   */
  handleMouseOver(event2) {
    this.addClass("vjs-hover");
    on(document$1$1, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * This gets called when a `VolumePanel` gains hover via a `mouseout` event.
   * Turns on listening for `mouseout` event. When they happen it
   * calls `this.handleMouseOut`.
   *
   * @param {Event} event
   *        The `mouseout` event that caused this function to be called.
   *
   * @listens mouseout
   */
  handleMouseOut(event2) {
    this.removeClass("vjs-hover");
    off(document$1$1, "keyup", this.handleKeyPressHandler_);
  }
  /**
   * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,
   * looking for ESC, which hides the `VolumeControl`.
   *
   * @param {Event} event
   *        The keypress that triggered this event.
   *
   * @listens keydown | keyup
   */
  handleKeyPress(event2) {
    if (event2.key === "Escape") {
      this.handleMouseOut();
    }
  }
}
VolumePanel.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
Component$1.registerComponent("VolumePanel", VolumePanel);
class SkipForward extends Button {
  constructor(player, options) {
    super(player, options);
    this.validOptions = [5, 10, 30];
    this.skipTime = this.getSkipForwardTime();
    if (this.skipTime && this.validOptions.includes(this.skipTime)) {
      this.setIcon(`forward-${this.skipTime}`);
      this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime.toLocaleString(player.language())]));
      this.show();
    } else {
      this.hide();
    }
  }
  getSkipForwardTime() {
    const playerOptions = this.options_.playerOptions;
    return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;
  }
  buildCSSClass() {
    return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips forward in the duration/seekable range by a configurable amount of seconds.
   * If the time left in the duration/seekable range is less than the configured 'skip forward' time,
   * skips to end of duration/seekable range.
   *
   * Handle a click on a `SkipForward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(event2) {
    if (isNaN(this.player_.duration())) {
      return;
    }
    const currentVideoTime = this.player_.currentTime();
    const liveTracker = this.player_.liveTracker;
    const duration2 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
    let newTime;
    if (currentVideoTime + this.skipTime <= duration2) {
      newTime = currentVideoTime + this.skipTime;
    } else {
      newTime = duration2;
    }
    this.player_.currentTime(newTime);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]));
  }
}
SkipForward.prototype.controlText_ = "Skip Forward";
Component$1.registerComponent("SkipForward", SkipForward);
class SkipBackward extends Button {
  constructor(player, options) {
    super(player, options);
    this.validOptions = [5, 10, 30];
    this.skipTime = this.getSkipBackwardTime();
    if (this.skipTime && this.validOptions.includes(this.skipTime)) {
      this.setIcon(`replay-${this.skipTime}`);
      this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime.toLocaleString(player.language())]));
      this.show();
    } else {
      this.hide();
    }
  }
  getSkipBackwardTime() {
    const playerOptions = this.options_.playerOptions;
    return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;
  }
  buildCSSClass() {
    return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
  }
  /**
   * On click, skips backward in the video by a configurable amount of seconds.
   * If the current time in the video is less than the configured 'skip backward' time,
   * skips to beginning of video or seekable range.
   *
   * Handle a click on a `SkipBackward` button
   *
   * @param {EventTarget~Event} event
   *        The `click` event that caused this function
   *        to be called
   */
  handleClick(event2) {
    const currentVideoTime = this.player_.currentTime();
    const liveTracker = this.player_.liveTracker;
    const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();
    let newTime;
    if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) {
      newTime = seekableStart;
    } else if (currentVideoTime >= this.skipTime) {
      newTime = currentVideoTime - this.skipTime;
    } else {
      newTime = 0;
    }
    this.player_.currentTime(newTime);
  }
  /**
   * Update control text on languagechange
   */
  handleLanguagechange() {
    this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]));
  }
}
SkipBackward.prototype.controlText_ = "Skip Backward";
Component$1.registerComponent("SkipBackward", SkipBackward);
class Menu extends Component$1 {
  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  constructor(player, options) {
    super(player, options);
    if (options) {
      this.menuButton_ = options.menuButton;
    }
    this.focusedChild_ = -1;
    this.on("keydown", (e) => this.handleKeyDown(e));
    this.boundHandleBlur_ = (e) => this.handleBlur(e);
    this.boundHandleTapClick_ = (e) => this.handleTapClick(e);
  }
  /**
   * Add event listeners to the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to add listeners to.
   *
   */
  addEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.on(component, "blur", this.boundHandleBlur_);
    this.on(component, ["tap", "click"], this.boundHandleTapClick_);
  }
  /**
   * Remove event listeners from the {@link MenuItem}.
   *
   * @param {Object} component
   *        The instance of the `MenuItem` to remove listeners.
   *
   */
  removeEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.off(component, "blur", this.boundHandleBlur_);
    this.off(component, ["tap", "click"], this.boundHandleTapClick_);
  }
  /**
   * This method will be called indirectly when the component has been added
   * before the component adds to the new menu instance by `addItem`.
   * In this case, the original menu instance will remove the component
   * by calling `removeChild`.
   *
   * @param {Object} component
   *        The instance of the `MenuItem`
   */
  removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    this.removeEventListenerForItem(component);
    super.removeChild(component);
  }
  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */
  addItem(component) {
    const childComponent = this.addChild(component);
    if (childComponent) {
      this.addEventListenerForItem(childComponent);
    }
  }
  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */
  createEl() {
    const contentElType = this.options_.contentElType || "ul";
    this.contentEl_ = createEl(contentElType, {
      className: "vjs-menu-content"
    });
    this.contentEl_.setAttribute("role", "menu");
    const el = super.createEl("div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    el.appendChild(this.contentEl_);
    on(el, "click", function(event2) {
      event2.preventDefault();
      event2.stopImmediatePropagation();
    });
    return el;
  }
  dispose() {
    this.contentEl_ = null;
    this.boundHandleBlur_ = null;
    this.boundHandleTapClick_ = null;
    super.dispose();
  }
  /**
   * Called when a `MenuItem` loses focus.
   *
   * @param {Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */
  handleBlur(event2) {
    const relatedTarget = event2.relatedTarget || document$1$1.activeElement;
    if (!this.children().some((element) => {
      return element.el() === relatedTarget;
    })) {
      const btn = this.menuButton_;
      if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
        btn.unpressButton();
      }
    }
  }
  /**
   * Called when a `MenuItem` gets clicked or tapped.
   *
   * @param {Event} event
   *        The `click` or `tap` event that caused this function to be called.
   *
   * @listens click,tap
   */
  handleTapClick(event2) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      const childComponents = this.children();
      if (!Array.isArray(childComponents)) {
        return;
      }
      const foundComponent = childComponents.filter((component) => component.el() === event2.target)[0];
      if (!foundComponent) {
        return;
      }
      if (foundComponent.name() !== "CaptionSettingsMenuItem") {
        this.menuButton_.focus();
      }
    }
  }
  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {KeyboardEvent} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (event2.key === "ArrowLeft" || event2.key === "ArrowDown") {
      event2.preventDefault();
      event2.stopPropagation();
      this.stepForward();
    } else if (event2.key === "ArrowRight" || event2.key === "ArrowUp") {
      event2.preventDefault();
      event2.stopPropagation();
      this.stepBack();
    }
  }
  /**
   * Move to next (lower) menu item for keyboard users.
   */
  stepForward() {
    let stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  }
  /**
   * Move to previous (higher) menu item for keyboard users.
   */
  stepBack() {
    let stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  }
  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */
  focus(item = 0) {
    const children = this.children().slice();
    const haveTitle = children.length && children[0].hasClass("vjs-menu-title");
    if (haveTitle) {
      children.shift();
    }
    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }
      this.focusedChild_ = item;
      children[item].el_.focus();
    }
  }
}
Component$1.registerComponent("Menu", Menu);
class MenuButton extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    super(player, options);
    this.menuButton_ = new Button(player, options);
    this.menuButton_.controlText(this.controlText_);
    this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    const buttonClass = Button.prototype.buildCSSClass();
    this.menuButton_.el_.className = this.buildCSSClass() + " " + buttonClass;
    this.menuButton_.removeClass("vjs-control");
    this.addChild(this.menuButton_);
    this.update();
    this.enabled_ = true;
    const handleClick = (e) => this.handleClick(e);
    this.handleMenuKeyUp_ = (e) => this.handleMenuKeyUp(e);
    this.on(this.menuButton_, "tap", handleClick);
    this.on(this.menuButton_, "click", handleClick);
    this.on(this.menuButton_, "keydown", (e) => this.handleKeyDown(e));
    this.on(this.menuButton_, "mouseenter", () => {
      this.addClass("vjs-hover");
      this.menu.show();
      on(document$1$1, "keyup", this.handleMenuKeyUp_);
    });
    this.on("mouseleave", (e) => this.handleMouseLeave(e));
    this.on("keydown", (e) => this.handleSubmenuKeyDown(e));
  }
  /**
   * Update the menu based on the current state of its items.
   */
  update() {
    const menu = this.createMenu();
    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }
    this.menu = menu;
    this.addChild(menu);
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute("aria-expanded", "false");
    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
      this.menu.contentEl_.removeAttribute("role");
    } else {
      this.show();
      this.menu.contentEl_.setAttribute("role", "menu");
    }
  }
  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */
  createMenu() {
    const menu = new Menu(this.player_, {
      menuButton: this
    });
    this.hideThreshold_ = 0;
    if (this.options_.title) {
      const titleEl = createEl("li", {
        className: "vjs-menu-title",
        textContent: toTitleCase$1(this.options_.title),
        tabIndex: -1
      });
      const titleComponent = new Component$1(this.player_, {
        el: titleEl
      });
      menu.addItem(titleComponent);
    }
    this.items = this.createItems();
    if (this.items) {
      for (let i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }
    return menu;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */
  createItems() {
  }
  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildWrapperCSSClass()
    }, {});
  }
  /**
   * Overwrites the `setIcon` method from `Component`.
   * In this case, we want the icon to be appended to the menuButton.
   *
   * @param {string} name
   *         The icon name to be added.
   */
  setIcon(name) {
    super.setIcon(name, this.menuButton_.el_);
  }
  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */
  buildWrapperCSSClass() {
    let menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    const buttonClass = Button.prototype.buildCSSClass();
    return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    let menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;
  }
  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */
  controlText(text2, el = this.menuButton_.el()) {
    return this.menuButton_.controlText(text2, el);
  }
  /**
   * Dispose of the `menu-button` and all child components.
   */
  dispose() {
    this.handleMouseLeave();
    super.dispose();
  }
  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  }
  /**
   * Handle `mouseleave` for `MenuButton`.
   *
   * @param {Event} event
   *        The `mouseleave` event that caused this function to be called.
   *
   * @listens mouseleave
   */
  handleMouseLeave(event2) {
    this.removeClass("vjs-hover");
    off(document$1$1, "keyup", this.handleMenuKeyUp_);
  }
  /**
   * Set the focus to the actual button, not to this element
   */
  focus() {
    this.menuButton_.focus();
  }
  /**
   * Remove the focus from the actual button, not this element
   */
  blur() {
    this.menuButton_.blur();
  }
  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (event2.key === "Esc" || event2.key === "Tab") {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!event2.key === "Tab") {
        event2.preventDefault();
        this.menuButton_.focus();
      }
    } else if (event2.key === "Up" || event2.key === "Down" && !(this.player_.options_.playerOptions.spatialNavigation && this.player_.options_.playerOptions.spatialNavigation.enabled)) {
      if (!this.buttonPressed_) {
        event2.preventDefault();
        this.pressButton();
      }
    }
  }
  /**
   * Handle a `keyup` event on a `MenuButton`. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keyup
   */
  handleMenuKeyUp(event2) {
    if (event2.key === "Esc" || event2.key === "Tab") {
      this.removeClass("vjs-hover");
    }
  }
  /**
   * This method name now delegates to `handleSubmenuKeyDown`. This means
   * anyone calling `handleSubmenuKeyPress` will not see their method calls
   * stop working.
   *
   * @param {Event} event
   *        The event that caused this function to be called.
   */
  handleSubmenuKeyPress(event2) {
    this.handleSubmenuKeyDown(event2);
  }
  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {Event} event
   *        Key press event
   *
   * @listens keydown
   */
  handleSubmenuKeyDown(event2) {
    if (event2.key === "Esc" || event2.key === "Tab") {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!event2.key === "Tab") {
        event2.preventDefault();
        this.menuButton_.focus();
      }
    }
  }
  /**
   * Put the current `MenuButton` into a pressed state.
   */
  pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.show();
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute("aria-expanded", "true");
      if (IS_IOS && isInFrame()) {
        return;
      }
      this.menu.focus();
    }
  }
  /**
   * Take the current `MenuButton` out of a pressed state.
   */
  unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menu.hide();
      this.menuButton_.el_.setAttribute("aria-expanded", "false");
    }
  }
  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */
  disable() {
    this.unpressButton();
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.menuButton_.disable();
  }
  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */
  enable() {
    this.enabled_ = true;
    this.removeClass("vjs-disabled");
    this.menuButton_.enable();
  }
}
Component$1.registerComponent("MenuButton", MenuButton);
class TrackButton extends MenuButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    const tracks = options.tracks;
    super(player, options);
    if (this.items.length <= 1) {
      this.hide();
    }
    if (!tracks) {
      return;
    }
    const updateHandler = bind_(this, this.update);
    tracks.addEventListener("removetrack", updateHandler);
    tracks.addEventListener("addtrack", updateHandler);
    tracks.addEventListener("labelchange", updateHandler);
    this.player_.on("ready", updateHandler);
    this.player_.on("dispose", function() {
      tracks.removeEventListener("removetrack", updateHandler);
      tracks.removeEventListener("addtrack", updateHandler);
      tracks.removeEventListener("labelchange", updateHandler);
    });
  }
}
Component$1.registerComponent("TrackButton", TrackButton);
class MenuItem extends ClickableComponent {
  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  constructor(player, options) {
    super(player, options);
    this.selectable = options.selectable;
    this.isSelected_ = options.selected || false;
    this.multiSelectable = options.multiSelectable;
    this.selected(this.isSelected_);
    if (this.selectable) {
      if (this.multiSelectable) {
        this.el_.setAttribute("role", "menuitemcheckbox");
      } else {
        this.el_.setAttribute("role", "menuitemradio");
      }
    } else {
      this.el_.setAttribute("role", "menuitem");
    }
  }
  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl(type, props, attrs) {
    this.nonIconControl = true;
    const el = super.createEl("li", Object.assign({
      className: "vjs-menu-item",
      tabIndex: -1
    }, props), attrs);
    const menuItemEl = createEl("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    });
    if (this.player_.options_.experimentalSvgIcons) {
      el.appendChild(menuItemEl);
    } else {
      el.replaceChild(menuItemEl, el.querySelector(".vjs-icon-placeholder"));
    }
    return el;
  }
  /**
   * Ignore keys which are used by the menu, but pass any other ones up. See
   * {@link ClickableComponent#handleKeyDown} for instances where this is called.
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    if (!["Tab", "Escape", "ArrowUp", "ArrowLeft", "ArrowRight", "ArrowDown"].includes(event2.key)) {
      super.handleKeyDown(event2);
    }
  }
  /**
   * Any click on a `MenuItem` puts it into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    this.selected(true);
  }
  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */
  selected(selected) {
    if (this.selectable) {
      if (selected) {
        this.addClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "true");
        this.controlText(", selected");
        this.isSelected_ = true;
      } else {
        this.removeClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "false");
        this.controlText("");
        this.isSelected_ = false;
      }
    }
  }
}
Component$1.registerComponent("MenuItem", MenuItem);
class TextTrackMenuItem extends MenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    const track = options.track;
    const tracks = player.textTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.mode === "showing";
    super(player, options);
    this.track = track;
    this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);
    const changeHandler = (...args) => {
      this.handleTracksChange.apply(this, args);
    };
    const selectedLanguageChangeHandler = (...args) => {
      this.handleSelectedLanguageChange.apply(this, args);
    };
    player.on(["loadstart", "texttrackchange"], changeHandler);
    tracks.addEventListener("change", changeHandler);
    tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    this.on("dispose", function() {
      player.off(["loadstart", "texttrackchange"], changeHandler);
      tracks.removeEventListener("change", changeHandler);
      tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    });
    if (tracks.onchange === void 0) {
      let event2;
      this.on(["tap", "click"], function() {
        if (typeof window$1$1.Event !== "object") {
          try {
            event2 = new window$1$1.Event("change");
          } catch (err) {
          }
        }
        if (!event2) {
          event2 = document$1$1.createEvent("Event");
          event2.initEvent("change", true, true);
        }
        tracks.dispatchEvent(event2);
      });
    }
    this.handleTracksChange();
  }
  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    const referenceTrack = this.track;
    const tracks = this.player_.textTracks();
    super.handleClick(event2);
    if (!tracks) {
      return;
    }
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      if (this.kinds.indexOf(track.kind) === -1) {
        continue;
      }
      if (track === referenceTrack) {
        if (track.mode !== "showing") {
          track.mode = "showing";
        }
      } else if (track.mode !== "disabled") {
        track.mode = "disabled";
      }
    }
  }
  /**
   * Handle text track list change
   *
   * @param {Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(event2) {
    const shouldBeSelected = this.track.mode === "showing";
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  }
  handleSelectedLanguageChange(event2) {
    if (this.track.mode === "showing") {
      const selectedLanguage = this.player_.cache_.selectedLanguage;
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }
      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  }
  dispose() {
    this.track = null;
    super.dispose();
  }
}
Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
class OffTextTrackMenuItem extends TextTrackMenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    options.track = {
      player,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: options.kind,
      kinds: options.kinds,
      default: false,
      mode: "disabled"
    };
    if (!options.kinds) {
      options.kinds = [options.kind];
    }
    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(" and ") + " off";
    }
    options.selectable = true;
    options.multiSelectable = false;
    super(player, options);
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   */
  handleTracksChange(event2) {
    const tracks = this.player().textTracks();
    let shouldBeSelected = true;
    for (let i = 0, l = tracks.length; i < l; i++) {
      const track = tracks[i];
      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
        shouldBeSelected = false;
        break;
      }
    }
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  }
  handleSelectedLanguageChange(event2) {
    const tracks = this.player().textTracks();
    let allHidden = true;
    for (let i = 0, l = tracks.length; i < l; i++) {
      const track = tracks[i];
      if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
        allHidden = false;
        break;
      }
    }
    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label);
    super.handleLanguagechange();
  }
}
Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
class TextTrackButton extends TrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    options.tracks = player.textTracks();
    super(player, options);
  }
  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */
  createItems(items = [], TrackMenuItem = TextTrackMenuItem) {
    let label;
    if (this.label_) {
      label = `${this.label_} off`;
    }
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label
    }));
    this.hideThreshold_ += 1;
    const tracks = this.player_.textTracks();
    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      if (this.kinds_.indexOf(track.kind) > -1) {
        const item = new TrackMenuItem(this.player_, {
          track,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        });
        item.addClass(`vjs-${track.kind}-menu-item`);
        items.push(item);
      }
    }
    return items;
  }
}
Component$1.registerComponent("TextTrackButton", TextTrackButton);
class ChaptersTrackMenuItem extends MenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    const track = options.track;
    const cue = options.cue;
    const currentTime = player.currentTime();
    options.selectable = true;
    options.multiSelectable = false;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    super(player, options);
    this.track = track;
    this.cue = cue;
  }
  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    super.handleClick();
    this.player_.currentTime(this.cue.startTime);
  }
}
Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
class ChaptersButton extends TextTrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this function is ready.
   */
  constructor(player, options, ready) {
    super(player, options, ready);
    this.setIcon("chapters");
    this.selectCurrentItem_ = () => {
      this.items.forEach((item) => {
        item.selected(this.track_.activeCues[0] === item.cue);
      });
    };
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-chapters-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Update the menu based on the current state of its items.
   *
   * @param {Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */
  update(event2) {
    if (event2 && event2.track && event2.track.kind !== "chapters") {
      return;
    }
    const track = this.findChaptersTrack();
    if (track !== this.track_) {
      this.setTrack(track);
      super.update();
    } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
      super.update();
    }
  }
  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */
  setTrack(track) {
    if (this.track_ === track) {
      return;
    }
    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }
    if (this.track_) {
      const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
      }
      this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
      this.track_ = null;
    }
    this.track_ = track;
    if (this.track_) {
      this.track_.mode = "hidden";
      const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (remoteTextTrackEl) {
        remoteTextTrackEl.addEventListener("load", this.updateHandler_);
      }
      this.track_.addEventListener("cuechange", this.selectCurrentItem_);
    }
  }
  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */
  findChaptersTrack() {
    const tracks = this.player_.textTracks() || [];
    for (let i = tracks.length - 1; i >= 0; i--) {
      const track = tracks[i];
      if (track.kind === this.kind_) {
        return track;
      }
    }
  }
  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */
  getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase$1(this.kind_));
  }
  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */
  createMenu() {
    this.options_.title = this.getMenuCaption();
    return super.createMenu();
  }
  /**
   * Create a menu item for each text track
   *
   * @return  {TextTrackMenuItem[]}
   *         Array of menu items
   */
  createItems() {
    const items = [];
    if (!this.track_) {
      return items;
    }
    const cues = this.track_.cues;
    if (!cues) {
      return items;
    }
    for (let i = 0, l = cues.length; i < l; i++) {
      const cue = cues[i];
      const mi = new ChaptersTrackMenuItem(this.player_, {
        track: this.track_,
        cue
      });
      items.push(mi);
    }
    return items;
  }
}
ChaptersButton.prototype.kind_ = "chapters";
ChaptersButton.prototype.controlText_ = "Chapters";
Component$1.registerComponent("ChaptersButton", ChaptersButton);
class DescriptionsButton extends TextTrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(player, options, ready) {
    super(player, options, ready);
    this.setIcon("audio-description");
    const tracks = player.textTracks();
    const changeHandler = bind_(this, this.handleTracksChange);
    tracks.addEventListener("change", changeHandler);
    this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
  }
  /**
   * Handle text track change
   *
   * @param {Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */
  handleTracksChange(event2) {
    const tracks = this.player().textTracks();
    let disabled = false;
    for (let i = 0, l = tracks.length; i < l; i++) {
      const track = tracks[i];
      if (track.kind !== this.kind_ && track.mode === "showing") {
        disabled = true;
        break;
      }
    }
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-descriptions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
  }
}
DescriptionsButton.prototype.kind_ = "descriptions";
DescriptionsButton.prototype.controlText_ = "Descriptions";
Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
class SubtitlesButton extends TextTrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(player, options, ready) {
    super(player, options, ready);
    this.setIcon("subtitles");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subtitles-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
  }
}
SubtitlesButton.prototype.kind_ = "subtitles";
SubtitlesButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
class CaptionSettingsMenuItem extends TextTrackMenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    options.track = {
      player,
      kind: options.kind,
      label: options.kind + " settings",
      selectable: false,
      default: false,
      mode: "disabled"
    };
    options.selectable = false;
    options.name = "CaptionSettingsMenuItem";
    super(player, options);
    this.addClass("vjs-texttrack-settings");
    this.controlText(", opens " + options.kind + " settings dialog");
  }
  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    this.player().getChild("textTrackSettings").open();
  }
  /**
   * Update control text and label on languagechange
   */
  handleLanguagechange() {
    this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings");
    super.handleLanguagechange();
  }
}
Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
class CaptionsButton extends TextTrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(player, options, ready) {
    super(player, options, ready);
    this.setIcon("captions");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-captions-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    const items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.kind_
      }));
      this.hideThreshold_ += 1;
    }
    return super.createItems(items);
  }
}
CaptionsButton.prototype.kind_ = "captions";
CaptionsButton.prototype.controlText_ = "Captions";
Component$1.registerComponent("CaptionsButton", CaptionsButton);
class SubsCapsMenuItem extends TextTrackMenuItem {
  createEl(type, props, attrs) {
    const el = super.createEl(type, props, attrs);
    const parentSpan = el.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "captions") {
      if (this.player_.options_.experimentalSvgIcons) {
        this.setIcon("captions", el);
      } else {
        parentSpan.appendChild(createEl("span", {
          className: "vjs-icon-placeholder"
        }, {
          "aria-hidden": true
        }));
      }
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: ` ${this.localize("Captions")}`
      }));
    }
    return el;
  }
}
Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
class SubsCapsButton extends TextTrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Function} [ready]
   *        The function to call when this component is ready.
   */
  constructor(player, options = {}) {
    super(player, options);
    this.label_ = "subtitles";
    this.setIcon("subtitles");
    if (["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1) {
      this.label_ = "captions";
      this.setIcon("captions");
    }
    this.menuButton_.controlText(toTitleCase$1(this.label_));
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-subs-caps-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */
  createItems() {
    let items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.label_
      }));
      this.hideThreshold_ += 1;
    }
    items = super.createItems(items, SubsCapsMenuItem);
    return items;
  }
}
SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
SubsCapsButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
class AudioTrackMenuItem extends MenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    const track = options.track;
    const tracks = player.audioTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.enabled;
    super(player, options);
    this.track = track;
    this.addClass(`vjs-${track.kind}-menu-item`);
    const changeHandler = (...args) => {
      this.handleTracksChange.apply(this, args);
    };
    tracks.addEventListener("change", changeHandler);
    this.on("dispose", () => {
      tracks.removeEventListener("change", changeHandler);
    });
  }
  createEl(type, props, attrs) {
    const el = super.createEl(type, props, attrs);
    const parentSpan = el.querySelector(".vjs-menu-item-text");
    if (["main-desc", "descriptions"].indexOf(this.options_.track.kind) >= 0) {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      }));
    }
    return el;
  }
  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    super.handleClick(event2);
    this.track.enabled = true;
    if (this.player_.tech_.featuresNativeAudioTracks) {
      const tracks = this.player_.audioTracks();
      for (let i = 0; i < tracks.length; i++) {
        const track = tracks[i];
        if (track === this.track) {
          continue;
        }
        track.enabled = track === this.track;
      }
    }
  }
  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */
  handleTracksChange(event2) {
    this.selected(this.track.enabled);
  }
}
Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
class AudioTrackButton extends TrackButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  constructor(player, options = {}) {
    options.tracks = player.audioTracks();
    super(player, options);
    this.setIcon("audio");
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-audio-button ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */
  createItems(items = []) {
    this.hideThreshold_ = 1;
    const tracks = this.player_.audioTracks();
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      items.push(new AudioTrackMenuItem(this.player_, {
        track,
        // MenuItem is selectable
        selectable: true,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: false
      }));
    }
    return items;
  }
}
AudioTrackButton.prototype.controlText_ = "Audio Track";
Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
class PlaybackRateMenuItem extends MenuItem {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    const label = options.rate;
    const rate = parseFloat(label, 10);
    options.label = label;
    options.selected = rate === player.playbackRate();
    options.selectable = true;
    options.multiSelectable = false;
    super(player, options);
    this.label = label;
    this.rate = rate;
    this.on(player, "ratechange", (e) => this.update(e));
  }
  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */
  handleClick(event2) {
    super.handleClick();
    this.player().playbackRate(this.rate);
  }
  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  update(event2) {
    this.selected(this.player().playbackRate() === this.rate);
  }
}
PlaybackRateMenuItem.prototype.contentElType = "button";
Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
class PlaybackRateMenuButton extends MenuButton {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_);
    this.updateVisibility();
    this.updateLabel();
    this.on(player, "loadstart", (e) => this.updateVisibility(e));
    this.on(player, "ratechange", (e) => this.updateLabel(e));
    this.on(player, "playbackrateschange", (e) => this.handlePlaybackRateschange(e));
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    const el = super.createEl();
    this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
    this.labelEl_ = createEl("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    });
    el.appendChild(this.labelEl_);
    return el;
  }
  dispose() {
    this.labelEl_ = null;
    super.dispose();
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-playback-rate ${super.buildCSSClass()}`;
  }
  buildWrapperCSSClass() {
    return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
  }
  /**
   * Create the list of menu items. Specific to each subclass.
   *
   */
  createItems() {
    const rates = this.playbackRates();
    const items = [];
    for (let i = rates.length - 1; i >= 0; i--) {
      items.push(new PlaybackRateMenuItem(this.player(), {
        rate: rates[i] + "x"
      }));
    }
    return items;
  }
  /**
   * On playbackrateschange, update the menu to account for the new items.
   *
   * @listens Player#playbackrateschange
   */
  handlePlaybackRateschange(event2) {
    this.update();
  }
  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */
  playbackRates() {
    const player = this.player();
    return player.playbackRates && player.playbackRates() || [];
  }
  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */
  playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  }
  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */
  updateVisibility(event2) {
    if (this.playbackRateSupported()) {
      this.removeClass("vjs-hidden");
    } else {
      this.addClass("vjs-hidden");
    }
  }
  /**
   * Update button label when rate changed
   *
   * @param {Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */
  updateLabel(event2) {
    if (this.playbackRateSupported()) {
      this.labelEl_.textContent = this.player().playbackRate() + "x";
    }
  }
}
PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
class Spacer extends Component$1 {
  /**
  * Builds the default DOM `className`.
  *
  * @return {string}
  *         The DOM `className` for this object.
  */
  buildCSSClass() {
    return `vjs-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl(tag = "div", props = {}, attributes = {}) {
    if (!props.className) {
      props.className = this.buildCSSClass();
    }
    return super.createEl(tag, props, attributes);
  }
}
Component$1.registerComponent("Spacer", Spacer);
class CustomControlSpacer extends Spacer {
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  buildCSSClass() {
    return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
  }
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: " "
    });
  }
}
Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
class ControlBar extends Component$1 {
  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    return super.createEl("div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  }
}
ControlBar.prototype.options_ = {
  children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"]
};
Component$1.registerComponent("ControlBar", ControlBar);
class ErrorDisplay extends ModalDialog {
  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  constructor(player, options) {
    super(player, options);
    this.on(player, "error", (e) => {
      this.open(e);
    });
  }
  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */
  buildCSSClass() {
    return `vjs-error-display ${super.buildCSSClass()}`;
  }
  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */
  content() {
    const error = this.player().error();
    return error ? this.localize(error.message) : "";
  }
}
ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});
Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
class TextTrackSelect extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements.
   */
  constructor(player, options = {}) {
    super(player, options);
    this.el_.setAttribute("aria-labelledby", this.selectLabelledbyIds);
  }
  /**
   * Create the `TextTrackSelect`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    this.selectLabelledbyIds = [this.options_.legendId, this.options_.labelId].join(" ").trim();
    const selectoptions = createEl("select", {
      id: this.options_.id
    }, {}, this.options_.SelectOptions.map((optionText) => {
      const optionId = (this.options_.labelId ? this.options_.labelId : `vjs-track-option-${newGUID()}`) + "-" + optionText[1].replace(/\W+/g, "");
      const option = createEl("option", {
        id: optionId,
        value: this.localize(optionText[0]),
        textContent: optionText[1]
      });
      option.setAttribute("aria-labelledby", `${this.selectLabelledbyIds} ${optionId}`);
      return option;
    }));
    return selectoptions;
  }
}
Component$1.registerComponent("TextTrackSelect", TextTrackSelect);
class TextTrackFieldset extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.legendId]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.id]
   *        A text with part of an string to create atribute of aria-labelledby.
   *        It passes to 'TextTrackSelect'.
   *
   * @param {string} [options.legendText]
   *        A text to use as the text content of the legend element.
   *
   * @param {Array} [options.selects]
   *        Array that contains the selects that are use to create 'selects'
   *        components.
   *
   * @param {Array} [options.SelectOptions]
   *        Array that contains the value & textContent of for each of the
   *        options elements, it passes to 'TextTrackSelect'.
   *
   * @param {string} [options.type]
   *        Conditions if some DOM elements will be added to the fieldset
   *        component.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the selects configurations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        These properties are use to configure the 'TextTrackSelect' Component.
   */
  constructor(player, options = {}) {
    super(player, options);
    const legendElement = createEl("legend", {
      textContent: this.localize(this.options_.legendText),
      id: this.options_.legendId
    });
    this.el().appendChild(legendElement);
    const selects = this.options_.selects;
    for (const i of selects) {
      const selectConfig = this.options_.selectConfigs[i];
      const selectClassName = selectConfig.className;
      const id = selectConfig.id.replace("%s", this.options_.id_);
      let span = null;
      const guid = `vjs_select_${newGUID()}`;
      if (this.options_.type === "colors") {
        span = createEl("span", {
          className: selectClassName
        });
        const label = createEl("label", {
          id,
          className: "vjs-label",
          textContent: selectConfig.label
        });
        label.setAttribute("for", guid);
        span.appendChild(label);
      }
      const textTrackSelect = new TextTrackSelect(player, {
        SelectOptions: selectConfig.options,
        legendId: this.options_.legendId,
        id: guid,
        labelId: id
      });
      this.addChild(textTrackSelect);
      if (this.options_.type === "colors") {
        span.appendChild(textTrackSelect.el());
        this.el().appendChild(span);
      }
    }
  }
  /**
   * Create the `TextTrackFieldset`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    const el = createEl("fieldset", {
      // Prefixing classes of elements within a player with "vjs-"
      // is a convention used in Video.js.
      className: this.options_.className
    });
    return el;
  }
}
Component$1.registerComponent("TextTrackFieldset", TextTrackFieldset);
class TextTrackSettingsColors extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(player, options = {}) {
    super(player, options);
    const id_ = this.options_.textTrackComponentid;
    const ElFgColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-text-legend-${id_}`,
      legendText: this.localize("Text"),
      className: "vjs-fg vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(ElFgColorFieldset);
    const ElBgColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-background-${id_}`,
      legendText: this.localize("Text Background"),
      className: "vjs-bg vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(ElBgColorFieldset);
    const ElWinColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-window-${id_}`,
      legendText: this.localize("Caption Area Background"),
      className: "vjs-window vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "colors"
    });
    this.addChild(ElWinColorFieldset);
  }
  /**
   * Create the `TextTrackSettingsColors`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    const el = createEl("div", {
      className: "vjs-track-settings-colors"
    });
    return el;
  }
}
Component$1.registerComponent("TextTrackSettingsColors", TextTrackSettingsColors);
class TextTrackSettingsFont extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {ContentDescriptor} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {Array} [options.fieldSets]
   *        Array that contains the configurations for the selects.
   *
   * @param {Object} [options.selectConfigs]
   *        Object with the following properties that are the select confugations:
   *        backgroundColor, backgroundOpacity, color, edgeStyle, fontFamily,
   *        fontPercent, textOpacity, windowColor, windowOpacity.
   *        it passes to 'TextTrackFieldset'.
   */
  constructor(player, options = {}) {
    super(player, options);
    const id_ = this.options_.textTrackComponentid;
    const ElFgColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-font-size-${id_}`,
      legendText: "Font Size",
      className: "vjs-font-percent vjs-track-setting",
      selects: this.options_.fieldSets[0],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(ElFgColorFieldset);
    const ElBgColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-edge-style-${id_}`,
      legendText: this.localize("Text Edge Style"),
      className: "vjs-edge-style vjs-track-setting",
      selects: this.options_.fieldSets[1],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(ElBgColorFieldset);
    const ElWinColorFieldset = new TextTrackFieldset(player, {
      id_,
      legendId: `captions-font-family-${id_}`,
      legendText: this.localize("Font Family"),
      className: "vjs-font-family vjs-track-setting",
      selects: this.options_.fieldSets[2],
      selectConfigs: this.options_.selectConfigs,
      type: "font"
    });
    this.addChild(ElWinColorFieldset);
  }
  /**
   * Create the `TextTrackSettingsFont`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    const el = createEl("div", {
      className: "vjs-track-settings-font"
    });
    return el;
  }
}
Component$1.registerComponent("TextTrackSettingsFont", TextTrackSettingsFont);
class TrackSettingsControls extends Component$1 {
  constructor(player, options = {}) {
    super(player, options);
    const defaultsDescription = this.localize("restore all settings to the default values");
    const resetButton = new Button(player, {
      controlText: defaultsDescription,
      className: "vjs-default-button"
    });
    resetButton.el().classList.remove("vjs-control", "vjs-button");
    resetButton.el().textContent = this.localize("Reset");
    this.addChild(resetButton);
    const doneButton = new Button(player, {
      controlText: defaultsDescription,
      className: "vjs-done-button"
    });
    doneButton.el().classList.remove("vjs-control", "vjs-button");
    doneButton.el().textContent = this.localize("Done");
    this.addChild(doneButton);
  }
  /**
   * Create the `TrackSettingsControls`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    const el = createEl("div", {
      className: "vjs-track-settings-controls"
    });
    return el;
  }
}
Component$1.registerComponent("TrackSettingsControls", TrackSettingsControls);
const LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
const COLOR_BLACK = ["#000", "Black"];
const COLOR_BLUE = ["#00F", "Blue"];
const COLOR_CYAN = ["#0FF", "Cyan"];
const COLOR_GREEN = ["#0F0", "Green"];
const COLOR_MAGENTA = ["#F0F", "Magenta"];
const COLOR_RED = ["#F00", "Red"];
const COLOR_WHITE = ["#FFF", "White"];
const COLOR_YELLOW = ["#FF0", "Yellow"];
const OPACITY_OPAQUE = ["1", "Opaque"];
const OPACITY_SEMI = ["0.5", "Semi-Transparent"];
const OPACITY_TRANS = ["0", "Transparent"];
const selectConfigs = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN],
    className: "vjs-bg-color"
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Opacity",
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS],
    className: "vjs-bg-opacity vjs-opacity"
  },
  color: {
    selector: ".vjs-text-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN],
    className: "vjs-text-color"
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Drop shadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    default: 2,
    parser: (v) => v === "1.00" ? null : Number(v)
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Opacity",
    options: [OPACITY_OPAQUE, OPACITY_SEMI],
    className: "vjs-text-opacity vjs-opacity"
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color",
    className: "vjs-window-color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Opacity",
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE],
    className: "vjs-window-opacity vjs-opacity"
  }
};
selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
function parseOptionValue(value2, parser2) {
  if (parser2) {
    value2 = parser2(value2);
  }
  if (value2 && value2 !== "none") {
    return value2;
  }
}
function getSelectedOptionValue(el, parser2) {
  const value2 = el.options[el.options.selectedIndex].value;
  return parseOptionValue(value2, parser2);
}
function setSelectedOption(el, value2, parser2) {
  if (!value2) {
    return;
  }
  for (let i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser2) === value2) {
      el.selectedIndex = i;
      break;
    }
  }
}
class TextTrackSettings extends ModalDialog {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  constructor(player, options) {
    options.temporary = false;
    super(player, options);
    this.updateDisplay = this.updateDisplay.bind(this);
    this.fill();
    this.hasBeenOpened_ = this.hasBeenFilled_ = true;
    this.renderModalComponents(player);
    this.endDialog = createEl("p", {
      className: "vjs-control-text",
      textContent: this.localize("End of dialog window.")
    });
    this.el().appendChild(this.endDialog);
    this.setDefaults();
    if (options.persistTextTrackSettings === void 0) {
      this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
    }
    this.bindFunctionsToSelectsAndButtons();
    if (this.options_.persistTextTrackSettings) {
      this.restoreSettings();
    }
  }
  renderModalComponents(player) {
    const textTrackSettingsColors = new TextTrackSettingsColors(player, {
      textTrackComponentid: this.id_,
      selectConfigs,
      fieldSets: [["color", "textOpacity"], ["backgroundColor", "backgroundOpacity"], ["windowColor", "windowOpacity"]]
    });
    this.addChild(textTrackSettingsColors);
    const textTrackSettingsFont = new TextTrackSettingsFont(player, {
      textTrackComponentid: this.id_,
      selectConfigs,
      fieldSets: [["fontPercent"], ["edgeStyle"], ["fontFamily"]]
    });
    this.addChild(textTrackSettingsFont);
    const trackSettingsControls = new TrackSettingsControls(player);
    this.addChild(trackSettingsControls);
  }
  bindFunctionsToSelectsAndButtons() {
    this.on(this.$(".vjs-done-button"), ["click", "tap"], () => {
      this.saveSettings();
      this.close();
    });
    this.on(this.$(".vjs-default-button"), ["click", "tap"], () => {
      this.setDefaults();
      this.updateDisplay();
    });
    each(selectConfigs, (config) => {
      this.on(this.$(config.selector), "change", this.updateDisplay);
    });
  }
  dispose() {
    this.endDialog = null;
    super.dispose();
  }
  label() {
    return this.localize("Caption Settings Dialog");
  }
  description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  }
  buildCSSClass() {
    return super.buildCSSClass() + " vjs-text-track-settings";
  }
  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */
  getValues() {
    return reduce(selectConfigs, (accum, config, key) => {
      const value2 = getSelectedOptionValue(this.$(config.selector), config.parser);
      if (value2 !== void 0) {
        accum[key] = value2;
      }
      return accum;
    }, {});
  }
  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */
  setValues(values2) {
    each(selectConfigs, (config, key) => {
      setSelectedOption(this.$(config.selector), values2[key], config.parser);
    });
  }
  /**
   * Sets all `<select>` elements to their default values.
   */
  setDefaults() {
    each(selectConfigs, (config) => {
      const index = config.hasOwnProperty("default") ? config.default : 0;
      this.$(config.selector).selectedIndex = index;
    });
  }
  /**
   * Restore texttrack settings from localStorage
   */
  restoreSettings() {
    let values2;
    try {
      values2 = JSON.parse(window$1$1.localStorage.getItem(LOCAL_STORAGE_KEY$1));
    } catch (err) {
      log$1.warn(err);
    }
    if (values2) {
      this.setValues(values2);
    }
  }
  /**
   * Save text track settings to localStorage
   */
  saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }
    const values2 = this.getValues();
    try {
      if (Object.keys(values2).length) {
        window$1$1.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values2));
      } else {
        window$1$1.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
      }
    } catch (err) {
      log$1.warn(err);
    }
  }
  /**
   * Update display of text track settings
   */
  updateDisplay() {
    const ttDisplay = this.player_.getChild("textTrackDisplay");
    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  }
  /**
   * Repopulate dialog with new localizations on languagechange
   */
  handleLanguagechange() {
    this.fill();
    this.renderModalComponents(this.player_);
    this.bindFunctionsToSelectsAndButtons();
  }
}
Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
class ResizeManager extends Component$1 {
  /**
   * Create the ResizeManager.
   *
   * @param {Object} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of ResizeManager options.
   *
   * @param {Object} [options.ResizeObserver]
   *        A polyfill for ResizeObserver can be passed in here.
   *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.
   */
  constructor(player, options) {
    let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window$1$1.ResizeObserver;
    if (options.ResizeObserver === null) {
      RESIZE_OBSERVER_AVAILABLE = false;
    }
    const options_ = merge$1({
      createEl: !RESIZE_OBSERVER_AVAILABLE,
      reportTouchActivity: false
    }, options);
    super(player, options_);
    this.ResizeObserver = options.ResizeObserver || window$1$1.ResizeObserver;
    this.loadListener_ = null;
    this.resizeObserver_ = null;
    this.debouncedHandler_ = debounce$4(() => {
      this.resizeHandler();
    }, 100, false, this);
    if (RESIZE_OBSERVER_AVAILABLE) {
      this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
      this.resizeObserver_.observe(player.el());
    } else {
      this.loadListener_ = () => {
        if (!this.el_ || !this.el_.contentWindow) {
          return;
        }
        const debouncedHandler_ = this.debouncedHandler_;
        let unloadListener_ = this.unloadListener_ = function() {
          off(this, "resize", debouncedHandler_);
          off(this, "unload", unloadListener_);
          unloadListener_ = null;
        };
        on(this.el_.contentWindow, "unload", unloadListener_);
        on(this.el_.contentWindow, "resize", debouncedHandler_);
      };
      this.one("load", this.loadListener_);
    }
  }
  createEl() {
    return super.createEl("iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  }
  /**
   * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver
   *
   * @fires Player#playerresize
   */
  resizeHandler() {
    if (!this.player_ || !this.player_.trigger) {
      return;
    }
    this.player_.trigger("playerresize");
  }
  dispose() {
    if (this.debouncedHandler_) {
      this.debouncedHandler_.cancel();
    }
    if (this.resizeObserver_) {
      if (this.player_.el()) {
        this.resizeObserver_.unobserve(this.player_.el());
      }
      this.resizeObserver_.disconnect();
    }
    if (this.loadListener_) {
      this.off("load", this.loadListener_);
    }
    if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
      this.unloadListener_.call(this.el_.contentWindow);
    }
    this.ResizeObserver = null;
    this.resizeObserver = null;
    this.debouncedHandler_ = null;
    this.loadListener_ = null;
    super.dispose();
  }
}
Component$1.registerComponent("ResizeManager", ResizeManager);
const defaults$1 = {
  trackingThreshold: 20,
  liveTolerance: 15
};
class LiveTracker extends Component$1 {
  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {number} [options.trackingThreshold=20]
   *        Number of seconds of live window (seekableEnd - seekableStart) that
   *        media needs to have before the liveui will be shown.
   *
   * @param {number} [options.liveTolerance=15]
   *        Number of seconds behind live that we have to be
   *        before we will be considered non-live. Note that this will only
   *        be used when playing at the live edge. This allows large seekable end
   *        changes to not effect whether we are live or not.
   */
  constructor(player, options) {
    const options_ = merge$1(defaults$1, options, {
      createEl: false
    });
    super(player, options_);
    this.trackLiveHandler_ = () => this.trackLive_();
    this.handlePlay_ = (e) => this.handlePlay(e);
    this.handleFirstTimeupdate_ = (e) => this.handleFirstTimeupdate(e);
    this.handleSeeked_ = (e) => this.handleSeeked(e);
    this.seekToLiveEdge_ = (e) => this.seekToLiveEdge(e);
    this.reset_();
    this.on(this.player_, "durationchange", (e) => this.handleDurationchange(e));
    this.on(this.player_, "canplay", () => this.toggleTracking());
  }
  /**
   * all the functionality for tracking when seek end changes
   * and for tracking how far past seek end we should be
   */
  trackLive_() {
    const seekable2 = this.player_.seekable();
    if (!seekable2 || !seekable2.length) {
      return;
    }
    const newTime = Number(window$1$1.performance.now().toFixed(4));
    const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
    this.lastTime_ = newTime;
    this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
    const liveCurrentTime = this.liveCurrentTime();
    const currentTime = this.player_.currentTime();
    let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
    if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
      isBehind = false;
    }
    if (isBehind !== this.behindLiveEdge_) {
      this.behindLiveEdge_ = isBehind;
      this.trigger("liveedgechange");
    }
  }
  /**
   * handle a durationchange event on the player
   * and start/stop tracking accordingly.
   */
  handleDurationchange() {
    this.toggleTracking();
  }
  /**
   * start/stop tracking
   */
  toggleTracking() {
    if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
      if (this.player_.options_.liveui) {
        this.player_.addClass("vjs-liveui");
      }
      this.startTracking();
    } else {
      this.player_.removeClass("vjs-liveui");
      this.stopTracking();
    }
  }
  /**
   * start tracking live playback
   */
  startTracking() {
    if (this.isTracking()) {
      return;
    }
    if (!this.timeupdateSeen_) {
      this.timeupdateSeen_ = this.player_.hasStarted();
    }
    this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
    this.trackLive_();
    this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
    if (!this.timeupdateSeen_) {
      this.one(this.player_, "play", this.handlePlay_);
      this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    } else {
      this.on(this.player_, "seeked", this.handleSeeked_);
    }
  }
  /**
   * handle the first timeupdate on the player if it wasn't already playing
   * when live tracker started tracking.
   */
  handleFirstTimeupdate() {
    this.timeupdateSeen_ = true;
    this.on(this.player_, "seeked", this.handleSeeked_);
  }
  /**
   * Keep track of what time a seek starts, and listen for seeked
   * to find where a seek ends.
   */
  handleSeeked() {
    const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
    this.nextSeekedFromUser_ = false;
    this.trackLive_();
  }
  /**
   * handle the first play on the player, and make sure that we seek
   * right to the live edge.
   */
  handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * Stop tracking, and set all internal variables to
   * their initial value.
   */
  reset_() {
    this.lastTime_ = -1;
    this.pastSeekEnd_ = 0;
    this.lastSeekEnd_ = -1;
    this.behindLiveEdge_ = true;
    this.timeupdateSeen_ = false;
    this.seekedBehindLive_ = false;
    this.nextSeekedFromUser_ = false;
    this.clearInterval(this.trackingInterval_);
    this.trackingInterval_ = null;
    this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
    this.off(this.player_, "seeked", this.handleSeeked_);
    this.off(this.player_, "play", this.handlePlay_);
    this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  }
  /**
   * The next seeked event is from the user. Meaning that any seek
   * > 2s behind live will be considered behind live for real and
   * liveTolerance will be ignored.
   */
  nextSeekedFromUser() {
    this.nextSeekedFromUser_ = true;
  }
  /**
   * stop tracking live playback
   */
  stopTracking() {
    if (!this.isTracking()) {
      return;
    }
    this.reset_();
    this.trigger("liveedgechange");
  }
  /**
   * A helper to get the player seekable end
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The furthest seekable end or Infinity.
   */
  seekableEnd() {
    const seekable2 = this.player_.seekable();
    const seekableEnds = [];
    let i = seekable2 ? seekable2.length : 0;
    while (i--) {
      seekableEnds.push(seekable2.end(i));
    }
    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
  }
  /**
   * A helper to get the player seekable start
   * so that we don't have to null check everywhere
   *
   * @return {number}
   *         The earliest seekable start or 0.
   */
  seekableStart() {
    const seekable2 = this.player_.seekable();
    const seekableStarts = [];
    let i = seekable2 ? seekable2.length : 0;
    while (i--) {
      seekableStarts.push(seekable2.start(i));
    }
    return seekableStarts.length ? seekableStarts.sort()[0] : 0;
  }
  /**
   * Get the live time window aka
   * the amount of time between seekable start and
   * live current time.
   *
   * @return {number}
   *         The amount of seconds that are seekable in
   *         the live video.
   */
  liveWindow() {
    const liveCurrentTime = this.liveCurrentTime();
    if (liveCurrentTime === Infinity) {
      return 0;
    }
    return liveCurrentTime - this.seekableStart();
  }
  /**
   * Determines if the player is live, only checks if this component
   * is tracking live playback or not
   *
   * @return {boolean}
   *         Whether liveTracker is tracking
   */
  isLive() {
    return this.isTracking();
  }
  /**
   * Determines if currentTime is at the live edge and won't fall behind
   * on each seekableendchange
   *
   * @return {boolean}
   *         Whether playback is at the live edge
   */
  atLiveEdge() {
    return !this.behindLiveEdge();
  }
  /**
   * get what we expect the live current time to be
   *
   * @return {number}
   *         The expected live current time
   */
  liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  }
  /**
   * The number of seconds that have occurred after seekable end
   * changed. This will be reset to 0 once seekable end changes.
   *
   * @return {number}
   *         Seconds past the current seekable end
   */
  pastSeekEnd() {
    const seekableEnd = this.seekableEnd();
    if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
      this.pastSeekEnd_ = 0;
    }
    this.lastSeekEnd_ = seekableEnd;
    return this.pastSeekEnd_;
  }
  /**
   * If we are currently behind the live edge, aka currentTime will be
   * behind on a seekableendchange
   *
   * @return {boolean}
   *         If we are behind the live edge
   */
  behindLiveEdge() {
    return this.behindLiveEdge_;
  }
  /**
   * Whether live tracker is currently tracking or not.
   */
  isTracking() {
    return typeof this.trackingInterval_ === "number";
  }
  /**
   * Seek to the live edge if we are behind the live edge
   */
  seekToLiveEdge() {
    this.seekedBehindLive_ = false;
    if (this.atLiveEdge()) {
      return;
    }
    this.nextSeekedFromUser_ = false;
    this.player_.currentTime(this.liveCurrentTime());
  }
  /**
   * Dispose of liveTracker
   */
  dispose() {
    this.stopTracking();
    super.dispose();
  }
}
Component$1.registerComponent("LiveTracker", LiveTracker);
class TitleBar extends Component$1 {
  constructor(player, options) {
    super(player, options);
    this.on("statechanged", (e) => this.updateDom_());
    this.updateDom_();
  }
  /**
   * Create the `TitleBar`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  createEl() {
    this.els = {
      title: createEl("div", {
        className: "vjs-title-bar-title",
        id: `vjs-title-bar-title-${newGUID()}`
      }),
      description: createEl("div", {
        className: "vjs-title-bar-description",
        id: `vjs-title-bar-description-${newGUID()}`
      })
    };
    return createEl("div", {
      className: "vjs-title-bar"
    }, {}, values(this.els));
  }
  /**
   * Updates the DOM based on the component's state object.
   */
  updateDom_() {
    const tech = this.player_.tech_;
    const techEl = tech && tech.el_;
    const techAriaAttrs = {
      title: "aria-labelledby",
      description: "aria-describedby"
    };
    ["title", "description"].forEach((k) => {
      const value2 = this.state[k];
      const el = this.els[k];
      const techAriaAttr = techAriaAttrs[k];
      emptyEl(el);
      if (value2) {
        textContent(el, value2);
      }
      if (techEl) {
        techEl.removeAttribute(techAriaAttr);
        if (value2) {
          techEl.setAttribute(techAriaAttr, el.id);
        }
      }
    });
    if (this.state.title || this.state.description) {
      this.show();
    } else {
      this.hide();
    }
  }
  /**
   * Update the contents of the title bar component with new title and
   * description text.
   *
   * If both title and description are missing, the title bar will be hidden.
   *
   * If either title or description are present, the title bar will be visible.
   *
   * NOTE: Any previously set value will be preserved. To unset a previously
   * set value, you must pass an empty string or null.
   *
   * For example:
   *
   * ```
   * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'
   * update({description: 'bar2'}) // title: 'foo', description: 'bar2'
   * update({title: ''}) // title: '', description: 'bar2'
   * update({title: 'foo', description: null}) // title: 'foo', description: null
   * ```
   *
   * @param  {Object} [options={}]
   *         An options object. When empty, the title bar will be hidden.
   *
   * @param  {string} [options.title]
   *         A title to display in the title bar.
   *
   * @param  {string} [options.description]
   *         A description to display in the title bar.
   */
  update(options) {
    this.setState(options);
  }
  /**
   * Dispose the component.
   */
  dispose() {
    const tech = this.player_.tech_;
    const techEl = tech && tech.el_;
    if (techEl) {
      techEl.removeAttribute("aria-labelledby");
      techEl.removeAttribute("aria-describedby");
    }
    super.dispose();
    this.els = null;
  }
}
Component$1.registerComponent("TitleBar", TitleBar);
const defaults$2 = {
  initialDisplay: 4e3,
  position: [],
  takeFocus: false
};
class TransientButton extends Button {
  /**
   * TransientButton constructor
   *
   * @param {Player} player The button's player
   * @param {TransientButtonOptions} options Options for the transient button
   */
  constructor(player, options) {
    options = merge$1(defaults$2, options);
    super(player, options);
    this.controlText(options.controlText);
    this.hide();
    this.on(this.player_, ["useractive", "userinactive"], (e) => {
      this.removeClass("force-display");
    });
  }
  /**
   * Return CSS class including position classes
   *
   * @return {string} CSS class list
   */
  buildCSSClass() {
    return `vjs-transient-button focus-visible ${this.options_.position.map((c) => `vjs-${c}`).join(" ")}`;
  }
  /**
   * Create the button element
   *
   * @return {HTMLButtonElement} The button element
   */
  createEl() {
    const el = createEl("button", {}, {
      type: "button",
      class: this.buildCSSClass()
    }, createEl("span"));
    this.controlTextEl_ = el.querySelector("span");
    return el;
  }
  /**
   * Show the button. The button will remain visible for the `initialDisplay` time, default 4s,
   * and when there is user activity.
   */
  show() {
    super.show();
    this.addClass("force-display");
    if (this.options_.takeFocus) {
      this.el().focus({
        preventScroll: true
      });
    }
    this.forceDisplayTimeout = this.player_.setTimeout(() => {
      this.removeClass("force-display");
    }, this.options_.initialDisplay);
  }
  /**
   * Hide the display, even if during the `initialDisplay` time.
   */
  hide() {
    this.removeClass("force-display");
    super.hide();
  }
  /**
   * Dispose the component
   */
  dispose() {
    this.player_.clearTimeout(this.forceDisplayTimeout);
    super.dispose();
  }
}
Component$1.registerComponent("TransientButton", TransientButton);
const sourcesetLoad = (tech) => {
  const el = tech.el();
  if (el.hasAttribute("src")) {
    tech.triggerSourceset(el.src);
    return true;
  }
  const sources = tech.$$("source");
  const srcUrls = [];
  let src = "";
  if (!sources.length) {
    return false;
  }
  for (let i = 0; i < sources.length; i++) {
    const url2 = sources[i].src;
    if (url2 && srcUrls.indexOf(url2) === -1) {
      srcUrls.push(url2);
    }
  }
  if (!srcUrls.length) {
    return false;
  }
  if (srcUrls.length === 1) {
    src = srcUrls[0];
  }
  tech.triggerSourceset(src);
  return true;
};
const innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
  get() {
    return this.cloneNode(true).innerHTML;
  },
  set(v) {
    const dummy = document$1$1.createElement(this.nodeName.toLowerCase());
    dummy.innerHTML = v;
    const docFrag = document$1$1.createDocumentFragment();
    while (dummy.childNodes.length) {
      docFrag.appendChild(dummy.childNodes[0]);
    }
    this.innerText = "";
    window$1$1.Element.prototype.appendChild.call(this, docFrag);
    return this.innerHTML;
  }
});
const getDescriptor = (priority, prop) => {
  let descriptor = {};
  for (let i = 0; i < priority.length; i++) {
    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
    if (descriptor && descriptor.set && descriptor.get) {
      break;
    }
  }
  descriptor.enumerable = true;
  descriptor.configurable = true;
  return descriptor;
};
const getInnerHTMLDescriptor = (tech) => getDescriptor([tech.el(), window$1$1.HTMLMediaElement.prototype, window$1$1.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
const firstSourceWatch = function(tech) {
  const el = tech.el();
  if (el.resetSourceWatch_) {
    return;
  }
  const old = {};
  const innerDescriptor = getInnerHTMLDescriptor(tech);
  const appendWrapper = (appendFn) => (...args) => {
    const retval = appendFn.apply(el, args);
    sourcesetLoad(tech);
    return retval;
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach((k) => {
    if (!el[k]) {
      return;
    }
    old[k] = el[k];
    el[k] = appendWrapper(old[k]);
  });
  Object.defineProperty(el, "innerHTML", merge$1(innerDescriptor, {
    set: appendWrapper(innerDescriptor.set)
  }));
  el.resetSourceWatch_ = () => {
    el.resetSourceWatch_ = null;
    Object.keys(old).forEach((k) => {
      el[k] = old[k];
    });
    Object.defineProperty(el, "innerHTML", innerDescriptor);
  };
  tech.one("sourceset", el.resetSourceWatch_);
};
const srcDescriptorPolyfill = Object.defineProperty({}, "src", {
  get() {
    if (this.hasAttribute("src")) {
      return getAbsoluteURL(window$1$1.Element.prototype.getAttribute.call(this, "src"));
    }
    return "";
  },
  set(v) {
    window$1$1.Element.prototype.setAttribute.call(this, "src", v);
    return v;
  }
});
const getSrcDescriptor = (tech) => getDescriptor([tech.el(), window$1$1.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
const setupSourceset = function(tech) {
  if (!tech.featuresSourceset) {
    return;
  }
  const el = tech.el();
  if (el.resetSourceset_) {
    return;
  }
  const srcDescriptor = getSrcDescriptor(tech);
  const oldSetAttribute = el.setAttribute;
  const oldLoad = el.load;
  Object.defineProperty(el, "src", merge$1(srcDescriptor, {
    set: (v) => {
      const retval = srcDescriptor.set.call(el, v);
      tech.triggerSourceset(el.src);
      return retval;
    }
  }));
  el.setAttribute = (n, v) => {
    const retval = oldSetAttribute.call(el, n, v);
    if (/src/i.test(n)) {
      tech.triggerSourceset(el.src);
    }
    return retval;
  };
  el.load = () => {
    const retval = oldLoad.call(el);
    if (!sourcesetLoad(tech)) {
      tech.triggerSourceset("");
      firstSourceWatch(tech);
    }
    return retval;
  };
  if (el.currentSrc) {
    tech.triggerSourceset(el.currentSrc);
  } else if (!sourcesetLoad(tech)) {
    firstSourceWatch(tech);
  }
  el.resetSourceset_ = () => {
    el.resetSourceset_ = null;
    el.load = oldLoad;
    el.setAttribute = oldSetAttribute;
    Object.defineProperty(el, "src", srcDescriptor);
    if (el.resetSourceWatch_) {
      el.resetSourceWatch_();
    }
  };
};
class Html5 extends Tech {
  /**
  * Create an instance of this Tech.
  *
  * @param {Object} [options]
  *        The key/value store of player options.
  *
  * @param {Function} [ready]
  *        Callback function to call when the `HTML5` Tech is ready.
  */
  constructor(options, ready) {
    super(options, ready);
    const source = options.source;
    let crossoriginTracks = false;
    this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO";
    if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      this.setSource(source);
    } else {
      this.handleLateInit_(this.el_);
    }
    if (options.enableSourceset) {
      this.setupSourcesetHandling_();
    }
    this.isScrubbing_ = false;
    if (this.el_.hasChildNodes()) {
      const nodes = this.el_.childNodes;
      let nodesLength = nodes.length;
      const removeNodes = [];
      while (nodesLength--) {
        const node = nodes[nodesLength];
        const nodeName = node.nodeName.toLowerCase();
        if (nodeName === "track") {
          if (!this.featuresNativeTextTracks) {
            removeNodes.push(node);
          } else {
            this.remoteTextTrackEls().addTrackElement_(node);
            this.remoteTextTracks().addTrack(node.track);
            this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }
      for (let i = 0; i < removeNodes.length; i++) {
        this.el_.removeChild(removeNodes[i]);
      }
    }
    this.proxyNativeTracks_();
    if (this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
    }
    this.restoreMetadataTracksInIOSNativePlayer_();
    if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {
      this.setControls(true);
    }
    this.proxyWebkitFullscreen_();
    this.triggerReady();
  }
  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */
  dispose() {
    if (this.el_ && this.el_.resetSourceset_) {
      this.el_.resetSourceset_();
    }
    Html5.disposeMediaElement(this.el_);
    this.options_ = null;
    super.dispose();
  }
  /**
   * Modify the media element so that we can detect when
   * the source is changed. Fires `sourceset` just after the source has changed
   */
  setupSourcesetHandling_() {
    setupSourceset(this);
  }
  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */
  restoreMetadataTracksInIOSNativePlayer_() {
    const textTracks = this.textTracks();
    let metadataTracksPreFullscreenState;
    const takeMetadataTrackSnapshot = () => {
      metadataTracksPreFullscreenState = [];
      for (let i = 0; i < textTracks.length; i++) {
        const track = textTracks[i];
        if (track.kind === "metadata") {
          metadataTracksPreFullscreenState.push({
            track,
            storedMode: track.mode
          });
        }
      }
    };
    takeMetadataTrackSnapshot();
    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
    this.on("dispose", () => textTracks.removeEventListener("change", takeMetadataTrackSnapshot));
    const restoreTrackMode = () => {
      for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        const storedTrack = metadataTracksPreFullscreenState[i];
        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      textTracks.removeEventListener("change", restoreTrackMode);
    };
    this.on("webkitbeginfullscreen", () => {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
      textTracks.addEventListener("change", restoreTrackMode);
    });
    this.on("webkitendfullscreen", () => {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.addEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
    });
  }
  /**
   * Attempt to force override of tracks for the given type
   *
   * @param {string} type - Track type to override, possible values include 'Audio',
   * 'Video', and 'Text'.
   * @param {boolean} override - If set to true native audio/video will be overridden,
   * otherwise native audio/video will potentially be used.
   * @private
   */
  overrideNative_(type, override) {
    if (override !== this[`featuresNative${type}Tracks`]) {
      return;
    }
    const lowerCaseType = type.toLowerCase();
    if (this[`${lowerCaseType}TracksListeners_`]) {
      Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach((eventName) => {
        const elTracks = this.el()[`${lowerCaseType}Tracks`];
        elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);
      });
    }
    this[`featuresNative${type}Tracks`] = !override;
    this[`${lowerCaseType}TracksListeners_`] = null;
    this.proxyNativeTracksForType_(lowerCaseType);
  }
  /**
   * Attempt to force override of native audio tracks.
   *
   * @param {boolean} override - If set to true native audio will be overridden,
   * otherwise native audio will potentially be used.
   */
  overrideNativeAudioTracks(override) {
    this.overrideNative_("Audio", override);
  }
  /**
   * Attempt to force override of native video tracks.
   *
   * @param {boolean} override - If set to true native video will be overridden,
   * otherwise native video will potentially be used.
   */
  overrideNativeVideoTracks(override) {
    this.overrideNative_("Video", override);
  }
  /**
   * Proxy native track list events for the given type to our track
   * lists if the browser we are playing in supports that type of track list.
   *
   * @param {string} name - Track type; values include 'audio', 'video', and 'text'
   * @private
   */
  proxyNativeTracksForType_(name) {
    const props = NORMAL[name];
    const elTracks = this.el()[props.getterName];
    const techTracks = this[props.getterName]();
    if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {
      return;
    }
    const listeners = {
      change: (e) => {
        const event2 = {
          type: "change",
          target: techTracks,
          currentTarget: techTracks,
          srcElement: techTracks
        };
        techTracks.trigger(event2);
        if (name === "text") {
          this[REMOTE.remoteText.getterName]().trigger(event2);
        }
      },
      addtrack(e) {
        techTracks.addTrack(e.track);
      },
      removetrack(e) {
        techTracks.removeTrack(e.track);
      }
    };
    const removeOldTracks = function() {
      const removeTracks = [];
      for (let i = 0; i < techTracks.length; i++) {
        let found = false;
        for (let j = 0; j < elTracks.length; j++) {
          if (elTracks[j] === techTracks[i]) {
            found = true;
            break;
          }
        }
        if (!found) {
          removeTracks.push(techTracks[i]);
        }
      }
      while (removeTracks.length) {
        techTracks.removeTrack(removeTracks.shift());
      }
    };
    this[props.getterName + "Listeners_"] = listeners;
    Object.keys(listeners).forEach((eventName) => {
      const listener = listeners[eventName];
      elTracks.addEventListener(eventName, listener);
      this.on("dispose", (e) => elTracks.removeEventListener(eventName, listener));
    });
    this.on("loadstart", removeOldTracks);
    this.on("dispose", (e) => this.off("loadstart", removeOldTracks));
  }
  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */
  proxyNativeTracks_() {
    NORMAL.names.forEach((name) => {
      this.proxyNativeTracksForType_(name);
    });
  }
  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  createEl() {
    let el = this.options_.tag;
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (el) {
        const clone = el.cloneNode(true);
        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document$1$1.createElement("video");
        const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        const attributes = merge$1({}, tagAttributes);
        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }
        setAttributes(el, Object.assign(attributes, {
          id: this.options_.techId,
          class: "vjs-tech"
        }));
      }
      el.playerId = this.options_.playerId;
    }
    if (typeof this.options_.preload !== "undefined") {
      setAttribute(el, "preload", this.options_.preload);
    }
    if (this.options_.disablePictureInPicture !== void 0) {
      el.disablePictureInPicture = this.options_.disablePictureInPicture;
    }
    const settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
    for (let i = 0; i < settingsAttrs.length; i++) {
      const attr = settingsAttrs[i];
      const value2 = this.options_[attr];
      if (typeof value2 !== "undefined") {
        if (value2) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value2;
      }
    }
    return el;
  }
  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */
  handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      return;
    }
    if (el.readyState === 0) {
      let loadstartFired = false;
      const setLoadstartFired = function() {
        loadstartFired = true;
      };
      this.on("loadstart", setLoadstartFired);
      const triggerLoadstart = function() {
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      };
      this.on("loadedmetadata", triggerLoadstart);
      this.ready(function() {
        this.off("loadstart", setLoadstartFired);
        this.off("loadedmetadata", triggerLoadstart);
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      });
      return;
    }
    const eventsToTrigger = ["loadstart"];
    eventsToTrigger.push("loadedmetadata");
    if (el.readyState >= 2) {
      eventsToTrigger.push("loadeddata");
    }
    if (el.readyState >= 3) {
      eventsToTrigger.push("canplay");
    }
    if (el.readyState >= 4) {
      eventsToTrigger.push("canplaythrough");
    }
    this.ready(function() {
      eventsToTrigger.forEach(function(type) {
        this.trigger(type);
      }, this);
    });
  }
  /**
   * Set whether we are scrubbing or not.
   * This is used to decide whether we should use `fastSeek` or not.
   * `fastSeek` is used to provide trick play on Safari browsers.
   *
   * @param {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  setScrubbing(isScrubbing) {
    this.isScrubbing_ = isScrubbing;
  }
  /**
   * Get whether we are scrubbing or not.
   *
   * @return {boolean} isScrubbing
   *                  - true for we are currently scrubbing
   *                  - false for we are no longer scrubbing
   */
  scrubbing() {
    return this.isScrubbing_;
  }
  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */
  setCurrentTime(seconds) {
    try {
      if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
        this.el_.fastSeek(seconds);
      } else {
        this.el_.currentTime = seconds;
      }
    } catch (e) {
      log$1(e, "Video is not ready. (Video.js)");
    }
  }
  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */
  duration() {
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      const checkProgress = () => {
        if (this.el_.currentTime > 0) {
          if (this.el_.duration === Infinity) {
            this.trigger("durationchange");
          }
          this.off("timeupdate", checkProgress);
        }
      };
      this.on("timeupdate", checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  }
  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */
  width() {
    return this.el_.offsetWidth;
  }
  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The height of the HTML5 media element.
   */
  height() {
    return this.el_.offsetHeight;
  }
  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */
  proxyWebkitFullscreen_() {
    if (!("webkitDisplayingFullscreen" in this.el_)) {
      return;
    }
    const endFn = function() {
      this.trigger("fullscreenchange", {
        isFullscreen: false
      });
      if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
        this.el_.controls = false;
      }
    };
    const beginFn = function() {
      if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
        this.one("webkitendfullscreen", endFn);
        this.trigger("fullscreenchange", {
          isFullscreen: true,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: true
        });
      }
    };
    this.on("webkitbeginfullscreen", beginFn);
    this.on("dispose", () => {
      this.off("webkitbeginfullscreen", beginFn);
      this.off("webkitendfullscreen", endFn);
    });
  }
  /**
   * Check if fullscreen is supported on the video el.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */
  supportsFullScreen() {
    return typeof this.el_.webkitEnterFullScreen === "function";
  }
  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */
  enterFullScreen() {
    const video = this.el_;
    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      silencePromise(this.el_.play());
      this.setTimeout(function() {
        video.pause();
        try {
          video.webkitEnterFullScreen();
        } catch (e) {
          this.trigger("fullscreenerror", e);
        }
      }, 0);
    } else {
      try {
        video.webkitEnterFullScreen();
      } catch (e) {
        this.trigger("fullscreenerror", e);
      }
    }
  }
  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */
  exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  }
  /**
   * Native requestVideoFrameCallback if supported by browser/tech, or fallback
   * Don't use rVCF on Safari when DRM is playing, as it doesn't fire
   * Needs to be checked later than the constructor
   * This will be a false positive for clear sources loaded after a Fairplay source
   *
   * @param {function} cb function to call
   * @return {number} id of request
   */
  requestVideoFrameCallback(cb) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      return this.el_.requestVideoFrameCallback(cb);
    }
    return super.requestVideoFrameCallback(cb);
  }
  /**
   * Native or fallback requestVideoFrameCallback
   *
   * @param {number} id request id to cancel
   */
  cancelVideoFrameCallback(id) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      this.el_.cancelVideoFrameCallback(id);
    } else {
      super.cancelVideoFrameCallback(id);
    }
  }
  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */
  src(src) {
    if (src === void 0) {
      return this.el_.src;
    }
    this.setSrc(src);
  }
  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */
  reset() {
    Html5.resetMediaElement(this.el_);
  }
  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */
  currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  }
  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */
  setControls(val) {
    this.el_.controls = !!val;
  }
  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */
  addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return super.addTextTrack(kind, label, language);
    }
    return this.el_.addTextTrack(kind, label, language);
  }
  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label]
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */
  createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return super.createRemoteTextTrack(options);
    }
    const htmlTrackElement = document$1$1.createElement("track");
    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options.default) {
      htmlTrackElement.default = options.default;
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }
    return htmlTrackElement;
  }
  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack
   * will not be removed from the TextTrackList and HtmlTrackElementList
   * after a source change
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   */
  addRemoteTextTrack(options, manualCleanup) {
    const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }
    return htmlTrackElement;
  }
  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */
  removeRemoteTextTrack(track) {
    super.removeRemoteTextTrack(track);
    if (this.featuresNativeTextTracks) {
      const tracks = this.$$("track");
      let i = tracks.length;
      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */
  getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === "function") {
      return this.el().getVideoPlaybackQuality();
    }
    const videoPlaybackQuality = {};
    if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }
    if (window$1$1.performance) {
      videoPlaybackQuality.creationTime = window$1$1.performance.now();
    }
    return videoPlaybackQuality;
  }
}
defineLazyProperty(Html5, "TEST_VID", function() {
  if (!isReal()) {
    return;
  }
  const video = document$1$1.createElement("video");
  const track = document$1$1.createElement("track");
  track.kind = "captions";
  track.srclang = "en";
  track.label = "English";
  video.appendChild(track);
  return video;
});
Html5.isSupported = function() {
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }
  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};
Html5.canPlayType = function(type) {
  return Html5.TEST_VID.canPlayType(type);
};
Html5.canPlaySource = function(srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};
Html5.canControlVolume = function() {
  try {
    const volume = Html5.TEST_VID.volume;
    Html5.TEST_VID.volume = volume / 2 + 0.1;
    const canControl = volume !== Html5.TEST_VID.volume;
    if (canControl && IS_IOS) {
      window$1$1.setTimeout(() => {
        if (Html5 && Html5.prototype) {
          Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
        }
      });
      return false;
    }
    return canControl;
  } catch (e) {
    return false;
  }
};
Html5.canMuteVolume = function() {
  try {
    const muted = Html5.TEST_VID.muted;
    Html5.TEST_VID.muted = !muted;
    if (Html5.TEST_VID.muted) {
      setAttribute(Html5.TEST_VID, "muted", "muted");
    } else {
      removeAttribute(Html5.TEST_VID, "muted", "muted");
    }
    return muted !== Html5.TEST_VID.muted;
  } catch (e) {
    return false;
  }
};
Html5.canControlPlaybackRate = function() {
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  try {
    const playbackRate = Html5.TEST_VID.playbackRate;
    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};
Html5.canOverrideAttributes = function() {
  try {
    const noop2 = () => {
    };
    Object.defineProperty(document$1$1.createElement("video"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document$1$1.createElement("audio"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document$1$1.createElement("video"), "innerHTML", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document$1$1.createElement("audio"), "innerHTML", {
      get: noop2,
      set: noop2
    });
  } catch (e) {
    return false;
  }
  return true;
};
Html5.supportsNativeTextTracks = function() {
  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
};
Html5.supportsNativeVideoTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};
Html5.supportsNativeAudioTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};
Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function([key, fn2]) {
  defineLazyProperty(Html5.prototype, key, () => Html5[fn2](), true);
});
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
Html5.prototype.movingMediaElementInDOM = !IS_IOS;
Html5.prototype.featuresFullscreenResize = true;
Html5.prototype.featuresProgressEvents = true;
Html5.prototype.featuresTimeupdateEvents = true;
Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
Html5.disposeMediaElement = function(el) {
  if (!el) {
    return;
  }
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
Html5.resetMediaElement = function(el) {
  if (!el) {
    return;
  }
  const sources = el.querySelectorAll("source");
  let i = sources.length;
  while (i--) {
    el.removeChild(sources[i]);
  }
  el.removeAttribute("src");
  if (typeof el.load === "function") {
    (function() {
      try {
        el.load();
      } catch (e) {
      }
    })();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
    this.el_[prop] = v;
    if (v) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop) {
  Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
    this.el_[prop] = v;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(prop) {
  Html5.prototype[prop] = function() {
    return this.el_[prop]();
  };
});
Tech.withSourceHandlers(Html5);
Html5.nativeSourceHandler = {};
Html5.nativeSourceHandler.canPlayType = function(type) {
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return "";
  }
};
Html5.nativeSourceHandler.canHandleSource = function(source, options) {
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);
  } else if (source.src) {
    const ext = getFileExtension(source.src);
    return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);
  }
  return "";
};
Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
  tech.setSrc(source.src);
};
Html5.nativeSourceHandler.dispose = function() {
};
Html5.registerSourceHandler(Html5.nativeSourceHandler);
Tech.registerTech("Html5", Html5);
const TECH_EVENTS_RETRIGGER = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
];
const TECH_EVENTS_QUEUE = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
};
const BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
const BREAKPOINT_CLASSES = {};
BREAKPOINT_ORDER.forEach((k) => {
  const v = k.charAt(0) === "x" ? `x-${k.substring(1)}` : k;
  BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;
});
const DEFAULT_BREAKPOINTS = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: Infinity
};
class Player extends Component$1 {
  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {PlayerReadyCallback} [ready]
   *        Ready callback function.
   */
  constructor(tag, options, ready) {
    tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;
    options = Object.assign(Player.getTagSettings(tag), options);
    options.initChildren = false;
    options.createEl = false;
    options.evented = false;
    options.reportTouchActivity = false;
    if (!options.language) {
      const closest = tag.closest("[lang]");
      if (closest) {
        options.language = closest.getAttribute("lang");
      }
    }
    super(null, options, ready);
    this.boundDocumentFullscreenChange_ = (e) => this.documentFullscreenChange_(e);
    this.boundFullWindowOnEscKey_ = (e) => this.fullWindowOnEscKey(e);
    this.boundUpdateStyleEl_ = (e) => this.updateStyleEl_(e);
    this.boundApplyInitTime_ = (e) => this.applyInitTime_(e);
    this.boundUpdateCurrentBreakpoint_ = (e) => this.updateCurrentBreakpoint_(e);
    this.boundHandleTechClick_ = (e) => this.handleTechClick_(e);
    this.boundHandleTechDoubleClick_ = (e) => this.handleTechDoubleClick_(e);
    this.boundHandleTechTouchStart_ = (e) => this.handleTechTouchStart_(e);
    this.boundHandleTechTouchMove_ = (e) => this.handleTechTouchMove_(e);
    this.boundHandleTechTouchEnd_ = (e) => this.handleTechTouchEnd_(e);
    this.boundHandleTechTap_ = (e) => this.handleTechTap_(e);
    this.boundUpdatePlayerHeightOnAudioOnlyMode_ = (e) => this.updatePlayerHeightOnAudioOnlyMode_(e);
    this.isFullscreen_ = false;
    this.log = createLogger(this.id_);
    this.fsApi_ = FullscreenApi;
    this.isPosterFromTech_ = false;
    this.queuedCallbacks_ = [];
    this.isReady_ = false;
    this.hasStarted_ = false;
    this.userActive_ = false;
    this.debugEnabled_ = false;
    this.audioOnlyMode_ = false;
    this.audioPosterMode_ = false;
    this.audioOnlyCache_ = {
      controlBarHeight: null,
      playerHeight: null,
      hiddenChildren: []
    };
    if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    }
    this.tag = tag;
    this.tagAttributes = tag && getAttributes(tag);
    this.language(this.options_.language);
    if (options.languages) {
      const languagesToLower = {};
      Object.getOwnPropertyNames(options.languages).forEach(function(name) {
        languagesToLower[name.toLowerCase()] = options.languages[name];
      });
      this.languages_ = languagesToLower;
    } else {
      this.languages_ = Player.prototype.options_.languages;
    }
    this.resetCache_();
    this.poster_ = options.poster || "";
    this.controls_ = !!options.controls;
    tag.controls = false;
    tag.removeAttribute("controls");
    this.changingSrc_ = false;
    this.playCallbacks_ = [];
    this.playTerminatedQueue_ = [];
    if (tag.hasAttribute("autoplay")) {
      this.autoplay(true);
    } else {
      this.autoplay(this.options_.autoplay);
    }
    if (options.plugins) {
      Object.keys(options.plugins).forEach((name) => {
        if (typeof this[name] !== "function") {
          throw new Error(`plugin "${name}" does not exist`);
        }
      });
    }
    this.scrubbing_ = false;
    this.el_ = this.createEl();
    evented(this, {
      eventBusKey: "el_"
    });
    if (this.fsApi_.requestFullscreen) {
      on(document$1$1, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
      this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
    }
    if (this.fluid_) {
      this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
    }
    const playerOptionsCopy = merge$1(this.options_);
    if (options.plugins) {
      Object.keys(options.plugins).forEach((name) => {
        this[name](options.plugins[name]);
      });
    }
    if (options.debug) {
      this.debug(true);
    }
    this.options_.playerOptions = playerOptionsCopy;
    this.middleware_ = [];
    this.playbackRates(options.playbackRates);
    if (options.experimentalSvgIcons) {
      const parser2 = new window$1$1.DOMParser();
      const parsedSVG = parser2.parseFromString(icons, "image/svg+xml");
      const errorNode = parsedSVG.querySelector("parsererror");
      if (errorNode) {
        log$1.warn("Failed to load SVG Icons. Falling back to Font Icons.");
        this.options_.experimentalSvgIcons = null;
      } else {
        const sprite = parsedSVG.documentElement;
        sprite.style.display = "none";
        this.el_.appendChild(sprite);
        this.addClass("vjs-svg-icons-enabled");
      }
    }
    this.initChildren();
    this.isAudio(tag.nodeName.toLowerCase() === "audio");
    if (this.controls()) {
      this.addClass("vjs-controls-enabled");
    } else {
      this.addClass("vjs-controls-disabled");
    }
    this.el_.setAttribute("role", "region");
    if (this.isAudio()) {
      this.el_.setAttribute("aria-label", this.localize("Audio Player"));
    } else {
      this.el_.setAttribute("aria-label", this.localize("Video Player"));
    }
    if (this.isAudio()) {
      this.addClass("vjs-audio");
    }
    if (options.spatialNavigation && options.spatialNavigation.enabled) {
      this.spatialNavigation = new SpatialNavigation(this);
      this.addClass("vjs-spatial-navigation-enabled");
    }
    if (TOUCH_ENABLED) {
      this.addClass("vjs-touch-enabled");
    }
    if (!IS_IOS) {
      this.addClass("vjs-workinghover");
    }
    Player.players[this.id_] = this;
    const majorVersion = version$6.split(".")[0];
    this.addClass(`vjs-v${majorVersion}`);
    this.userActive(true);
    this.reportUserActivity();
    this.one("play", (e) => this.listenForUserActivity_(e));
    this.on("keydown", (e) => this.handleKeyDown(e));
    this.on("languagechange", (e) => this.handleLanguagechange(e));
    this.breakpoints(this.options_.breakpoints);
    this.responsive(this.options_.responsive);
    this.on("ready", () => {
      this.audioPosterMode(this.options_.audioPosterMode);
      this.audioOnlyMode(this.options_.audioOnlyMode);
    });
  }
  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */
  dispose() {
    this.trigger("dispose");
    this.off("dispose");
    off(document$1$1, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
    off(document$1$1, "keydown", this.boundFullWindowOnEscKey_);
    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }
    Player.players[this.id_] = null;
    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }
    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }
    if (this.tech_) {
      this.tech_.dispose();
      this.isPosterFromTech_ = false;
      this.poster_ = "";
    }
    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }
    if (this.tag) {
      this.tag = null;
    }
    clearCacheForPlayer(this);
    ALL.names.forEach((name) => {
      const props = ALL[name];
      const list = this[props.getterName]();
      if (list && list.off) {
        list.off();
      }
    });
    super.dispose({
      restoreEl: this.options_.restoreEl
    });
  }
  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */
  createEl() {
    let tag = this.tag;
    let el;
    let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
    const divEmbed = this.tag.tagName.toLowerCase() === "video-js";
    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el = this.el_ = super.createEl("div");
    }
    const attrs = getAttributes(tag);
    if (divEmbed) {
      el = this.el_ = tag;
      tag = this.tag = document$1$1.createElement("video");
      while (el.children.length) {
        tag.appendChild(el.firstChild);
      }
      if (!hasClass(el, "video-js")) {
        addClass(el, "video-js");
      }
      el.appendChild(tag);
      playerElIngest = this.playerElIngest_ = el;
      Object.keys(el).forEach((k) => {
        try {
          tag[k] = el[k];
        } catch (e) {
        }
      });
    }
    tag.setAttribute("tabindex", "-1");
    attrs.tabindex = "-1";
    if (IS_CHROME && IS_WINDOWS) {
      tag.setAttribute("role", "application");
      attrs.role = "application";
    }
    tag.removeAttribute("width");
    tag.removeAttribute("height");
    if ("width" in attrs) {
      delete attrs.width;
    }
    if ("height" in attrs) {
      delete attrs.height;
    }
    Object.getOwnPropertyNames(attrs).forEach(function(attr) {
      if (!(divEmbed && attr === "class")) {
        el.setAttribute(attr, attrs[attr]);
      }
      if (divEmbed) {
        tag.setAttribute(attr, attrs[attr]);
      }
    });
    tag.playerId = tag.id;
    tag.id += "_html5_api";
    tag.className = "vjs-tech";
    tag.player = el.player = this;
    this.addClass("vjs-paused");
    const deviceClassNames = ["IS_SMART_TV", "IS_TIZEN", "IS_WEBOS", "IS_ANDROID", "IS_IPAD", "IS_IPHONE", "IS_CHROMECAST_RECEIVER"].filter((key) => browser$1[key]).map((key) => {
      return "vjs-device-" + key.substring(3).toLowerCase().replace(/\_/g, "-");
    });
    this.addClass(...deviceClassNames);
    if (window$1$1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement("vjs-styles-dimensions");
      const defaultsStyleEl = $(".vjs-styles-defaults");
      const head = $("head");
      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }
    this.fill_ = false;
    this.fluid_ = false;
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fill(this.options_.fill);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);
    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    const links = tag.getElementsByTagName("a");
    for (let i = 0; i < links.length; i++) {
      const linkEl = links.item(i);
      addClass(linkEl, "vjs-hidden");
      linkEl.setAttribute("hidden", "hidden");
    }
    tag.initNetworkState_ = tag.networkState;
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }
    prependTo(tag, el);
    this.children_.unshift(tag);
    this.el_.setAttribute("lang", this.language_);
    this.el_.setAttribute("translate", "no");
    this.el_ = el;
    return el;
  }
  /**
   * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this
   * sets the `crossOrigin` property on the `<video>` tag to control the CORS
   * behavior.
   *
   * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}
   *
   * @param {string|null} [value]
   *        The value to set the `Player`'s crossOrigin to. If an argument is
   *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.
   *
   * @return {string|null|undefined}
   *         - The current crossOrigin value of the `Player` when getting.
   *         - undefined when setting
   */
  crossOrigin(value2) {
    if (typeof value2 === "undefined") {
      return this.techGet_("crossOrigin");
    }
    if (value2 !== null && value2 !== "anonymous" && value2 !== "use-credentials") {
      log$1.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value2}"`);
      return;
    }
    this.techCall_("setCrossOrigin", value2);
    if (this.posterImage) {
      this.posterImage.crossOrigin(value2);
    }
    return;
  }
  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s width to.
   *
   * @return {number|undefined}
   *         - The current width of the `Player` when getting.
   *         - Nothing when setting
   */
  width(value2) {
    return this.dimension("width", value2);
  }
  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number|string} [value]
   *        CSS value to set the `Player`'s height to.
   *
   * @return {number|undefined}
   *         - The current height of the `Player` when getting.
   *         - Nothing when setting
   */
  height(value2) {
    return this.dimension("height", value2);
  }
  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number|string} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */
  dimension(dimension, value2) {
    const privDimension = dimension + "_";
    if (value2 === void 0) {
      return this[privDimension] || 0;
    }
    if (value2 === "" || value2 === "auto") {
      this[privDimension] = void 0;
      this.updateStyleEl_();
      return;
    }
    const parsedVal = parseFloat(value2);
    if (isNaN(parsedVal)) {
      log$1.error(`Improper value "${value2}" supplied for for ${dimension}`);
      return;
    }
    this[privDimension] = parsedVal;
    this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * Turning this on will turn off fill mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fluid(bool) {
    if (bool === void 0) {
      return !!this.fluid_;
    }
    this.fluid_ = !!bool;
    if (isEvented(this)) {
      this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
    }
    if (bool) {
      this.addClass("vjs-fluid");
      this.fill(false);
      addEventedCallback(this, () => {
        this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
      });
    } else {
      this.removeClass("vjs-fluid");
    }
    this.updateStyleEl_();
  }
  /**
   * A getter/setter/toggler for the vjs-fill `className` on the `Player`.
   *
   * Turning this on will turn off fluid mode.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will be a getter.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */
  fill(bool) {
    if (bool === void 0) {
      return !!this.fill_;
    }
    this.fill_ = !!bool;
    if (bool) {
      this.addClass("vjs-fill");
      this.fluid(false);
    } else {
      this.removeClass("vjs-fill");
    }
  }
  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */
  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player`'s aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */
  aspectRatio(ratio) {
    if (ratio === void 0) {
      return this.aspectRatio_;
    }
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    }
    this.aspectRatio_ = ratio;
    this.fluid(true);
    this.updateStyleEl_();
  }
  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */
  updateStyleEl_() {
    if (window$1$1.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      const width2 = typeof this.width_ === "number" ? this.width_ : this.options_.width;
      const height2 = typeof this.height_ === "number" ? this.height_ : this.options_.height;
      const techEl = this.tech_ && this.tech_.el();
      if (techEl) {
        if (width2 >= 0) {
          techEl.width = width2;
        }
        if (height2 >= 0) {
          techEl.height = height2;
        }
      }
      return;
    }
    let width;
    let height;
    let aspectRatio;
    let idClass;
    if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      aspectRatio = this.videoWidth() + ":" + this.videoHeight();
    } else {
      aspectRatio = "16:9";
    }
    const ratioParts = aspectRatio.split(":");
    const ratioMultiplier = ratioParts[1] / ratioParts[0];
    if (this.width_ !== void 0) {
      width = this.width_;
    } else if (this.height_ !== void 0) {
      width = this.height_ / ratioMultiplier;
    } else {
      width = this.videoWidth() || 300;
    }
    if (this.height_ !== void 0) {
      height = this.height_;
    } else {
      height = width * ratioMultiplier;
    }
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = "dimensions-" + this.id();
    } else {
      idClass = this.id() + "-dimensions";
    }
    this.addClass(idClass);
    setTextContent(this.styleEl_, `
      .${idClass} {
        width: ${width}px;
        height: ${height}px;
      }

      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${ratioMultiplier * 100}%;
      }
    `);
  }
  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */
  loadTech_(techName, source) {
    if (this.tech_) {
      this.unloadTech_();
    }
    const titleTechName = toTitleCase$1(techName);
    const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
    if (titleTechName !== "Html5" && this.tag) {
      Tech.getTech("Html5").disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }
    this.techName_ = titleTechName;
    this.isReady_ = false;
    let autoplay = this.autoplay();
    if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
      autoplay = false;
    }
    const techOptions = {
      source,
      autoplay,
      "nativeControlsForTouch": this.options_.nativeControlsForTouch,
      "playerId": this.id(),
      "techId": `${this.id()}_${camelTechName}_api`,
      "playsinline": this.options_.playsinline,
      "preload": this.options_.preload,
      "loop": this.options_.loop,
      "disablePictureInPicture": this.options_.disablePictureInPicture,
      "muted": this.options_.muted,
      "poster": this.poster(),
      "language": this.language(),
      "playerElIngest": this.playerElIngest_ || false,
      "vtt.js": this.options_["vtt.js"],
      "canOverridePoster": !!this.options_.techCanOverridePoster,
      "enableSourceset": this.options_.enableSourceset
    };
    ALL.names.forEach((name) => {
      const props = ALL[name];
      techOptions[props.getterName] = this[props.privateName];
    });
    Object.assign(techOptions, this.options_[titleTechName]);
    Object.assign(techOptions, this.options_[camelTechName]);
    Object.assign(techOptions, this.options_[techName.toLowerCase()]);
    if (this.tag) {
      techOptions.tag = this.tag;
    }
    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }
    const TechClass = Tech.getTech(techName);
    if (!TechClass) {
      throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);
    }
    this.tech_ = new TechClass(techOptions);
    this.tech_.ready(bind_(this, this.handleTechReady_), true);
    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
    TECH_EVENTS_RETRIGGER.forEach((event2) => {
      this.on(this.tech_, event2, (e) => this[`handleTech${toTitleCase$1(event2)}_`](e));
    });
    Object.keys(TECH_EVENTS_QUEUE).forEach((event2) => {
      this.on(this.tech_, event2, (eventObj) => {
        if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
          this.queuedCallbacks_.push({
            callback: this[`handleTech${TECH_EVENTS_QUEUE[event2]}_`].bind(this),
            event: eventObj
          });
          return;
        }
        this[`handleTech${TECH_EVENTS_QUEUE[event2]}_`](eventObj);
      });
    });
    this.on(this.tech_, "loadstart", (e) => this.handleTechLoadStart_(e));
    this.on(this.tech_, "sourceset", (e) => this.handleTechSourceset_(e));
    this.on(this.tech_, "waiting", (e) => this.handleTechWaiting_(e));
    this.on(this.tech_, "ended", (e) => this.handleTechEnded_(e));
    this.on(this.tech_, "seeking", (e) => this.handleTechSeeking_(e));
    this.on(this.tech_, "play", (e) => this.handleTechPlay_(e));
    this.on(this.tech_, "pause", (e) => this.handleTechPause_(e));
    this.on(this.tech_, "durationchange", (e) => this.handleTechDurationChange_(e));
    this.on(this.tech_, "fullscreenchange", (e, data) => this.handleTechFullscreenChange_(e, data));
    this.on(this.tech_, "fullscreenerror", (e, err) => this.handleTechFullscreenError_(e, err));
    this.on(this.tech_, "enterpictureinpicture", (e) => this.handleTechEnterPictureInPicture_(e));
    this.on(this.tech_, "leavepictureinpicture", (e) => this.handleTechLeavePictureInPicture_(e));
    this.on(this.tech_, "error", (e) => this.handleTechError_(e));
    this.on(this.tech_, "posterchange", (e) => this.handleTechPosterChange_(e));
    this.on(this.tech_, "textdata", (e) => this.handleTechTextData_(e));
    this.on(this.tech_, "ratechange", (e) => this.handleTechRateChange_(e));
    this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
    this.usingNativeControls(this.techGet_("controls"));
    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  }
  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */
  unloadTech_() {
    ALL.names.forEach((name) => {
      const props = ALL[name];
      this[props.privateName] = this[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
    this.isReady_ = false;
    this.tech_.dispose();
    this.tech_ = false;
    if (this.isPosterFromTech_) {
      this.poster_ = "";
      this.trigger("posterchange");
    }
    this.isPosterFromTech_ = false;
  }
  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */
  tech(safety) {
    if (safety === void 0) {
      log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
    }
    return this.tech_;
  }
  /**
   * An object that contains Video.js version.
   *
   * @typedef {Object} PlayerVersion
   *
   * @property {string} 'video.js' - Video.js version
   */
  /**
   * Returns an object with Video.js version.
   *
   * @return {PlayerVersion}
   *          An object with Video.js version.
   */
  version() {
    return {
      "video.js": version$6
    };
  }
  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */
  addTechControlsListeners_() {
    this.removeTechControlsListeners_();
    this.on(this.tech_, "click", this.boundHandleTechClick_);
    this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
    this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.on(this.tech_, "tap", this.boundHandleTechTap_);
  }
  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */
  removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_);
    this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.off(this.tech_, "click", this.boundHandleTechClick_);
    this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  }
  /**
   * Player waits for the tech to be ready
   *
   * @private
   */
  handleTechReady_() {
    this.triggerReady();
    if (this.cache_.volume) {
      this.techCall_("setVolume", this.cache_.volume);
    }
    this.handleTechPosterChange_();
    this.handleTechDurationChange_();
  }
  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}.
   *
   * @fires Player#loadstart
   * @listens Tech#loadstart
   * @private
   */
  handleTechLoadStart_() {
    this.removeClass("vjs-ended", "vjs-seeking");
    this.error(null);
    this.handleTechDurationChange_();
    if (!this.paused()) {
      this.trigger("loadstart");
    } else {
      this.hasStarted(false);
      this.trigger("loadstart");
    }
    this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  }
  /**
   * Handle autoplay string values, rather than the typical boolean
   * values that should be handled by the tech. Note that this is not
   * part of any specification. Valid values and what they do can be
   * found on the autoplay getter at Player#autoplay()
   */
  manualAutoplay_(type) {
    if (!this.tech_ || typeof type !== "string") {
      return;
    }
    const resolveMuted = () => {
      const previouslyMuted = this.muted();
      this.muted(true);
      const restoreMuted = () => {
        this.muted(previouslyMuted);
      };
      this.playTerminatedQueue_.push(restoreMuted);
      const mutedPromise = this.play();
      if (!isPromise(mutedPromise)) {
        return;
      }
      return mutedPromise.catch((err) => {
        restoreMuted();
        throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ""}`);
      });
    };
    let promise;
    if (type === "any" && !this.muted()) {
      promise = this.play();
      if (isPromise(promise)) {
        promise = promise.catch(resolveMuted);
      }
    } else if (type === "muted" && !this.muted()) {
      promise = resolveMuted();
    } else {
      promise = this.play();
    }
    if (!isPromise(promise)) {
      return;
    }
    return promise.then(() => {
      this.trigger({
        type: "autoplay-success",
        autoplay: type
      });
    }).catch(() => {
      this.trigger({
        type: "autoplay-failure",
        autoplay: type
      });
    });
  }
  /**
   * Update the internal source caches so that we return the correct source from
   * `src()`, `currentSource()`, and `currentSources()`.
   *
   * > Note: `currentSources` will not be updated if the source that is passed in exists
   *         in the current `currentSources` cache.
   *
   *
   * @param {Tech~SourceObject} srcObj
   *        A string or object source to update our caches to.
   */
  updateSourceCaches_(srcObj = "") {
    let src = srcObj;
    let type = "";
    if (typeof src !== "string") {
      src = srcObj.src;
      type = srcObj.type;
    }
    this.cache_.source = this.cache_.source || {};
    this.cache_.sources = this.cache_.sources || [];
    if (src && !type) {
      type = findMimetype(this, src);
    }
    this.cache_.source = merge$1({}, srcObj, {
      src,
      type
    });
    const matchingSources = this.cache_.sources.filter((s) => s.src && s.src === src);
    const sourceElSources = [];
    const sourceEls = this.$$("source");
    const matchingSourceEls = [];
    for (let i = 0; i < sourceEls.length; i++) {
      const sourceObj = getAttributes(sourceEls[i]);
      sourceElSources.push(sourceObj);
      if (sourceObj.src && sourceObj.src === src) {
        matchingSourceEls.push(sourceObj.src);
      }
    }
    if (matchingSourceEls.length && !matchingSources.length) {
      this.cache_.sources = sourceElSources;
    } else if (!matchingSources.length) {
      this.cache_.sources = [this.cache_.source];
    }
    this.cache_.src = src;
  }
  /**
   * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}
   * causing the media element to reload.
   *
   * It will fire for the initial source and each subsequent source.
   * This event is a custom event from Video.js and is triggered by the {@link Tech}.
   *
   * The event object for this event contains a `src` property that will contain the source
   * that was available when the event was triggered. This is generally only necessary if Video.js
   * is switching techs while the source was being changed.
   *
   * It is also fired when `load` is called on the player (or media element)
   * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}
   * says that the resource selection algorithm needs to be aborted and restarted.
   * In this case, it is very likely that the `src` property will be set to the
   * empty string `""` to indicate we do not know what the source will be but
   * that it is changing.
   *
   * *This event is currently still experimental and may change in minor releases.*
   * __To use this, pass `enableSourceset` option to the player.__
   *
   * @event Player#sourceset
   * @type {Event}
   * @prop {string} src
   *                The source url available when the `sourceset` was triggered.
   *                It will be an empty string if we cannot know what the source is
   *                but know that the source will change.
   */
  /**
   * Retrigger the `sourceset` event that was triggered by the {@link Tech}.
   *
   * @fires Player#sourceset
   * @listens Tech#sourceset
   * @private
   */
  handleTechSourceset_(event2) {
    if (!this.changingSrc_) {
      let updateSourceCaches = (src) => this.updateSourceCaches_(src);
      const playerSrc = this.currentSource().src;
      const eventSrc = event2.src;
      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
          updateSourceCaches = () => {
          };
        }
      }
      updateSourceCaches(eventSrc);
      if (!event2.src) {
        this.tech_.any(["sourceset", "loadstart"], (e) => {
          if (e.type === "sourceset") {
            return;
          }
          const techSrc = this.techGet_("currentSrc");
          this.lastSource_.tech = techSrc;
          this.updateSourceCaches_(techSrc);
        });
      }
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: event2.src
    };
    this.trigger({
      src: event2.src,
      type: "sourceset"
    });
  }
  /**
   * Add/remove the vjs-has-started class
   *
   *
   * @param {boolean} request
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted_
   */
  hasStarted(request) {
    if (request === void 0) {
      return this.hasStarted_;
    }
    if (request === this.hasStarted_) {
      return;
    }
    this.hasStarted_ = request;
    if (this.hasStarted_) {
      this.addClass("vjs-has-started");
    } else {
      this.removeClass("vjs-has-started");
    }
  }
  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */
  handleTechPlay_() {
    this.removeClass("vjs-ended", "vjs-paused");
    this.addClass("vjs-playing");
    this.hasStarted(true);
    this.trigger("play");
  }
  /**
   * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
   *
   * If there were any events queued while the playback rate was zero, fire
   * those events now.
   *
   * @private
   * @method Player#handleTechRateChange_
   * @fires Player#ratechange
   * @listens Tech#ratechange
   */
  handleTechRateChange_() {
    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
      this.queuedCallbacks_.forEach((queued) => queued.callback(queued.event));
      this.queuedCallbacks_ = [];
    }
    this.cache_.lastPlaybackRate = this.tech_.playbackRate();
    this.trigger("ratechange");
  }
  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */
  handleTechWaiting_() {
    this.addClass("vjs-waiting");
    this.trigger("waiting");
    const timeWhenWaiting = this.currentTime();
    const timeUpdateListener = () => {
      if (timeWhenWaiting !== this.currentTime()) {
        this.removeClass("vjs-waiting");
        this.off("timeupdate", timeUpdateListener);
      }
    };
    this.on("timeupdate", timeUpdateListener);
  }
  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */
  handleTechCanPlay_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplay");
  }
  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */
  handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplaythrough");
  }
  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */
  handleTechPlaying_() {
    this.removeClass("vjs-waiting");
    this.trigger("playing");
  }
  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */
  handleTechSeeking_() {
    this.addClass("vjs-seeking");
    this.trigger("seeking");
  }
  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */
  handleTechSeeked_() {
    this.removeClass("vjs-seeking", "vjs-ended");
    this.trigger("seeked");
  }
  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */
  handleTechPause_() {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.trigger("pause");
  }
  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */
  handleTechEnded_() {
    this.addClass("vjs-ended");
    this.removeClass("vjs-waiting");
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }
    this.trigger("ended");
  }
  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */
  handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  }
  /**
   * Handle a click on the media element to play/pause
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#click
   * @private
   */
  handleTechClick_(event2) {
    if (!this.controls_) {
      return;
    }
    if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
      if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
        this.options_.userActions.click.call(this, event2);
      } else if (this.paused()) {
        silencePromise(this.play());
      } else {
        this.pause();
      }
    }
  }
  /**
   * Handle a double-click on the media element to enter/exit fullscreen
   *
   * @param {Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#dblclick
   * @private
   */
  handleTechDoubleClick_(event2) {
    if (!this.controls_) {
      return;
    }
    const inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (el) => el.contains(event2.target));
    if (!inAllowedEls) {
      if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
        if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
          this.options_.userActions.doubleClick.call(this, event2);
        } else if (this.isFullscreen()) {
          this.exitFullscreen();
        } else {
          this.requestFullscreen();
        }
      }
    }
  }
  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */
  handleTechTap_() {
    this.userActive(!this.userActive());
  }
  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */
  handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  }
  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */
  handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  }
  /**
   * Handle touch to end
   *
   * @param {Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */
  handleTechTouchEnd_(event2) {
    if (event2.cancelable) {
      event2.preventDefault();
    }
  }
  /**
   * @private
   */
  toggleFullscreenClass_() {
    if (this.isFullscreen()) {
      this.addClass("vjs-fullscreen");
    } else {
      this.removeClass("vjs-fullscreen");
    }
  }
  /**
   * when the document fschange event triggers it calls this
   */
  documentFullscreenChange_(e) {
    const targetPlayer = e.target.player;
    if (targetPlayer && targetPlayer !== this) {
      return;
    }
    const el = this.el();
    let isFs = document$1$1[this.fsApi_.fullscreenElement] === el;
    if (!isFs && el.matches) {
      isFs = el.matches(":" + this.fsApi_.fullscreen);
    }
    this.isFullscreen(isFs);
  }
  /**
   * Handle Tech Fullscreen Change
   *
   * @param {Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */
  handleTechFullscreenChange_(event2, data) {
    if (data) {
      if (data.nativeIOSFullscreen) {
        this.addClass("vjs-ios-native-fs");
        this.tech_.one("webkitendfullscreen", () => {
          this.removeClass("vjs-ios-native-fs");
        });
      }
      this.isFullscreen(data.isFullscreen);
    }
  }
  handleTechFullscreenError_(event2, err) {
    this.trigger("fullscreenerror", err);
  }
  /**
   * @private
   */
  togglePictureInPictureClass_() {
    if (this.isInPictureInPicture()) {
      this.addClass("vjs-picture-in-picture");
    } else {
      this.removeClass("vjs-picture-in-picture");
    }
  }
  /**
   * Handle Tech Enter Picture-in-Picture.
   *
   * @param {Event} event
   *        the enterpictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#enterpictureinpicture
   */
  handleTechEnterPictureInPicture_(event2) {
    this.isInPictureInPicture(true);
  }
  /**
   * Handle Tech Leave Picture-in-Picture.
   *
   * @param {Event} event
   *        the leavepictureinpicture event that triggered this function
   *
   * @private
   * @listens Tech#leavepictureinpicture
   */
  handleTechLeavePictureInPicture_(event2) {
    this.isInPictureInPicture(false);
  }
  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */
  handleTechError_() {
    const error = this.tech_.error();
    if (error) {
      this.error(error);
    }
  }
  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */
  handleTechTextData_() {
    let data = null;
    if (arguments.length > 1) {
      data = arguments[1];
    }
    this.trigger("textdata", data);
  }
  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */
  getCache() {
    return this.cache_;
  }
  /**
   * Resets the internal cache object.
   *
   * Using this function outside the player constructor or reset method may
   * have unintended side-effects.
   *
   * @private
   */
  resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  }
  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} [arg]
   *        the argument to pass
   *
   * @private
   */
  techCall_(method, arg) {
    this.ready(function() {
      if (method in allowedSetters) {
        return set(this.middleware_, this.tech_, method, arg);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method, arg);
      }
      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  }
  /**
   * Mediate attempt to call playback tech method
   * and return the value of the method called.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {*}
   *         Value returned by the tech method called, undefined if tech
   *         is not ready or tech method is not present
   *
   * @private
   */
  techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }
    if (method in allowedGetters) {
      return get(this.middleware_, this.tech_, method);
    } else if (method in allowedMediators) {
      return mediate(this.middleware_, this.tech_, method);
    }
    try {
      return this.tech_[method]();
    } catch (e) {
      if (this.tech_[method] === void 0) {
        log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);
        throw e;
      }
      if (e.name === "TypeError") {
        log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);
        this.tech_.isReady_ = false;
        throw e;
      }
      log$1(e);
      throw e;
    }
  }
  /**
   * Attempt to begin playback at the first opportunity.
   *
   * @return {Promise|undefined}
   *         Returns a promise if the browser supports Promises (or one
   *         was passed in as an option). This promise will be resolved on
   *         the return value of play. If this is undefined it will fulfill the
   *         promise chain otherwise the promise chain will be fulfilled when
   *         the promise from play is fulfilled.
   */
  play() {
    return new Promise((resolve) => {
      this.play_(resolve);
    });
  }
  /**
   * The actual logic for play, takes a callback that will be resolved on the
   * return value of play. This allows us to resolve to the play promise if there
   * is one on modern browsers.
   *
   * @private
   * @param {Function} [callback]
   *        The callback that should be called when the techs play is actually called
   */
  play_(callback = silencePromise) {
    this.playCallbacks_.push(callback);
    const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
    const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);
    if (this.waitToPlay_) {
      this.off(["ready", "loadstart"], this.waitToPlay_);
      this.waitToPlay_ = null;
    }
    if (!this.isReady_ || !isSrcReady) {
      this.waitToPlay_ = (e) => {
        this.play_();
      };
      this.one(["ready", "loadstart"], this.waitToPlay_);
      if (!isSrcReady && isSafariOrIOS) {
        this.load();
      }
      return;
    }
    const val = this.techGet_("play");
    const isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
    if (isNativeReplay) {
      this.resetProgressBar_();
    }
    if (val === null) {
      this.runPlayTerminatedQueue_();
    } else {
      this.runPlayCallbacks_(val);
    }
  }
  /**
   * These functions will be run when if play is terminated. If play
   * runPlayCallbacks_ is run these function will not be run. This allows us
   * to differentiate between a terminated play and an actual call to play.
   */
  runPlayTerminatedQueue_() {
    const queue = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [];
    queue.forEach(function(q) {
      q();
    });
  }
  /**
   * When a callback to play is delayed we have to run these
   * callbacks when play is actually called on the tech. This function
   * runs the callbacks that were delayed and accepts the return value
   * from the tech.
   *
   * @param {undefined|Promise} val
   *        The return value from the tech.
   */
  runPlayCallbacks_(val) {
    const callbacks = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [];
    this.playTerminatedQueue_ = [];
    callbacks.forEach(function(cb) {
      cb(val);
    });
  }
  /**
   * Pause the video playback
   */
  pause() {
    this.techCall_("pause");
  }
  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */
  paused() {
    return this.techGet_("paused") === false ? false : true;
  }
  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */
  played() {
    return this.techGet_("played") || createTimeRanges$1(0, 0);
  }
  /**
   * Sets or returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        whether the user is or is not scrubbing
   *
   * @return {boolean|undefined}
   *         - The value of scrubbing when getting
   *         - Nothing when setting
   */
  scrubbing(isScrubbing) {
    if (typeof isScrubbing === "undefined") {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;
    this.techCall_("setScrubbing", this.scrubbing_);
    if (isScrubbing) {
      this.addClass("vjs-scrubbing");
    } else {
      this.removeClass("vjs-scrubbing");
    }
  }
  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number|undefined}
   *         - the current time in seconds when getting
   *         - Nothing when setting
   */
  currentTime(seconds) {
    if (seconds === void 0) {
      this.cache_.currentTime = this.techGet_("currentTime") || 0;
      return this.cache_.currentTime;
    }
    if (seconds < 0) {
      seconds = 0;
    }
    if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
      this.cache_.initTime = seconds;
      this.off("canplay", this.boundApplyInitTime_);
      this.one("canplay", this.boundApplyInitTime_);
      return;
    }
    this.techCall_("setCurrentTime", seconds);
    this.cache_.initTime = 0;
    if (isFinite(seconds)) {
      this.cache_.currentTime = Number(seconds);
    }
  }
  /**
   * Apply the value of initTime stored in cache as currentTime.
   *
   * @private
   */
  applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  }
  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and depending on preload behaviour may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number|undefined}
   *         - The duration of the video in seconds when getting
   *         - Nothing when setting
   */
  duration(seconds) {
    if (seconds === void 0) {
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    }
    seconds = parseFloat(seconds);
    if (seconds < 0) {
      seconds = Infinity;
    }
    if (seconds !== this.cache_.duration) {
      this.cache_.duration = seconds;
      if (seconds === Infinity) {
        this.addClass("vjs-live");
      } else {
        this.removeClass("vjs-live");
      }
      if (!isNaN(seconds)) {
        this.trigger("durationchange");
      }
    }
  }
  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */
  remainingTime() {
    return this.duration() - this.currentTime();
  }
  /**
   * A remaining time function that is intended to be used when
   * the time is to be displayed directly to the user.
   *
   * @return {number}
   *         The rounded time remaining in seconds
   */
  remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  }
  //
  // Kind of like an array of portions of the video that have been downloaded.
  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  buffered() {
    let buffered = this.techGet_("buffered");
    if (!buffered || !buffered.length) {
      buffered = createTimeRanges$1(0, 0);
    }
    return buffered;
  }
  /**
   * Get the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @see [Seekable Spec]{@link https://html.spec.whatwg.org/multipage/media.html#dom-media-seekable}
   *
   * @return {TimeRange}
   *         A mock {@link TimeRanges} object (following HTML spec)
   */
  seekable() {
    let seekable2 = this.techGet_("seekable");
    if (!seekable2 || !seekable2.length) {
      seekable2 = createTimeRanges$1(0, 0);
    }
    return seekable2;
  }
  /**
   * Returns whether the player is in the "seeking" state.
   *
   * @return {boolean} True if the player is in the seeking state, false if not.
   */
  seeking() {
    return this.techGet_("seeking");
  }
  /**
   * Returns whether the player is in the "ended" state.
   *
   * @return {boolean} True if the player is in the ended state, false if not.
   */
  ended() {
    return this.techGet_("ended");
  }
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   */
  networkState() {
    return this.techGet_("networkState");
  }
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   */
  readyState() {
    return this.techGet_("readyState");
  }
  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is buffered 0 being 0% and 1 being 100%
   */
  bufferedPercent() {
    return bufferedPercent(this.buffered(), this.duration());
  }
  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */
  bufferedEnd() {
    const buffered = this.buffered();
    const duration2 = this.duration();
    let end2 = buffered.end(buffered.length - 1);
    if (end2 > duration2) {
      end2 = duration2;
    }
    return end2;
  }
  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         The current volume as a percent when getting
   */
  volume(percentAsDecimal) {
    let vol;
    if (percentAsDecimal !== void 0) {
      vol = Math.max(0, Math.min(1, percentAsDecimal));
      this.cache_.volume = vol;
      this.techCall_("setVolume", vol);
      if (vol > 0) {
        this.lastVolume_(vol);
      }
      return;
    }
    vol = parseFloat(this.techGet_("volume"));
    return isNaN(vol) ? 1 : vol;
  }
  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   *         - nothing if setting
   */
  muted(muted) {
    if (muted !== void 0) {
      this.techCall_("setMuted", muted);
      return;
    }
    return this.techGet_("muted") || false;
  }
  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on initial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|undefined}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - Nothing when setting
   */
  defaultMuted(defaultMuted) {
    if (defaultMuted !== void 0) {
      this.techCall_("setDefaultMuted", defaultMuted);
    }
    return this.techGet_("defaultMuted") || false;
  }
  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number|undefined}
   *         - The current value of lastVolume as a percent when getting
   *         - Nothing when setting
   *
   * @private
   */
  lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  }
  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */
  supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || false;
  }
  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean|undefined}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   *         - Nothing when setting
   */
  isFullscreen(isFS) {
    if (isFS !== void 0) {
      const oldValue = this.isFullscreen_;
      this.isFullscreen_ = Boolean(isFS);
      if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
        this.trigger("fullscreenchange");
      }
      this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  }
  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @param  {Object} [fullscreenOptions]
   *         Override the player fullscreen options
   *
   * @fires Player#fullscreenchange
   */
  requestFullscreen(fullscreenOptions) {
    if (this.isInPictureInPicture()) {
      this.exitPictureInPicture();
    }
    const self2 = this;
    return new Promise((resolve, reject) => {
      function offHandler() {
        self2.off("fullscreenerror", errorHandler);
        self2.off("fullscreenchange", changeHandler);
      }
      function changeHandler() {
        offHandler();
        resolve();
      }
      function errorHandler(e, err) {
        offHandler();
        reject(err);
      }
      self2.one("fullscreenchange", changeHandler);
      self2.one("fullscreenerror", errorHandler);
      const promise = self2.requestFullscreenHelper_(fullscreenOptions);
      if (promise) {
        promise.then(offHandler, offHandler);
        promise.then(resolve, reject);
      }
    });
  }
  requestFullscreenHelper_(fullscreenOptions) {
    let fsOptions;
    if (!this.fsApi_.prefixed) {
      fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
      if (fullscreenOptions !== void 0) {
        fsOptions = fullscreenOptions;
      }
    }
    if (this.fsApi_.requestFullscreen) {
      const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
      if (promise) {
        promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("enterFullScreen");
    } else {
      this.enterFullWindow();
    }
  }
  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */
  exitFullscreen() {
    const self2 = this;
    return new Promise((resolve, reject) => {
      function offHandler() {
        self2.off("fullscreenerror", errorHandler);
        self2.off("fullscreenchange", changeHandler);
      }
      function changeHandler() {
        offHandler();
        resolve();
      }
      function errorHandler(e, err) {
        offHandler();
        reject(err);
      }
      self2.one("fullscreenchange", changeHandler);
      self2.one("fullscreenerror", errorHandler);
      const promise = self2.exitFullscreenHelper_();
      if (promise) {
        promise.then(offHandler, offHandler);
        promise.then(resolve, reject);
      }
    });
  }
  exitFullscreenHelper_() {
    if (this.fsApi_.requestFullscreen) {
      const promise = document$1$1[this.fsApi_.exitFullscreen]();
      if (promise) {
        silencePromise(promise.then(() => this.isFullscreen(false)));
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("exitFullScreen");
    } else {
      this.exitFullWindow();
    }
  }
  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */
  enterFullWindow() {
    this.isFullscreen(true);
    this.isFullWindow = true;
    this.docOrigOverflow = document$1$1.documentElement.style.overflow;
    on(document$1$1, "keydown", this.boundFullWindowOnEscKey_);
    document$1$1.documentElement.style.overflow = "hidden";
    addClass(document$1$1.body, "vjs-full-window");
    this.trigger("enterFullWindow");
  }
  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */
  fullWindowOnEscKey(event2) {
    if (event2.key === "Escape") {
      if (this.isFullscreen() === true) {
        if (!this.isFullWindow) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  }
  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */
  exitFullWindow() {
    this.isFullscreen(false);
    this.isFullWindow = false;
    off(document$1$1, "keydown", this.boundFullWindowOnEscKey_);
    document$1$1.documentElement.style.overflow = this.docOrigOverflow;
    removeClass(document$1$1.body, "vjs-full-window");
    this.trigger("exitFullWindow");
  }
  /**
   * Get or set disable Picture-in-Picture mode.
   *
   * @param {boolean} [value]
   *                  - true will disable Picture-in-Picture mode
   *                  - false will enable Picture-in-Picture mode
   */
  disablePictureInPicture(value2) {
    if (value2 === void 0) {
      return this.techGet_("disablePictureInPicture");
    }
    this.techCall_("setDisablePictureInPicture", value2);
    this.options_.disablePictureInPicture = value2;
    this.trigger("disablepictureinpicturechanged");
  }
  /**
   * Check if the player is in Picture-in-Picture mode or tell the player that it
   * is or is not in Picture-in-Picture mode.
   *
   * @param  {boolean} [isPiP]
   *         Set the players current Picture-in-Picture state
   *
   * @return {boolean|undefined}
   *         - true if Picture-in-Picture is on and getting
   *         - false if Picture-in-Picture is off and getting
   *         - nothing if setting
   */
  isInPictureInPicture(isPiP) {
    if (isPiP !== void 0) {
      this.isInPictureInPicture_ = !!isPiP;
      this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  }
  /**
   * Create a floating video window always on top of other windows so that users may
   * continue consuming media while they interact with other content sites, or
   * applications on their device.
   *
   * This can use document picture-in-picture or element picture in picture
   *
   * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser
   * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser
   *
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}
   * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}
   *
   * @fires Player#enterpictureinpicture
   *
   * @return {Promise}
   *         A promise with a Picture-in-Picture window.
   */
  requestPictureInPicture() {
    if (this.options_.enableDocumentPictureInPicture && window$1$1.documentPictureInPicture) {
      const pipContainer = document$1$1.createElement(this.el().tagName);
      pipContainer.classList = this.el().classList;
      pipContainer.classList.add("vjs-pip-container");
      if (this.posterImage) {
        pipContainer.appendChild(this.posterImage.el().cloneNode(true));
      }
      if (this.titleBar) {
        pipContainer.appendChild(this.titleBar.el().cloneNode(true));
      }
      pipContainer.appendChild(createEl("p", {
        className: "vjs-pip-text"
      }, {}, this.localize("Playing in picture-in-picture")));
      return window$1$1.documentPictureInPicture.requestWindow({
        // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629
        width: this.videoWidth(),
        height: this.videoHeight()
      }).then((pipWindow) => {
        copyStyleSheetsToWindow(pipWindow);
        this.el_.parentNode.insertBefore(pipContainer, this.el_);
        pipWindow.document.body.appendChild(this.el_);
        pipWindow.document.body.classList.add("vjs-pip-window");
        this.player_.isInPictureInPicture(true);
        this.player_.trigger({
          type: "enterpictureinpicture",
          pipWindow
        });
        pipWindow.addEventListener("pagehide", (event2) => {
          const pipVideo = event2.target.querySelector(".video-js");
          pipContainer.parentNode.replaceChild(pipVideo, pipContainer);
          this.player_.isInPictureInPicture(false);
          this.player_.trigger("leavepictureinpicture");
        });
        return pipWindow;
      });
    }
    if ("pictureInPictureEnabled" in document$1$1 && this.disablePictureInPicture() === false) {
      return this.techGet_("requestPictureInPicture");
    }
    return Promise.reject("No PiP mode is available");
  }
  /**
   * Exit Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://wicg.github.io/picture-in-picture}
   *
   * @fires Player#leavepictureinpicture
   *
   * @return {Promise}
   *         A promise.
   */
  exitPictureInPicture() {
    if (window$1$1.documentPictureInPicture && window$1$1.documentPictureInPicture.window) {
      window$1$1.documentPictureInPicture.window.close();
      return Promise.resolve();
    }
    if ("pictureInPictureEnabled" in document$1$1) {
      return document$1$1.exitPictureInPicture();
    }
  }
  /**
   * Called when this Player has focus and a key gets pressed down, or when
   * any Component of this player receives a key press that it doesn't handle.
   * This allows player-wide hotkeys (either as defined below, or optionally
   * by an external function).
   *
   * @param {KeyboardEvent} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */
  handleKeyDown(event2) {
    const {
      userActions
    } = this.options_;
    if (!userActions || !userActions.hotkeys) {
      return;
    }
    const excludeElement = (el) => {
      const tagName = el.tagName.toLowerCase();
      if (el.isContentEditable) {
        return true;
      }
      const allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      if (tagName === "input") {
        return allowedInputTypes.indexOf(el.type) === -1;
      }
      const excludedTags = ["textarea"];
      return excludedTags.indexOf(tagName) !== -1;
    };
    if (excludeElement(this.el_.ownerDocument.activeElement)) {
      return;
    }
    if (typeof userActions.hotkeys === "function") {
      userActions.hotkeys.call(this, event2);
    } else {
      this.handleHotkeys(event2);
    }
  }
  /**
   * Called when this Player receives a hotkey keydown event.
   * Supported player-wide hotkeys are:
   *
   *   f          - toggle fullscreen
   *   m          - toggle mute
   *   k or Space - toggle play/pause
   *
   * @param {Event} event
   *        The `keydown` event that caused this function to be called.
   */
  handleHotkeys(event2) {
    const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
    const {
      fullscreenKey = (keydownEvent) => event2.key.toLowerCase() === "f",
      muteKey = (keydownEvent) => event2.key.toLowerCase() === "m",
      playPauseKey = (keydownEvent) => event2.key.toLowerCase() === "k" || event2.key.toLowerCase() === " "
    } = hotkeys;
    if (fullscreenKey.call(this, event2)) {
      event2.preventDefault();
      event2.stopPropagation();
      const FSToggle = Component$1.getComponent("FullscreenToggle");
      if (document$1$1[this.fsApi_.fullscreenEnabled] !== false) {
        FSToggle.prototype.handleClick.call(this, event2);
      }
    } else if (muteKey.call(this, event2)) {
      event2.preventDefault();
      event2.stopPropagation();
      const MuteToggle2 = Component$1.getComponent("MuteToggle");
      MuteToggle2.prototype.handleClick.call(this, event2);
    } else if (playPauseKey.call(this, event2)) {
      event2.preventDefault();
      event2.stopPropagation();
      const PlayToggle2 = Component$1.getComponent("PlayToggle");
      PlayToggle2.prototype.handleClick.call(this, event2);
    }
  }
  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  canPlayType(type) {
    let can;
    for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
      const techName = j[i];
      let tech = Tech.getTech(techName);
      if (!tech) {
        tech = Component$1.getComponent(techName);
      }
      if (!tech) {
        log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
        continue;
      }
      if (tech.isSupported()) {
        can = tech.canPlayType(type);
        if (can) {
          return can;
        }
      }
    }
    return "";
  }
  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */
  selectSource(sources) {
    const techs = this.options_.techOrder.map((techName) => {
      return [techName, Tech.getTech(techName)];
    }).filter(([techName, tech]) => {
      if (tech) {
        return tech.isSupported();
      }
      log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
      return false;
    });
    const findFirstPassingTechSourcePair = function(outerArray, innerArray, tester) {
      let found;
      outerArray.some((outerChoice) => {
        return innerArray.some((innerChoice) => {
          found = tester(outerChoice, innerChoice);
          if (found) {
            return true;
          }
        });
      });
      return found;
    };
    let foundSourceAndTech;
    const flip2 = (fn2) => (a, b) => fn2(b, a);
    const finder = ([techName, tech], source) => {
      if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {
        return {
          source,
          tech: techName
        };
      }
    };
    if (this.options_.sourceOrder) {
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip2(finder));
    } else {
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }
    return foundSourceAndTech || false;
  }
  /**
   * Executes source setting and getting logic
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   * @param {boolean} [isRetry]
   *        Indicates whether this is being called internally as a result of a retry
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  handleSrc_(source, isRetry) {
    if (typeof source === "undefined") {
      return this.cache_.src || "";
    }
    if (this.resetRetryOnError_) {
      this.resetRetryOnError_();
    }
    const sources = filterSource(source);
    if (!sources.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    this.changingSrc_ = true;
    if (!isRetry) {
      this.cache_.sources = sources;
    }
    this.updateSourceCaches_(sources[0]);
    setSource(this, sources[0], (middlewareSource, mws) => {
      this.middleware_ = mws;
      if (!isRetry) {
        this.cache_.sources = sources;
      }
      this.updateSourceCaches_(middlewareSource);
      const err = this.src_(middlewareSource);
      if (err) {
        if (sources.length > 1) {
          return this.handleSrc_(sources.slice(1));
        }
        this.changingSrc_ = false;
        this.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        this.triggerReady();
        return;
      }
      setTech(mws, this.tech_);
    });
    if (sources.length > 1) {
      const retry2 = () => {
        this.error(null);
        this.handleSrc_(sources.slice(1), true);
      };
      const stopListeningForErrors = () => {
        this.off("error", retry2);
      };
      this.one("error", retry2);
      this.one("playing", stopListeningForErrors);
      this.resetRetryOnError_ = () => {
        this.off("error", retry2);
        this.off("playing", stopListeningForErrors);
      };
    }
  }
  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */
  src(source) {
    return this.handleSrc_(source, false);
  }
  /**
   * Set the source object on the tech, returns a boolean that indicates whether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */
  src_(source) {
    const sourceTech = this.selectSource([source]);
    if (!sourceTech) {
      return true;
    }
    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;
      this.loadTech_(sourceTech.tech, sourceTech.source);
      this.tech_.ready(() => {
        this.changingSrc_ = false;
      });
      return false;
    }
    this.ready(function() {
      if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
        this.techCall_("setSource", source);
      } else {
        this.techCall_("src", source.src);
      }
      this.changingSrc_ = false;
    }, true);
    return false;
  }
  /**
   * Begin loading the src data.
   */
  load() {
    if (this.tech_ && this.tech_.vhs) {
      this.src(this.currentSource());
      return;
    }
    this.techCall_("load");
  }
  /**
   * Reset the player. Loads the first tech in the techOrder,
   * removes all the text tracks in the existing `tech`,
   * and calls `reset` on the `tech`.
   */
  reset() {
    if (this.paused()) {
      this.doReset_();
    } else {
      const playPromise = this.play();
      silencePromise(playPromise.then(() => this.doReset_()));
    }
  }
  doReset_() {
    if (this.tech_) {
      this.tech_.clearTracks("text");
    }
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.resetCache_();
    this.poster("");
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_("reset");
    this.resetControlBarUI_();
    this.error(null);
    if (this.titleBar) {
      this.titleBar.update({
        title: void 0,
        description: void 0
      });
    }
    if (isEvented(this)) {
      this.trigger("playerreset");
    }
  }
  /**
   * Reset Control Bar's UI by calling sub-methods that reset
   * all of Control Bar's components
   */
  resetControlBarUI_() {
    this.resetProgressBar_();
    this.resetPlaybackRate_();
    this.resetVolumeBar_();
  }
  /**
   * Reset tech's progress so progress bar is reset in the UI
   */
  resetProgressBar_() {
    this.currentTime(0);
    const {
      currentTimeDisplay,
      durationDisplay,
      progressControl,
      remainingTimeDisplay
    } = this.controlBar || {};
    const {
      seekBar
    } = progressControl || {};
    if (currentTimeDisplay) {
      currentTimeDisplay.updateContent();
    }
    if (durationDisplay) {
      durationDisplay.updateContent();
    }
    if (remainingTimeDisplay) {
      remainingTimeDisplay.updateContent();
    }
    if (seekBar) {
      seekBar.update();
      if (seekBar.loadProgressBar) {
        seekBar.loadProgressBar.update();
      }
    }
  }
  /**
   * Reset Playback ratio
   */
  resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate());
    this.handleTechRateChange_();
  }
  /**
   * Reset Volume bar
   */
  resetVolumeBar_() {
    this.volume(1);
    this.trigger("volumechange");
  }
  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */
  currentSources() {
    const source = this.currentSource();
    const sources = [];
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }
    return this.cache_.sources || sources;
  }
  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */
  currentSource() {
    return this.cache_.source || {};
  }
  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */
  currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  }
  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */
  currentType() {
    return this.currentSource() && this.currentSource().type || "";
  }
  /**
   * Get or set the preload attribute
   *
   * @param {'none'|'auto'|'metadata'} [value]
   *        Preload mode to pass to tech
   *
   * @return {string|undefined}
   *         - The preload attribute value when getting
   *         - Nothing when setting
   */
  preload(value2) {
    if (value2 !== void 0) {
      this.techCall_("setPreload", value2);
      this.options_.preload = value2;
      return;
    }
    return this.techGet_("preload");
  }
  /**
   * Get or set the autoplay option. When this is a boolean it will
   * modify the attribute on the tech. When this is a string the attribute on
   * the tech will be removed and `Player` will handle autoplay on loadstarts.
   *
   * @param {boolean|'play'|'muted'|'any'} [value]
   *        - true: autoplay using the browser behavior
   *        - false: do not autoplay
   *        - 'play': call play() on every loadstart
   *        - 'muted': call muted() then play() on every loadstart
   *        - 'any': call play() on every loadstart. if that fails call muted() then play().
   *        - *: values other than those listed here will be set `autoplay` to true
   *
   * @return {boolean|string|undefined}
   *         - The current value of autoplay when getting
   *         - Nothing when setting
   */
  autoplay(value2) {
    if (value2 === void 0) {
      return this.options_.autoplay || false;
    }
    let techAutoplay;
    if (typeof value2 === "string" && /(any|play|muted)/.test(value2) || value2 === true && this.options_.normalizeAutoplay) {
      this.options_.autoplay = value2;
      this.manualAutoplay_(typeof value2 === "string" ? value2 : "play");
      techAutoplay = false;
    } else if (!value2) {
      this.options_.autoplay = false;
    } else {
      this.options_.autoplay = true;
    }
    techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
    if (this.tech_) {
      this.techCall_("setAutoplay", techAutoplay);
    }
  }
  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|undefined}
   *         - the current value of playsinline
   *         - Nothing when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  playsinline(value2) {
    if (value2 !== void 0) {
      this.techCall_("setPlaysinline", value2);
      this.options_.playsinline = value2;
    }
    return this.techGet_("playsinline");
  }
  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {boolean|undefined}
   *         - The current value of loop when getting
   *         - Nothing when setting
   */
  loop(value2) {
    if (value2 !== void 0) {
      this.techCall_("setLoop", value2);
      this.options_.loop = value2;
      return;
    }
    return this.techGet_("loop");
  }
  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string|undefined}
   *         - The current value of poster when getting
   *         - Nothing when setting
   */
  poster(src) {
    if (src === void 0) {
      return this.poster_;
    }
    if (!src) {
      src = "";
    }
    if (src === this.poster_) {
      return;
    }
    this.poster_ = src;
    this.techCall_("setPoster", src);
    this.isPosterFromTech_ = false;
    this.trigger("posterchange");
  }
  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */
  handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      const newPoster = this.tech_.poster() || "";
      if (newPoster !== this.poster_) {
        this.poster_ = newPoster;
        this.isPosterFromTech_ = true;
        this.trigger("posterchange");
      }
    }
  }
  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean|undefined}
   *         - The current value of controls when getting
   *         - Nothing when setting
   */
  controls(bool) {
    if (bool === void 0) {
      return !!this.controls_;
    }
    bool = !!bool;
    if (this.controls_ === bool) {
      return;
    }
    this.controls_ = bool;
    if (this.usingNativeControls()) {
      this.techCall_("setControls", bool);
    }
    if (this.controls_) {
      this.removeClass("vjs-controls-disabled");
      this.addClass("vjs-controls-enabled");
      this.trigger("controlsenabled");
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass("vjs-controls-enabled");
      this.addClass("vjs-controls-disabled");
      this.trigger("controlsdisabled");
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  }
  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls) or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean|undefined}
   *         - The current value of native controls when getting
   *         - Nothing when setting
   */
  usingNativeControls(bool) {
    if (bool === void 0) {
      return !!this.usingNativeControls_;
    }
    bool = !!bool;
    if (this.usingNativeControls_ === bool) {
      return;
    }
    this.usingNativeControls_ = bool;
    if (this.usingNativeControls_) {
      this.addClass("vjs-using-native-controls");
      this.trigger("usingnativecontrols");
    } else {
      this.removeClass("vjs-using-native-controls");
      this.trigger("usingcustomcontrols");
    }
  }
  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null|undefined}
   *         - The current MediaError when getting (or null)
   *         - Nothing when setting
   */
  error(err) {
    if (err === void 0) {
      return this.error_ || null;
    }
    hooks("beforeerror").forEach((hookFunction) => {
      const newErr = hookFunction(this, err);
      if (!(isObject$4(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
        this.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      err = newErr;
    });
    if (this.options_.suppressNotSupportedError && err && err.code === 4) {
      const triggerSuppressedError = function() {
        this.error(err);
      };
      this.options_.suppressNotSupportedError = false;
      this.any(["click", "touchstart"], triggerSuppressedError);
      this.one("loadstart", function() {
        this.off(["click", "touchstart"], triggerSuppressedError);
      });
      return;
    }
    if (err === null) {
      this.error_ = null;
      this.removeClass("vjs-error");
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }
    this.error_ = new MediaError(err);
    this.addClass("vjs-error");
    log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);
    this.trigger("error");
    hooks("error").forEach((hookFunction) => hookFunction(this, this.error_));
    return;
  }
  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */
  reportUserActivity(event2) {
    this.userActivity_ = true;
  }
  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean|undefined}
   *         - The current value of userActive when getting
   *         - Nothing when setting
   */
  userActive(bool) {
    if (bool === void 0) {
      return this.userActive_;
    }
    bool = !!bool;
    if (bool === this.userActive_) {
      return;
    }
    this.userActive_ = bool;
    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass("vjs-user-inactive");
      this.addClass("vjs-user-active");
      this.trigger("useractive");
      return;
    }
    if (this.tech_) {
      this.tech_.one("mousemove", function(e) {
        e.stopPropagation();
        e.preventDefault();
      });
    }
    this.userActivity_ = false;
    this.removeClass("vjs-user-active");
    this.addClass("vjs-user-inactive");
    this.trigger("userinactive");
  }
  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */
  listenForUserActivity_() {
    let mouseInProgress;
    let lastMoveX;
    let lastMoveY;
    const handleActivity = bind_(this, this.reportUserActivity);
    const handleMouseMove = function(e) {
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };
    const handleMouseDown = function() {
      handleActivity();
      this.clearInterval(mouseInProgress);
      mouseInProgress = this.setInterval(handleActivity, 250);
    };
    const handleMouseUpAndMouseLeave = function(event2) {
      handleActivity();
      this.clearInterval(mouseInProgress);
    };
    this.on("mousedown", handleMouseDown);
    this.on("mousemove", handleMouseMove);
    this.on("mouseup", handleMouseUpAndMouseLeave);
    this.on("mouseleave", handleMouseUpAndMouseLeave);
    const controlBar = this.getChild("controlBar");
    if (controlBar && !IS_IOS && !IS_ANDROID) {
      controlBar.on("mouseenter", function(event2) {
        if (this.player().options_.inactivityTimeout !== 0) {
          this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
        }
        this.player().options_.inactivityTimeout = 0;
      });
      controlBar.on("mouseleave", function(event2) {
        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
      });
    }
    this.on("keydown", handleActivity);
    this.on("keyup", handleActivity);
    let inactivityTimeout;
    const activityCheck = function() {
      if (!this.userActivity_) {
        return;
      }
      this.userActivity_ = false;
      this.userActive(true);
      this.clearTimeout(inactivityTimeout);
      const timeout = this.options_.inactivityTimeout;
      if (timeout <= 0) {
        return;
      }
      inactivityTimeout = this.setTimeout(function() {
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    };
    this.setInterval(activityCheck, 250);
  }
  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number|undefined}
   *         - The current playback rate when getting or 1.0
   *         - Nothing when setting
   */
  playbackRate(rate) {
    if (rate !== void 0) {
      this.techCall_("setPlaybackRate", rate);
      return;
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
    }
    return 1;
  }
  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|undefined}
   *         - The default playback rate when getting or 1.0
   *         - Nothing when setting
   */
  defaultPlaybackRate(rate) {
    if (rate !== void 0) {
      return this.techCall_("setDefaultPlaybackRate", rate);
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_("defaultPlaybackRate");
    }
    return 1;
  }
  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} [bool]
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean|undefined}
   *         - The current value of isAudio when getting
   *         - Nothing when setting
   */
  isAudio(bool) {
    if (bool !== void 0) {
      this.isAudio_ = !!bool;
      return;
    }
    return !!this.isAudio_;
  }
  updatePlayerHeightOnAudioOnlyMode_() {
    const controlBar = this.getChild("ControlBar");
    if (!controlBar || this.audioOnlyCache_.controlBarHeight === controlBar.currentHeight()) {
      return;
    }
    this.audioOnlyCache_.controlBarHeight = controlBar.currentHeight();
    this.height(this.audioOnlyCache_.controlBarHeight);
  }
  enableAudioOnlyUI_() {
    this.addClass("vjs-audio-only-mode");
    const playerChildren = this.children();
    const controlBar = this.getChild("ControlBar");
    const controlBarHeight = controlBar && controlBar.currentHeight();
    playerChildren.forEach((child) => {
      if (child === controlBar) {
        return;
      }
      if (child.el_ && !child.hasClass("vjs-hidden")) {
        child.hide();
        this.audioOnlyCache_.hiddenChildren.push(child);
      }
    });
    this.audioOnlyCache_.playerHeight = this.currentHeight();
    this.audioOnlyCache_.controlBarHeight = controlBarHeight;
    this.on("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_);
    this.height(controlBarHeight);
    this.trigger("audioonlymodechange");
  }
  disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode");
    this.off("playerresize", this.boundUpdatePlayerHeightOnAudioOnlyMode_);
    this.audioOnlyCache_.hiddenChildren.forEach((child) => child.show());
    this.height(this.audioOnlyCache_.playerHeight);
    this.trigger("audioonlymodechange");
  }
  /**
   * Get the current audioOnlyMode state or set audioOnlyMode to true or false.
   *
   * Setting this to `true` will hide all player components except the control bar,
   * as well as control bar components needed only for video.
   *
   * @param {boolean} [value]
   *         The value to set audioOnlyMode to.
   *
   * @return {Promise|boolean}
   *        A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioOnlyMode(value2) {
    if (typeof value2 !== "boolean" || value2 === this.audioOnlyMode_) {
      return this.audioOnlyMode_;
    }
    this.audioOnlyMode_ = value2;
    if (value2) {
      const exitPromises = [];
      if (this.isInPictureInPicture()) {
        exitPromises.push(this.exitPictureInPicture());
      }
      if (this.isFullscreen()) {
        exitPromises.push(this.exitFullscreen());
      }
      if (this.audioPosterMode()) {
        exitPromises.push(this.audioPosterMode(false));
      }
      return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());
    }
    return Promise.resolve().then(() => this.disableAudioOnlyUI_());
  }
  enablePosterModeUI_() {
    const tech = this.tech_ && this.tech_;
    tech.hide();
    this.addClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  }
  disablePosterModeUI_() {
    const tech = this.tech_ && this.tech_;
    tech.show();
    this.removeClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  }
  /**
   * Get the current audioPosterMode state or set audioPosterMode to true or false
   *
   * @param {boolean} [value]
   *         The value to set audioPosterMode to.
   *
   * @return {Promise|boolean}
   *         A Promise is returned when setting the state, and a boolean when getting
   *        the present state
   */
  audioPosterMode(value2) {
    if (typeof value2 !== "boolean" || value2 === this.audioPosterMode_) {
      return this.audioPosterMode_;
    }
    this.audioPosterMode_ = value2;
    if (value2) {
      if (this.audioOnlyMode()) {
        const audioOnlyModePromise = this.audioOnlyMode(false);
        return audioOnlyModePromise.then(() => {
          this.enablePosterModeUI_();
        });
      }
      return Promise.resolve().then(() => {
        this.enablePosterModeUI_();
      });
    }
    return Promise.resolve().then(() => {
      this.disablePosterModeUI_();
    });
  }
  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */
  addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  }
  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed
   *                                        from the TextTrackList and HtmlTrackElementList
   *                                        after a source change
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   */
  addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  }
  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */
  removeRemoteTextTrack(obj = {}) {
    let {
      track
    } = obj;
    if (!track) {
      track = obj;
    }
    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  }
  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */
  getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  }
  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */
  videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  }
  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */
  videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  }
  /**
   * Set or get the player's language code.
   *
   * Changing the language will trigger
   * [languagechange]{@link Player#event:languagechange}
   * which Components can use to update control text.
   * ClickableComponent will update its control text by default on
   * [languagechange]{@link Player#event:languagechange}.
   *
   * @fires Player#languagechange
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string|undefined}
   *         - The current language code when getting
   *         - Nothing when setting
   */
  language(code) {
    if (code === void 0) {
      return this.language_;
    }
    if (this.language_ !== String(code).toLowerCase()) {
      this.language_ = String(code).toLowerCase();
      if (isEvented(this)) {
        this.trigger("languagechange");
      }
    }
  }
  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */
  languages() {
    return merge$1(Player.prototype.options_.languages, this.languages_);
  }
  /**
   * returns a JavaScript object representing the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */
  toJSON() {
    const options = merge$1(this.options_);
    const tracks = options.tracks;
    options.tracks = [];
    for (let i = 0; i < tracks.length; i++) {
      let track = tracks[i];
      track = merge$1(track);
      track.player = void 0;
      options.tracks[i] = track;
    }
    return options;
  }
  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */
  createModal(content, options) {
    options = options || {};
    options.content = content || "";
    const modal = new ModalDialog(this, options);
    this.addChild(modal);
    modal.on("dispose", () => {
      this.removeChild(modal);
    });
    modal.open();
    return modal;
  }
  /**
   * Change breakpoint classes when the player resizes.
   *
   * @private
   */
  updateCurrentBreakpoint_() {
    if (!this.responsive()) {
      return;
    }
    const currentBreakpoint = this.currentBreakpoint();
    const currentWidth = this.currentWidth();
    for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {
      const candidateBreakpoint = BREAKPOINT_ORDER[i];
      const maxWidth = this.breakpoints_[candidateBreakpoint];
      if (currentWidth <= maxWidth) {
        if (currentBreakpoint === candidateBreakpoint) {
          return;
        }
        if (currentBreakpoint) {
          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
        }
        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
        this.breakpoint_ = candidateBreakpoint;
        break;
      }
    }
  }
  /**
   * Removes the current breakpoint.
   *
   * @private
   */
  removeCurrentBreakpoint_() {
    const className = this.currentBreakpointClass();
    this.breakpoint_ = "";
    if (className) {
      this.removeClass(className);
    }
  }
  /**
   * Get or set breakpoints on the player.
   *
   * Calling this method with an object or `true` will remove any previous
   * custom breakpoints and start from the defaults again.
   *
   * @param  {Object|boolean} [breakpoints]
   *         If an object is given, it can be used to provide custom
   *         breakpoints. If `true` is given, will set default breakpoints.
   *         If this argument is not given, will simply return the current
   *         breakpoints.
   *
   * @param  {number} [breakpoints.tiny]
   *         The maximum width for the "vjs-layout-tiny" class.
   *
   * @param  {number} [breakpoints.xsmall]
   *         The maximum width for the "vjs-layout-x-small" class.
   *
   * @param  {number} [breakpoints.small]
   *         The maximum width for the "vjs-layout-small" class.
   *
   * @param  {number} [breakpoints.medium]
   *         The maximum width for the "vjs-layout-medium" class.
   *
   * @param  {number} [breakpoints.large]
   *         The maximum width for the "vjs-layout-large" class.
   *
   * @param  {number} [breakpoints.xlarge]
   *         The maximum width for the "vjs-layout-x-large" class.
   *
   * @param  {number} [breakpoints.huge]
   *         The maximum width for the "vjs-layout-huge" class.
   *
   * @return {Object}
   *         An object mapping breakpoint names to maximum width values.
   */
  breakpoints(breakpoints2) {
    if (breakpoints2 === void 0) {
      return Object.assign(this.breakpoints_);
    }
    this.breakpoint_ = "";
    this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints2);
    this.updateCurrentBreakpoint_();
    return Object.assign(this.breakpoints_);
  }
  /**
   * Get or set a flag indicating whether or not this player should adjust
   * its UI based on its dimensions.
   *
   * @param  {boolean} [value]
   *         Should be `true` if the player should adjust its UI based on its
   *         dimensions; otherwise, should be `false`.
   *
   * @return {boolean|undefined}
   *         Will be `true` if this player should adjust its UI based on its
   *         dimensions; otherwise, will be `false`.
   *         Nothing if setting
   */
  responsive(value2) {
    if (value2 === void 0) {
      return this.responsive_;
    }
    value2 = Boolean(value2);
    const current = this.responsive_;
    if (value2 === current) {
      return;
    }
    this.responsive_ = value2;
    if (value2) {
      this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.updateCurrentBreakpoint_();
    } else {
      this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.removeCurrentBreakpoint_();
    }
    return value2;
  }
  /**
   * Get current breakpoint name, if any.
   *
   * @return {string}
   *         If there is currently a breakpoint set, returns a the key from the
   *         breakpoints object matching it. Otherwise, returns an empty string.
   */
  currentBreakpoint() {
    return this.breakpoint_;
  }
  /**
   * Get the current breakpoint class name.
   *
   * @return {string}
   *         The matching class name (e.g. `"vjs-layout-tiny"` or
   *         `"vjs-layout-large"`) for the current breakpoint. Empty string if
   *         there is no current breakpoint.
   */
  currentBreakpointClass() {
    return BREAKPOINT_CLASSES[this.breakpoint_] || "";
  }
  /**
   * An object that describes a single piece of media.
   *
   * Properties that are not part of this type description will be retained; so,
   * this can be viewed as a generic metadata storage mechanism as well.
   *
   * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}
   * @typedef  {Object} Player~MediaObject
   *
   * @property {string} [album]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {string} [artist]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [artwork]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API. If not specified, will be populated via the `poster`, if
   *           available.
   *
   * @property {string} [poster]
   *           URL to an image that will display before playback.
   *
   * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]
   *           A single source object, an array of source objects, or a string
   *           referencing a URL to a media source. It is _highly recommended_
   *           that an object or array of objects is used here, so that source
   *           selection algorithms can take the `type` into account.
   *
   * @property {string} [title]
   *           Unused, except if this object is passed to the `MediaSession`
   *           API.
   *
   * @property {Object[]} [textTracks]
   *           An array of objects to be used to create text tracks, following
   *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.
   *           For ease of removal, these will be created as "remote" text
   *           tracks and set to automatically clean up on source changes.
   *
   *           These objects may have properties like `src`, `kind`, `label`,
   *           and `language`, see {@link Tech#createRemoteTextTrack}.
   */
  /**
   * Populate the player using a {@link Player~MediaObject|MediaObject}.
   *
   * @param  {Player~MediaObject} media
   *         A media object.
   *
   * @param  {Function} ready
   *         A callback to be called when the player is ready.
   */
  loadMedia(media, ready) {
    if (!media || typeof media !== "object") {
      return;
    }
    const crossOrigin = this.crossOrigin();
    this.reset();
    this.cache_.media = merge$1(media);
    const {
      artist,
      artwork,
      description,
      poster,
      src,
      textTracks,
      title
    } = this.cache_.media;
    if (!artwork && poster) {
      this.cache_.media.artwork = [{
        src: poster,
        type: getMimetype(poster)
      }];
    }
    if (crossOrigin) {
      this.crossOrigin(crossOrigin);
    }
    if (src) {
      this.src(src);
    }
    if (poster) {
      this.poster(poster);
    }
    if (Array.isArray(textTracks)) {
      textTracks.forEach((tt) => this.addRemoteTextTrack(tt, false));
    }
    if (this.titleBar) {
      this.titleBar.update({
        title,
        description: description || artist || ""
      });
    }
    this.ready(ready);
  }
  /**
   * Get a clone of the current {@link Player~MediaObject} for this player.
   *
   * If the `loadMedia` method has not been used, will attempt to return a
   * {@link Player~MediaObject} based on the current state of the player.
   *
   * @return {Player~MediaObject}
   */
  getMedia() {
    if (!this.cache_.media) {
      const poster = this.poster();
      const src = this.currentSources();
      const textTracks = Array.prototype.map.call(this.remoteTextTracks(), (tt) => ({
        kind: tt.kind,
        label: tt.label,
        language: tt.language,
        src: tt.src
      }));
      const media = {
        src,
        textTracks
      };
      if (poster) {
        media.poster = poster;
        media.artwork = [{
          src: media.poster,
          type: getMimetype(media.poster)
        }];
      }
      return media;
    }
    return merge$1(this.cache_.media);
  }
  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */
  static getTagSettings(tag) {
    const baseOptions = {
      sources: [],
      tracks: []
    };
    const tagOptions = getAttributes(tag);
    const dataSetup = tagOptions["data-setup"];
    if (hasClass(tag, "vjs-fill")) {
      tagOptions.fill = true;
    }
    if (hasClass(tag, "vjs-fluid")) {
      tagOptions.fluid = true;
    }
    if (dataSetup !== null) {
      const [err, data] = safeParseTuple(dataSetup || "{}");
      if (err) {
        log$1.error(err);
      }
      Object.assign(tagOptions, data);
    }
    Object.assign(baseOptions, tagOptions);
    if (tag.hasChildNodes()) {
      const children = tag.childNodes;
      for (let i = 0, j = children.length; i < j; i++) {
        const child = children[i];
        const childName = child.nodeName.toLowerCase();
        if (childName === "source") {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === "track") {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }
    return baseOptions;
  }
  /**
   * Set debug mode to enable/disable logs at info level.
   *
   * @param {boolean} enabled
   * @fires Player#debugon
   * @fires Player#debugoff
   * @return {boolean|undefined}
   */
  debug(enabled) {
    if (enabled === void 0) {
      return this.debugEnabled_;
    }
    if (enabled) {
      this.trigger("debugon");
      this.previousLogLevel_ = this.log.level;
      this.log.level("debug");
      this.debugEnabled_ = true;
    } else {
      this.trigger("debugoff");
      this.log.level(this.previousLogLevel_);
      this.previousLogLevel_ = void 0;
      this.debugEnabled_ = false;
    }
  }
  /**
   * Set or get current playback rates.
   * Takes an array and updates the playback rates menu with the new items.
   * Pass in an empty array to hide the menu.
   * Values other than arrays are ignored.
   *
   * @fires Player#playbackrateschange
   * @param {number[]} [newRates]
   *                   The new rates that the playback rates menu should update to.
   *                   An empty array will hide the menu
   * @return {number[]} When used as a getter will return the current playback rates
   */
  playbackRates(newRates) {
    if (newRates === void 0) {
      return this.cache_.playbackRates;
    }
    if (!Array.isArray(newRates)) {
      return;
    }
    if (!newRates.every((rate) => typeof rate === "number")) {
      return;
    }
    this.cache_.playbackRates = newRates;
    this.trigger("playbackrateschange");
  }
}
ALL.names.forEach(function(name) {
  const props = ALL[name];
  Player.prototype[props.getterName] = function() {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Player.prototype.crossorigin = Player.prototype.crossOrigin;
Player.players = {};
const navigator$1 = window$1$1.navigator;
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,
  html5: {},
  // enable sourceset by default
  enableSourceset: true,
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: false,
  // Included control sets
  children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: false,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: false,
  audioOnlyMode: false,
  audioPosterMode: false,
  spatialNavigation: {
    enabled: false,
    horizontalSeek: false
  },
  // Default smooth seeking to false
  enableSmoothSeeking: false
};
TECH_EVENTS_RETRIGGER.forEach(function(event2) {
  Player.prototype[`handleTech${toTitleCase$1(event2)}_`] = function() {
    return this.trigger(event2);
  };
});
Component$1.registerComponent("Player", Player);
const BASE_PLUGIN_NAME = "plugin";
const PLUGIN_CACHE_KEY = "activePlugins_";
const pluginStorage = {};
const pluginExists = (name) => pluginStorage.hasOwnProperty(name);
const getPlugin = (name) => pluginExists(name) ? pluginStorage[name] : void 0;
const markPluginAsActive = (player, name) => {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};
const triggerSetupEvent = (player, hash2, before) => {
  const eventName = (before ? "before" : "") + "pluginsetup";
  player.trigger(eventName, hash2);
  player.trigger(eventName + ":" + hash2.name, hash2);
};
const createBasicPlugin = function(name, plugin) {
  const basicPluginWrapper = function() {
    triggerSetupEvent(this, {
      name,
      plugin,
      instance: null
    }, true);
    const instance = plugin.apply(this, arguments);
    markPluginAsActive(this, name);
    triggerSetupEvent(this, {
      name,
      plugin,
      instance
    });
    return instance;
  };
  Object.keys(plugin).forEach(function(prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });
  return basicPluginWrapper;
};
const createPluginFactory = (name, PluginSubClass) => {
  PluginSubClass.prototype.name = name;
  return function(...args) {
    triggerSetupEvent(this, {
      name,
      plugin: PluginSubClass,
      instance: null
    }, true);
    const instance = new PluginSubClass(...[this, ...args]);
    this[name] = () => instance;
    triggerSetupEvent(this, instance.getEventHash());
    return instance;
  };
};
class Plugin {
  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  constructor(player) {
    if (this.constructor === Plugin) {
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    }
    this.player = player;
    if (!this.log) {
      this.log = this.player.log.createLogger(this.name);
    }
    evented(this);
    delete this.trigger;
    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);
    this.dispose = this.dispose.bind(this);
    player.on("dispose", this.dispose);
  }
  /**
   * Get the version of the plugin that was set on <pluginName>.VERSION
   */
  version() {
    return this.constructor.VERSION;
  }
  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @return {PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */
  getEventHash(hash2 = {}) {
    hash2.name = this.name;
    hash2.plugin = this.constructor;
    hash2.instance = this;
    return hash2;
  }
  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link PluginEventHash|PluginEventHash}.
   *
   * @return {boolean}
   *          Whether or not default was prevented.
   */
  trigger(event2, hash2 = {}) {
    return trigger(this.eventBusEl_, event2, this.getEventHash(hash2));
  }
  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */
  handleStateChanged(e) {
  }
  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */
  dispose() {
    const {
      name,
      player
    } = this;
    this.trigger("dispose");
    this.off();
    player.off("dispose", this.dispose);
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;
    player[name] = createPluginFactory(name, pluginStorage[name]);
  }
  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @return {boolean}
   *          Whether or not a plugin is a basic plugin.
   */
  static isBasic(plugin) {
    const p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
    return typeof p === "function" && !Plugin.prototype.isPrototypeOf(p.prototype);
  }
  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {typeof Plugin|Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @return {typeof Plugin|Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */
  static registerPlugin(name, plugin) {
    if (typeof name !== "string") {
      throw new Error(`Illegal plugin name, "${name}", must be a string, was ${typeof name}.`);
    }
    if (pluginExists(name)) {
      log$1.warn(`A plugin named "${name}" already exists. You may want to avoid re-registering plugins!`);
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error(`Illegal plugin name, "${name}", cannot share a name with an existing player method!`);
    }
    if (typeof plugin !== "function") {
      throw new Error(`Illegal plugin for "${name}", must be a function, was ${typeof plugin}.`);
    }
    pluginStorage[name] = plugin;
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }
    return plugin;
  }
  /**
   * De-register a Video.js plugin.
   *
   * @param  {string} name
   *         The name of the plugin to be de-registered. Must be a string that
   *         matches an existing plugin.
   *
   * @throws {Error}
   *         If an attempt is made to de-register the base plugin.
   */
  static deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error("Cannot de-register base plugin.");
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  }
  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @return {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */
  static getPlugins(names = Object.keys(pluginStorage)) {
    let result;
    names.forEach((name) => {
      const plugin = getPlugin(name);
      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });
    return result;
  }
  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @return {string}
   *          The plugin's version or an empty string.
   */
  static getPluginVersion(name) {
    const plugin = getPlugin(name);
    return plugin && plugin.VERSION || "";
  }
}
Plugin.getPlugin = getPlugin;
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
Player.prototype.usingPlugin = function(name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};
Player.prototype.hasPlugin = function(name) {
  return !!pluginExists(name);
};
function deprecate(message, fn2) {
  let warned = false;
  return function(...args) {
    if (!warned) {
      log$1.warn(message);
    }
    warned = true;
    return fn2.apply(this, args);
  };
}
function deprecateForMajor(major, oldName, newName, fn2) {
  return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn2);
}
var VjsErrors = {
  NetworkBadStatus: "networkbadstatus",
  NetworkRequestFailed: "networkrequestfailed",
  NetworkRequestAborted: "networkrequestaborted",
  NetworkRequestTimeout: "networkrequesttimeout",
  NetworkBodyParserFailed: "networkbodyparserfailed",
  StreamingHlsPlaylistParserError: "streaminghlsplaylistparsererror",
  StreamingDashManifestParserError: "streamingdashmanifestparsererror",
  StreamingContentSteeringParserError: "streamingcontentsteeringparsererror",
  StreamingVttParserError: "streamingvttparsererror",
  StreamingFailedToSelectNextSegment: "streamingfailedtoselectnextsegment",
  StreamingFailedToDecryptSegment: "streamingfailedtodecryptsegment",
  StreamingFailedToTransmuxSegment: "streamingfailedtotransmuxsegment",
  StreamingFailedToAppendSegment: "streamingfailedtoappendsegment",
  StreamingCodecsChangeError: "streamingcodecschangeerror"
};
const normalizeId = (id) => id.indexOf("#") === 0 ? id.slice(1) : id;
function videojs$2(id, options, ready) {
  let player = videojs$2.getPlayer(id);
  if (player) {
    if (options) {
      log$1.warn(`Player "${id}" is already initialised. Options will not be applied.`);
    }
    if (ready) {
      player.ready(ready);
    }
    return player;
  }
  const el = typeof id === "string" ? $("#" + normalizeId(id)) : id;
  if (!isEl(el)) {
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  }
  const inShadowDom = "getRootNode" in el ? el.getRootNode() instanceof window$1$1.ShadowRoot : false;
  const rootNode = inShadowDom ? el.getRootNode() : el.ownerDocument.body;
  if (!el.ownerDocument.defaultView || !rootNode.contains(el)) {
    log$1.warn("The element supplied is not included in the DOM");
  }
  options = options || {};
  if (options.restoreEl === true) {
    options.restoreEl = (el.parentNode && el.parentNode.hasAttribute && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
  }
  hooks("beforesetup").forEach((hookFunction) => {
    const opts = hookFunction(el, merge$1(options));
    if (!isObject$4(opts) || Array.isArray(opts)) {
      log$1.error("please return an object in beforesetup hooks");
      return;
    }
    options = merge$1(options, opts);
  });
  const PlayerComponent = Component$1.getComponent("Player");
  player = new PlayerComponent(el, options, ready);
  hooks("setup").forEach((hookFunction) => hookFunction(player));
  return player;
}
videojs$2.hooks_ = hooks_;
videojs$2.hooks = hooks;
videojs$2.hook = hook;
videojs$2.hookOnce = hookOnce;
videojs$2.removeHook = removeHook;
if (window$1$1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  let style2 = $(".vjs-styles-defaults");
  if (!style2) {
    style2 = createStyleElement("vjs-styles-defaults");
    const head = $("head");
    if (head) {
      head.insertBefore(style2, head.firstChild);
    }
    setTextContent(style2, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `);
  }
}
autoSetupTimeout(1, videojs$2);
videojs$2.VERSION = version$6;
videojs$2.options = Player.prototype.options_;
videojs$2.getPlayers = () => Player.players;
videojs$2.getPlayer = (id) => {
  const players = Player.players;
  let tag;
  if (typeof id === "string") {
    const nId = normalizeId(id);
    const player = players[nId];
    if (player) {
      return player;
    }
    tag = $("#" + nId);
  } else {
    tag = id;
  }
  if (isEl(tag)) {
    const {
      player,
      playerId
    } = tag;
    if (player || players[playerId]) {
      return player || players[playerId];
    }
  }
};
videojs$2.getAllPlayers = () => (
  // Disposed players leave a key with a `null` value, so we need to make sure
  // we filter those out.
  Object.keys(Player.players).map((k) => Player.players[k]).filter(Boolean)
);
videojs$2.players = Player.players;
videojs$2.getComponent = Component$1.getComponent;
videojs$2.registerComponent = (name, comp) => {
  if (Tech.isTech(comp)) {
    log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
  }
  return Component$1.registerComponent.call(Component$1, name, comp);
};
videojs$2.getTech = Tech.getTech;
videojs$2.registerTech = Tech.registerTech;
videojs$2.use = use;
Object.defineProperty(videojs$2, "middleware", {
  value: {},
  writeable: false,
  enumerable: true
});
Object.defineProperty(videojs$2.middleware, "TERMINATOR", {
  value: TERMINATOR,
  writeable: false,
  enumerable: true
});
videojs$2.browser = browser$1;
videojs$2.obj = Obj;
videojs$2.mergeOptions = deprecateForMajor(9, "videojs.mergeOptions", "videojs.obj.merge", merge$1);
videojs$2.defineLazyProperty = deprecateForMajor(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", defineLazyProperty);
videojs$2.bind = deprecateForMajor(9, "videojs.bind", "native Function.prototype.bind", bind_);
videojs$2.registerPlugin = Plugin.registerPlugin;
videojs$2.deregisterPlugin = Plugin.deregisterPlugin;
videojs$2.plugin = (name, plugin) => {
  log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
  return Plugin.registerPlugin(name, plugin);
};
videojs$2.getPlugins = Plugin.getPlugins;
videojs$2.getPlugin = Plugin.getPlugin;
videojs$2.getPluginVersion = Plugin.getPluginVersion;
videojs$2.addLanguage = function(code, data) {
  code = ("" + code).toLowerCase();
  videojs$2.options.languages = merge$1(videojs$2.options.languages, {
    [code]: data
  });
  return videojs$2.options.languages[code];
};
videojs$2.log = log$1;
videojs$2.createLogger = createLogger;
videojs$2.time = Time;
videojs$2.createTimeRange = deprecateForMajor(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", createTimeRanges$1);
videojs$2.createTimeRanges = deprecateForMajor(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", createTimeRanges$1);
videojs$2.formatTime = deprecateForMajor(9, "videojs.formatTime", "videojs.time.formatTime", formatTime);
videojs$2.setFormatTime = deprecateForMajor(9, "videojs.setFormatTime", "videojs.time.setFormatTime", setFormatTime);
videojs$2.resetFormatTime = deprecateForMajor(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", resetFormatTime);
videojs$2.parseUrl = deprecateForMajor(9, "videojs.parseUrl", "videojs.url.parseUrl", parseUrl);
videojs$2.isCrossOrigin = deprecateForMajor(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", isCrossOrigin);
videojs$2.EventTarget = EventTarget$2;
videojs$2.any = any;
videojs$2.on = on;
videojs$2.one = one;
videojs$2.off = off;
videojs$2.trigger = trigger;
videojs$2.xhr = XHR;
videojs$2.TextTrack = TextTrack;
videojs$2.AudioTrack = AudioTrack;
videojs$2.VideoTrack = VideoTrack;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach((k) => {
  videojs$2[k] = function() {
    log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);
    return Dom[k].apply(null, arguments);
  };
});
videojs$2.computedStyle = deprecateForMajor(9, "videojs.computedStyle", "videojs.dom.computedStyle", computedStyle);
videojs$2.dom = Dom;
videojs$2.fn = Fn;
videojs$2.num = Num;
videojs$2.str = Str;
videojs$2.url = Url;
videojs$2.Error = VjsErrors;
/*! @name videojs-contrib-quality-levels @version 4.1.0 @license Apache-2.0 */
class QualityLevel {
  /**
   * Creates a QualityLevel
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   */
  constructor(representation) {
    let level = this;
    level.id = representation.id;
    level.label = level.id;
    level.width = representation.width;
    level.height = representation.height;
    level.bitrate = representation.bandwidth;
    level.frameRate = representation.frameRate;
    level.enabled_ = representation.enabled;
    Object.defineProperty(level, "enabled", {
      /**
       * Get whether the QualityLevel is enabled.
       *
       * @return {boolean} True if the QualityLevel is enabled.
       */
      get() {
        return level.enabled_();
      },
      /**
       * Enable or disable the QualityLevel.
       *
       * @param {boolean} enable true to enable QualityLevel, false to disable.
       */
      set(enable) {
        level.enabled_(enable);
      }
    });
    return level;
  }
}
class QualityLevelList extends videojs$2.EventTarget {
  /**
   * Creates a QualityLevelList.
   */
  constructor() {
    super();
    let list = this;
    list.levels_ = [];
    list.selectedIndex_ = -1;
    Object.defineProperty(list, "selectedIndex", {
      get() {
        return list.selectedIndex_;
      }
    });
    Object.defineProperty(list, "length", {
      get() {
        return list.levels_.length;
      }
    });
    list[Symbol.iterator] = () => list.levels_.values();
    return list;
  }
  /**
   * Adds a quality level to the list.
   *
   * @param {Representation|Object} representation The representation of the quality level
   * @param {string}   representation.id        Unique id of the QualityLevel
   * @param {number=}  representation.width     Resolution width of the QualityLevel
   * @param {number=}  representation.height    Resolution height of the QualityLevel
   * @param {number}   representation.bandwidth Bitrate of the QualityLevel
   * @param {number=}  representation.frameRate Frame-rate of the QualityLevel
   * @param {Function} representation.enabled   Callback to enable/disable QualityLevel
   * @return {QualityLevel} the QualityLevel added to the list
   * @method addQualityLevel
   */
  addQualityLevel(representation) {
    let qualityLevel = this.getQualityLevelById(representation.id);
    if (qualityLevel) {
      return qualityLevel;
    }
    const index = this.levels_.length;
    qualityLevel = new QualityLevel(representation);
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this.levels_[index];
        }
      });
    }
    this.levels_.push(qualityLevel);
    this.trigger({
      qualityLevel,
      type: "addqualitylevel"
    });
    return qualityLevel;
  }
  /**
   * Removes a quality level from the list.
   *
   * @param {QualityLevel} qualityLevel The QualityLevel to remove from the list.
   * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed
   * @method removeQualityLevel
   */
  removeQualityLevel(qualityLevel) {
    let removed = null;
    for (let i = 0, l = this.length; i < l; i++) {
      if (this[i] === qualityLevel) {
        removed = this.levels_.splice(i, 1)[0];
        if (this.selectedIndex_ === i) {
          this.selectedIndex_ = -1;
        } else if (this.selectedIndex_ > i) {
          this.selectedIndex_--;
        }
        break;
      }
    }
    if (removed) {
      this.trigger({
        qualityLevel,
        type: "removequalitylevel"
      });
    }
    return removed;
  }
  /**
   * Searches for a QualityLevel with the given id.
   *
   * @param {string} id The id of the QualityLevel to find.
   * @return {QualityLevel|null} The QualityLevel with id, or null if not found.
   * @method getQualityLevelById
   */
  getQualityLevelById(id) {
    for (let i = 0, l = this.length; i < l; i++) {
      const level = this[i];
      if (level.id === id) {
        return level;
      }
    }
    return null;
  }
  /**
   * Resets the list of QualityLevels to empty
   *
   * @method dispose
   */
  dispose() {
    this.selectedIndex_ = -1;
    this.levels_.length = 0;
  }
}
QualityLevelList.prototype.allowedEvents_ = {
  change: "change",
  addqualitylevel: "addqualitylevel",
  removequalitylevel: "removequalitylevel"
};
for (const event2 in QualityLevelList.prototype.allowedEvents_) {
  QualityLevelList.prototype["on" + event2] = null;
}
var version$5 = "4.1.0";
const initPlugin$1 = function(player, options) {
  const originalPluginFn = player.qualityLevels;
  const qualityLevelList = new QualityLevelList();
  const disposeHandler = function() {
    qualityLevelList.dispose();
    player.qualityLevels = originalPluginFn;
    player.off("dispose", disposeHandler);
  };
  player.on("dispose", disposeHandler);
  player.qualityLevels = () => qualityLevelList;
  player.qualityLevels.VERSION = version$5;
  return qualityLevelList;
};
const qualityLevels = function(options) {
  return initPlugin$1(this, videojs$2.obj.merge({}, options));
};
videojs$2.registerPlugin("qualityLevels", qualityLevels);
qualityLevels.VERSION = version$5;
/*! @name @videojs/http-streaming @version 3.13.2 @license Apache-2.0 */
const resolveUrl22 = resolveUrl$1;
const resolveManifestRedirect = (url2, req) => {
  if (req && req.responseURL && url2 !== req.responseURL) {
    return req.responseURL;
  }
  return url2;
};
const logger = (source) => {
  if (videojs$2.log.debug) {
    return videojs$2.log.debug.bind(videojs$2, "VHS:", `${source} >`);
  }
  return function() {
  };
};
function merge(...args) {
  const context = videojs$2.obj || videojs$2;
  const fn2 = context.merge || context.mergeOptions;
  return fn2.apply(context, args);
}
function createTimeRanges(...args) {
  const context = videojs$2.time || videojs$2;
  const fn2 = context.createTimeRanges || context.createTimeRanges;
  return fn2.apply(context, args);
}
function bufferedRangesToString(buffered) {
  if (buffered.length === 0) {
    return "Buffered Ranges are empty";
  }
  let bufferedRangesStr = "Buffered Ranges: \n";
  for (let i = 0; i < buffered.length; i++) {
    const start2 = buffered.start(i);
    const end2 = buffered.end(i);
    bufferedRangesStr += `${start2} --> ${end2}. Duration (${end2 - start2})
`;
  }
  return bufferedRangesStr;
}
const TIME_FUDGE_FACTOR = 1 / 30;
const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
const filterRanges = function(timeRanges, predicate) {
  const results = [];
  let i;
  if (timeRanges && timeRanges.length) {
    for (i = 0; i < timeRanges.length; i++) {
      if (predicate(timeRanges.start(i), timeRanges.end(i))) {
        results.push([timeRanges.start(i), timeRanges.end(i)]);
      }
    }
  }
  return createTimeRanges(results);
};
const findRange = function(buffered, time) {
  return filterRanges(buffered, function(start2, end2) {
    return start2 - SAFE_TIME_DELTA <= time && end2 + SAFE_TIME_DELTA >= time;
  });
};
const findNextRange = function(timeRanges, time) {
  return filterRanges(timeRanges, function(start2) {
    return start2 - TIME_FUDGE_FACTOR >= time;
  });
};
const findGaps = function(buffered) {
  if (buffered.length < 2) {
    return createTimeRanges();
  }
  const ranges = [];
  for (let i = 1; i < buffered.length; i++) {
    const start2 = buffered.end(i - 1);
    const end2 = buffered.start(i);
    ranges.push([start2, end2]);
  }
  return createTimeRanges(ranges);
};
const bufferIntersection = function(bufferA, bufferB) {
  let start2 = null;
  let end2 = null;
  let arity = 0;
  const extents = [];
  const ranges = [];
  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
    return createTimeRanges();
  }
  let count = bufferA.length;
  while (count--) {
    extents.push({
      time: bufferA.start(count),
      type: "start"
    });
    extents.push({
      time: bufferA.end(count),
      type: "end"
    });
  }
  count = bufferB.length;
  while (count--) {
    extents.push({
      time: bufferB.start(count),
      type: "start"
    });
    extents.push({
      time: bufferB.end(count),
      type: "end"
    });
  }
  extents.sort(function(a, b) {
    return a.time - b.time;
  });
  for (count = 0; count < extents.length; count++) {
    if (extents[count].type === "start") {
      arity++;
      if (arity === 2) {
        start2 = extents[count].time;
      }
    } else if (extents[count].type === "end") {
      arity--;
      if (arity === 1) {
        end2 = extents[count].time;
      }
    }
    if (start2 !== null && end2 !== null) {
      ranges.push([start2, end2]);
      start2 = null;
      end2 = null;
    }
  }
  return createTimeRanges(ranges);
};
const printableRange = (range2) => {
  const strArr = [];
  if (!range2 || !range2.length) {
    return "";
  }
  for (let i = 0; i < range2.length; i++) {
    strArr.push(range2.start(i) + " => " + range2.end(i));
  }
  return strArr.join(", ");
};
const timeUntilRebuffer = function(buffered, currentTime, playbackRate = 1) {
  const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
  return (bufferedEnd - currentTime) / playbackRate;
};
const timeRangesToArray = (timeRanges) => {
  const timeRangesList = [];
  for (let i = 0; i < timeRanges.length; i++) {
    timeRangesList.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return timeRangesList;
};
const isRangeDifferent = function(a, b) {
  if (a === b) {
    return false;
  }
  if (!a && b || !b && a) {
    return true;
  }
  if (a.length !== b.length) {
    return true;
  }
  for (let i = 0; i < a.length; i++) {
    if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {
      return true;
    }
  }
  return false;
};
const lastBufferedEnd = function(a) {
  if (!a || !a.length || !a.end) {
    return;
  }
  return a.end(a.length - 1);
};
const timeAheadOf = function(range2, startTime) {
  let time = 0;
  if (!range2 || !range2.length) {
    return time;
  }
  for (let i = 0; i < range2.length; i++) {
    const start2 = range2.start(i);
    const end2 = range2.end(i);
    if (startTime > end2) {
      continue;
    }
    if (startTime > start2 && startTime <= end2) {
      time += end2 - startTime;
      continue;
    }
    time += end2 - start2;
  }
  return time;
};
const segmentDurationWithParts = (playlist, segment) => {
  if (!segment.preload) {
    return segment.duration;
  }
  let result = 0;
  (segment.parts || []).forEach(function(p) {
    result += p.duration;
  });
  (segment.preloadHints || []).forEach(function(p) {
    if (p.type === "PART") {
      result += playlist.partTargetDuration;
    }
  });
  return result;
};
const getPartsAndSegments = (playlist) => (playlist.segments || []).reduce((acc, segment, si) => {
  if (segment.parts) {
    segment.parts.forEach(function(part, pi) {
      acc.push({
        duration: part.duration,
        segmentIndex: si,
        partIndex: pi,
        part,
        segment
      });
    });
  } else {
    acc.push({
      duration: segment.duration,
      segmentIndex: si,
      partIndex: null,
      segment,
      part: null
    });
  }
  return acc;
}, []);
const getLastParts = (media) => {
  const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
  return lastSegment && lastSegment.parts || [];
};
const getKnownPartCount = ({
  preloadSegment
}) => {
  if (!preloadSegment) {
    return;
  }
  const {
    parts: parts2,
    preloadHints
  } = preloadSegment;
  let partCount = (preloadHints || []).reduce((count, hint) => count + (hint.type === "PART" ? 1 : 0), 0);
  partCount += parts2 && parts2.length ? parts2.length : 0;
  return partCount;
};
const liveEdgeDelay = (main2, media) => {
  if (media.endList) {
    return 0;
  }
  if (main2 && main2.suggestedPresentationDelay) {
    return main2.suggestedPresentationDelay;
  }
  const hasParts = getLastParts(media).length > 0;
  if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
    return media.serverControl.partHoldBack;
  } else if (hasParts && media.partTargetDuration) {
    return media.partTargetDuration * 3;
  } else if (media.serverControl && media.serverControl.holdBack) {
    return media.serverControl.holdBack;
  } else if (media.targetDuration) {
    return media.targetDuration * 3;
  }
  return 0;
};
const backwardDuration = function(playlist, endSequence) {
  let result = 0;
  let i = endSequence - playlist.mediaSequence;
  let segment = playlist.segments[i];
  if (segment) {
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start,
        precise: true
      };
    }
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - segment.duration,
        precise: true
      };
    }
  }
  while (i--) {
    segment = playlist.segments[i];
    if (typeof segment.end !== "undefined") {
      return {
        result: result + segment.end,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.start !== "undefined") {
      return {
        result: result + segment.start,
        precise: true
      };
    }
  }
  return {
    result,
    precise: false
  };
};
const forwardDuration = function(playlist, endSequence) {
  let result = 0;
  let segment;
  let i = endSequence - playlist.mediaSequence;
  for (; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start - result,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - result,
        precise: true
      };
    }
  }
  return {
    result: -1,
    precise: false
  };
};
const intervalDuration = function(playlist, endSequence, expired) {
  if (typeof endSequence === "undefined") {
    endSequence = playlist.mediaSequence + playlist.segments.length;
  }
  if (endSequence < playlist.mediaSequence) {
    return 0;
  }
  const backward = backwardDuration(playlist, endSequence);
  if (backward.precise) {
    return backward.result;
  }
  const forward = forwardDuration(playlist, endSequence);
  if (forward.precise) {
    return forward.result;
  }
  return backward.result + expired;
};
const duration = function(playlist, endSequence, expired) {
  if (!playlist) {
    return 0;
  }
  if (typeof expired !== "number") {
    expired = 0;
  }
  if (typeof endSequence === "undefined") {
    if (playlist.totalDuration) {
      return playlist.totalDuration;
    }
    if (!playlist.endList) {
      return window$1$1.Infinity;
    }
  }
  return intervalDuration(playlist, endSequence, expired);
};
const sumDurations = function({
  defaultDuration,
  durationList,
  startIndex,
  endIndex
}) {
  let durations = 0;
  if (startIndex > endIndex) {
    [startIndex, endIndex] = [endIndex, startIndex];
  }
  if (startIndex < 0) {
    for (let i = startIndex; i < Math.min(0, endIndex); i++) {
      durations += defaultDuration;
    }
    startIndex = 0;
  }
  for (let i = startIndex; i < endIndex; i++) {
    durations += durationList[i].duration;
  }
  return durations;
};
const playlistEnd = function(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
  if (!playlist || !playlist.segments) {
    return null;
  }
  if (playlist.endList) {
    return duration(playlist);
  }
  if (expired === null) {
    return null;
  }
  expired = expired || 0;
  let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
  if (useSafeLiveEnd) {
    liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
    lastSegmentEndTime -= liveEdgePadding;
  }
  return Math.max(0, lastSegmentEndTime);
};
const seekable = function(playlist, expired, liveEdgePadding) {
  const useSafeLiveEnd = true;
  const seekableStart = expired || 0;
  let seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
  if (seekableEnd === null) {
    return createTimeRanges();
  }
  if (seekableEnd < seekableStart) {
    seekableEnd = seekableStart;
  }
  return createTimeRanges(seekableStart, seekableEnd);
};
const getMediaInfoForTime = function({
  playlist,
  currentTime,
  startingSegmentIndex,
  startingPartIndex,
  startTime,
  exactManifestTimings
}) {
  let time = currentTime - startTime;
  const partsAndSegments = getPartsAndSegments(playlist);
  let startIndex = 0;
  for (let i = 0; i < partsAndSegments.length; i++) {
    const partAndSegment = partsAndSegments[i];
    if (startingSegmentIndex !== partAndSegment.segmentIndex) {
      continue;
    }
    if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
      continue;
    }
    startIndex = i;
    break;
  }
  if (time < 0) {
    if (startIndex > 0) {
      for (let i = startIndex - 1; i >= 0; i--) {
        const partAndSegment = partsAndSegments[i];
        time += partAndSegment.duration;
        if (exactManifestTimings) {
          if (time < 0) {
            continue;
          }
        } else if (time + TIME_FUDGE_FACTOR <= 0) {
          continue;
        }
        return {
          partIndex: partAndSegment.partIndex,
          segmentIndex: partAndSegment.segmentIndex,
          startTime: startTime - sumDurations({
            defaultDuration: playlist.targetDuration,
            durationList: partsAndSegments,
            startIndex,
            endIndex: i
          })
        };
      }
    }
    return {
      partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
      segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
      startTime: currentTime
    };
  }
  if (startIndex < 0) {
    for (let i = startIndex; i < 0; i++) {
      time -= playlist.targetDuration;
      if (time < 0) {
        return {
          partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
          segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
          startTime: currentTime
        };
      }
    }
    startIndex = 0;
  }
  for (let i = startIndex; i < partsAndSegments.length; i++) {
    const partAndSegment = partsAndSegments[i];
    time -= partAndSegment.duration;
    const canUseFudgeFactor = partAndSegment.duration > TIME_FUDGE_FACTOR;
    const isExactlyAtTheEnd = time === 0;
    const isExtremelyCloseToTheEnd = canUseFudgeFactor && time + TIME_FUDGE_FACTOR >= 0;
    if (isExactlyAtTheEnd || isExtremelyCloseToTheEnd) {
      if (i !== partsAndSegments.length - 1) {
        continue;
      }
    }
    if (exactManifestTimings) {
      if (time > 0) {
        continue;
      }
    } else if (time - TIME_FUDGE_FACTOR >= 0) {
      continue;
    }
    return {
      partIndex: partAndSegment.partIndex,
      segmentIndex: partAndSegment.segmentIndex,
      startTime: startTime + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: partsAndSegments,
        startIndex,
        endIndex: i
      })
    };
  }
  return {
    segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
    partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
    startTime: currentTime
  };
};
const isExcluded = function(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil > Date.now();
};
const isIncompatible = function(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil === Infinity;
};
const isEnabled = function(playlist) {
  const excluded = isExcluded(playlist);
  return !playlist.disabled && !excluded;
};
const isDisabled = function(playlist) {
  return playlist.disabled;
};
const isAes = function(media) {
  for (let i = 0; i < media.segments.length; i++) {
    if (media.segments[i].key) {
      return true;
    }
  }
  return false;
};
const hasAttribute = function(attr, playlist) {
  return playlist.attributes && playlist.attributes[attr];
};
const estimateSegmentRequestTime = function(segmentDuration, bandwidth, playlist, bytesReceived = 0) {
  if (!hasAttribute("BANDWIDTH", playlist)) {
    return NaN;
  }
  const size = segmentDuration * playlist.attributes.BANDWIDTH;
  return (size - bytesReceived * 8) / bandwidth;
};
const isLowestEnabledRendition = (main2, media) => {
  if (main2.playlists.length === 1) {
    return true;
  }
  const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
  return main2.playlists.filter((playlist) => {
    if (!isEnabled(playlist)) {
      return false;
    }
    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
  }).length === 0;
};
const playlistMatch = (a, b) => {
  if (!a && !b || !a && b || a && !b) {
    return false;
  }
  if (a === b) {
    return true;
  }
  if (a.id && b.id && a.id === b.id) {
    return true;
  }
  if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {
    return true;
  }
  if (a.uri && b.uri && a.uri === b.uri) {
    return true;
  }
  return false;
};
const someAudioVariant = function(main2, callback) {
  const AUDIO = main2 && main2.mediaGroups && main2.mediaGroups.AUDIO || {};
  let found = false;
  for (const groupName in AUDIO) {
    for (const label in AUDIO[groupName]) {
      found = callback(AUDIO[groupName][label]);
      if (found) {
        break;
      }
    }
    if (found) {
      break;
    }
  }
  return !!found;
};
const isAudioOnly = (main2) => {
  if (!main2 || !main2.playlists || !main2.playlists.length) {
    const found = someAudioVariant(main2, (variant) => variant.playlists && variant.playlists.length || variant.uri);
    return found;
  }
  for (let i = 0; i < main2.playlists.length; i++) {
    const playlist = main2.playlists[i];
    const CODECS = playlist.attributes && playlist.attributes.CODECS;
    if (CODECS && CODECS.split(",").every((c) => isAudioCodec(c))) {
      continue;
    }
    const found = someAudioVariant(main2, (variant) => playlistMatch(playlist, variant));
    if (found) {
      continue;
    }
    return false;
  }
  return true;
};
var Playlist = {
  liveEdgeDelay,
  duration,
  seekable,
  getMediaInfoForTime,
  isEnabled,
  isDisabled,
  isExcluded,
  isIncompatible,
  playlistEnd,
  isAes,
  hasAttribute,
  estimateSegmentRequestTime,
  isLowestEnabledRendition,
  isAudioOnly,
  playlistMatch,
  segmentDurationWithParts
};
const {
  log
} = videojs$2;
const createPlaylistID = (index, uri) => {
  return `${index}-${uri}`;
};
const groupID = (type, group, label) => {
  return `placeholder-uri-${type}-${group}-${label}`;
};
const parseManifest = ({
  onwarn,
  oninfo,
  manifestString,
  customTagParsers = [],
  customTagMappers = [],
  llhls
}) => {
  const parser2 = new Parser3();
  if (onwarn) {
    parser2.on("warn", onwarn);
  }
  if (oninfo) {
    parser2.on("info", oninfo);
  }
  customTagParsers.forEach((customParser) => parser2.addParser(customParser));
  customTagMappers.forEach((mapper) => parser2.addTagMapper(mapper));
  parser2.push(manifestString);
  parser2.end();
  const manifest = parser2.manifest;
  if (!llhls) {
    ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k) {
      if (manifest.hasOwnProperty(k)) {
        delete manifest[k];
      }
    });
    if (manifest.segments) {
      manifest.segments.forEach(function(segment) {
        ["parts", "preloadHints"].forEach(function(k) {
          if (segment.hasOwnProperty(k)) {
            delete segment[k];
          }
        });
      });
    }
  }
  if (!manifest.targetDuration) {
    let targetDuration = 10;
    if (manifest.segments && manifest.segments.length) {
      targetDuration = manifest.segments.reduce((acc, s) => Math.max(acc, s.duration), 0);
    }
    if (onwarn) {
      onwarn({
        message: `manifest has no targetDuration defaulting to ${targetDuration}`
      });
    }
    manifest.targetDuration = targetDuration;
  }
  const parts2 = getLastParts(manifest);
  if (parts2.length && !manifest.partTargetDuration) {
    const partTargetDuration = parts2.reduce((acc, p) => Math.max(acc, p.duration), 0);
    if (onwarn) {
      onwarn({
        message: `manifest has no partTargetDuration defaulting to ${partTargetDuration}`
      });
      log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
    }
    manifest.partTargetDuration = partTargetDuration;
  }
  return manifest;
};
const forEachMediaGroup2 = (main2, callback) => {
  if (!main2.mediaGroups) {
    return;
  }
  ["AUDIO", "SUBTITLES"].forEach((mediaType) => {
    if (!main2.mediaGroups[mediaType]) {
      return;
    }
    for (const groupKey in main2.mediaGroups[mediaType]) {
      for (const labelKey in main2.mediaGroups[mediaType][groupKey]) {
        const mediaProperties = main2.mediaGroups[mediaType][groupKey][labelKey];
        callback(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
const setupMediaPlaylist = ({
  playlist,
  uri,
  id
}) => {
  playlist.id = id;
  playlist.playlistErrors_ = 0;
  if (uri) {
    playlist.uri = uri;
  }
  playlist.attributes = playlist.attributes || {};
};
const setupMediaPlaylists = (main2) => {
  let i = main2.playlists.length;
  while (i--) {
    const playlist = main2.playlists[i];
    setupMediaPlaylist({
      playlist,
      id: createPlaylistID(i, playlist.uri)
    });
    playlist.resolvedUri = resolveUrl22(main2.uri, playlist.uri);
    main2.playlists[playlist.id] = playlist;
    main2.playlists[playlist.uri] = playlist;
    if (!playlist.attributes.BANDWIDTH) {
      log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
    }
  }
};
const resolveMediaGroupUris = (main2) => {
  forEachMediaGroup2(main2, (properties) => {
    if (properties.uri) {
      properties.resolvedUri = resolveUrl22(main2.uri, properties.uri);
    }
  });
};
const mainForMedia = (media, uri) => {
  const id = createPlaylistID(0, uri);
  const main2 = {
    mediaGroups: {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    },
    uri: window$1$1.location.href,
    resolvedUri: window$1$1.location.href,
    playlists: [{
      uri,
      id,
      resolvedUri: uri,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  main2.playlists[id] = main2.playlists[0];
  main2.playlists[uri] = main2.playlists[0];
  return main2;
};
const addPropertiesToMain = (main2, uri, createGroupID = groupID) => {
  main2.uri = uri;
  for (let i = 0; i < main2.playlists.length; i++) {
    if (!main2.playlists[i].uri) {
      const phonyUri = `placeholder-uri-${i}`;
      main2.playlists[i].uri = phonyUri;
    }
  }
  const audioOnlyMain = isAudioOnly(main2);
  forEachMediaGroup2(main2, (properties, mediaType, groupKey, labelKey) => {
    if (!properties.playlists || !properties.playlists.length) {
      if (audioOnlyMain && mediaType === "AUDIO" && !properties.uri) {
        for (let i = 0; i < main2.playlists.length; i++) {
          const p = main2.playlists[i];
          if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {
            return;
          }
        }
      }
      properties.playlists = [_extends$2({}, properties)];
    }
    properties.playlists.forEach(function(p, i) {
      const groupId = createGroupID(mediaType, groupKey, labelKey, p);
      const id = createPlaylistID(i, groupId);
      if (p.uri) {
        p.resolvedUri = p.resolvedUri || resolveUrl22(main2.uri, p.uri);
      } else {
        p.uri = i === 0 ? groupId : id;
        p.resolvedUri = p.uri;
      }
      p.id = p.id || id;
      p.attributes = p.attributes || {};
      main2.playlists[p.id] = p;
      main2.playlists[p.uri] = p;
    });
  });
  setupMediaPlaylists(main2);
  resolveMediaGroupUris(main2);
};
class DateRangesStorage {
  constructor() {
    this.offset_ = null;
    this.pendingDateRanges_ = /* @__PURE__ */ new Map();
    this.processedDateRanges_ = /* @__PURE__ */ new Map();
  }
  setOffset(segments = []) {
    if (this.offset_ !== null) {
      return;
    }
    if (!segments.length) {
      return;
    }
    const [firstSegment] = segments;
    if (firstSegment.programDateTime === void 0) {
      return;
    }
    this.offset_ = firstSegment.programDateTime / 1e3;
  }
  setPendingDateRanges(dateRanges = []) {
    if (!dateRanges.length) {
      return;
    }
    const [dateRange] = dateRanges;
    const startTime = dateRange.startDate.getTime();
    this.trimProcessedDateRanges_(startTime);
    this.pendingDateRanges_ = dateRanges.reduce((map2, pendingDateRange) => {
      map2.set(pendingDateRange.id, pendingDateRange);
      return map2;
    }, /* @__PURE__ */ new Map());
  }
  processDateRange(dateRange) {
    this.pendingDateRanges_.delete(dateRange.id);
    this.processedDateRanges_.set(dateRange.id, dateRange);
  }
  getDateRangesToProcess() {
    if (this.offset_ === null) {
      return [];
    }
    const dateRangeClasses = {};
    const dateRangesToProcess = [];
    this.pendingDateRanges_.forEach((dateRange, id) => {
      if (this.processedDateRanges_.has(id)) {
        return;
      }
      dateRange.startTime = dateRange.startDate.getTime() / 1e3 - this.offset_;
      dateRange.processDateRange = () => this.processDateRange(dateRange);
      dateRangesToProcess.push(dateRange);
      if (!dateRange.class) {
        return;
      }
      if (dateRangeClasses[dateRange.class]) {
        const length2 = dateRangeClasses[dateRange.class].push(dateRange);
        dateRange.classListIndex = length2 - 1;
      } else {
        dateRangeClasses[dateRange.class] = [dateRange];
        dateRange.classListIndex = 0;
      }
    });
    for (const dateRange of dateRangesToProcess) {
      const classList = dateRangeClasses[dateRange.class] || [];
      if (dateRange.endDate) {
        dateRange.endTime = dateRange.endDate.getTime() / 1e3 - this.offset_;
      } else if (dateRange.endOnNext && classList[dateRange.classListIndex + 1]) {
        dateRange.endTime = classList[dateRange.classListIndex + 1].startTime;
      } else if (dateRange.duration) {
        dateRange.endTime = dateRange.startTime + dateRange.duration;
      } else if (dateRange.plannedDuration) {
        dateRange.endTime = dateRange.startTime + dateRange.plannedDuration;
      } else {
        dateRange.endTime = dateRange.startTime;
      }
    }
    return dateRangesToProcess;
  }
  trimProcessedDateRanges_(startTime) {
    const copy2 = new Map(this.processedDateRanges_);
    copy2.forEach((dateRange, id) => {
      if (dateRange.startDate.getTime() < startTime) {
        this.processedDateRanges_.delete(id);
      }
    });
  }
}
const QUOTA_EXCEEDED_ERR = 22;
const getStreamingNetworkErrorMetadata = ({
  requestType,
  request,
  error,
  parseFailure
}) => {
  const isBadStatus = request.status < 200 || request.status > 299;
  const isFailure = request.status >= 400 && request.status <= 499;
  const errorMetadata = {
    uri: request.uri,
    requestType
  };
  const isBadStatusOrParseFailure = isBadStatus && !isFailure || parseFailure;
  if (error && isFailure) {
    errorMetadata.error = _extends$2({}, error);
    errorMetadata.errorType = videojs$2.Error.NetworkRequestFailed;
  } else if (request.aborted) {
    errorMetadata.errorType = videojs$2.Error.NetworkRequestAborted;
  } else if (request.timedout) {
    errorMetadata.erroType = videojs$2.Error.NetworkRequestTimeout;
  } else if (isBadStatusOrParseFailure) {
    const errorType = parseFailure ? videojs$2.Error.NetworkBodyParserFailed : videojs$2.Error.NetworkBadStatus;
    errorMetadata.errorType = errorType;
    errorMetadata.status = request.status;
    errorMetadata.headers = request.headers;
  }
  return errorMetadata;
};
const {
  EventTarget: EventTarget$1
} = videojs$2;
const addLLHLSQueryDirectives = (uri, media) => {
  if (media.endList || !media.serverControl) {
    return uri;
  }
  const parameters = {};
  if (media.serverControl.canBlockReload) {
    const {
      preloadSegment
    } = media;
    let nextMSN = media.mediaSequence + media.segments.length;
    if (preloadSegment) {
      const parts2 = preloadSegment.parts || [];
      const nextPart = getKnownPartCount(media) - 1;
      if (nextPart > -1 && nextPart !== parts2.length - 1) {
        parameters._HLS_part = nextPart;
      }
      if (nextPart > -1 || parts2.length) {
        nextMSN--;
      }
    }
    parameters._HLS_msn = nextMSN;
  }
  if (media.serverControl && media.serverControl.canSkipUntil) {
    parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
  }
  if (Object.keys(parameters).length) {
    const parsedUri = new window$1$1.URL(uri);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
      if (!parameters.hasOwnProperty(name)) {
        return;
      }
      parsedUri.searchParams.set(name, parameters[name]);
    });
    uri = parsedUri.toString();
  }
  return uri;
};
const updateSegment = (a, b) => {
  if (!a) {
    return b;
  }
  const result = merge(a, b);
  if (a.preloadHints && !b.preloadHints) {
    delete result.preloadHints;
  }
  if (a.parts && !b.parts) {
    delete result.parts;
  } else if (a.parts && b.parts) {
    for (let i = 0; i < b.parts.length; i++) {
      if (a.parts && a.parts[i]) {
        result.parts[i] = merge(a.parts[i], b.parts[i]);
      }
    }
  }
  if (!a.skipped && b.skipped) {
    result.skipped = false;
  }
  if (a.preload && !b.preload) {
    result.preload = false;
  }
  return result;
};
const updateSegments = (original, update2, offset2) => {
  const oldSegments = original.slice();
  const newSegments = update2.slice();
  offset2 = offset2 || 0;
  const result = [];
  let currentMap;
  for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {
    const oldSegment = oldSegments[newIndex + offset2];
    const newSegment = newSegments[newIndex];
    if (oldSegment) {
      currentMap = oldSegment.map || currentMap;
      result.push(updateSegment(oldSegment, newSegment));
    } else {
      if (currentMap && !newSegment.map) {
        newSegment.map = currentMap;
      }
      result.push(newSegment);
    }
  }
  return result;
};
const resolveSegmentUris = (segment, baseUri) => {
  if (!segment.resolvedUri && segment.uri) {
    segment.resolvedUri = resolveUrl22(baseUri, segment.uri);
  }
  if (segment.key && !segment.key.resolvedUri) {
    segment.key.resolvedUri = resolveUrl22(baseUri, segment.key.uri);
  }
  if (segment.map && !segment.map.resolvedUri) {
    segment.map.resolvedUri = resolveUrl22(baseUri, segment.map.uri);
  }
  if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
    segment.map.key.resolvedUri = resolveUrl22(baseUri, segment.map.key.uri);
  }
  if (segment.parts && segment.parts.length) {
    segment.parts.forEach((p) => {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl22(baseUri, p.uri);
    });
  }
  if (segment.preloadHints && segment.preloadHints.length) {
    segment.preloadHints.forEach((p) => {
      if (p.resolvedUri) {
        return;
      }
      p.resolvedUri = resolveUrl22(baseUri, p.uri);
    });
  }
};
const getAllSegments = function(media) {
  const segments = media.segments || [];
  const preloadSegment = media.preloadSegment;
  if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
    if (preloadSegment.preloadHints) {
      for (let i = 0; i < preloadSegment.preloadHints.length; i++) {
        if (preloadSegment.preloadHints[i].type === "MAP") {
          return segments;
        }
      }
    }
    preloadSegment.duration = media.targetDuration;
    preloadSegment.preload = true;
    segments.push(preloadSegment);
  }
  return segments;
};
const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
const updateMain$1 = (main2, newMedia, unchangedCheck = isPlaylistUnchanged) => {
  const result = merge(main2, {});
  const oldMedia = result.playlists[newMedia.id];
  if (!oldMedia) {
    return null;
  }
  if (unchangedCheck(oldMedia, newMedia)) {
    return null;
  }
  newMedia.segments = getAllSegments(newMedia);
  const mergedPlaylist = merge(oldMedia, newMedia);
  if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
    delete mergedPlaylist.preloadSegment;
  }
  if (oldMedia.segments) {
    if (newMedia.skip) {
      newMedia.segments = newMedia.segments || [];
      for (let i = 0; i < newMedia.skip.skippedSegments; i++) {
        newMedia.segments.unshift({
          skipped: true
        });
      }
    }
    mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
  }
  mergedPlaylist.segments.forEach((segment) => {
    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
  });
  for (let i = 0; i < result.playlists.length; i++) {
    if (result.playlists[i].id === newMedia.id) {
      result.playlists[i] = mergedPlaylist;
    }
  }
  result.playlists[newMedia.id] = mergedPlaylist;
  result.playlists[newMedia.uri] = mergedPlaylist;
  forEachMediaGroup2(main2, (properties, mediaType, groupKey, labelKey) => {
    if (!properties.playlists) {
      return;
    }
    for (let i = 0; i < properties.playlists.length; i++) {
      if (newMedia.id === properties.playlists[i].id) {
        properties.playlists[i] = mergedPlaylist;
      }
    }
  });
  return result;
};
const refreshDelay = (media, update2) => {
  const segments = media.segments || [];
  const lastSegment = segments[segments.length - 1];
  const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
  const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
  if (update2 && lastDuration) {
    return lastDuration * 1e3;
  }
  return (media.partTargetDuration || media.targetDuration || 10) * 500;
};
const playlistMetadataPayload = (playlists, type, isLive) => {
  if (!playlists) {
    return;
  }
  const renditions = [];
  playlists.forEach((playlist) => {
    if (!playlist.attributes) {
      return;
    }
    const {
      BANDWIDTH,
      RESOLUTION,
      CODECS
    } = playlist.attributes;
    renditions.push({
      id: playlist.id,
      bandwidth: BANDWIDTH,
      resolution: RESOLUTION,
      codecs: CODECS
    });
  });
  return {
    type,
    isLive,
    renditions
  };
};
class PlaylistLoader extends EventTarget$1 {
  constructor(src, vhs, options = {}) {
    super();
    if (!src) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    this.logger_ = logger("PlaylistLoader");
    const {
      withCredentials = false
    } = options;
    this.src = src;
    this.vhs_ = vhs;
    this.withCredentials = withCredentials;
    this.addDateRangesToTextTrack_ = options.addDateRangesToTextTrack;
    const vhsOptions = vhs.options_;
    this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
    this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
    this.llhls = vhsOptions && vhsOptions.llhls;
    this.dateRangesStorage_ = new DateRangesStorage();
    this.state = "HAVE_NOTHING";
    this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);
    this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_);
    this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this));
  }
  handleLoadedPlaylist_() {
    const mediaPlaylist = this.media();
    if (!mediaPlaylist) {
      return;
    }
    this.dateRangesStorage_.setOffset(mediaPlaylist.segments);
    this.dateRangesStorage_.setPendingDateRanges(mediaPlaylist.dateRanges);
    const availableDateRanges = this.dateRangesStorage_.getDateRangesToProcess();
    if (!availableDateRanges.length || !this.addDateRangesToTextTrack_) {
      return;
    }
    this.addDateRangesToTextTrack_(availableDateRanges);
  }
  handleMediaupdatetimeout_() {
    if (this.state !== "HAVE_METADATA") {
      return;
    }
    const media = this.media();
    let uri = resolveUrl22(this.main.uri, media.uri);
    if (this.llhls) {
      uri = addLLHLSQueryDirectives(uri, media);
    }
    this.state = "HAVE_CURRENT_METADATA";
    this.request = this.vhs_.xhr({
      uri,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (error, req) => {
      if (!this.request) {
        return;
      }
      if (error) {
        return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
      }
      this.haveMetadata({
        playlistString: this.request.responseText,
        url: this.media().uri,
        id: this.media().id
      });
    });
  }
  playlistRequestError(xhr, playlist, startingState) {
    const {
      uri,
      id
    } = playlist;
    this.request = null;
    if (startingState) {
      this.state = startingState;
    }
    this.error = {
      playlist: this.main.playlists[id],
      status: xhr.status,
      message: `HLS playlist request error at URL: ${uri}.`,
      responseText: xhr.responseText,
      code: xhr.status >= 500 ? 4 : 2,
      metadata: getStreamingNetworkErrorMetadata({
        requestType: xhr.requestType,
        request: xhr,
        error: xhr.error
      })
    };
    this.trigger("error");
  }
  parseManifest_({
    url: url2,
    manifestString
  }) {
    try {
      return parseManifest({
        onwarn: ({
          message
        }) => this.logger_(`m3u8-parser warn for ${url2}: ${message}`),
        oninfo: ({
          message
        }) => this.logger_(`m3u8-parser info for ${url2}: ${message}`),
        manifestString,
        customTagParsers: this.customTagParsers,
        customTagMappers: this.customTagMappers,
        llhls: this.llhls
      });
    } catch (error) {
      this.error = error;
      this.error.metadata = {
        errorType: videojs$2.Error.StreamingHlsPlaylistParserError,
        error
      };
    }
  }
  /**
   * Update the playlist loader's state in response to a new or updated playlist.
   *
   * @param {string} [playlistString]
   *        Playlist string (if playlistObject is not provided)
   * @param {Object} [playlistObject]
   *        Playlist object (if playlistString is not provided)
   * @param {string} url
   *        URL of playlist
   * @param {string} id
   *        ID to use for playlist
   */
  haveMetadata({
    playlistString,
    playlistObject,
    url: url2,
    id
  }) {
    this.request = null;
    this.state = "HAVE_METADATA";
    const metadata = {
      playlistInfo: {
        type: "media",
        uri: url2
      }
    };
    this.trigger({
      type: "playlistparsestart",
      metadata
    });
    const playlist = playlistObject || this.parseManifest_({
      url: url2,
      manifestString: playlistString
    });
    playlist.lastRequest = Date.now();
    setupMediaPlaylist({
      playlist,
      uri: url2,
      id
    });
    const update2 = updateMain$1(this.main, playlist);
    this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
    this.pendingMedia_ = null;
    if (update2) {
      this.main = update2;
      this.media_ = this.main.playlists[id];
    } else {
      this.trigger("playlistunchanged");
    }
    this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update2));
    metadata.parsedPlaylist = playlistMetadataPayload(this.main.playlists, metadata.playlistInfo.type, !this.media_.endList);
    this.trigger({
      type: "playlistparsecomplete",
      metadata
    });
    this.trigger("loadedplaylist");
  }
  /**
    * Abort any outstanding work and clean up.
    */
  dispose() {
    this.trigger("dispose");
    this.stopRequest();
    window$1$1.clearTimeout(this.mediaUpdateTimeout);
    window$1$1.clearTimeout(this.finalRenditionTimeout);
    this.dateRangesStorage_ = new DateRangesStorage();
    this.off();
  }
  stopRequest() {
    if (this.request) {
      const oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  }
  /**
    * When called without any arguments, returns the currently
    * active media playlist. When called with a single argument,
    * triggers the playlist loader to asynchronously switch to the
    * specified media playlist. Calling this method while the
    * loader is in the HAVE_NOTHING causes an error to be emitted
    * but otherwise has no effect.
    *
    * @param {Object=} playlist the parsed media playlist
    * object to switch to
    * @param {boolean=} shouldDelay whether we should delay the request by half target duration
    *
    * @return {Playlist} the current loaded media
    */
  media(playlist, shouldDelay) {
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    if (typeof playlist === "string") {
      if (!this.main.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.main.playlists[playlist];
    }
    window$1$1.clearTimeout(this.finalRenditionTimeout);
    if (shouldDelay) {
      const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
      this.finalRenditionTimeout = window$1$1.setTimeout(this.media.bind(this, playlist, false), delay);
      return;
    }
    const startingState = this.state;
    const mediaChange = !this.media_ || playlist.id !== this.media_.id;
    const mainPlaylistRef = this.main.playlists[playlist.id];
    if (mainPlaylistRef && mainPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    playlist.endList && playlist.segments.length) {
      if (this.request) {
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        if (startingState === "HAVE_MAIN_MANIFEST") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      }
      return;
    }
    this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
    if (!mediaChange) {
      return;
    }
    this.state = "SWITCHING_MEDIA";
    if (this.request) {
      if (playlist.resolvedUri === this.request.url) {
        return;
      }
      this.request.onreadystatechange = null;
      this.request.abort();
      this.request = null;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.pendingMedia_ = playlist;
    const metadata = {
      playlistInfo: {
        type: "media",
        uri: playlist.uri
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata
    });
    this.request = this.vhs_.xhr({
      uri: playlist.resolvedUri,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (error, req) => {
      if (!this.request) {
        return;
      }
      playlist.lastRequest = Date.now();
      playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);
      if (error) {
        return this.playlistRequestError(this.request, playlist, startingState);
      }
      this.trigger({
        type: "playlistrequestcomplete",
        metadata
      });
      this.haveMetadata({
        playlistString: req.responseText,
        url: playlist.uri,
        id: playlist.id
      });
      if (startingState === "HAVE_MAIN_MANIFEST") {
        this.trigger("loadedmetadata");
      } else {
        this.trigger("mediachange");
      }
    });
  }
  /**
   * pause loading of the playlist
   */
  pause() {
    if (this.mediaUpdateTimeout) {
      window$1$1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    this.stopRequest();
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
    if (this.state === "SWITCHING_MEDIA") {
      if (this.media_) {
        this.state = "HAVE_METADATA";
      } else {
        this.state = "HAVE_MAIN_MANIFEST";
      }
    } else if (this.state === "HAVE_CURRENT_METADATA") {
      this.state = "HAVE_METADATA";
    }
  }
  /**
   * start loading of the playlist
   */
  load(shouldDelay) {
    if (this.mediaUpdateTimeout) {
      window$1$1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    const media = this.media();
    if (shouldDelay) {
      const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = window$1$1.setTimeout(() => {
        this.mediaUpdateTimeout = null;
        this.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  }
  updateMediaUpdateTimeout_(delay) {
    if (this.mediaUpdateTimeout) {
      window$1$1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    if (!this.media() || this.media().endList) {
      return;
    }
    this.mediaUpdateTimeout = window$1$1.setTimeout(() => {
      this.mediaUpdateTimeout = null;
      this.trigger("mediaupdatetimeout");
      this.updateMediaUpdateTimeout_(delay);
    }, delay);
  }
  /**
   * start loading of the playlist
   */
  start() {
    this.started = true;
    if (typeof this.src === "object") {
      if (!this.src.uri) {
        this.src.uri = window$1$1.location.href;
      }
      this.src.resolvedUri = this.src.uri;
      setTimeout(() => {
        this.setupInitialPlaylist(this.src);
      }, 0);
      return;
    }
    const metadata = {
      playlistInfo: {
        type: "multivariant",
        uri: this.src
      }
    };
    this.trigger({
      type: "playlistrequeststart",
      metadata
    });
    this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials,
      requestType: "hls-playlist"
    }, (error, req) => {
      if (!this.request) {
        return;
      }
      this.request = null;
      if (error) {
        this.error = {
          status: req.status,
          message: `HLS playlist request error at URL: ${this.src}.`,
          responseText: req.responseText,
          // MEDIA_ERR_NETWORK
          code: 2,
          metadata: getStreamingNetworkErrorMetadata({
            requestType: req.requestType,
            request: req,
            error
          })
        };
        if (this.state === "HAVE_NOTHING") {
          this.started = false;
        }
        return this.trigger("error");
      }
      this.trigger({
        type: "playlistrequestcomplete",
        metadata
      });
      this.src = resolveManifestRedirect(this.src, req);
      this.trigger({
        type: "playlistparsestart",
        metadata
      });
      const manifest = this.parseManifest_({
        manifestString: req.responseText,
        url: this.src
      });
      metadata.parsedPlaylist = playlistMetadataPayload(manifest.playlists, metadata.playlistInfo.type, false);
      this.trigger({
        type: "playlistparsecomplete",
        metadata
      });
      this.setupInitialPlaylist(manifest);
    });
  }
  srcUri() {
    return typeof this.src === "string" ? this.src : this.src.uri;
  }
  /**
   * Given a manifest object that's either a main or media playlist, trigger the proper
   * events and set the state of the playlist loader.
   *
   * If the manifest object represents a main playlist, `loadedplaylist` will be
   * triggered to allow listeners to select a playlist. If none is selected, the loader
   * will default to the first one in the playlists array.
   *
   * If the manifest object represents a media playlist, `loadedplaylist` will be
   * triggered followed by `loadedmetadata`, as the only available playlist is loaded.
   *
   * In the case of a media playlist, a main playlist object wrapper with one playlist
   * will be created so that all logic can handle playlists in the same fashion (as an
   * assumed manifest object schema).
   *
   * @param {Object} manifest
   *        The parsed manifest object
   */
  setupInitialPlaylist(manifest) {
    this.state = "HAVE_MAIN_MANIFEST";
    if (manifest.playlists) {
      this.main = manifest;
      addPropertiesToMain(this.main, this.srcUri());
      manifest.playlists.forEach((playlist) => {
        playlist.segments = getAllSegments(playlist);
        playlist.segments.forEach((segment) => {
          resolveSegmentUris(segment, playlist.resolvedUri);
        });
      });
      this.trigger("loadedplaylist");
      if (!this.request) {
        this.media(this.main.playlists[0]);
      }
      return;
    }
    const uri = this.srcUri() || window$1$1.location.href;
    this.main = mainForMedia(manifest, uri);
    this.haveMetadata({
      playlistObject: manifest,
      url: uri,
      id: this.main.playlists[0].id
    });
    this.trigger("loadedmetadata");
  }
  /**
   * Updates or deletes a preexisting pathway clone.
   * Ensures that all playlists related to the old pathway clone are
   * either updated or deleted.
   *
   * @param {Object} clone On update, the pathway clone object for the newly updated pathway clone.
   *        On delete, the old pathway clone object to be deleted.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteClone(clone, isUpdate) {
    const main2 = this.main;
    const pathway = clone.ID;
    let i = main2.playlists.length;
    while (i--) {
      const p = main2.playlists[i];
      if (p.attributes["PATHWAY-ID"] === pathway) {
        const oldPlaylistUri = p.resolvedUri;
        const oldPlaylistId = p.id;
        if (isUpdate) {
          const newPlaylistUri = this.createCloneURI_(p.resolvedUri, clone);
          const newPlaylistId = createPlaylistID(pathway, newPlaylistUri);
          const attributes = this.createCloneAttributes_(pathway, p.attributes);
          const updatedPlaylist = this.createClonePlaylist_(p, newPlaylistId, clone, attributes);
          main2.playlists[i] = updatedPlaylist;
          main2.playlists[newPlaylistId] = updatedPlaylist;
          main2.playlists[newPlaylistUri] = updatedPlaylist;
        } else {
          main2.playlists.splice(i, 1);
        }
        delete main2.playlists[oldPlaylistId];
        delete main2.playlists[oldPlaylistUri];
      }
    }
    this.updateOrDeleteCloneMedia(clone, isUpdate);
  }
  /**
   * Updates or deletes media data based on the pathway clone object.
   * Due to the complexity of the media groups and playlists, in all cases
   * we remove all of the old media groups and playlists.
   * On updates, we then create new media groups and playlists based on the
   * new pathway clone object.
   *
   * @param {Object} clone The pathway clone object for the newly updated pathway clone.
   * @param {boolean} isUpdate True if the pathway is to be updated,
   *        false if it is meant to be deleted.
   */
  updateOrDeleteCloneMedia(clone, isUpdate) {
    const main2 = this.main;
    const id = clone.ID;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
      if (!main2.mediaGroups[mediaType] || !main2.mediaGroups[mediaType][id]) {
        return;
      }
      for (const groupKey in main2.mediaGroups[mediaType]) {
        if (groupKey === id) {
          for (const labelKey in main2.mediaGroups[mediaType][groupKey]) {
            const oldMedia = main2.mediaGroups[mediaType][groupKey][labelKey];
            oldMedia.playlists.forEach((p, i) => {
              const oldMediaPlaylist = main2.playlists[p.id];
              const oldPlaylistId = oldMediaPlaylist.id;
              const oldPlaylistUri = oldMediaPlaylist.resolvedUri;
              delete main2.playlists[oldPlaylistId];
              delete main2.playlists[oldPlaylistUri];
            });
          }
          delete main2.mediaGroups[mediaType][groupKey];
        }
      }
    });
    if (isUpdate) {
      this.createClonedMediaGroups_(clone);
    }
  }
  /**
   * Given a pathway clone object, clones all necessary playlists.
   *
   * @param {Object} clone The pathway clone object.
   * @param {Object} basePlaylist The original playlist to clone from.
   */
  addClonePathway(clone, basePlaylist = {}) {
    const main2 = this.main;
    const index = main2.playlists.length;
    const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
    const playlistId = createPlaylistID(clone.ID, uri);
    const attributes = this.createCloneAttributes_(clone.ID, basePlaylist.attributes);
    const playlist = this.createClonePlaylist_(basePlaylist, playlistId, clone, attributes);
    main2.playlists[index] = playlist;
    main2.playlists[playlistId] = playlist;
    main2.playlists[uri] = playlist;
    this.createClonedMediaGroups_(clone);
  }
  /**
   * Given a pathway clone object we create clones of all media.
   * In this function, all necessary information and updated playlists
   * are added to the `mediaGroup` object.
   * Playlists are also added to the `playlists` array so the media groups
   * will be properly linked.
   *
   * @param {Object} clone The pathway clone object.
   */
  createClonedMediaGroups_(clone) {
    const id = clone.ID;
    const baseID = clone["BASE-ID"];
    const main2 = this.main;
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
      if (!main2.mediaGroups[mediaType] || main2.mediaGroups[mediaType][id]) {
        return;
      }
      for (const groupKey in main2.mediaGroups[mediaType]) {
        if (groupKey === baseID) {
          main2.mediaGroups[mediaType][id] = {};
        } else {
          continue;
        }
        for (const labelKey in main2.mediaGroups[mediaType][groupKey]) {
          const oldMedia = main2.mediaGroups[mediaType][groupKey][labelKey];
          main2.mediaGroups[mediaType][id][labelKey] = _extends$2({}, oldMedia);
          const newMedia = main2.mediaGroups[mediaType][id][labelKey];
          const newUri = this.createCloneURI_(oldMedia.resolvedUri, clone);
          newMedia.resolvedUri = newUri;
          newMedia.uri = newUri;
          newMedia.playlists = [];
          oldMedia.playlists.forEach((p, i) => {
            const oldMediaPlaylist = main2.playlists[p.id];
            const group = groupID(mediaType, id, labelKey);
            const newPlaylistID = createPlaylistID(id, group);
            if (oldMediaPlaylist && !main2.playlists[newPlaylistID]) {
              const newMediaPlaylist = this.createClonePlaylist_(oldMediaPlaylist, newPlaylistID, clone);
              const newPlaylistUri = newMediaPlaylist.resolvedUri;
              main2.playlists[newPlaylistID] = newMediaPlaylist;
              main2.playlists[newPlaylistUri] = newMediaPlaylist;
            }
            newMedia.playlists[i] = this.createClonePlaylist_(p, newPlaylistID, clone);
          });
        }
      }
    });
  }
  /**
   * Using the original playlist to be cloned, and the pathway clone object
   * information, we create a new playlist.
   *
   * @param {Object} basePlaylist  The original playlist to be cloned from.
   * @param {string} id The desired id of the newly cloned playlist.
   * @param {Object} clone The pathway clone object.
   * @param {Object} attributes An optional object to populate the `attributes` property in the playlist.
   *
   * @return {Object} The combined cloned playlist.
   */
  createClonePlaylist_(basePlaylist, id, clone, attributes) {
    const uri = this.createCloneURI_(basePlaylist.resolvedUri, clone);
    const newProps = {
      resolvedUri: uri,
      uri,
      id
    };
    if (basePlaylist.segments) {
      newProps.segments = [];
    }
    if (attributes) {
      newProps.attributes = attributes;
    }
    return merge(basePlaylist, newProps);
  }
  /**
   * Generates an updated URI for a cloned pathway based on the original
   * pathway's URI and the paramaters from the pathway clone object in the
   * content steering server response.
   *
   * @param {string} baseUri URI to be updated in the cloned pathway.
   * @param {Object} clone The pathway clone object.
   *
   * @return {string} The updated URI for the cloned pathway.
   */
  createCloneURI_(baseURI, clone) {
    const uri = new URL(baseURI);
    uri.hostname = clone["URI-REPLACEMENT"].HOST;
    const params = clone["URI-REPLACEMENT"].PARAMS;
    for (const key of Object.keys(params)) {
      uri.searchParams.set(key, params[key]);
    }
    return uri.href;
  }
  /**
   * Helper function to create the attributes needed for the new clone.
   * This mainly adds the necessary media attributes.
   *
   * @param {string} id The pathway clone object ID.
   * @param {Object} oldAttributes The old attributes to compare to.
   * @return {Object} The new attributes to add to the playlist.
   */
  createCloneAttributes_(id, oldAttributes) {
    const attributes = {
      ["PATHWAY-ID"]: id
    };
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((mediaType) => {
      if (oldAttributes[mediaType]) {
        attributes[mediaType] = id;
      }
    });
    return attributes;
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(playlist) {
    if (playlist.contentProtection) {
      const keyIds = /* @__PURE__ */ new Set();
      for (const keysystem in playlist.contentProtection) {
        const keyId = playlist.contentProtection[keysystem].attributes.keyId;
        if (keyId) {
          keyIds.add(keyId.toLowerCase());
        }
      }
      return keyIds;
    }
  }
}
const callbackWrapper = function(request, error, response, callback) {
  const reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
  if (!error && reqResponse) {
    request.responseTime = Date.now();
    request.roundTripTime = request.responseTime - request.requestTime;
    request.bytesReceived = reqResponse.byteLength || reqResponse.length;
    if (!request.bandwidth) {
      request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
    }
  }
  if (response.headers) {
    request.responseHeaders = response.headers;
  }
  if (error && error.code === "ETIMEDOUT") {
    request.timedout = true;
  }
  if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
    error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
  }
  callback(error, request);
};
const callAllRequestHooks = (requestSet, options) => {
  if (!requestSet || !requestSet.size) {
    return;
  }
  let newOptions = options;
  requestSet.forEach((requestCallback) => {
    newOptions = requestCallback(newOptions);
  });
  return newOptions;
};
const callAllResponseHooks = (responseSet, request, error, response) => {
  if (!responseSet || !responseSet.size) {
    return;
  }
  responseSet.forEach((responseCallback) => {
    responseCallback(request, error, response);
  });
};
const xhrFactory = function() {
  const xhr = function XhrFunction(options, callback) {
    options = merge({
      timeout: 45e3
    }, options);
    const beforeRequest = XhrFunction.beforeRequest || videojs$2.Vhs.xhr.beforeRequest;
    const _requestCallbackSet = XhrFunction._requestCallbackSet || videojs$2.Vhs.xhr._requestCallbackSet || /* @__PURE__ */ new Set();
    const _responseCallbackSet = XhrFunction._responseCallbackSet || videojs$2.Vhs.xhr._responseCallbackSet;
    if (beforeRequest && typeof beforeRequest === "function") {
      videojs$2.log.warn("beforeRequest is deprecated, use onRequest instead.");
      _requestCallbackSet.add(beforeRequest);
    }
    const xhrMethod = videojs$2.Vhs.xhr.original === true ? videojs$2.xhr : videojs$2.Vhs.xhr;
    const beforeRequestOptions = callAllRequestHooks(_requestCallbackSet, options);
    _requestCallbackSet.delete(beforeRequest);
    const request = xhrMethod(beforeRequestOptions || options, function(error, response) {
      callAllResponseHooks(_responseCallbackSet, request, error, response);
      return callbackWrapper(request, error, response, callback);
    });
    const originalAbort = request.abort;
    request.abort = function() {
      request.aborted = true;
      return originalAbort.apply(request, arguments);
    };
    request.uri = options.uri;
    request.requestType = options.requestType;
    request.requestTime = Date.now();
    return request;
  };
  xhr.original = true;
  return xhr;
};
const byterangeStr = function(byterange) {
  let byterangeEnd;
  const byterangeStart = byterange.offset;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    byterangeEnd = window$1$1.BigInt(byterange.offset) + window$1$1.BigInt(byterange.length) - window$1$1.BigInt(1);
  } else {
    byterangeEnd = byterange.offset + byterange.length - 1;
  }
  return "bytes=" + byterangeStart + "-" + byterangeEnd;
};
const segmentXhrHeaders = function(segment) {
  const headers = {};
  if (segment.byterange) {
    headers.Range = byterangeStr(segment.byterange);
  }
  return headers;
};
const textRange = function(range2, i) {
  return range2.start(i) + "-" + range2.end(i);
};
const formatHexString = function(e, i) {
  const value2 = e.toString(16);
  return "00".substring(0, 2 - value2.length) + value2 + (i % 2 ? " " : "");
};
const formatAsciiString = function(e) {
  if (e >= 32 && e < 126) {
    return String.fromCharCode(e);
  }
  return ".";
};
const createTransferableMessage = function(message) {
  const transferable = {};
  Object.keys(message).forEach((key) => {
    const value2 = message[key];
    if (isArrayBufferView(value2)) {
      transferable[key] = {
        bytes: value2.buffer,
        byteOffset: value2.byteOffset,
        byteLength: value2.byteLength
      };
    } else {
      transferable[key] = value2;
    }
  });
  return transferable;
};
const initSegmentId = function(initSegment) {
  const byterange = initSegment.byterange || {
    length: Infinity,
    offset: 0
  };
  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
};
const segmentKeyId = function(key) {
  return key.resolvedUri;
};
const hexDump = (data) => {
  const bytes = Array.prototype.slice.call(data);
  const step = 16;
  let result = "";
  let hex;
  let ascii;
  for (let j = 0; j < bytes.length / step; j++) {
    hex = bytes.slice(j * step, j * step + step).map(formatHexString).join("");
    ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join("");
    result += hex + " " + ascii + "\n";
  }
  return result;
};
const tagDump = ({
  bytes
}) => hexDump(bytes);
const textRanges = (ranges) => {
  let result = "";
  let i;
  for (i = 0; i < ranges.length; i++) {
    result += textRange(ranges, i) + " ";
  }
  return result;
};
var utils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage,
  initSegmentId,
  segmentKeyId,
  hexDump,
  tagDump,
  textRanges
});
const SEGMENT_END_FUDGE_PERCENT = 0.25;
const playerTimeToProgramTime = (playerTime, segment) => {
  if (!segment.dateTimeObject) {
    return null;
  }
  const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
  const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
  const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
  const offsetFromSegmentStart = playerTime - startOfSegment;
  return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
};
const originalSegmentVideoDuration = (videoTimingInfo) => {
  return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
};
const findSegmentForProgramTime = (programTime, playlist) => {
  let dateTimeObject;
  try {
    dateTimeObject = new Date(programTime);
  } catch (e) {
    return null;
  }
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  let segment = playlist.segments[0];
  if (dateTimeObject < new Date(segment.dateTimeObject)) {
    return null;
  }
  for (let i = 0; i < playlist.segments.length - 1; i++) {
    segment = playlist.segments[i];
    const nextSegmentStart = new Date(playlist.segments[i + 1].dateTimeObject);
    if (dateTimeObject < nextSegmentStart) {
      break;
    }
  }
  const lastSegment = playlist.segments[playlist.segments.length - 1];
  const lastSegmentStart = lastSegment.dateTimeObject;
  const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
  const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
  if (dateTimeObject > lastSegmentEnd) {
    return null;
  }
  if (dateTimeObject > new Date(lastSegmentStart)) {
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
const findSegmentForPlayerTime = (time, playlist) => {
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  let segmentEnd = 0;
  let segment;
  for (let i = 0; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
    if (time <= segmentEnd) {
      break;
    }
  }
  const lastSegment = playlist.segments[playlist.segments.length - 1];
  if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {
    return null;
  }
  if (time > segmentEnd) {
    if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
      return null;
    }
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {
  let segmentDateTime;
  let programDateTime;
  try {
    segmentDateTime = new Date(comparisonTimeStamp);
    programDateTime = new Date(programTime);
  } catch (e) {
  }
  const segmentTimeEpoch = segmentDateTime.getTime();
  const programTimeEpoch = programDateTime.getTime();
  return (programTimeEpoch - segmentTimeEpoch) / 1e3;
};
const verifyProgramDateTimeTags = (playlist) => {
  if (!playlist.segments || playlist.segments.length === 0) {
    return false;
  }
  for (let i = 0; i < playlist.segments.length; i++) {
    const segment = playlist.segments[i];
    if (!segment.dateTimeObject) {
      return false;
    }
  }
  return true;
};
const getProgramTime = ({
  playlist,
  time = void 0,
  callback
}) => {
  if (!callback) {
    throw new Error("getProgramTime: callback must be provided");
  }
  if (!playlist || time === void 0) {
    return callback({
      message: "getProgramTime: playlist and time must be provided"
    });
  }
  const matchedSegment = findSegmentForPlayerTime(time, playlist);
  if (!matchedSegment) {
    return callback({
      message: "valid programTime was not found"
    });
  }
  if (matchedSegment.type === "estimate") {
    return callback({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: matchedSegment.estimatedStart
    });
  }
  const programTimeObject = {
    mediaSeconds: time
  };
  const programTime = playerTimeToProgramTime(time, matchedSegment.segment);
  if (programTime) {
    programTimeObject.programDateTime = programTime.toISOString();
  }
  return callback(null, programTimeObject);
};
const seekToProgramTime = ({
  programTime,
  playlist,
  retryCount = 2,
  seekTo,
  pauseAfterSeek = true,
  tech,
  callback
}) => {
  if (!callback) {
    throw new Error("seekToProgramTime: callback must be provided");
  }
  if (typeof programTime === "undefined" || !playlist || !seekTo) {
    return callback({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  }
  if (!playlist.endList && !tech.hasStarted_) {
    return callback({
      message: "player must be playing a live stream to start buffering"
    });
  }
  if (!verifyProgramDateTimeTags(playlist)) {
    return callback({
      message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
    });
  }
  const matchedSegment = findSegmentForProgramTime(programTime, playlist);
  if (!matchedSegment) {
    return callback({
      message: `${programTime} was not found in the stream`
    });
  }
  const segment = matchedSegment.segment;
  const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
  if (matchedSegment.type === "estimate") {
    if (retryCount === 0) {
      return callback({
        message: `${programTime} is not buffered yet. Try again`
      });
    }
    seekTo(matchedSegment.estimatedStart + mediaOffset);
    tech.one("seeked", () => {
      seekToProgramTime({
        programTime,
        playlist,
        retryCount: retryCount - 1,
        seekTo,
        pauseAfterSeek,
        tech,
        callback
      });
    });
    return;
  }
  const seekToTime = segment.start + mediaOffset;
  const seekedCallback = () => {
    return callback(null, tech.currentTime());
  };
  tech.one("seeked", seekedCallback);
  if (pauseAfterSeek) {
    tech.pause();
  }
  seekTo(seekToTime);
};
const callbackOnCompleted = (request, cb) => {
  if (request.readyState === 4) {
    return cb();
  }
  return;
};
const containerRequest = (uri, xhr, cb, requestType) => {
  let bytes = [];
  let id3Offset;
  let finished = false;
  const endRequestAndCallback = function(err, req, type, _bytes) {
    req.abort();
    finished = true;
    return cb(err, req, type, _bytes);
  };
  const progressListener = function(error, request2) {
    if (finished) {
      return;
    }
    if (error) {
      error.metadata = getStreamingNetworkErrorMetadata({
        requestType,
        request: request2,
        error
      });
      return endRequestAndCallback(error, request2, "", bytes);
    }
    const newPart = request2.responseText.substring(bytes && bytes.byteLength || 0, request2.responseText.length);
    bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
    id3Offset = id3Offset || getId3Offset(bytes);
    if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
      return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
    }
    const type = detectContainerForBytes(bytes);
    if (type === "ts" && bytes.length < 188) {
      return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
    }
    if (!type && bytes.length < 376) {
      return callbackOnCompleted(request2, () => endRequestAndCallback(error, request2, "", bytes));
    }
    return endRequestAndCallback(null, request2, type, bytes);
  };
  const options = {
    uri,
    beforeSend(request2) {
      request2.overrideMimeType("text/plain; charset=x-user-defined");
      request2.addEventListener("progress", function({
        total,
        loaded
      }) {
        return callbackWrapper(request2, null, {
          statusCode: request2.status
        }, progressListener);
      });
    }
  };
  const request = xhr(options, function(error, response) {
    return callbackWrapper(request, error, response, progressListener);
  });
  return request;
};
const {
  EventTarget
} = videojs$2;
const dashPlaylistUnchanged = function(a, b) {
  if (!isPlaylistUnchanged(a, b)) {
    return false;
  }
  if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {
    return false;
  } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {
    return false;
  }
  if (a.segments && !b.segments || !a.segments && b.segments) {
    return false;
  }
  if (!a.segments && !b.segments) {
    return true;
  }
  for (let i = 0; i < a.segments.length; i++) {
    const aSegment = a.segments[i];
    const bSegment = b.segments[i];
    if (aSegment.uri !== bSegment.uri) {
      return false;
    }
    if (!aSegment.byterange && !bSegment.byterange) {
      continue;
    }
    const aByterange = aSegment.byterange;
    const bByterange = bSegment.byterange;
    if (aByterange && !bByterange || !aByterange && bByterange) {
      return false;
    }
    if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
      return false;
    }
  }
  return true;
};
const dashGroupId = (type, group, label, playlist) => {
  const playlistId = playlist.attributes.NAME || label;
  return `placeholder-uri-${type}-${group}-${playlistId}`;
};
const parseMainXml = ({
  mainXml,
  srcUrl,
  clientOffset,
  sidxMapping,
  previousManifest
}) => {
  const manifest = parse(mainXml, {
    manifestUri: srcUrl,
    clientOffset,
    sidxMapping,
    previousManifest
  });
  addPropertiesToMain(manifest, srcUrl, dashGroupId);
  return manifest;
};
const removeOldMediaGroupLabels = (update2, newMain) => {
  forEachMediaGroup2(update2, (properties, type, group, label) => {
    if (!(label in newMain.mediaGroups[type][group])) {
      delete update2.mediaGroups[type][group][label];
    }
  });
};
const updateMain = (oldMain, newMain, sidxMapping) => {
  let noChanges = true;
  let update2 = merge(oldMain, {
    // These are top level properties that can be updated
    duration: newMain.duration,
    minimumUpdatePeriod: newMain.minimumUpdatePeriod,
    timelineStarts: newMain.timelineStarts
  });
  for (let i = 0; i < newMain.playlists.length; i++) {
    const playlist = newMain.playlists[i];
    if (playlist.sidx) {
      const sidxKey = generateSidxKey(playlist.sidx);
      if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
        addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
      }
    }
    const playlistUpdate = updateMain$1(update2, playlist, dashPlaylistUnchanged);
    if (playlistUpdate) {
      update2 = playlistUpdate;
      noChanges = false;
    }
  }
  forEachMediaGroup2(newMain, (properties, type, group, label) => {
    if (properties.playlists && properties.playlists.length) {
      const id = properties.playlists[0].id;
      const playlistUpdate = updateMain$1(update2, properties.playlists[0], dashPlaylistUnchanged);
      if (playlistUpdate) {
        update2 = playlistUpdate;
        if (!(label in update2.mediaGroups[type][group])) {
          update2.mediaGroups[type][group][label] = properties;
        }
        update2.mediaGroups[type][group][label].playlists[0] = update2.playlists[id];
        noChanges = false;
      }
    }
  });
  removeOldMediaGroupLabels(update2, newMain);
  if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {
    noChanges = false;
  }
  if (noChanges) {
    return null;
  }
  return update2;
};
const equivalentSidx = (a, b) => {
  const neitherMap = Boolean(!a.map && !b.map);
  const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
  return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
};
const compareSidxEntry = (playlists, oldSidxMapping) => {
  const newSidxMapping = {};
  for (const id in playlists) {
    const playlist = playlists[id];
    const currentSidxInfo = playlist.sidx;
    if (currentSidxInfo) {
      const key = generateSidxKey(currentSidxInfo);
      if (!oldSidxMapping[key]) {
        break;
      }
      const savedSidxInfo = oldSidxMapping[key].sidxInfo;
      if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
        newSidxMapping[key] = oldSidxMapping[key];
      }
    }
  }
  return newSidxMapping;
};
const filterChangedSidxMappings = (main2, oldSidxMapping) => {
  const videoSidx = compareSidxEntry(main2.playlists, oldSidxMapping);
  let mediaGroupSidx = videoSidx;
  forEachMediaGroup2(main2, (properties, mediaType, groupKey, labelKey) => {
    if (properties.playlists && properties.playlists.length) {
      const playlists = properties.playlists;
      mediaGroupSidx = merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
    }
  });
  return mediaGroupSidx;
};
class DashPlaylistLoader extends EventTarget {
  // DashPlaylistLoader must accept either a src url or a playlist because subsequent
  // playlist loader setups from media groups will expect to be able to pass a playlist
  // (since there aren't external URLs to media playlists with DASH)
  constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {
    super();
    this.mainPlaylistLoader_ = mainPlaylistLoader || this;
    if (!mainPlaylistLoader) {
      this.isMain_ = true;
    }
    const {
      withCredentials = false
    } = options;
    this.vhs_ = vhs;
    this.withCredentials = withCredentials;
    this.addMetadataToTextTrack = options.addMetadataToTextTrack;
    if (!srcUrlOrPlaylist) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    this.on("minimumUpdatePeriod", () => {
      this.refreshXml_();
    });
    this.on("mediaupdatetimeout", () => {
      this.refreshMedia_(this.media().id);
    });
    this.state = "HAVE_NOTHING";
    this.loadedPlaylists_ = {};
    this.logger_ = logger("DashPlaylistLoader");
    if (this.isMain_) {
      this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
      this.mainPlaylistLoader_.sidxMapping_ = {};
    } else {
      this.childPlaylist_ = srcUrlOrPlaylist;
    }
  }
  requestErrored_(err, request, startingState) {
    if (!this.request) {
      return true;
    }
    this.request = null;
    if (err) {
      this.error = typeof err === "object" && !(err instanceof Error) ? err : {
        status: request.status,
        message: "DASH request error at URL: " + request.uri,
        response: request.response,
        // MEDIA_ERR_NETWORK
        code: 2,
        metadata: err.metadata
      };
      if (startingState) {
        this.state = startingState;
      }
      this.trigger("error");
      return true;
    }
  }
  /**
   * Verify that the container of the sidx segment can be parsed
   * and if it can, get and parse that segment.
   */
  addSidxSegments_(playlist, startingState, cb) {
    const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
    if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {
      this.mediaRequest_ = window$1$1.setTimeout(() => cb(false), 0);
      return;
    }
    const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);
    const fin = (err, request) => {
      if (this.requestErrored_(err, request, startingState)) {
        return;
      }
      const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;
      const {
        requestType
      } = request;
      let sidx;
      try {
        sidx = parseSidx$1(toUint8(request.response).subarray(8));
      } catch (e) {
        e.metadata = getStreamingNetworkErrorMetadata({
          requestType,
          request,
          parseFailure: true
        });
        this.requestErrored_(e, request, startingState);
        return;
      }
      sidxMapping[sidxKey] = {
        sidxInfo: playlist.sidx,
        sidx
      };
      addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
      return cb(true);
    };
    const REQUEST_TYPE = "dash-sidx";
    this.request = containerRequest(uri, this.vhs_.xhr, (err, request, container, bytes) => {
      if (err) {
        return fin(err, request);
      }
      if (!container || container !== "mp4") {
        const sidxContainer = container || "unknown";
        return fin({
          status: request.status,
          message: `Unsupported ${sidxContainer} container type for sidx segment at URL: ${uri}`,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist,
          internal: true,
          playlistExclusionDuration: Infinity,
          // MEDIA_ERR_NETWORK
          code: 2
        }, request);
      }
      const {
        offset: offset2,
        length: length2
      } = playlist.sidx.byterange;
      if (bytes.length >= length2 + offset2) {
        return fin(err, {
          response: bytes.subarray(offset2, offset2 + length2),
          status: request.status,
          uri: request.uri
        });
      }
      this.request = this.vhs_.xhr({
        uri,
        responseType: "arraybuffer",
        requestType: "dash-sidx",
        headers: segmentXhrHeaders({
          byterange: playlist.sidx.byterange
        })
      }, fin);
    }, REQUEST_TYPE);
  }
  dispose() {
    this.trigger("dispose");
    this.stopRequest();
    this.loadedPlaylists_ = {};
    window$1$1.clearTimeout(this.minimumUpdatePeriodTimeout_);
    window$1$1.clearTimeout(this.mediaRequest_);
    window$1$1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    this.mediaRequest_ = null;
    this.minimumUpdatePeriodTimeout_ = null;
    if (this.mainPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
      this.mainPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.off();
  }
  hasPendingRequest() {
    return this.request || this.mediaRequest_;
  }
  stopRequest() {
    if (this.request) {
      const oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  }
  media(playlist) {
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    const startingState = this.state;
    if (typeof playlist === "string") {
      if (!this.mainPlaylistLoader_.main.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.mainPlaylistLoader_.main.playlists[playlist];
    }
    const mediaChange = !this.media_ || playlist.id !== this.media_.id;
    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        this.trigger("mediachange");
      }
      return;
    }
    if (!mediaChange) {
      return;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.addSidxSegments_(playlist, startingState, (sidxChanged) => {
      this.haveMetadata({
        startingState,
        playlist
      });
    });
  }
  haveMetadata({
    startingState,
    playlist
  }) {
    this.state = "HAVE_METADATA";
    this.loadedPlaylists_[playlist.id] = playlist;
    this.mediaRequest_ = null;
    this.refreshMedia_(playlist.id);
    if (startingState === "HAVE_MAIN_MANIFEST") {
      this.trigger("loadedmetadata");
    } else {
      this.trigger("mediachange");
    }
  }
  pause() {
    if (this.mainPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
      this.mainPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.stopRequest();
    window$1$1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    if (this.isMain_) {
      window$1$1.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);
      this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
    }
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
  }
  load(isFinalRendition) {
    window$1$1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    const media = this.media();
    if (isFinalRendition) {
      const delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = window$1$1.setTimeout(() => this.load(), delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {
        this.trigger("minimumUpdatePeriod");
        this.updateMinimumUpdatePeriodTimeout_();
      }
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  }
  start() {
    this.started = true;
    if (!this.isMain_) {
      this.mediaRequest_ = window$1$1.setTimeout(() => this.haveMain_(), 0);
      return;
    }
    this.requestMain_((req, mainChanged) => {
      this.haveMain_();
      if (!this.hasPendingRequest() && !this.media_) {
        this.media(this.mainPlaylistLoader_.main.playlists[0]);
      }
    });
  }
  requestMain_(cb) {
    const metadata = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestrequeststart",
      metadata
    });
    this.request = this.vhs_.xhr({
      uri: this.mainPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials,
      requestType: "dash-manifest"
    }, (error, req) => {
      if (error) {
        const {
          requestType
        } = req;
        error.metadata = getStreamingNetworkErrorMetadata({
          requestType,
          request: req,
          error
        });
      }
      if (this.requestErrored_(error, req)) {
        if (this.state === "HAVE_NOTHING") {
          this.started = false;
        }
        return;
      }
      this.trigger({
        type: "manifestrequestcomplete",
        metadata
      });
      const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;
      this.mainPlaylistLoader_.mainXml_ = req.responseText;
      if (req.responseHeaders && req.responseHeaders.date) {
        this.mainLoaded_ = Date.parse(req.responseHeaders.date);
      } else {
        this.mainLoaded_ = Date.now();
      }
      this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);
      if (mainChanged) {
        this.handleMain_();
        this.syncClientServerClock_(() => {
          return cb(req, mainChanged);
        });
        return;
      }
      return cb(req, mainChanged);
    });
  }
  /**
   * Parses the main xml for UTCTiming node to sync the client clock to the server
   * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.
   *
   * @param {Function} done
   *        Function to call when clock sync has completed
   */
  syncClientServerClock_(done) {
    const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_);
    if (utcTiming === null) {
      this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
      return done();
    }
    if (utcTiming.method === "DIRECT") {
      this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
      return done();
    }
    this.request = this.vhs_.xhr({
      uri: resolveUrl22(this.mainPlaylistLoader_.srcUrl, utcTiming.value),
      method: utcTiming.method,
      withCredentials: this.withCredentials,
      requestType: "dash-clock-sync"
    }, (error, req) => {
      if (!this.request) {
        return;
      }
      if (error) {
        const {
          requestType
        } = req;
        this.error.metadata = getStreamingNetworkErrorMetadata({
          requestType,
          request: req,
          error
        });
        this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
        return done();
      }
      let serverTime;
      if (utcTiming.method === "HEAD") {
        if (!req.responseHeaders || !req.responseHeaders.date) {
          serverTime = this.mainLoaded_;
        } else {
          serverTime = Date.parse(req.responseHeaders.date);
        }
      } else {
        serverTime = Date.parse(req.responseText);
      }
      this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();
      done();
    });
  }
  haveMain_() {
    this.state = "HAVE_MAIN_MANIFEST";
    if (this.isMain_) {
      this.trigger("loadedplaylist");
    } else if (!this.media_) {
      this.media(this.childPlaylist_);
    }
  }
  handleMain_() {
    this.mediaRequest_ = null;
    const oldMain = this.mainPlaylistLoader_.main;
    const metadata = {
      manifestInfo: {
        uri: this.mainPlaylistLoader_.srcUrl
      }
    };
    this.trigger({
      type: "manifestparsestart",
      metadata
    });
    let newMain;
    try {
      newMain = parseMainXml({
        mainXml: this.mainPlaylistLoader_.mainXml_,
        srcUrl: this.mainPlaylistLoader_.srcUrl,
        clientOffset: this.mainPlaylistLoader_.clientOffset_,
        sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
        previousManifest: oldMain
      });
    } catch (error) {
      this.error = error;
      this.error.metadata = {
        errorType: videojs$2.Error.StreamingDashManifestParserError,
        error
      };
      this.trigger("error");
    }
    if (oldMain) {
      newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);
    }
    this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;
    const location2 = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
    if (location2 && location2 !== this.mainPlaylistLoader_.srcUrl) {
      this.mainPlaylistLoader_.srcUrl = location2;
    }
    if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {
      this.updateMinimumUpdatePeriodTimeout_();
    }
    this.addEventStreamToMetadataTrack_(newMain);
    if (newMain) {
      const {
        duration: duration2,
        endList
      } = newMain;
      const renditions = [];
      newMain.playlists.forEach((playlist) => {
        renditions.push({
          id: playlist.id,
          bandwidth: playlist.attributes.BANDWIDTH,
          resolution: playlist.attributes.RESOLUTION,
          codecs: playlist.attributes.CODECS
        });
      });
      const parsedManifest = {
        duration: duration2,
        isLive: !endList,
        renditions
      };
      metadata.parsedManifest = parsedManifest;
      this.trigger({
        type: "manifestparsecomplete",
        metadata
      });
    }
    return Boolean(newMain);
  }
  updateMinimumUpdatePeriodTimeout_() {
    const mpl = this.mainPlaylistLoader_;
    if (mpl.createMupOnMedia_) {
      mpl.off("loadedmetadata", mpl.createMupOnMedia_);
      mpl.createMupOnMedia_ = null;
    }
    if (mpl.minimumUpdatePeriodTimeout_) {
      window$1$1.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
      mpl.minimumUpdatePeriodTimeout_ = null;
    }
    let mup = mpl.main && mpl.main.minimumUpdatePeriod;
    if (mup === 0) {
      if (mpl.media()) {
        mup = mpl.media().targetDuration * 1e3;
      } else {
        mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
        mpl.one("loadedmetadata", mpl.createMupOnMedia_);
      }
    }
    if (typeof mup !== "number" || mup <= 0) {
      if (mup < 0) {
        this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);
      }
      return;
    }
    this.createMUPTimeout_(mup);
  }
  createMUPTimeout_(mup) {
    const mpl = this.mainPlaylistLoader_;
    mpl.minimumUpdatePeriodTimeout_ = window$1$1.setTimeout(() => {
      mpl.minimumUpdatePeriodTimeout_ = null;
      mpl.trigger("minimumUpdatePeriod");
      mpl.createMUPTimeout_(mup);
    }, mup);
  }
  /**
   * Sends request to refresh the main xml and updates the parsed main manifest
   */
  refreshXml_() {
    this.requestMain_((req, mainChanged) => {
      if (!mainChanged) {
        return;
      }
      if (this.media_) {
        this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];
      }
      this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);
      this.addSidxSegments_(this.media(), this.state, (sidxChanged) => {
        this.refreshMedia_(this.media().id);
      });
    });
  }
  /**
   * Refreshes the media playlist by re-parsing the main xml and updating playlist
   * references. If this is an alternate loader, the updated parsed manifest is retrieved
   * from the main loader.
   */
  refreshMedia_(mediaID) {
    if (!mediaID) {
      throw new Error("refreshMedia_ must take a media id");
    }
    if (this.media_ && this.isMain_) {
      this.handleMain_();
    }
    const playlists = this.mainPlaylistLoader_.main.playlists;
    const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
    if (mediaChanged) {
      this.media_ = playlists[mediaID];
    } else {
      this.trigger("playlistunchanged");
    }
    if (!this.mediaUpdateTimeout) {
      const createMediaUpdateTimeout = () => {
        if (this.media().endList) {
          return;
        }
        this.mediaUpdateTimeout = window$1$1.setTimeout(() => {
          this.trigger("mediaupdatetimeout");
          createMediaUpdateTimeout();
        }, refreshDelay(this.media(), Boolean(mediaChanged)));
      };
      createMediaUpdateTimeout();
    }
    this.trigger("loadedplaylist");
  }
  /**
   * Takes eventstream data from a parsed DASH manifest and adds it to the metadata text track.
   *
   * @param {manifest} newMain the newly parsed manifest
   */
  addEventStreamToMetadataTrack_(newMain) {
    if (newMain && this.mainPlaylistLoader_.main.eventStream) {
      const metadataArray = this.mainPlaylistLoader_.main.eventStream.map((eventStreamNode) => {
        return {
          cueTime: eventStreamNode.start,
          frames: [{
            data: eventStreamNode.messageData
          }]
        };
      });
      this.addMetadataToTextTrack("EventStream", metadataArray, this.mainPlaylistLoader_.main.duration);
    }
  }
  /**
   * Returns the key ID set from a playlist
   *
   * @param {playlist} playlist to fetch the key ID set from.
   * @return a Set of 32 digit hex strings that represent the unique keyIds for that playlist.
   */
  getKeyIdSet(playlist) {
    if (playlist.contentProtection) {
      const keyIds = /* @__PURE__ */ new Set();
      for (const keysystem in playlist.contentProtection) {
        const defaultKID = playlist.contentProtection[keysystem].attributes["cenc:default_KID"];
        if (defaultKID) {
          keyIds.add(defaultKID.replace(/-/g, "").toLowerCase());
        }
      }
      return keyIds;
    }
  }
}
var Config = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
const stringToArrayBuffer = (string) => {
  const view = new Uint8Array(new ArrayBuffer(string.length));
  for (let i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view.buffer;
};
const browserWorkerPolyFill = function(workerObj) {
  workerObj.on = workerObj.addEventListener;
  workerObj.off = workerObj.removeEventListener;
  return workerObj;
};
const createObjectURL = function(str) {
  try {
    return URL.createObjectURL(new Blob([str], {
      type: "application/javascript"
    }));
  } catch (e) {
    const blob = new BlobBuilder();
    blob.append(str);
    return URL.createObjectURL(blob.getBlob());
  }
};
const factory = function(code) {
  return function() {
    const objectUrl = createObjectURL(code);
    const worker = browserWorkerPolyFill(new Worker(objectUrl));
    worker.objURL = objectUrl;
    const terminate = worker.terminate;
    worker.on = worker.addEventListener;
    worker.off = worker.removeEventListener;
    worker.terminate = function() {
      URL.revokeObjectURL(objectUrl);
      return terminate.call(this);
    };
    return worker;
  };
};
const transform = function(code) {
  return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};
browserWorkerPolyFill(self);
` + code;
};
const getWorkerString = function(fn2) {
  return fn2.toString().replace(/^function.+?{/, "").slice(0, -1);
};
const workerCode$1 = transform(getWorkerString(function() {
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var Stream$8 = function() {
    this.init = function() {
      var listeners = {};
      this.on = function(type2, listener) {
        if (!listeners[type2]) {
          listeners[type2] = [];
        }
        listeners[type2] = listeners[type2].concat(listener);
      };
      this.off = function(type2, listener) {
        var index;
        if (!listeners[type2]) {
          return false;
        }
        index = listeners[type2].indexOf(listener);
        listeners[type2] = listeners[type2].slice();
        listeners[type2].splice(index, 1);
        return index > -1;
      };
      this.trigger = function(type2) {
        var callbacks, i, length2, args;
        callbacks = listeners[type2];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          length2 = callbacks.length;
          for (i = 0; i < length2; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          args = [];
          i = arguments.length;
          for (i = 1; i < arguments.length; ++i) {
            args.push(arguments[i]);
          }
          length2 = callbacks.length;
          for (i = 0; i < length2; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      };
      this.dispose = function() {
        listeners = {};
      };
    };
  };
  Stream$8.prototype.pipe = function(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
    this.on("done", function(flushSource) {
      destination.flush(flushSource);
    });
    this.on("partialdone", function(flushSource) {
      destination.partialFlush(flushSource);
    });
    this.on("endedtimeline", function(flushSource) {
      destination.endTimeline(flushSource);
    });
    this.on("reset", function(flushSource) {
      destination.reset(flushSource);
    });
    return destination;
  };
  Stream$8.prototype.push = function(data) {
    this.trigger("data", data);
  };
  Stream$8.prototype.flush = function(flushSource) {
    this.trigger("done", flushSource);
  };
  Stream$8.prototype.partialFlush = function(flushSource) {
    this.trigger("partialdone", flushSource);
  };
  Stream$8.prototype.endTimeline = function(flushSource) {
    this.trigger("endedtimeline", flushSource);
  };
  Stream$8.prototype.reset = function(flushSource) {
    this.trigger("reset", flushSource);
  };
  var stream = Stream$8;
  var MAX_UINT32$1 = Math.pow(2, 32);
  var getUint64$3 = function(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value2;
    if (dv.getBigUint64) {
      value2 = dv.getBigUint64(0);
      if (value2 < Number.MAX_SAFE_INTEGER) {
        return Number(value2);
      }
      return value2;
    }
    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
  };
  var numbers2 = {
    getUint64: getUint64$3,
    MAX_UINT32: MAX_UINT32$1
  };
  var MAX_UINT322 = numbers2.MAX_UINT32;
  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
  (function() {
    var i;
    types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    };
    if (typeof Uint8Array === "undefined") {
      return;
    }
    for (i in types) {
      if (types.hasOwnProperty(i)) {
        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
    AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
    VIDEO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]);
    AUDIO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    HDLR_TYPES = {
      video: VIDEO_HDLR,
      audio: AUDIO_HDLR
    };
    DREF = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]);
    SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance, 0 means centered
      0,
      0
      // reserved
    ]);
    STCO = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    STSC = STCO;
    STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]);
    STTS = STCO;
    VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]);
  })();
  box = function(type2) {
    var payload = [], size = 0, i, result, view;
    for (i = 1; i < arguments.length; i++) {
      payload.push(arguments[i]);
    }
    i = payload.length;
    while (i--) {
      size += payload[i].byteLength;
    }
    result = new Uint8Array(size + 8);
    view = new DataView(result.buffer, result.byteOffset, result.byteLength);
    view.setUint32(0, result.byteLength);
    result.set(type2, 4);
    for (i = 0, size = 8; i < payload.length; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };
  dinf = function() {
    return box(types.dinf, box(types.dref, DREF));
  };
  esds = function(track) {
    return box(types.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
      track.samplingfrequencyindex << 7 | track.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  };
  ftyp = function() {
    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
  };
  hdlr = function(type2) {
    return box(types.hdlr, HDLR_TYPES[type2]);
  };
  mdat = function(data) {
    return box(types.mdat, data);
  };
  mdhd = function(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      track.duration >>> 24 & 255,
      track.duration >>> 16 & 255,
      track.duration >>> 8 & 255,
      track.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    if (track.samplerate) {
      result[12] = track.samplerate >>> 24 & 255;
      result[13] = track.samplerate >>> 16 & 255;
      result[14] = track.samplerate >>> 8 & 255;
      result[15] = track.samplerate & 255;
    }
    return box(types.mdhd, result);
  };
  mdia = function(track) {
    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
  };
  mfhd = function(sequenceNumber) {
    return box(types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (sequenceNumber & 4278190080) >> 24,
      (sequenceNumber & 16711680) >> 16,
      (sequenceNumber & 65280) >> 8,
      sequenceNumber & 255
      // sequence_number
    ]));
  };
  minf = function(track) {
    return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
  };
  moof = function(sequenceNumber, tracks) {
    var trackFragments = [], i = tracks.length;
    while (i--) {
      trackFragments[i] = traf(tracks[i]);
    }
    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
  };
  moov = function(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trak(tracks[i]);
    }
    return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
  };
  mvex = function(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trex(tracks[i]);
    }
    return box.apply(null, [types.mvex].concat(boxes));
  };
  mvhd = function(duration2) {
    var bytes = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (duration2 & 4278190080) >> 24,
      (duration2 & 16711680) >> 16,
      (duration2 & 65280) >> 8,
      duration2 & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return box(types.mvhd, bytes);
  };
  sdtp = function(track) {
    var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return box(types.sdtp, bytes);
  };
  stbl = function(track) {
    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
  };
  (function() {
    var videoSample, audioSample;
    stsd = function(track) {
      return box(types.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), track.type === "video" ? videoSample(track) : audioSample(track));
    };
    videoSample = function(track) {
      var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i, avc1Box;
      for (i = 0; i < sps.length; i++) {
        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
        sequenceParameterSets.push(sps[i].byteLength & 255);
        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
      }
      for (i = 0; i < pps.length; i++) {
        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
        pictureParameterSets.push(pps[i].byteLength & 255);
        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
      }
      avc1Box = [types.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (track.width & 65280) >> 8,
        track.width & 255,
        // width
        (track.height & 65280) >> 8,
        track.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), box(types.avcC, new Uint8Array([
        1,
        // configurationVersion
        track.profileIdc,
        // AVCProfileIndication
        track.profileCompatibility,
        // profile_compatibility
        track.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [sps.length],
        // numOfSequenceParameterSets
        sequenceParameterSets,
        // "SPS"
        [pps.length],
        // numOfPictureParameterSets
        pictureParameterSets
        // "PPS"
      ))), box(types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))];
      if (track.sarRatio) {
        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
      }
      return box.apply(null, avc1Box);
    };
    audioSample = function(track) {
      return box(types.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (track.channelcount & 65280) >> 8,
        track.channelcount & 255,
        // channelcount
        (track.samplesize & 65280) >> 8,
        track.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (track.samplerate & 65280) >> 8,
        track.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), esds(track));
    };
  })();
  tkhd = function(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (track.duration & 4278190080) >> 24,
      (track.duration & 16711680) >> 16,
      (track.duration & 65280) >> 8,
      track.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (track.width & 65280) >> 8,
      track.width & 255,
      0,
      0,
      // width
      (track.height & 65280) >> 8,
      track.height & 255,
      0,
      0
      // height
    ]);
    return box(types.tkhd, result);
  };
  traf = function(track) {
    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
    trackFragmentHeader = box(types.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ]));
    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT322);
    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT322);
    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      upperWordBaseMediaDecodeTime >>> 24 & 255,
      upperWordBaseMediaDecodeTime >>> 16 & 255,
      upperWordBaseMediaDecodeTime >>> 8 & 255,
      upperWordBaseMediaDecodeTime & 255,
      lowerWordBaseMediaDecodeTime >>> 24 & 255,
      lowerWordBaseMediaDecodeTime >>> 16 & 255,
      lowerWordBaseMediaDecodeTime >>> 8 & 255,
      lowerWordBaseMediaDecodeTime & 255
    ]));
    dataOffset = 32 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8;
    if (track.type === "audio") {
      trackFragmentRun = trun$1(track, dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
    }
    sampleDependencyTable = sdtp(track);
    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
  };
  trak = function(track) {
    track.duration = track.duration || 4294967295;
    return box(types.trak, tkhd(track), mdia(track));
  };
  trex = function(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    if (track.type !== "video") {
      result[result.length - 1] = 0;
    }
    return box(types.trex, result);
  };
  (function() {
    var audioTrun, videoTrun, trunHeader;
    trunHeader = function(samples, offset2) {
      var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
      if (samples.length) {
        if (samples[0].duration !== void 0) {
          durationPresent = 1;
        }
        if (samples[0].size !== void 0) {
          sizePresent = 2;
        }
        if (samples[0].flags !== void 0) {
          flagsPresent = 4;
        }
        if (samples[0].compositionTimeOffset !== void 0) {
          compositionTimeOffset = 8;
        }
      }
      return [
        0,
        // version 0
        0,
        durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
        1,
        // flags
        (samples.length & 4278190080) >>> 24,
        (samples.length & 16711680) >>> 16,
        (samples.length & 65280) >>> 8,
        samples.length & 255,
        // sample_count
        (offset2 & 4278190080) >>> 24,
        (offset2 & 16711680) >>> 16,
        (offset2 & 65280) >>> 8,
        offset2 & 255
        // data_offset
      ];
    };
    videoTrun = function(track, offset2) {
      var bytesOffest, bytes, header, samples, sample, i;
      samples = track.samples || [];
      offset2 += 8 + 12 + 16 * samples.length;
      header = trunHeader(samples, offset2);
      bytes = new Uint8Array(header.length + samples.length * 16);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
      }
      return box(types.trun, bytes);
    };
    audioTrun = function(track, offset2) {
      var bytes, bytesOffest, header, samples, sample, i;
      samples = track.samples || [];
      offset2 += 8 + 12 + 8 * samples.length;
      header = trunHeader(samples, offset2);
      bytes = new Uint8Array(header.length + samples.length * 8);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
      }
      return box(types.trun, bytes);
    };
    trun$1 = function(track, offset2) {
      if (track.type === "audio") {
        return audioTrun(track, offset2);
      }
      return videoTrun(track, offset2);
    };
  })();
  var mp4Generator = {
    ftyp,
    mdat,
    moof,
    moov,
    initSegment: function(tracks) {
      var fileType = ftyp(), movie = moov(tracks), result;
      result = new Uint8Array(fileType.byteLength + movie.byteLength);
      result.set(fileType);
      result.set(movie, fileType.byteLength);
      return result;
    }
  };
  var groupNalsIntoFrames = function(nalUnits) {
    var i, currentNal, currentFrame = [], frames = [];
    frames.byteLength = 0;
    frames.nalCount = 0;
    frames.duration = 0;
    currentFrame.byteLength = 0;
    for (i = 0; i < nalUnits.length; i++) {
      currentNal = nalUnits[i];
      if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
        if (currentFrame.length) {
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          frames.byteLength += currentFrame.byteLength;
          frames.nalCount += currentFrame.length;
          frames.duration += currentFrame.duration;
          frames.push(currentFrame);
        }
        currentFrame = [currentNal];
        currentFrame.byteLength = currentNal.data.byteLength;
        currentFrame.pts = currentNal.pts;
        currentFrame.dts = currentNal.dts;
      } else {
        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
          currentFrame.keyFrame = true;
        }
        currentFrame.duration = currentNal.dts - currentFrame.dts;
        currentFrame.byteLength += currentNal.data.byteLength;
        currentFrame.push(currentNal);
      }
    }
    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
      currentFrame.duration = frames[frames.length - 1].duration;
    }
    frames.byteLength += currentFrame.byteLength;
    frames.nalCount += currentFrame.length;
    frames.duration += currentFrame.duration;
    frames.push(currentFrame);
    return frames;
  };
  var groupFramesIntoGops = function(frames) {
    var i, currentFrame, currentGop = [], gops = [];
    currentGop.byteLength = 0;
    currentGop.nalCount = 0;
    currentGop.duration = 0;
    currentGop.pts = frames[0].pts;
    currentGop.dts = frames[0].dts;
    gops.byteLength = 0;
    gops.nalCount = 0;
    gops.duration = 0;
    gops.pts = frames[0].pts;
    gops.dts = frames[0].dts;
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      if (currentFrame.keyFrame) {
        if (currentGop.length) {
          gops.push(currentGop);
          gops.byteLength += currentGop.byteLength;
          gops.nalCount += currentGop.nalCount;
          gops.duration += currentGop.duration;
        }
        currentGop = [currentFrame];
        currentGop.nalCount = currentFrame.length;
        currentGop.byteLength = currentFrame.byteLength;
        currentGop.pts = currentFrame.pts;
        currentGop.dts = currentFrame.dts;
        currentGop.duration = currentFrame.duration;
      } else {
        currentGop.duration += currentFrame.duration;
        currentGop.nalCount += currentFrame.length;
        currentGop.byteLength += currentFrame.byteLength;
        currentGop.push(currentFrame);
      }
    }
    if (gops.length && currentGop.duration <= 0) {
      currentGop.duration = gops[gops.length - 1].duration;
    }
    gops.byteLength += currentGop.byteLength;
    gops.nalCount += currentGop.nalCount;
    gops.duration += currentGop.duration;
    gops.push(currentGop);
    return gops;
  };
  var extendFirstKeyFrame = function(gops) {
    var currentGop;
    if (!gops[0][0].keyFrame && gops.length > 1) {
      currentGop = gops.shift();
      gops.byteLength -= currentGop.byteLength;
      gops.nalCount -= currentGop.nalCount;
      gops[0][0].dts = currentGop.dts;
      gops[0][0].pts = currentGop.pts;
      gops[0][0].duration += currentGop.duration;
    }
    return gops;
  };
  var createDefaultSample = function() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  };
  var sampleForFrame = function(frame, dataOffset) {
    var sample = createDefaultSample();
    sample.dataOffset = dataOffset;
    sample.compositionTimeOffset = frame.pts - frame.dts;
    sample.duration = frame.duration;
    sample.size = 4 * frame.length;
    sample.size += frame.byteLength;
    if (frame.keyFrame) {
      sample.flags.dependsOn = 2;
      sample.flags.isNonSyncSample = 0;
    }
    return sample;
  };
  var generateSampleTable$1 = function(gops, baseDataOffset) {
    var h2, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
    for (h2 = 0; h2 < gops.length; h2++) {
      currentGop = gops[h2];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        sample = sampleForFrame(currentFrame, dataOffset);
        dataOffset += sample.size;
        samples.push(sample);
      }
    }
    return samples;
  };
  var concatenateNalData = function(gops) {
    var h2, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (h2 = 0; h2 < gops.length; h2++) {
      currentGop = gops[h2];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        for (j = 0; j < currentFrame.length; j++) {
          currentNal = currentFrame[j];
          view.setUint32(dataOffset, currentNal.data.byteLength);
          dataOffset += 4;
          data.set(currentNal.data, dataOffset);
          dataOffset += currentNal.data.byteLength;
        }
      }
    }
    return data;
  };
  var generateSampleTableForFrame = function(frame, baseDataOffset) {
    var sample, dataOffset = baseDataOffset || 0, samples = [];
    sample = sampleForFrame(frame, dataOffset);
    samples.push(sample);
    return samples;
  };
  var concatenateNalDataForFrame = function(frame) {
    var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (i = 0; i < frame.length; i++) {
      currentNal = frame[i];
      view.setUint32(dataOffset, currentNal.data.byteLength);
      dataOffset += 4;
      data.set(currentNal.data, dataOffset);
      dataOffset += currentNal.data.byteLength;
    }
    return data;
  };
  var frameUtils$1 = {
    groupNalsIntoFrames,
    groupFramesIntoGops,
    extendFirstKeyFrame,
    generateSampleTable: generateSampleTable$1,
    concatenateNalData,
    generateSampleTableForFrame,
    concatenateNalDataForFrame
  };
  var highPrefix = [33, 16, 5, 32, 164, 27];
  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
  var zeroFill = function(count) {
    var a = [];
    while (count--) {
      a.push(0);
    }
    return a;
  };
  var makeTable = function(metaTable) {
    return Object.keys(metaTable).reduce(function(obj, key) {
      obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
        return arr.concat(part);
      }, []));
      return obj;
    }, {});
  };
  var silence;
  var silence_1 = function() {
    if (!silence) {
      var coneOfSilence2 = {
        96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
        88200: [highPrefix, [231], zeroFill(170), [56]],
        64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
        48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
        32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
        24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
        16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
        12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
        8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
      };
      silence = makeTable(coneOfSilence2);
    }
    return silence;
  };
  var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs2, secondsToAudioTs2, videoTsToSeconds2, audioTsToSeconds2, audioTsToVideoTs2, videoTsToAudioTs2, metadataTsToSeconds2;
  secondsToVideoTs2 = function(seconds) {
    return seconds * ONE_SECOND_IN_TS$4;
  };
  secondsToAudioTs2 = function(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds2 = function(timestamp) {
    return timestamp / ONE_SECOND_IN_TS$4;
  };
  audioTsToSeconds2 = function(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs2 = function(timestamp, sampleRate) {
    return secondsToVideoTs2(audioTsToSeconds2(timestamp, sampleRate));
  };
  videoTsToAudioTs2 = function(timestamp, sampleRate) {
    return secondsToAudioTs2(videoTsToSeconds2(timestamp), sampleRate);
  };
  metadataTsToSeconds2 = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds2(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock$2 = {
    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
    secondsToVideoTs: secondsToVideoTs2,
    secondsToAudioTs: secondsToAudioTs2,
    videoTsToSeconds: videoTsToSeconds2,
    audioTsToSeconds: audioTsToSeconds2,
    audioTsToVideoTs: audioTsToVideoTs2,
    videoTsToAudioTs: videoTsToAudioTs2,
    metadataTsToSeconds: metadataTsToSeconds2
  };
  var coneOfSilence = silence_1;
  var clock$1 = clock$2;
  var sumFrameByteLengths = function(array) {
    var i, currentObj, sum = 0;
    for (i = 0; i < array.length; i++) {
      currentObj = array[i];
      sum += currentObj.data.byteLength;
    }
    return sum;
  };
  var prefixWithSilence = function(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
    var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i, firstFrame;
    if (!frames.length) {
      return;
    }
    baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
    frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));
    if (audioAppendStartTs && videoBaseMediaDecodeTime) {
      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
      audioFillDuration = audioFillFrameCount * frameDuration;
    }
    if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) {
      return;
    }
    silentFrame = coneOfSilence()[track.samplerate];
    if (!silentFrame) {
      silentFrame = frames[0].data;
    }
    for (i = 0; i < audioFillFrameCount; i++) {
      firstFrame = frames[0];
      frames.splice(0, 0, {
        data: silentFrame,
        dts: firstFrame.dts - frameDuration,
        pts: firstFrame.pts - frameDuration
      });
    }
    track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));
    return audioFillDuration;
  };
  var trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {
    if (track.minSegmentDts >= earliestAllowedDts) {
      return adtsFrames;
    }
    track.minSegmentDts = Infinity;
    return adtsFrames.filter(function(currentFrame) {
      if (currentFrame.dts >= earliestAllowedDts) {
        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
        track.minSegmentPts = track.minSegmentDts;
        return true;
      }
      return false;
    });
  };
  var generateSampleTable = function(frames) {
    var i, currentFrame, samples = [];
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      samples.push({
        size: currentFrame.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    }
    return samples;
  };
  var concatenateFrameData = function(frames) {
    var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      data.set(currentFrame.data, dataOffset);
      dataOffset += currentFrame.data.byteLength;
    }
    return data;
  };
  var audioFrameUtils$1 = {
    prefixWithSilence,
    trimAdtsFramesByEarliestDts,
    generateSampleTable,
    concatenateFrameData
  };
  var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;
  var collectDtsInfo = function(track, data) {
    if (typeof data.pts === "number") {
      if (track.timelineStartInfo.pts === void 0) {
        track.timelineStartInfo.pts = data.pts;
      }
      if (track.minSegmentPts === void 0) {
        track.minSegmentPts = data.pts;
      } else {
        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
      }
      if (track.maxSegmentPts === void 0) {
        track.maxSegmentPts = data.pts;
      } else {
        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
      }
    }
    if (typeof data.dts === "number") {
      if (track.timelineStartInfo.dts === void 0) {
        track.timelineStartInfo.dts = data.dts;
      }
      if (track.minSegmentDts === void 0) {
        track.minSegmentDts = data.dts;
      } else {
        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
      }
      if (track.maxSegmentDts === void 0) {
        track.maxSegmentDts = data.dts;
      } else {
        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
      }
    }
  };
  var clearDtsInfo = function(track) {
    delete track.minSegmentDts;
    delete track.maxSegmentDts;
    delete track.minSegmentPts;
    delete track.maxSegmentPts;
  };
  var calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {
    var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
    if (!keepOriginalTimestamps) {
      minSegmentDts -= track.timelineStartInfo.dts;
    }
    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
    baseMediaDecodeTime += minSegmentDts;
    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
    if (track.type === "audio") {
      scale = track.samplerate / ONE_SECOND_IN_TS$3;
      baseMediaDecodeTime *= scale;
      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
    }
    return baseMediaDecodeTime;
  };
  var trackDecodeInfo$1 = {
    clearDtsInfo,
    calculateTrackBaseMediaDecodeTime,
    collectDtsInfo
  };
  var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
  var parseSei = function(bytes) {
    var i = 0, result = {
      payloadType: -1,
      payloadSize: 0
    }, payloadType = 0, payloadSize = 0;
    while (i < bytes.byteLength) {
      if (bytes[i] === RBSP_TRAILING_BITS) {
        break;
      }
      while (bytes[i] === 255) {
        payloadType += 255;
        i++;
      }
      payloadType += bytes[i++];
      while (bytes[i] === 255) {
        payloadSize += 255;
        i++;
      }
      payloadSize += bytes[i++];
      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
        if (userIdentifier === "GA94") {
          result.payloadType = payloadType;
          result.payloadSize = payloadSize;
          result.payload = bytes.subarray(i, i + payloadSize);
          break;
        } else {
          result.payload = void 0;
        }
      }
      i += payloadSize;
      payloadType = 0;
      payloadSize = 0;
    }
    return result;
  };
  var parseUserData = function(sei) {
    if (sei.payload[0] !== 181) {
      return null;
    }
    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
      return null;
    }
    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
      return null;
    }
    if (sei.payload[7] !== 3) {
      return null;
    }
    return sei.payload.subarray(8, sei.payload.length - 1);
  };
  var parseCaptionPackets = function(pts, userData) {
    var results = [], i, count, offset2, data;
    if (!(userData[0] & 64)) {
      return results;
    }
    count = userData[0] & 31;
    for (i = 0; i < count; i++) {
      offset2 = i * 3;
      data = {
        type: userData[offset2 + 2] & 3,
        pts
      };
      if (userData[offset2 + 2] & 4) {
        data.ccData = userData[offset2 + 3] << 8 | userData[offset2 + 4];
        results.push(data);
      }
    }
    return results;
  };
  var discardEmulationPreventionBytes$1 = function(data) {
    var length2 = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
    while (i < length2 - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
        emulationPreventionBytesPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }
    if (emulationPreventionBytesPositions.length === 0) {
      return data;
    }
    newLength = length2 - emulationPreventionBytesPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === emulationPreventionBytesPositions[0]) {
        sourceIndex++;
        emulationPreventionBytesPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };
  var captionPacketParser = {
    parseSei,
    parseUserData,
    parseCaptionPackets,
    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
    USER_DATA_REGISTERED_ITU_T_T35
  };
  var Stream$7 = stream;
  var cea708Parser = captionPacketParser;
  var CaptionStream$2 = function(options) {
    options = options || {};
    CaptionStream$2.prototype.init.call(this);
    this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
    this.captionPackets_ = [];
    this.ccStreams_ = [
      new Cea608Stream(0, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(0, 1),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 1)
      // eslint-disable-line no-use-before-define
    ];
    if (this.parse708captions_) {
      this.cc708Stream_ = new Cea708Stream({
        captionServices: options.captionServices
      });
    }
    this.reset();
    this.ccStreams_.forEach(function(cc) {
      cc.on("data", this.trigger.bind(this, "data"));
      cc.on("partialdone", this.trigger.bind(this, "partialdone"));
      cc.on("done", this.trigger.bind(this, "done"));
    }, this);
    if (this.parse708captions_) {
      this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
      this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
      this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
    }
  };
  CaptionStream$2.prototype = new Stream$7();
  CaptionStream$2.prototype.push = function(event2) {
    var sei, userData, newCaptionPackets;
    if (event2.nalUnitType !== "sei_rbsp") {
      return;
    }
    sei = cea708Parser.parseSei(event2.escapedRBSP);
    if (!sei.payload) {
      return;
    }
    if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {
      return;
    }
    userData = cea708Parser.parseUserData(sei);
    if (!userData) {
      return;
    }
    if (event2.dts < this.latestDts_) {
      this.ignoreNextEqualDts_ = true;
      return;
    } else if (event2.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
      this.numSameDts_--;
      if (!this.numSameDts_) {
        this.ignoreNextEqualDts_ = false;
      }
      return;
    }
    newCaptionPackets = cea708Parser.parseCaptionPackets(event2.pts, userData);
    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
    if (this.latestDts_ !== event2.dts) {
      this.numSameDts_ = 0;
    }
    this.numSameDts_++;
    this.latestDts_ = event2.dts;
  };
  CaptionStream$2.prototype.flushCCStreams = function(flushType) {
    this.ccStreams_.forEach(function(cc) {
      return flushType === "flush" ? cc.flush() : cc.partialFlush();
    }, this);
  };
  CaptionStream$2.prototype.flushStream = function(flushType) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(flushType);
      return;
    }
    this.captionPackets_.forEach(function(elem, idx) {
      elem.presortIndex = idx;
    });
    this.captionPackets_.sort(function(a, b) {
      if (a.pts === b.pts) {
        return a.presortIndex - b.presortIndex;
      }
      return a.pts - b.pts;
    });
    this.captionPackets_.forEach(function(packet) {
      if (packet.type < 2) {
        this.dispatchCea608Packet(packet);
      } else {
        this.dispatchCea708Packet(packet);
      }
    }, this);
    this.captionPackets_.length = 0;
    this.flushCCStreams(flushType);
  };
  CaptionStream$2.prototype.flush = function() {
    return this.flushStream("flush");
  };
  CaptionStream$2.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  };
  CaptionStream$2.prototype.reset = function() {
    this.latestDts_ = null;
    this.ignoreNextEqualDts_ = false;
    this.numSameDts_ = 0;
    this.activeCea608Channel_ = [null, null];
    this.ccStreams_.forEach(function(ccStream) {
      ccStream.reset();
    });
  };
  CaptionStream$2.prototype.dispatchCea608Packet = function(packet) {
    if (this.setsTextOrXDSActive(packet)) {
      this.activeCea608Channel_[packet.type] = null;
    } else if (this.setsChannel1Active(packet)) {
      this.activeCea608Channel_[packet.type] = 0;
    } else if (this.setsChannel2Active(packet)) {
      this.activeCea608Channel_[packet.type] = 1;
    }
    if (this.activeCea608Channel_[packet.type] === null) {
      return;
    }
    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
  };
  CaptionStream$2.prototype.setsChannel1Active = function(packet) {
    return (packet.ccData & 30720) === 4096;
  };
  CaptionStream$2.prototype.setsChannel2Active = function(packet) {
    return (packet.ccData & 30720) === 6144;
  };
  CaptionStream$2.prototype.setsTextOrXDSActive = function(packet) {
    return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
  };
  CaptionStream$2.prototype.dispatchCea708Packet = function(packet) {
    if (this.parse708captions_) {
      this.cc708Stream_.push(packet);
    }
  };
  var CHARACTER_TRANSLATION_708 = {
    127: 9834,
    // ♪
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // …
    4138: 352,
    // Š
    4140: 338,
    // Œ
    4144: 9608,
    // █
    4145: 8216,
    // ‘
    4146: 8217,
    // ’
    4147: 8220,
    // “
    4148: 8221,
    // ”
    4149: 8226,
    // •
    4153: 8482,
    // ™
    4154: 353,
    // š
    4156: 339,
    // œ
    4157: 8480,
    // ℠
    4159: 376,
    // Ÿ
    4214: 8539,
    // ⅛
    4215: 8540,
    // ⅜
    4216: 8541,
    // ⅝
    4217: 8542,
    // ⅞
    4218: 9168,
    // ⏐
    4219: 9124,
    // ⎤
    4220: 9123,
    // ⎣
    4221: 9135,
    // ⎯
    4222: 9126,
    // ⎦
    4223: 9121,
    // ⎡
    4256: 12600
    // ㄸ (CC char)
  };
  var get708CharFromCode = function(code) {
    var newCode = CHARACTER_TRANSLATION_708[code] || code;
    if (code & 4096 && code === newCode) {
      return "";
    }
    return String.fromCharCode(newCode);
  };
  var within708TextBlock = function(b) {
    return 32 <= b && b <= 127 || 160 <= b && b <= 255;
  };
  var Cea708Window = function(windowNum) {
    this.windowNum = windowNum;
    this.reset();
  };
  Cea708Window.prototype.reset = function() {
    this.clearText();
    this.pendingNewLine = false;
    this.winAttr = {};
    this.penAttr = {};
    this.penLoc = {};
    this.penColor = {};
    this.visible = 0;
    this.rowLock = 0;
    this.columnLock = 0;
    this.priority = 0;
    this.relativePositioning = 0;
    this.anchorVertical = 0;
    this.anchorHorizontal = 0;
    this.anchorPoint = 0;
    this.rowCount = 1;
    this.virtualRowCount = this.rowCount + 1;
    this.columnCount = 41;
    this.windowStyle = 0;
    this.penStyle = 0;
  };
  Cea708Window.prototype.getText = function() {
    return this.rows.join("\n");
  };
  Cea708Window.prototype.clearText = function() {
    this.rows = [""];
    this.rowIdx = 0;
  };
  Cea708Window.prototype.newLine = function(pts) {
    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
      this.beforeRowOverflow(pts);
    }
    if (this.rows.length > 0) {
      this.rows.push("");
      this.rowIdx++;
    }
    while (this.rows.length > this.virtualRowCount) {
      this.rows.shift();
      this.rowIdx--;
    }
  };
  Cea708Window.prototype.isEmpty = function() {
    if (this.rows.length === 0) {
      return true;
    } else if (this.rows.length === 1) {
      return this.rows[0] === "";
    }
    return false;
  };
  Cea708Window.prototype.addText = function(text2) {
    this.rows[this.rowIdx] += text2;
  };
  Cea708Window.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var row = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = row.substr(0, row.length - 1);
    }
  };
  var Cea708Service = function(serviceNum, encoding, stream2) {
    this.serviceNum = serviceNum;
    this.text = "";
    this.currentWindow = new Cea708Window(-1);
    this.windows = [];
    this.stream = stream2;
    if (typeof encoding === "string") {
      this.createTextDecoder(encoding);
    }
  };
  Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
    this.startPts = pts;
    for (var win3 = 0; win3 < 8; win3++) {
      this.windows[win3] = new Cea708Window(win3);
      if (typeof beforeRowOverflow === "function") {
        this.windows[win3].beforeRowOverflow = beforeRowOverflow;
      }
    }
  };
  Cea708Service.prototype.setCurrentWindow = function(windowNum) {
    this.currentWindow = this.windows[windowNum];
  };
  Cea708Service.prototype.createTextDecoder = function(encoding) {
    if (typeof TextDecoder === "undefined") {
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    } else {
      try {
        this.textDecoder_ = new TextDecoder(encoding);
      } catch (error) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + encoding + " encoding. " + error
        });
      }
    }
  };
  var Cea708Stream = function(options) {
    options = options || {};
    Cea708Stream.prototype.init.call(this);
    var self2 = this;
    var captionServices = options.captionServices || {};
    var captionServiceEncodings = {};
    var serviceProps;
    Object.keys(captionServices).forEach((serviceName) => {
      serviceProps = captionServices[serviceName];
      if (/^SERVICE/.test(serviceName)) {
        captionServiceEncodings[serviceName] = serviceProps.encoding;
      }
    });
    this.serviceEncodings = captionServiceEncodings;
    this.current708Packet = null;
    this.services = {};
    this.push = function(packet) {
      if (packet.type === 3) {
        self2.new708Packet();
        self2.add708Bytes(packet);
      } else {
        if (self2.current708Packet === null) {
          self2.new708Packet();
        }
        self2.add708Bytes(packet);
      }
    };
  };
  Cea708Stream.prototype = new Stream$7();
  Cea708Stream.prototype.new708Packet = function() {
    if (this.current708Packet !== null) {
      this.push708Packet();
    }
    this.current708Packet = {
      data: [],
      ptsVals: []
    };
  };
  Cea708Stream.prototype.add708Bytes = function(packet) {
    var data = packet.ccData;
    var byte0 = data >>> 8;
    var byte1 = data & 255;
    this.current708Packet.ptsVals.push(packet.pts);
    this.current708Packet.data.push(byte0);
    this.current708Packet.data.push(byte1);
  };
  Cea708Stream.prototype.push708Packet = function() {
    var packet708 = this.current708Packet;
    var packetData = packet708.data;
    var serviceNum = null;
    var blockSize = null;
    var i = 0;
    var b = packetData[i++];
    packet708.seq = b >> 6;
    packet708.sizeCode = b & 63;
    for (; i < packetData.length; i++) {
      b = packetData[i++];
      serviceNum = b >> 5;
      blockSize = b & 31;
      if (serviceNum === 7 && blockSize > 0) {
        b = packetData[i++];
        serviceNum = b;
      }
      this.pushServiceBlock(serviceNum, i, blockSize);
      if (blockSize > 0) {
        i += blockSize - 1;
      }
    }
  };
  Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start2, size) {
    var b;
    var i = start2;
    var packetData = this.current708Packet.data;
    var service = this.services[serviceNum];
    if (!service) {
      service = this.initService(serviceNum, i);
    }
    for (; i < start2 + size && i < packetData.length; i++) {
      b = packetData[i];
      if (within708TextBlock(b)) {
        i = this.handleText(i, service);
      } else if (b === 24) {
        i = this.multiByteCharacter(i, service);
      } else if (b === 16) {
        i = this.extendedCommands(i, service);
      } else if (128 <= b && b <= 135) {
        i = this.setCurrentWindow(i, service);
      } else if (152 <= b && b <= 159) {
        i = this.defineWindow(i, service);
      } else if (b === 136) {
        i = this.clearWindows(i, service);
      } else if (b === 140) {
        i = this.deleteWindows(i, service);
      } else if (b === 137) {
        i = this.displayWindows(i, service);
      } else if (b === 138) {
        i = this.hideWindows(i, service);
      } else if (b === 139) {
        i = this.toggleWindows(i, service);
      } else if (b === 151) {
        i = this.setWindowAttributes(i, service);
      } else if (b === 144) {
        i = this.setPenAttributes(i, service);
      } else if (b === 145) {
        i = this.setPenColor(i, service);
      } else if (b === 146) {
        i = this.setPenLocation(i, service);
      } else if (b === 143) {
        service = this.reset(i, service);
      } else if (b === 8) {
        service.currentWindow.backspace();
      } else if (b === 12) {
        service.currentWindow.clearText();
      } else if (b === 13) {
        service.currentWindow.pendingNewLine = true;
      } else if (b === 14) {
        service.currentWindow.clearText();
      } else if (b === 141) {
        i++;
      } else
        ;
    }
  };
  Cea708Stream.prototype.extendedCommands = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    if (within708TextBlock(b)) {
      i = this.handleText(i, service, {
        isExtended: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.getPts = function(byteIndex) {
    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
  };
  Cea708Stream.prototype.initService = function(serviceNum, i) {
    var serviceName = "SERVICE" + serviceNum;
    var self2 = this;
    var serviceName;
    var encoding;
    if (serviceName in this.serviceEncodings) {
      encoding = this.serviceEncodings[serviceName];
    }
    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
    this.services[serviceNum].init(this.getPts(i), function(pts) {
      self2.flushDisplayed(pts, self2.services[serviceNum]);
    });
    return this.services[serviceNum];
  };
  Cea708Stream.prototype.handleText = function(i, service, options) {
    var isExtended = options && options.isExtended;
    var isMultiByte = options && options.isMultiByte;
    var packetData = this.current708Packet.data;
    var extended = isExtended ? 4096 : 0;
    var currentByte = packetData[i];
    var nextByte = packetData[i + 1];
    var win3 = service.currentWindow;
    var char;
    var charCodeArray;
    function toHexString2(byteArray) {
      return byteArray.map((byte) => {
        return ("0" + (byte & 255).toString(16)).slice(-2);
      }).join("");
    }
    if (isMultiByte) {
      charCodeArray = [currentByte, nextByte];
      i++;
    } else {
      charCodeArray = [currentByte];
    }
    if (service.textDecoder_ && !isExtended) {
      char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
    } else {
      if (isMultiByte) {
        const unicode = toHexString2(charCodeArray);
        char = String.fromCharCode(parseInt(unicode, 16));
      } else {
        char = get708CharFromCode(extended | currentByte);
      }
    }
    if (win3.pendingNewLine && !win3.isEmpty()) {
      win3.newLine(this.getPts(i));
    }
    win3.pendingNewLine = false;
    win3.addText(char);
    return i;
  };
  Cea708Stream.prototype.multiByteCharacter = function(i, service) {
    var packetData = this.current708Packet.data;
    var firstByte = packetData[i + 1];
    var secondByte = packetData[i + 2];
    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
      i = this.handleText(++i, service, {
        isMultiByte: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.setCurrentWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var windowNum = b & 7;
    service.setCurrentWindow(windowNum);
    return i;
  };
  Cea708Stream.prototype.defineWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var windowNum = b & 7;
    service.setCurrentWindow(windowNum);
    var win3 = service.currentWindow;
    b = packetData[++i];
    win3.visible = (b & 32) >> 5;
    win3.rowLock = (b & 16) >> 4;
    win3.columnLock = (b & 8) >> 3;
    win3.priority = b & 7;
    b = packetData[++i];
    win3.relativePositioning = (b & 128) >> 7;
    win3.anchorVertical = b & 127;
    b = packetData[++i];
    win3.anchorHorizontal = b;
    b = packetData[++i];
    win3.anchorPoint = (b & 240) >> 4;
    win3.rowCount = b & 15;
    b = packetData[++i];
    win3.columnCount = b & 63;
    b = packetData[++i];
    win3.windowStyle = (b & 56) >> 3;
    win3.penStyle = b & 7;
    win3.virtualRowCount = win3.rowCount + 1;
    return i;
  };
  Cea708Stream.prototype.setWindowAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var winAttr = service.currentWindow.winAttr;
    b = packetData[++i];
    winAttr.fillOpacity = (b & 192) >> 6;
    winAttr.fillRed = (b & 48) >> 4;
    winAttr.fillGreen = (b & 12) >> 2;
    winAttr.fillBlue = b & 3;
    b = packetData[++i];
    winAttr.borderType = (b & 192) >> 6;
    winAttr.borderRed = (b & 48) >> 4;
    winAttr.borderGreen = (b & 12) >> 2;
    winAttr.borderBlue = b & 3;
    b = packetData[++i];
    winAttr.borderType += (b & 128) >> 5;
    winAttr.wordWrap = (b & 64) >> 6;
    winAttr.printDirection = (b & 48) >> 4;
    winAttr.scrollDirection = (b & 12) >> 2;
    winAttr.justify = b & 3;
    b = packetData[++i];
    winAttr.effectSpeed = (b & 240) >> 4;
    winAttr.effectDirection = (b & 12) >> 2;
    winAttr.displayEffect = b & 3;
    return i;
  };
  Cea708Stream.prototype.flushDisplayed = function(pts, service) {
    var displayedText = [];
    for (var winId = 0; winId < 8; winId++) {
      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
        displayedText.push(service.windows[winId].getText());
      }
    }
    service.endPts = pts;
    service.text = displayedText.join("\n\n");
    this.pushCaption(service);
    service.startPts = pts;
  };
  Cea708Stream.prototype.pushCaption = function(service) {
    if (service.text !== "") {
      this.trigger("data", {
        startPts: service.startPts,
        endPts: service.endPts,
        text: service.text,
        stream: "cc708_" + service.serviceNum
      });
      service.text = "";
      service.startPts = service.endPts;
    }
  };
  Cea708Stream.prototype.displayWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible = 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.hideWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible = 0;
      }
    }
    return i;
  };
  Cea708Stream.prototype.toggleWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].visible ^= 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.clearWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].clearText();
      }
    }
    return i;
  };
  Cea708Stream.prototype.deleteWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b & 1 << winId) {
        service.windows[winId].reset();
      }
    }
    return i;
  };
  Cea708Stream.prototype.setPenAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penAttr = service.currentWindow.penAttr;
    b = packetData[++i];
    penAttr.textTag = (b & 240) >> 4;
    penAttr.offset = (b & 12) >> 2;
    penAttr.penSize = b & 3;
    b = packetData[++i];
    penAttr.italics = (b & 128) >> 7;
    penAttr.underline = (b & 64) >> 6;
    penAttr.edgeType = (b & 56) >> 3;
    penAttr.fontStyle = b & 7;
    return i;
  };
  Cea708Stream.prototype.setPenColor = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penColor = service.currentWindow.penColor;
    b = packetData[++i];
    penColor.fgOpacity = (b & 192) >> 6;
    penColor.fgRed = (b & 48) >> 4;
    penColor.fgGreen = (b & 12) >> 2;
    penColor.fgBlue = b & 3;
    b = packetData[++i];
    penColor.bgOpacity = (b & 192) >> 6;
    penColor.bgRed = (b & 48) >> 4;
    penColor.bgGreen = (b & 12) >> 2;
    penColor.bgBlue = b & 3;
    b = packetData[++i];
    penColor.edgeRed = (b & 48) >> 4;
    penColor.edgeGreen = (b & 12) >> 2;
    penColor.edgeBlue = b & 3;
    return i;
  };
  Cea708Stream.prototype.setPenLocation = function(i, service) {
    var packetData = this.current708Packet.data;
    var b = packetData[i];
    var penLoc = service.currentWindow.penLoc;
    service.currentWindow.pendingNewLine = true;
    b = packetData[++i];
    penLoc.row = b & 15;
    b = packetData[++i];
    penLoc.column = b & 63;
    return i;
  };
  Cea708Stream.prototype.reset = function(i, service) {
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    return this.initService(service.serviceNum, i);
  };
  var CHARACTER_TRANSLATION = {
    42: 225,
    // á
    92: 233,
    // é
    94: 237,
    // í
    95: 243,
    // ó
    96: 250,
    // ú
    123: 231,
    // ç
    124: 247,
    // ÷
    125: 209,
    // Ñ
    126: 241,
    // ñ
    127: 9608,
    // █
    304: 174,
    // ®
    305: 176,
    // °
    306: 189,
    // ½
    307: 191,
    // ¿
    308: 8482,
    // ™
    309: 162,
    // ¢
    310: 163,
    // £
    311: 9834,
    // ♪
    312: 224,
    // à
    313: 160,
    //
    314: 232,
    // è
    315: 226,
    // â
    316: 234,
    // ê
    317: 238,
    // î
    318: 244,
    // ô
    319: 251,
    // û
    544: 193,
    // Á
    545: 201,
    // É
    546: 211,
    // Ó
    547: 218,
    // Ú
    548: 220,
    // Ü
    549: 252,
    // ü
    550: 8216,
    // ‘
    551: 161,
    // ¡
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // —
    555: 169,
    // ©
    556: 8480,
    // ℠
    557: 8226,
    // •
    558: 8220,
    // “
    559: 8221,
    // ”
    560: 192,
    // À
    561: 194,
    // Â
    562: 199,
    // Ç
    563: 200,
    // È
    564: 202,
    // Ê
    565: 203,
    // Ë
    566: 235,
    // ë
    567: 206,
    // Î
    568: 207,
    // Ï
    569: 239,
    // ï
    570: 212,
    // Ô
    571: 217,
    // Ù
    572: 249,
    // ù
    573: 219,
    // Û
    574: 171,
    // «
    575: 187,
    // »
    800: 195,
    // Ã
    801: 227,
    // ã
    802: 205,
    // Í
    803: 204,
    // Ì
    804: 236,
    // ì
    805: 210,
    // Ò
    806: 242,
    // ò
    807: 213,
    // Õ
    808: 245,
    // õ
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // Ä
    817: 228,
    // ä
    818: 214,
    // Ö
    819: 246,
    // ö
    820: 223,
    // ß
    821: 165,
    // ¥
    822: 164,
    // ¤
    823: 9474,
    // │
    824: 197,
    // Å
    825: 229,
    // å
    826: 216,
    // Ø
    827: 248,
    // ø
    828: 9484,
    // ┌
    829: 9488,
    // ┐
    830: 9492,
    // └
    831: 9496
    // ┘
  };
  var getCharFromCode = function(code) {
    if (code === null) {
      return "";
    }
    code = CHARACTER_TRANSLATION[code] || code;
    return String.fromCharCode(code);
  };
  var BOTTOM_ROW = 14;
  var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
  var createDisplayBuffer = function() {
    var result = [], i = BOTTOM_ROW + 1;
    while (i--) {
      result.push({
        text: "",
        indent: 0,
        offset: 0
      });
    }
    return result;
  };
  var Cea608Stream = function(field, dataChannel) {
    Cea608Stream.prototype.init.call(this);
    this.field_ = field || 0;
    this.dataChannel_ = dataChannel || 0;
    this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
    this.setConstants();
    this.reset();
    this.push = function(packet) {
      var data, swap, char0, char1, text2;
      data = packet.ccData & 32639;
      if (data === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((data & 61440) === 4096) {
        this.lastControlCode_ = data;
      } else if (data !== this.PADDING_) {
        this.lastControlCode_ = null;
      }
      char0 = data >>> 8;
      char1 = data & 255;
      if (data === this.PADDING_) {
        return;
      } else if (data === this.RESUME_CAPTION_LOADING_) {
        this.mode_ = "popOn";
      } else if (data === this.END_OF_CAPTION_) {
        this.mode_ = "popOn";
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        swap = this.displayed_;
        this.displayed_ = this.nonDisplayed_;
        this.nonDisplayed_ = swap;
        this.startPts_ = packet.pts;
      } else if (data === this.ROLL_UP_2_ROWS_) {
        this.rollUpRows_ = 2;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_3_ROWS_) {
        this.rollUpRows_ = 3;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_4_ROWS_) {
        this.rollUpRows_ = 4;
        this.setRollUp(packet.pts);
      } else if (data === this.CARRIAGE_RETURN_) {
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        this.shiftRowsUp_();
        this.startPts_ = packet.pts;
      } else if (data === this.BACKSPACE_) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);
        } else {
          this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
        }
      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
        this.flushDisplayed(packet.pts);
        this.displayed_ = createDisplayBuffer();
      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
        this.nonDisplayed_ = createDisplayBuffer();
      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
        if (this.mode_ !== "paintOn") {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        }
        this.mode_ = "paintOn";
        this.startPts_ = packet.pts;
      } else if (this.isSpecialCharacter(char0, char1)) {
        char0 = (char0 & 3) << 8;
        text2 = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text2);
        this.column_++;
      } else if (this.isExtCharacter(char0, char1)) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1);
        } else {
          this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
        }
        char0 = (char0 & 3) << 8;
        text2 = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text2);
        this.column_++;
      } else if (this.isMidRowCode(char0, char1)) {
        this.clearFormatting(packet.pts);
        this[this.mode_](packet.pts, " ");
        this.column_++;
        if ((char1 & 14) === 14) {
          this.addFormatting(packet.pts, ["i"]);
        }
        if ((char1 & 1) === 1) {
          this.addFormatting(packet.pts, ["u"]);
        }
      } else if (this.isOffsetControlCode(char0, char1)) {
        const offset2 = char1 & 3;
        this.nonDisplayed_[this.row_].offset = offset2;
        this.column_ += offset2;
      } else if (this.isPAC(char0, char1)) {
        var row = ROWS.indexOf(data & 7968);
        if (this.mode_ === "rollUp") {
          if (row - this.rollUpRows_ + 1 < 0) {
            row = this.rollUpRows_ - 1;
          }
          this.setRollUp(packet.pts, row);
        }
        if (row !== this.row_ && row >= 0 && row <= 14) {
          this.clearFormatting(packet.pts);
          this.row_ = row;
        }
        if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
          this.addFormatting(packet.pts, ["u"]);
        }
        if ((data & 16) === 16) {
          const indentations = (data & 14) >> 1;
          this.column_ = indentations * 4;
          this.nonDisplayed_[this.row_].indent += indentations;
        }
        if (this.isColorPAC(char1)) {
          if ((char1 & 14) === 14) {
            this.addFormatting(packet.pts, ["i"]);
          }
        }
      } else if (this.isNormalChar(char0)) {
        if (char1 === 0) {
          char1 = null;
        }
        text2 = getCharFromCode(char0);
        text2 += getCharFromCode(char1);
        this[this.mode_](packet.pts, text2);
        this.column_ += text2.length;
      }
    };
  };
  Cea608Stream.prototype = new Stream$7();
  Cea608Stream.prototype.flushDisplayed = function(pts) {
    const logWarning = (index) => {
      this.trigger("log", {
        level: "warn",
        message: "Skipping a malformed 608 caption at index " + index + "."
      });
    };
    const content = [];
    this.displayed_.forEach((row, i) => {
      if (row && row.text && row.text.length) {
        try {
          row.text = row.text.trim();
        } catch (e) {
          logWarning(i);
        }
        if (row.text.length) {
          content.push({
            // The text to be displayed in the caption from this specific row, with whitespace removed.
            text: row.text,
            // Value between 1 and 15 representing the PAC row used to calculate line height.
            line: i + 1,
            // A number representing the indent position by percentage (CEA-608 PAC indent code).
            // The value will be a number between 10 and 80. Offset is used to add an aditional
            // value to the position if necessary.
            position: 10 + Math.min(70, row.indent * 10) + row.offset * 2.5
          });
        }
      } else if (row === void 0 || row === null) {
        logWarning(i);
      }
    });
    if (content.length) {
      this.trigger("data", {
        startPts: this.startPts_,
        endPts: pts,
        content,
        stream: this.name_
      });
    }
  };
  Cea608Stream.prototype.reset = function() {
    this.mode_ = "popOn";
    this.topRow_ = 0;
    this.startPts_ = 0;
    this.displayed_ = createDisplayBuffer();
    this.nonDisplayed_ = createDisplayBuffer();
    this.lastControlCode_ = null;
    this.column_ = 0;
    this.row_ = BOTTOM_ROW;
    this.rollUpRows_ = 2;
    this.formatting_ = [];
  };
  Cea608Stream.prototype.setConstants = function() {
    if (this.dataChannel_ === 0) {
      this.BASE_ = 16;
      this.EXT_ = 17;
      this.CONTROL_ = (20 | this.field_) << 8;
      this.OFFSET_ = 23;
    } else if (this.dataChannel_ === 1) {
      this.BASE_ = 24;
      this.EXT_ = 25;
      this.CONTROL_ = (28 | this.field_) << 8;
      this.OFFSET_ = 31;
    }
    this.PADDING_ = 0;
    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
    this.END_OF_CAPTION_ = this.CONTROL_ | 47;
    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
    this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
    this.BACKSPACE_ = this.CONTROL_ | 33;
    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  };
  Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
  };
  Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
  };
  Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
  };
  Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
    return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
  };
  Cea608Stream.prototype.isPAC = function(char0, char1) {
    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
  };
  Cea608Stream.prototype.isColorPAC = function(char1) {
    return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
  };
  Cea608Stream.prototype.isNormalChar = function(char) {
    return char >= 32 && char <= 127;
  };
  Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
    if (this.mode_ !== "rollUp") {
      this.row_ = BOTTOM_ROW;
      this.mode_ = "rollUp";
      this.flushDisplayed(pts);
      this.nonDisplayed_ = createDisplayBuffer();
      this.displayed_ = createDisplayBuffer();
    }
    if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
      for (var i = 0; i < this.rollUpRows_; i++) {
        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
        this.displayed_[this.row_ - i] = {
          text: "",
          indent: 0,
          offset: 0
        };
      }
    }
    if (newBaseRow === void 0) {
      newBaseRow = this.row_;
    }
    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
  };
  Cea608Stream.prototype.addFormatting = function(pts, format) {
    this.formatting_ = this.formatting_.concat(format);
    var text2 = format.reduce(function(text22, format2) {
      return text22 + "<" + format2 + ">";
    }, "");
    this[this.mode_](pts, text2);
  };
  Cea608Stream.prototype.clearFormatting = function(pts) {
    if (!this.formatting_.length) {
      return;
    }
    var text2 = this.formatting_.reverse().reduce(function(text22, format) {
      return text22 + "</" + format + ">";
    }, "");
    this.formatting_ = [];
    this[this.mode_](pts, text2);
  };
  Cea608Stream.prototype.popOn = function(pts, text2) {
    var baseRow = this.nonDisplayed_[this.row_].text;
    baseRow += text2;
    this.nonDisplayed_[this.row_].text = baseRow;
  };
  Cea608Stream.prototype.rollUp = function(pts, text2) {
    var baseRow = this.displayed_[this.row_].text;
    baseRow += text2;
    this.displayed_[this.row_].text = baseRow;
  };
  Cea608Stream.prototype.shiftRowsUp_ = function() {
    var i;
    for (i = 0; i < this.topRow_; i++) {
      this.displayed_[i] = {
        text: "",
        indent: 0,
        offset: 0
      };
    }
    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
      this.displayed_[i] = {
        text: "",
        indent: 0,
        offset: 0
      };
    }
    for (i = this.topRow_; i < this.row_; i++) {
      this.displayed_[i] = this.displayed_[i + 1];
    }
    this.displayed_[this.row_] = {
      text: "",
      indent: 0,
      offset: 0
    };
  };
  Cea608Stream.prototype.paintOn = function(pts, text2) {
    var baseRow = this.displayed_[this.row_].text;
    baseRow += text2;
    this.displayed_[this.row_].text = baseRow;
  };
  var captionStream = {
    CaptionStream: CaptionStream$2,
    Cea608Stream,
    Cea708Stream
  };
  var streamTypes = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  };
  var Stream$6 = stream;
  var MAX_TS = 8589934592;
  var RO_THRESH = 4294967296;
  var TYPE_SHARED = "shared";
  var handleRollover$1 = function(value2, reference2) {
    var direction = 1;
    if (value2 > reference2) {
      direction = -1;
    }
    while (Math.abs(reference2 - value2) > RO_THRESH) {
      value2 += direction * MAX_TS;
    }
    return value2;
  };
  var TimestampRolloverStream$1 = function(type2) {
    var lastDTS, referenceDTS;
    TimestampRolloverStream$1.prototype.init.call(this);
    this.type_ = type2 || TYPE_SHARED;
    this.push = function(data) {
      if (data.type === "metadata") {
        this.trigger("data", data);
        return;
      }
      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
        return;
      }
      if (referenceDTS === void 0) {
        referenceDTS = data.dts;
      }
      data.dts = handleRollover$1(data.dts, referenceDTS);
      data.pts = handleRollover$1(data.pts, referenceDTS);
      lastDTS = data.dts;
      this.trigger("data", data);
    };
    this.flush = function() {
      referenceDTS = lastDTS;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.discontinuity = function() {
      referenceDTS = void 0;
      lastDTS = void 0;
    };
    this.reset = function() {
      this.discontinuity();
      this.trigger("reset");
    };
  };
  TimestampRolloverStream$1.prototype = new Stream$6();
  var timestampRolloverStream = {
    TimestampRolloverStream: TimestampRolloverStream$1,
    handleRollover: handleRollover$1
  };
  var typedArrayIndexOf$1 = (typedArray2, element, fromIndex) => {
    if (!typedArray2) {
      return -1;
    }
    var currentIndex = fromIndex;
    for (; currentIndex < typedArray2.length; currentIndex++) {
      if (typedArray2[currentIndex] === element) {
        return currentIndex;
      }
    }
    return -1;
  };
  var typedArray = {
    typedArrayIndexOf: typedArrayIndexOf$1
  };
  var typedArrayIndexOf = typedArray.typedArrayIndexOf, textEncodingDescriptionByte = {
    Iso88591: 0,
    // ISO-8859-1, terminated with \0.
    Utf16: 1,
    // UTF-16 encoded Unicode BOM, terminated with \0\0
    Utf16be: 2,
    // UTF-16BE encoded Unicode, without BOM, terminated with \0\0
    Utf8: 3
    // UTF-8 encoded Unicode, terminated with \0
  }, percentEncode$1 = function(bytes, start2, end2) {
    var i, result = "";
    for (i = start2; i < end2; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  }, parseUtf8 = function(bytes, start2, end2) {
    return decodeURIComponent(percentEncode$1(bytes, start2, end2));
  }, parseIso88591$1 = function(bytes, start2, end2) {
    return unescape(percentEncode$1(bytes, start2, end2));
  }, parseSyncSafeInteger$1 = function(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  }, frameParsers = {
    "APIC": function(frame) {
      var i = 1, mimeTypeEndIndex, descriptionEndIndex, LINK_MIME_TYPE = "-->";
      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
        return;
      }
      mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);
      if (mimeTypeEndIndex < 0) {
        return;
      }
      frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);
      i = mimeTypeEndIndex + 1;
      frame.pictureType = frame.data[i];
      i++;
      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);
      if (descriptionEndIndex < 0) {
        return;
      }
      frame.description = parseUtf8(frame.data, i, descriptionEndIndex);
      i = descriptionEndIndex + 1;
      if (frame.mimeType === LINK_MIME_TYPE) {
        frame.url = parseIso88591$1(frame.data, i, frame.data.length);
      } else {
        frame.pictureData = frame.data.subarray(i, frame.data.length);
      }
    },
    "T*": function(frame) {
      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
        return;
      }
      frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\0*$/, "");
      frame.values = frame.value.split("\0");
    },
    "TXXX": function(frame) {
      var descriptionEndIndex;
      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
        return;
      }
      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
      if (descriptionEndIndex === -1) {
        return;
      }
      frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
      frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0*$/, "");
      frame.data = frame.value;
    },
    "W*": function(frame) {
      frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\0.*$/, "");
    },
    "WXXX": function(frame) {
      var descriptionEndIndex;
      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {
        return;
      }
      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
      if (descriptionEndIndex === -1) {
        return;
      }
      frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
      frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0.*$/, "");
    },
    "PRIV": function(frame) {
      var i;
      for (i = 0; i < frame.data.length; i++) {
        if (frame.data[i] === 0) {
          frame.owner = parseIso88591$1(frame.data, 0, i);
          break;
        }
      }
      frame.privateData = frame.data.subarray(i + 1);
      frame.data = frame.privateData;
    }
  };
  var parseId3Frames$1 = function(data) {
    var frameSize, frameHeader, frameStart = 10, tagSize = 0, frames = [];
    if (data.length < 10 || data[0] !== "I".charCodeAt(0) || data[1] !== "D".charCodeAt(0) || data[2] !== "3".charCodeAt(0)) {
      return;
    }
    tagSize = parseSyncSafeInteger$1(data.subarray(6, 10));
    tagSize += 10;
    var hasExtendedHeader = data[5] & 64;
    if (hasExtendedHeader) {
      frameStart += 4;
      frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));
      tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20));
    }
    do {
      frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));
      if (frameSize < 1) {
        break;
      }
      frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);
      var frame = {
        id: frameHeader,
        data: data.subarray(frameStart + 10, frameStart + frameSize + 10)
      };
      frame.key = frame.id;
      if (frameParsers[frame.id]) {
        frameParsers[frame.id](frame);
      } else if (frame.id[0] === "T") {
        frameParsers["T*"](frame);
      } else if (frame.id[0] === "W") {
        frameParsers["W*"](frame);
      }
      frames.push(frame);
      frameStart += 10;
      frameStart += frameSize;
    } while (frameStart < tagSize);
    return frames;
  };
  var parseId3 = {
    parseId3Frames: parseId3Frames$1,
    parseSyncSafeInteger: parseSyncSafeInteger$1,
    frameParsers
  };
  var Stream$5 = stream, StreamTypes$3 = streamTypes, id3 = parseId3, MetadataStream;
  MetadataStream = function(options) {
    var settings = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: options && options.descriptor
    }, tagSize = 0, buffer = [], bufferSize = 0, i;
    MetadataStream.prototype.init.call(this);
    this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);
    if (settings.descriptor) {
      for (i = 0; i < settings.descriptor.length; i++) {
        this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
      }
    }
    this.push = function(chunk) {
      var tag, frameStart, frameSize, frame, i2, frameHeader;
      if (chunk.type !== "timed-metadata") {
        return;
      }
      if (chunk.dataAlignmentIndicator) {
        bufferSize = 0;
        buffer.length = 0;
      }
      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping unrecognized metadata packet"
        });
        return;
      }
      buffer.push(chunk);
      bufferSize += chunk.data.byteLength;
      if (buffer.length === 1) {
        tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10));
        tagSize += 10;
      }
      if (bufferSize < tagSize) {
        return;
      }
      tag = {
        data: new Uint8Array(tagSize),
        frames: [],
        pts: buffer[0].pts,
        dts: buffer[0].dts
      };
      for (i2 = 0; i2 < tagSize; ) {
        tag.data.set(buffer[0].data.subarray(0, tagSize - i2), i2);
        i2 += buffer[0].data.byteLength;
        bufferSize -= buffer[0].data.byteLength;
        buffer.shift();
      }
      frameStart = 10;
      if (tag.data[5] & 64) {
        frameStart += 4;
        frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14));
        tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));
      }
      do {
        frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          this.trigger("log", {
            level: "warn",
            message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
          });
          break;
        }
        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
        frame = {
          id: frameHeader,
          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
        };
        frame.key = frame.id;
        if (id3.frameParsers[frame.id]) {
          id3.frameParsers[frame.id](frame);
        } else if (frame.id[0] === "T") {
          id3.frameParsers["T*"](frame);
        } else if (frame.id[0] === "W") {
          id3.frameParsers["W*"](frame);
        }
        if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
          var d = frame.data, size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
          size *= 4;
          size += d[7] & 3;
          frame.timeStamp = size;
          if (tag.pts === void 0 && tag.dts === void 0) {
            tag.pts = frame.timeStamp;
            tag.dts = frame.timeStamp;
          }
          this.trigger("timestamp", frame);
        }
        tag.frames.push(frame);
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < tagSize);
      this.trigger("data", tag);
    };
  };
  MetadataStream.prototype = new Stream$5();
  var metadataStream = MetadataStream;
  var Stream$4 = stream, CaptionStream$1 = captionStream, StreamTypes$2 = streamTypes, TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
  var TransportPacketStream, TransportParseStream, ElementaryStream;
  var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
  TransportPacketStream = function() {
    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
    TransportPacketStream.prototype.init.call(this);
    this.push = function(bytes) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
      if (bytesInBuffer) {
        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
        everything.set(buffer.subarray(0, bytesInBuffer));
        everything.set(bytes, bytesInBuffer);
        bytesInBuffer = 0;
      } else {
        everything = bytes;
      }
      while (endIndex < everything.byteLength) {
        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
          this.trigger("data", everything.subarray(startIndex, endIndex));
          startIndex += MP2T_PACKET_LENGTH$1;
          endIndex += MP2T_PACKET_LENGTH$1;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      if (startIndex < everything.byteLength) {
        buffer.set(everything.subarray(startIndex), 0);
        bytesInBuffer = everything.byteLength - startIndex;
      }
    };
    this.flush = function() {
      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
        this.trigger("data", buffer);
        bytesInBuffer = 0;
      }
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.reset = function() {
      bytesInBuffer = 0;
      this.trigger("reset");
    };
  };
  TransportPacketStream.prototype = new Stream$4();
  TransportParseStream = function() {
    var parsePsi, parsePat2, parsePmt2, self2;
    TransportParseStream.prototype.init.call(this);
    self2 = this;
    this.packetsWaitingForPmt = [];
    this.programMapTable = void 0;
    parsePsi = function(payload, psi) {
      var offset2 = 0;
      if (psi.payloadUnitStartIndicator) {
        offset2 += payload[offset2] + 1;
      }
      if (psi.type === "pat") {
        parsePat2(payload.subarray(offset2), psi);
      } else {
        parsePmt2(payload.subarray(offset2), psi);
      }
    };
    parsePat2 = function(payload, pat) {
      pat.section_number = payload[7];
      pat.last_section_number = payload[8];
      self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
      pat.pmtPid = self2.pmtPid;
    };
    parsePmt2 = function(payload, pmt) {
      var sectionLength, tableEnd, programInfoLength, offset2;
      if (!(payload[5] & 1)) {
        return;
      }
      self2.programMapTable = {
        video: null,
        audio: null,
        "timed-metadata": {}
      };
      sectionLength = (payload[1] & 15) << 8 | payload[2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (payload[10] & 15) << 8 | payload[11];
      offset2 = 12 + programInfoLength;
      while (offset2 < tableEnd) {
        var streamType = payload[offset2];
        var pid = (payload[offset2 + 1] & 31) << 8 | payload[offset2 + 2];
        if (streamType === StreamTypes$2.H264_STREAM_TYPE && self2.programMapTable.video === null) {
          self2.programMapTable.video = pid;
        } else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
          self2.programMapTable.audio = pid;
        } else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) {
          self2.programMapTable["timed-metadata"][pid] = streamType;
        }
        offset2 += ((payload[offset2 + 3] & 15) << 8 | payload[offset2 + 4]) + 5;
      }
      pmt.programMapTable = self2.programMapTable;
    };
    this.push = function(packet) {
      var result = {}, offset2 = 4;
      result.payloadUnitStartIndicator = !!(packet[1] & 64);
      result.pid = packet[1] & 31;
      result.pid <<= 8;
      result.pid |= packet[2];
      if ((packet[3] & 48) >>> 4 > 1) {
        offset2 += packet[offset2] + 1;
      }
      if (result.pid === 0) {
        result.type = "pat";
        parsePsi(packet.subarray(offset2), result);
        this.trigger("data", result);
      } else if (result.pid === this.pmtPid) {
        result.type = "pmt";
        parsePsi(packet.subarray(offset2), result);
        this.trigger("data", result);
        while (this.packetsWaitingForPmt.length) {
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        }
      } else if (this.programMapTable === void 0) {
        this.packetsWaitingForPmt.push([packet, offset2, result]);
      } else {
        this.processPes_(packet, offset2, result);
      }
    };
    this.processPes_ = function(packet, offset2, result) {
      if (result.pid === this.programMapTable.video) {
        result.streamType = StreamTypes$2.H264_STREAM_TYPE;
      } else if (result.pid === this.programMapTable.audio) {
        result.streamType = StreamTypes$2.ADTS_STREAM_TYPE;
      } else {
        result.streamType = this.programMapTable["timed-metadata"][result.pid];
      }
      result.type = "pes";
      result.data = packet.subarray(offset2);
      this.trigger("data", result);
    };
  };
  TransportParseStream.prototype = new Stream$4();
  TransportParseStream.STREAM_TYPES = {
    h264: 27,
    adts: 15
  };
  ElementaryStream = function() {
    var self2 = this, segmentHadPmt = false, video = {
      data: [],
      size: 0
    }, audio = {
      data: [],
      size: 0
    }, timedMetadata = {
      data: [],
      size: 0
    }, programMapTable, parsePes = function(payload, pes) {
      var ptsDtsFlags;
      const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
      pes.data = new Uint8Array();
      if (startPrefix !== 1) {
        return;
      }
      pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
      pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
      ptsDtsFlags = payload[7];
      if (ptsDtsFlags & 192) {
        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
        pes.pts *= 4;
        pes.pts += (payload[13] & 6) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 64) {
          pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
          pes.dts *= 4;
          pes.dts += (payload[18] & 6) >>> 1;
        }
      }
      pes.data = payload.subarray(9 + payload[8]);
    }, flushStream = function(stream2, type2, forceFlush) {
      var packetData = new Uint8Array(stream2.size), event2 = {
        type: type2
      }, i = 0, offset2 = 0, packetFlushable = false, fragment;
      if (!stream2.data.length || stream2.size < 9) {
        return;
      }
      event2.trackId = stream2.data[0].pid;
      for (i = 0; i < stream2.data.length; i++) {
        fragment = stream2.data[i];
        packetData.set(fragment.data, offset2);
        offset2 += fragment.data.byteLength;
      }
      parsePes(packetData, event2);
      packetFlushable = type2 === "video" || event2.packetLength <= stream2.size;
      if (forceFlush || packetFlushable) {
        stream2.size = 0;
        stream2.data.length = 0;
      }
      if (packetFlushable) {
        self2.trigger("data", event2);
      }
    };
    ElementaryStream.prototype.init.call(this);
    this.push = function(data) {
      ({
        pat: function() {
        },
        pes: function() {
          var stream2, streamType;
          switch (data.streamType) {
            case StreamTypes$2.H264_STREAM_TYPE:
              stream2 = video;
              streamType = "video";
              break;
            case StreamTypes$2.ADTS_STREAM_TYPE:
              stream2 = audio;
              streamType = "audio";
              break;
            case StreamTypes$2.METADATA_STREAM_TYPE:
              stream2 = timedMetadata;
              streamType = "timed-metadata";
              break;
            default:
              return;
          }
          if (data.payloadUnitStartIndicator) {
            flushStream(stream2, streamType, true);
          }
          stream2.data.push(data);
          stream2.size += data.data.byteLength;
        },
        pmt: function() {
          var event2 = {
            type: "metadata",
            tracks: []
          };
          programMapTable = data.programMapTable;
          if (programMapTable.video !== null) {
            event2.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: "avc",
              type: "video"
            });
          }
          if (programMapTable.audio !== null) {
            event2.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: "adts",
              type: "audio"
            });
          }
          segmentHadPmt = true;
          self2.trigger("data", event2);
        }
      })[data.type]();
    };
    this.reset = function() {
      video.size = 0;
      video.data.length = 0;
      audio.size = 0;
      audio.data.length = 0;
      this.trigger("reset");
    };
    this.flushStreams_ = function() {
      flushStream(video, "video");
      flushStream(audio, "audio");
      flushStream(timedMetadata, "timed-metadata");
    };
    this.flush = function() {
      if (!segmentHadPmt && programMapTable) {
        var pmt = {
          type: "metadata",
          tracks: []
        };
        if (programMapTable.video !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.video,
            codec: "avc",
            type: "video"
          });
        }
        if (programMapTable.audio !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.audio,
            codec: "adts",
            type: "audio"
          });
        }
        self2.trigger("data", pmt);
      }
      segmentHadPmt = false;
      this.flushStreams_();
      this.trigger("done");
    };
  };
  ElementaryStream.prototype = new Stream$4();
  var m2ts$1 = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
    TransportPacketStream,
    TransportParseStream,
    ElementaryStream,
    TimestampRolloverStream,
    CaptionStream: CaptionStream$1.CaptionStream,
    Cea608Stream: CaptionStream$1.Cea608Stream,
    Cea708Stream: CaptionStream$1.Cea708Stream,
    MetadataStream: metadataStream
  };
  for (var type in StreamTypes$2) {
    if (StreamTypes$2.hasOwnProperty(type)) {
      m2ts$1[type] = StreamTypes$2[type];
    }
  }
  var m2ts_1 = m2ts$1;
  var Stream$3 = stream;
  var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;
  var AdtsStream$1;
  var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  AdtsStream$1 = function(handlePartialSegments) {
    var buffer, frameNum = 0;
    AdtsStream$1.prototype.init.call(this);
    this.skipWarn_ = function(start2, end2) {
      this.trigger("log", {
        level: "warn",
        message: `adts skiping bytes ${start2} to ${end2} in frame ${frameNum} outside syncword`
      });
    };
    this.push = function(packet) {
      var i = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
      if (!handlePartialSegments) {
        frameNum = 0;
      }
      if (packet.type !== "audio") {
        return;
      }
      if (buffer && buffer.length) {
        oldBuffer = buffer;
        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
        buffer.set(oldBuffer);
        buffer.set(packet.data, oldBuffer.byteLength);
      } else {
        buffer = packet.data;
      }
      var skip;
      while (i + 7 < buffer.length) {
        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
          if (typeof skip !== "number") {
            skip = i;
          }
          i++;
          continue;
        }
        if (typeof skip === "number") {
          this.skipWarn_(skip, i);
          skip = null;
        }
        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
        if (buffer.byteLength - i < frameLength) {
          break;
        }
        this.trigger("data", {
          pts: packet.pts + frameNum * adtsFrameDuration,
          dts: packet.dts + frameNum * adtsFrameDuration,
          sampleCount,
          audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
          samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
          samplesize: 16,
          // data is the frame without it's header
          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameNum++;
        i += frameLength;
      }
      if (typeof skip === "number") {
        this.skipWarn_(skip, i);
        skip = null;
      }
      buffer = buffer.subarray(i);
    };
    this.flush = function() {
      frameNum = 0;
      this.trigger("done");
    };
    this.reset = function() {
      buffer = void 0;
      this.trigger("reset");
    };
    this.endTimeline = function() {
      buffer = void 0;
      this.trigger("endedtimeline");
    };
  };
  AdtsStream$1.prototype = new Stream$3();
  var adts = AdtsStream$1;
  var ExpGolomb$1;
  ExpGolomb$1 = function(workingData) {
    var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
    this.length = function() {
      return 8 * workingBytesAvailable;
    };
    this.bitsAvailable = function() {
      return 8 * workingBytesAvailable + workingBitsAvailable;
    };
    this.loadWord = function() {
      var position2 = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(workingData.subarray(position2, position2 + availableBytes));
      workingWord = new DataView(workingBytes.buffer).getUint32(0);
      workingBitsAvailable = availableBytes * 8;
      workingBytesAvailable -= availableBytes;
    };
    this.skipBits = function(count) {
      var skipBytes;
      if (workingBitsAvailable > count) {
        workingWord <<= count;
        workingBitsAvailable -= count;
      } else {
        count -= workingBitsAvailable;
        skipBytes = Math.floor(count / 8);
        count -= skipBytes * 8;
        workingBytesAvailable -= skipBytes;
        this.loadWord();
        workingWord <<= count;
        workingBitsAvailable -= count;
      }
    };
    this.readBits = function(size) {
      var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
      workingBitsAvailable -= bits;
      if (workingBitsAvailable > 0) {
        workingWord <<= bits;
      } else if (workingBytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      }
      return valu;
    };
    this.skipLeadingZeros = function() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
        if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
          workingWord <<= leadingZeroCount;
          workingBitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLeadingZeros();
    };
    this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.readUnsignedExpGolomb = function() {
      var clz = this.skipLeadingZeros();
      return this.readBits(clz + 1) - 1;
    };
    this.readExpGolomb = function() {
      var valu = this.readUnsignedExpGolomb();
      if (1 & valu) {
        return 1 + valu >>> 1;
      }
      return -1 * (valu >>> 1);
    };
    this.readBoolean = function() {
      return this.readBits(1) === 1;
    };
    this.readUnsignedByte = function() {
      return this.readBits(8);
    };
    this.loadWord();
  };
  var expGolomb = ExpGolomb$1;
  var Stream$2 = stream;
  var ExpGolomb = expGolomb;
  var H264Stream$1, NalByteStream;
  var PROFILES_WITH_OPTIONAL_SPS_DATA;
  NalByteStream = function() {
    var syncPoint = 0, i, buffer;
    NalByteStream.prototype.init.call(this);
    this.push = function(data) {
      var swapBuffer;
      if (!buffer) {
        buffer = data.data;
      } else {
        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
        swapBuffer.set(buffer);
        swapBuffer.set(data.data, buffer.byteLength);
        buffer = swapBuffer;
      }
      var len = buffer.byteLength;
      for (; syncPoint < len - 3; syncPoint++) {
        if (buffer[syncPoint + 2] === 1) {
          i = syncPoint + 5;
          break;
        }
      }
      while (i < len) {
        switch (buffer[i]) {
          case 0:
            if (buffer[i - 1] !== 0) {
              i += 2;
              break;
            } else if (buffer[i - 2] !== 0) {
              i++;
              break;
            }
            if (syncPoint + 3 !== i - 2) {
              this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            }
            do {
              i++;
            } while (buffer[i] !== 1 && i < len);
            syncPoint = i - 2;
            i += 3;
            break;
          case 1:
            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
              i += 3;
              break;
            }
            this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            syncPoint = i - 2;
            i += 3;
            break;
          default:
            i += 3;
            break;
        }
      }
      buffer = buffer.subarray(syncPoint);
      i -= syncPoint;
      syncPoint = 0;
    };
    this.reset = function() {
      buffer = null;
      syncPoint = 0;
      this.trigger("reset");
    };
    this.flush = function() {
      if (buffer && buffer.byteLength > 3) {
        this.trigger("data", buffer.subarray(syncPoint + 3));
      }
      buffer = null;
      syncPoint = 0;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
  };
  NalByteStream.prototype = new Stream$2();
  PROFILES_WITH_OPTIONAL_SPS_DATA = {
    100: true,
    110: true,
    122: true,
    244: true,
    44: true,
    83: true,
    86: true,
    118: true,
    128: true,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: true,
    139: true,
    134: true
  };
  H264Stream$1 = function() {
    var nalByteStream = new NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes4, readSequenceParameterSet, skipScalingList;
    H264Stream$1.prototype.init.call(this);
    self2 = this;
    this.push = function(packet) {
      if (packet.type !== "video") {
        return;
      }
      trackId = packet.trackId;
      currentPts = packet.pts;
      currentDts = packet.dts;
      nalByteStream.push(packet);
    };
    nalByteStream.on("data", function(data) {
      var event2 = {
        trackId,
        pts: currentPts,
        dts: currentDts,
        data,
        nalUnitTypeCode: data[0] & 31
      };
      switch (event2.nalUnitTypeCode) {
        case 5:
          event2.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          event2.nalUnitType = "sei_rbsp";
          event2.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          break;
        case 7:
          event2.nalUnitType = "seq_parameter_set_rbsp";
          event2.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          event2.config = readSequenceParameterSet(event2.escapedRBSP);
          break;
        case 8:
          event2.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          event2.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      self2.trigger("data", event2);
    });
    nalByteStream.on("done", function() {
      self2.trigger("done");
    });
    nalByteStream.on("partialdone", function() {
      self2.trigger("partialdone");
    });
    nalByteStream.on("reset", function() {
      self2.trigger("reset");
    });
    nalByteStream.on("endedtimeline", function() {
      self2.trigger("endedtimeline");
    });
    this.flush = function() {
      nalByteStream.flush();
    };
    this.partialFlush = function() {
      nalByteStream.partialFlush();
    };
    this.reset = function() {
      nalByteStream.reset();
    };
    this.endTimeline = function() {
      nalByteStream.endTimeline();
    };
    skipScalingList = function(count, expGolombDecoder) {
      var lastScale = 8, nextScale = 8, j, deltaScale;
      for (j = 0; j < count; j++) {
        if (nextScale !== 0) {
          deltaScale = expGolombDecoder.readExpGolomb();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    };
    discardEmulationPreventionBytes4 = function(data) {
      var length2 = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
      while (i < length2 - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length2 - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    readSequenceParameterSet = function(data) {
      var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i;
      expGolombDecoder = new ExpGolomb(data);
      profileIdc = expGolombDecoder.readUnsignedByte();
      profileCompatibility = expGolombDecoder.readUnsignedByte();
      levelIdc = expGolombDecoder.readUnsignedByte();
      expGolombDecoder.skipUnsignedExpGolomb();
      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
        if (chromaFormatIdc === 3) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (expGolombDecoder.readBoolean()) {
              if (i < 6) {
                skipScalingList(16, expGolombDecoder);
              } else {
                skipScalingList(64, expGolombDecoder);
              }
            }
          }
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
      if (picOrderCntType === 0) {
        expGolombDecoder.readUnsignedExpGolomb();
      } else if (picOrderCntType === 1) {
        expGolombDecoder.skipBits(1);
        expGolombDecoder.skipExpGolomb();
        expGolombDecoder.skipExpGolomb();
        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          expGolombDecoder.skipExpGolomb();
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      expGolombDecoder.skipBits(1);
      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      frameMbsOnlyFlag = expGolombDecoder.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        expGolombDecoder.skipBits(1);
      }
      expGolombDecoder.skipBits(1);
      if (expGolombDecoder.readBoolean()) {
        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
      }
      if (expGolombDecoder.readBoolean()) {
        if (expGolombDecoder.readBoolean()) {
          aspectRatioIdc = expGolombDecoder.readUnsignedByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
              break;
            }
          }
          if (sarRatio) {
            sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        profileIdc,
        levelIdc,
        profileCompatibility,
        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
        // sar is sample aspect ratio
        sarRatio
      };
    };
  };
  H264Stream$1.prototype = new Stream$2();
  var h2642 = {
    H264Stream: H264Stream$1,
    NalByteStream
  };
  var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  var parseId3TagSize = function(header, byteIndex) {
    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
    returnSize = returnSize >= 0 ? returnSize : 0;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset3 = function(data, offset2) {
    if (data.length - offset2 < 10 || data[offset2] !== "I".charCodeAt(0) || data[offset2 + 1] !== "D".charCodeAt(0) || data[offset2 + 2] !== "3".charCodeAt(0)) {
      return offset2;
    }
    offset2 += parseId3TagSize(data, offset2);
    return getId3Offset3(data, offset2);
  };
  var isLikelyAacData$1 = function(data) {
    var offset2 = getId3Offset3(data, 0);
    return data.length >= offset2 + 2 && (data[offset2] & 255) === 255 && (data[offset2 + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (data[offset2 + 1] & 22) === 16;
  };
  var parseSyncSafeInteger = function(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  };
  var percentEncode = function(bytes, start2, end2) {
    var i, result = "";
    for (i = start2; i < end2; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  };
  var parseIso88591 = function(bytes, start2, end2) {
    return unescape(percentEncode(bytes, start2, end2));
  };
  var parseAdtsSize = function(header, byteIndex) {
    var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
    return highTwo | middle | lowThree;
  };
  var parseType$4 = function(header, byteIndex) {
    if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
      return "timed-metadata";
    } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
      return "audio";
    }
    return null;
  };
  var parseSampleRate = function(packet) {
    var i = 0;
    while (i + 5 < packet.length) {
      if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
        i++;
        continue;
      }
      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
    }
    return null;
  };
  var parseAacTimestamp = function(packet) {
    var frameStart, frameSize, frame, frameHeader;
    frameStart = 10;
    if (packet[5] & 64) {
      frameStart += 4;
      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
    }
    do {
      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
      if (frameSize < 1) {
        return null;
      }
      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
      if (frameHeader === "PRIV") {
        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
        for (var i = 0; i < frame.byteLength; i++) {
          if (frame[i] === 0) {
            var owner = parseIso88591(frame, 0, i);
            if (owner === "com.apple.streaming.transportStreamTimestamp") {
              var d = frame.subarray(i + 1);
              var size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
              size *= 4;
              size += d[7] & 3;
              return size;
            }
            break;
          }
        }
      }
      frameStart += 10;
      frameStart += frameSize;
    } while (frameStart < packet.byteLength);
    return null;
  };
  var utils2 = {
    isLikelyAacData: isLikelyAacData$1,
    parseId3TagSize,
    parseAdtsSize,
    parseType: parseType$4,
    parseSampleRate,
    parseAacTimestamp
  };
  var Stream$1 = stream;
  var aacUtils = utils2;
  var AacStream$1;
  AacStream$1 = function() {
    var everything = new Uint8Array(), timeStamp = 0;
    AacStream$1.prototype.init.call(this);
    this.setTimestamp = function(timestamp) {
      timeStamp = timestamp;
    };
    this.push = function(bytes) {
      var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
      if (everything.length) {
        tempLength = everything.length;
        everything = new Uint8Array(bytes.byteLength + tempLength);
        everything.set(everything.subarray(0, tempLength));
        everything.set(bytes, tempLength);
      } else {
        everything = bytes;
      }
      while (everything.length - byteIndex >= 3) {
        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
          if (everything.length - byteIndex < 10) {
            break;
          }
          frameSize = aacUtils.parseId3TagSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          chunk = {
            type: "timed-metadata",
            data: everything.subarray(byteIndex, byteIndex + frameSize)
          };
          this.trigger("data", chunk);
          byteIndex += frameSize;
          continue;
        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
          if (everything.length - byteIndex < 7) {
            break;
          }
          frameSize = aacUtils.parseAdtsSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          packet = {
            type: "audio",
            data: everything.subarray(byteIndex, byteIndex + frameSize),
            pts: timeStamp,
            dts: timeStamp
          };
          this.trigger("data", packet);
          byteIndex += frameSize;
          continue;
        }
        byteIndex++;
      }
      bytesLeft = everything.length - byteIndex;
      if (bytesLeft > 0) {
        everything = everything.subarray(byteIndex);
      } else {
        everything = new Uint8Array();
      }
    };
    this.reset = function() {
      everything = new Uint8Array();
      this.trigger("reset");
    };
    this.endTimeline = function() {
      everything = new Uint8Array();
      this.trigger("endedtimeline");
    };
  };
  AacStream$1.prototype = new Stream$1();
  var aac2 = AacStream$1;
  var AUDIO_PROPERTIES$1 = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
  var audioProperties = AUDIO_PROPERTIES$1;
  var VIDEO_PROPERTIES$1 = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
  var videoProperties = VIDEO_PROPERTIES$1;
  var Stream2 = stream;
  var mp42 = mp4Generator;
  var frameUtils = frameUtils$1;
  var audioFrameUtils = audioFrameUtils$1;
  var trackDecodeInfo = trackDecodeInfo$1;
  var m2ts = m2ts_1;
  var clock2 = clock$2;
  var AdtsStream = adts;
  var H264Stream = h2642.H264Stream;
  var AacStream = aac2;
  var isLikelyAacData = utils2.isLikelyAacData;
  var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;
  var AUDIO_PROPERTIES = audioProperties;
  var VIDEO_PROPERTIES = videoProperties;
  var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;
  var retriggerForStream = function(key, event2) {
    event2.stream = key;
    this.trigger("log", event2);
  };
  var addPipelineLogRetriggers = function(transmuxer2, pipeline) {
    var keys2 = Object.keys(pipeline);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key === "headOfPipeline" || !pipeline[key].on) {
        continue;
      }
      pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
    }
  };
  var arrayEquals = function(a, b) {
    var i;
    if (a.length !== b.length) {
      return false;
    }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  var generateSegmentTimingInfo = function(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
    var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
    return {
      start: {
        dts: baseMediaDecodeTime,
        pts: baseMediaDecodeTime + ptsOffsetFromDts
      },
      end: {
        dts: baseMediaDecodeTime + decodeDuration,
        pts: baseMediaDecodeTime + presentationDuration
      },
      prependedContentDuration,
      baseMediaDecodeTime
    };
  };
  AudioSegmentStream = function(track, options) {
    var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    AudioSegmentStream.prototype.init.call(this);
    this.push = function(data) {
      trackDecodeInfo.collectDtsInfo(track, data);
      if (track) {
        AUDIO_PROPERTIES.forEach(function(prop) {
          track[prop] = data[prop];
        });
      }
      adtsFrames.push(data);
    };
    this.setEarliestDts = function(earliestDts) {
      earliestAllowedDts = earliestDts;
    };
    this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      videoBaseMediaDecodeTime = baseMediaDecodeTime;
    };
    this.setAudioAppendStart = function(timestamp) {
      audioAppendStartTs = timestamp;
    };
    this.flush = function() {
      var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
      if (adtsFrames.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
      track.samples = audioFrameUtils.generateSampleTable(frames);
      mdat2 = mp42.mdat(audioFrameUtils.concatenateFrameData(frames));
      adtsFrames = [];
      moof2 = mp42.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      trackDecodeInfo.clearDtsInfo(track);
      frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
      if (frames.length) {
        segmentDuration = frames.length * frameDuration;
        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(
          // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
          // frame info is in video clock cycles. Convert to match expectation of
          // listeners (that all timestamps will be based on video clock cycles).
          clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
          // frame times are already in video clock, as is segment duration
          frames[0].dts,
          frames[0].pts,
          frames[0].dts + segmentDuration,
          frames[0].pts + segmentDuration,
          videoClockCyclesOfSilencePrefixed || 0
        ));
        this.trigger("timingInfo", {
          start: frames[0].pts,
          end: frames[0].pts + segmentDuration
        });
      }
      this.trigger("data", {
        track,
        boxes
      });
      this.trigger("done", "AudioSegmentStream");
    };
    this.reset = function() {
      trackDecodeInfo.clearDtsInfo(track);
      adtsFrames = [];
      this.trigger("reset");
    };
  };
  AudioSegmentStream.prototype = new Stream2();
  VideoSegmentStream = function(track, options) {
    var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config, pps;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    VideoSegmentStream.prototype.init.call(this);
    delete track.minPTS;
    this.gopCache_ = [];
    this.push = function(nalUnit) {
      trackDecodeInfo.collectDtsInfo(track, nalUnit);
      if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
        config = nalUnit.config;
        track.sps = [nalUnit.data];
        VIDEO_PROPERTIES.forEach(function(prop) {
          track[prop] = config[prop];
        }, this);
      }
      if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
        pps = nalUnit.data;
        track.pps = [nalUnit.data];
      }
      nalUnits.push(nalUnit);
    };
    this.flush = function() {
      var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
      while (nalUnits.length) {
        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
          break;
        }
        nalUnits.shift();
      }
      if (nalUnits.length === 0) {
        this.resetStream_();
        this.trigger("done", "VideoSegmentStream");
        return;
      }
      frames = frameUtils.groupNalsIntoFrames(nalUnits);
      gops = frameUtils.groupFramesIntoGops(frames);
      if (!gops[0][0].keyFrame) {
        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
        if (gopForFusion) {
          prependedContentDuration = gopForFusion.duration;
          gops.unshift(gopForFusion);
          gops.byteLength += gopForFusion.byteLength;
          gops.nalCount += gopForFusion.nalCount;
          gops.pts = gopForFusion.pts;
          gops.dts = gopForFusion.dts;
          gops.duration += gopForFusion.duration;
        } else {
          gops = frameUtils.extendFirstKeyFrame(gops);
        }
      }
      if (gopsToAlignWith.length) {
        var alignedGops;
        if (options.alignGopsAtEnd) {
          alignedGops = this.alignGopsAtEnd_(gops);
        } else {
          alignedGops = this.alignGopsAtStart_(gops);
        }
        if (!alignedGops) {
          this.gopCache_.unshift({
            gop: gops.pop(),
            pps: track.pps,
            sps: track.sps
          });
          this.gopCache_.length = Math.min(6, this.gopCache_.length);
          nalUnits = [];
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
          return;
        }
        trackDecodeInfo.clearDtsInfo(track);
        gops = alignedGops;
      }
      trackDecodeInfo.collectDtsInfo(track, gops);
      track.samples = frameUtils.generateSampleTable(gops);
      mdat2 = mp42.mdat(frameUtils.concatenateNalData(gops));
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      this.trigger("processedGopsInfo", gops.map(function(gop) {
        return {
          pts: gop.pts,
          dts: gop.dts,
          byteLength: gop.byteLength
        };
      }));
      firstGop = gops[0];
      lastGop = gops[gops.length - 1];
      this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
      this.trigger("timingInfo", {
        start: gops[0].pts,
        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
      });
      this.gopCache_.unshift({
        gop: gops.pop(),
        pps: track.pps,
        sps: track.sps
      });
      this.gopCache_.length = Math.min(6, this.gopCache_.length);
      nalUnits = [];
      this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
      this.trigger("timelineStartInfo", track.timelineStartInfo);
      moof2 = mp42.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      this.trigger("data", {
        track,
        boxes
      });
      this.resetStream_();
      this.trigger("done", "VideoSegmentStream");
    };
    this.reset = function() {
      this.resetStream_();
      nalUnits = [];
      this.gopCache_.length = 0;
      gopsToAlignWith.length = 0;
      this.trigger("reset");
    };
    this.resetStream_ = function() {
      trackDecodeInfo.clearDtsInfo(track);
      config = void 0;
      pps = void 0;
    };
    this.getGopForFusion_ = function(nalUnit) {
      var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i;
      for (i = 0; i < this.gopCache_.length; i++) {
        currentGopObj = this.gopCache_[i];
        currentGop = currentGopObj.gop;
        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
          continue;
        }
        if (currentGop.dts < track.timelineStartInfo.dts) {
          continue;
        }
        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
          if (!nearestGopObj || nearestDistance > dtsDistance) {
            nearestGopObj = currentGopObj;
            nearestDistance = dtsDistance;
          }
        }
      }
      if (nearestGopObj) {
        return nearestGopObj.gop;
      }
      return null;
    };
    this.alignGopsAtStart_ = function(gops) {
      var alignIndex, gopIndex, align, gop, byteLength2, nalCount, duration2, alignedGops;
      byteLength2 = gops.byteLength;
      nalCount = gops.nalCount;
      duration2 = gops.duration;
      alignIndex = gopIndex = 0;
      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          break;
        }
        if (gop.pts > align.pts) {
          alignIndex++;
          continue;
        }
        gopIndex++;
        byteLength2 -= gop.byteLength;
        nalCount -= gop.nalCount;
        duration2 -= gop.duration;
      }
      if (gopIndex === 0) {
        return gops;
      }
      if (gopIndex === gops.length) {
        return null;
      }
      alignedGops = gops.slice(gopIndex);
      alignedGops.byteLength = byteLength2;
      alignedGops.duration = duration2;
      alignedGops.nalCount = nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsAtEnd_ = function(gops) {
      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
      alignIndex = gopsToAlignWith.length - 1;
      gopIndex = gops.length - 1;
      alignEndIndex = null;
      matchFound = false;
      while (alignIndex >= 0 && gopIndex >= 0) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          matchFound = true;
          break;
        }
        if (align.pts > gop.pts) {
          alignIndex--;
          continue;
        }
        if (alignIndex === gopsToAlignWith.length - 1) {
          alignEndIndex = gopIndex;
        }
        gopIndex--;
      }
      if (!matchFound && alignEndIndex === null) {
        return null;
      }
      var trimIndex;
      if (matchFound) {
        trimIndex = gopIndex;
      } else {
        trimIndex = alignEndIndex;
      }
      if (trimIndex === 0) {
        return gops;
      }
      var alignedGops = gops.slice(trimIndex);
      var metadata = alignedGops.reduce(function(total, gop2) {
        total.byteLength += gop2.byteLength;
        total.duration += gop2.duration;
        total.nalCount += gop2.nalCount;
        return total;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      alignedGops.byteLength = metadata.byteLength;
      alignedGops.duration = metadata.duration;
      alignedGops.nalCount = metadata.nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsWith = function(newGopsToAlignWith) {
      gopsToAlignWith = newGopsToAlignWith;
    };
  };
  VideoSegmentStream.prototype = new Stream2();
  CoalesceStream = function(options, metadataStream2) {
    this.numberOfTracks = 0;
    this.metadataStream = metadataStream2;
    options = options || {};
    if (typeof options.remux !== "undefined") {
      this.remuxTracks = !!options.remux;
    } else {
      this.remuxTracks = true;
    }
    if (typeof options.keepOriginalTimestamps === "boolean") {
      this.keepOriginalTimestamps = options.keepOriginalTimestamps;
    } else {
      this.keepOriginalTimestamps = false;
    }
    this.pendingTracks = [];
    this.videoTrack = null;
    this.pendingBoxes = [];
    this.pendingCaptions = [];
    this.pendingMetadata = [];
    this.pendingBytes = 0;
    this.emittedTracks = 0;
    CoalesceStream.prototype.init.call(this);
    this.push = function(output) {
      if (output.content || output.text) {
        return this.pendingCaptions.push(output);
      }
      if (output.frames) {
        return this.pendingMetadata.push(output);
      }
      this.pendingTracks.push(output.track);
      this.pendingBytes += output.boxes.byteLength;
      if (output.track.type === "video") {
        this.videoTrack = output.track;
        this.pendingBoxes.push(output.boxes);
      }
      if (output.track.type === "audio") {
        this.audioTrack = output.track;
        this.pendingBoxes.unshift(output.boxes);
      }
    };
  };
  CoalesceStream.prototype = new Stream2();
  CoalesceStream.prototype.flush = function(flushSource) {
    var offset2 = 0, event2 = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, caption, id32, initSegment, timelineStartPts = 0, i;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
        return;
      } else if (this.remuxTracks) {
        return;
      } else if (this.pendingTracks.length === 0) {
        this.emittedTracks++;
        if (this.emittedTracks >= this.numberOfTracks) {
          this.trigger("done");
          this.emittedTracks = 0;
        }
        return;
      }
    }
    if (this.videoTrack) {
      timelineStartPts = this.videoTrack.timelineStartInfo.pts;
      VIDEO_PROPERTIES.forEach(function(prop) {
        event2.info[prop] = this.videoTrack[prop];
      }, this);
    } else if (this.audioTrack) {
      timelineStartPts = this.audioTrack.timelineStartInfo.pts;
      AUDIO_PROPERTIES.forEach(function(prop) {
        event2.info[prop] = this.audioTrack[prop];
      }, this);
    }
    if (this.videoTrack || this.audioTrack) {
      if (this.pendingTracks.length === 1) {
        event2.type = this.pendingTracks[0].type;
      } else {
        event2.type = "combined";
      }
      this.emittedTracks += this.pendingTracks.length;
      initSegment = mp42.initSegment(this.pendingTracks);
      event2.initSegment = new Uint8Array(initSegment.byteLength);
      event2.initSegment.set(initSegment);
      event2.data = new Uint8Array(this.pendingBytes);
      for (i = 0; i < this.pendingBoxes.length; i++) {
        event2.data.set(this.pendingBoxes[i], offset2);
        offset2 += this.pendingBoxes[i].byteLength;
      }
      for (i = 0; i < this.pendingCaptions.length; i++) {
        caption = this.pendingCaptions[i];
        caption.startTime = clock2.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
        caption.endTime = clock2.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
        event2.captionStreams[caption.stream] = true;
        event2.captions.push(caption);
      }
      for (i = 0; i < this.pendingMetadata.length; i++) {
        id32 = this.pendingMetadata[i];
        id32.cueTime = clock2.metadataTsToSeconds(id32.pts, timelineStartPts, this.keepOriginalTimestamps);
        event2.metadata.push(id32);
      }
      event2.metadata.dispatchType = this.metadataStream.dispatchType;
      this.pendingTracks.length = 0;
      this.videoTrack = null;
      this.pendingBoxes.length = 0;
      this.pendingCaptions.length = 0;
      this.pendingBytes = 0;
      this.pendingMetadata.length = 0;
      this.trigger("data", event2);
      for (i = 0; i < event2.captions.length; i++) {
        caption = event2.captions[i];
        this.trigger("caption", caption);
      }
      for (i = 0; i < event2.metadata.length; i++) {
        id32 = event2.metadata[i];
        this.trigger("id3Frame", id32);
      }
    }
    if (this.emittedTracks >= this.numberOfTracks) {
      this.trigger("done");
      this.emittedTracks = 0;
    }
  };
  CoalesceStream.prototype.setRemux = function(val) {
    this.remuxTracks = val;
  };
  Transmuxer = function(options) {
    var self2 = this, hasFlushed = true, videoTrack, audioTrack;
    Transmuxer.prototype.init.call(this);
    options = options || {};
    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
    this.transmuxPipeline_ = {};
    this.setupAacPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "aac";
      pipeline.metadataStream = new m2ts.MetadataStream();
      pipeline.aacStream = new AacStream();
      pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream("audio");
      pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream("timed-metadata");
      pipeline.adtsStream = new AdtsStream();
      pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.aacStream;
      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.metadataStream.on("timestamp", function(frame) {
        pipeline.aacStream.setTimestamp(frame.timeStamp);
      });
      pipeline.aacStream.on("data", function(data) {
        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
          return;
        }
        audioTrack = audioTrack || {
          timelineStartInfo: {
            baseMediaDecodeTime: self2.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        };
        pipeline.coalesceStream.numberOfTracks++;
        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
        pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
        pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
        self2.trigger("trackinfo", {
          hasAudio: !!audioTrack,
          hasVideo: !!videoTrack
        });
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setupTsPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "ts";
      pipeline.metadataStream = new m2ts.MetadataStream();
      pipeline.packetStream = new m2ts.TransportPacketStream();
      pipeline.parseStream = new m2ts.TransportParseStream();
      pipeline.elementaryStream = new m2ts.ElementaryStream();
      pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();
      pipeline.adtsStream = new AdtsStream();
      pipeline.h264Stream = new H264Stream();
      pipeline.captionStream = new m2ts.CaptionStream(options);
      pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.packetStream;
      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
      pipeline.elementaryStream.on("data", function(data) {
        var i;
        if (data.type === "metadata") {
          i = data.tracks.length;
          while (i--) {
            if (!videoTrack && data.tracks[i].type === "video") {
              videoTrack = data.tracks[i];
              videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            } else if (!audioTrack && data.tracks[i].type === "audio") {
              audioTrack = data.tracks[i];
              audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            }
          }
          if (videoTrack && !pipeline.videoSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);
            pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
            pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
              if (audioTrack && !options.keepOriginalTimestamps) {
                audioTrack.timelineStartInfo = timelineStartInfo;
                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
            pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
            pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
              if (audioTrack) {
                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
          }
          if (audioTrack && !pipeline.audioSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
            pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
            pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
            pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          }
          self2.trigger("trackinfo", {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        }
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
        self2.trigger("id3Frame", id3Frame);
      });
      pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      var pipeline = this.transmuxPipeline_;
      if (!options.keepOriginalTimestamps) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
      }
      if (audioTrack) {
        audioTrack.timelineStartInfo.dts = void 0;
        audioTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(audioTrack);
        if (pipeline.audioTimestampRolloverStream) {
          pipeline.audioTimestampRolloverStream.discontinuity();
        }
      }
      if (videoTrack) {
        if (pipeline.videoSegmentStream) {
          pipeline.videoSegmentStream.gopCache_ = [];
        }
        videoTrack.timelineStartInfo.dts = void 0;
        videoTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(videoTrack);
        pipeline.captionStream.reset();
      }
      if (pipeline.timestampRolloverStream) {
        pipeline.timestampRolloverStream.discontinuity();
      }
    };
    this.setAudioAppendStart = function(timestamp) {
      if (audioTrack) {
        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
      }
    };
    this.setRemux = function(val) {
      var pipeline = this.transmuxPipeline_;
      options.remux = val;
      if (pipeline && pipeline.coalesceStream) {
        pipeline.coalesceStream.setRemux(val);
      }
    };
    this.alignGopsWith = function(gopsToAlignWith) {
      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
      }
    };
    this.getLogTrigger_ = function(key) {
      var self3 = this;
      return function(event2) {
        event2.stream = key;
        self3.trigger("log", event2);
      };
    };
    this.push = function(data) {
      if (hasFlushed) {
        var isAac = isLikelyAacData(data);
        if (isAac && this.transmuxPipeline_.type !== "aac") {
          this.setupAacPipeline();
        } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
          this.setupTsPipeline();
        }
        hasFlushed = false;
      }
      this.transmuxPipeline_.headOfPipeline.push(data);
    };
    this.flush = function() {
      hasFlushed = true;
      this.transmuxPipeline_.headOfPipeline.flush();
    };
    this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    };
    this.reset = function() {
      if (this.transmuxPipeline_.headOfPipeline) {
        this.transmuxPipeline_.headOfPipeline.reset();
      }
    };
    this.resetCaptions = function() {
      if (this.transmuxPipeline_.captionStream) {
        this.transmuxPipeline_.captionStream.reset();
      }
    };
  };
  Transmuxer.prototype = new Stream2();
  var transmuxer = {
    Transmuxer,
    VideoSegmentStream,
    AudioSegmentStream,
    AUDIO_PROPERTIES,
    VIDEO_PROPERTIES,
    // exported for testing
    generateSegmentTimingInfo
  };
  var toUnsigned$3 = function(value2) {
    return value2 >>> 0;
  };
  var toHexString$1 = function(value2) {
    return ("00" + value2.toString(16)).slice(-2);
  };
  var bin2 = {
    toUnsigned: toUnsigned$3,
    toHexString: toHexString$1
  };
  var parseType$3 = function(buffer) {
    var result = "";
    result += String.fromCharCode(buffer[0]);
    result += String.fromCharCode(buffer[1]);
    result += String.fromCharCode(buffer[2]);
    result += String.fromCharCode(buffer[3]);
    return result;
  };
  var parseType_1 = parseType$3;
  var toUnsigned$2 = bin2.toUnsigned;
  var parseType$2 = parseType_1;
  var findBox$2 = function(data, path2) {
    var results = [], i, size, type2, end2, subresults;
    if (!path2.length) {
      return null;
    }
    for (i = 0; i < data.byteLength; ) {
      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
      type2 = parseType$2(data.subarray(i + 4, i + 8));
      end2 = size > 1 ? i + size : data.byteLength;
      if (type2 === path2[0]) {
        if (path2.length === 1) {
          results.push(data.subarray(i + 8, end2));
        } else {
          subresults = findBox$2(data.subarray(i + 8, end2), path2.slice(1));
          if (subresults.length) {
            results = results.concat(subresults);
          }
        }
      }
      i = end2;
    }
    return results;
  };
  var findBox_1 = findBox$2;
  var toUnsigned$1 = bin2.toUnsigned;
  var getUint64$2 = numbers2.getUint64;
  var tfdt = function(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4))
    };
    if (result.version === 1) {
      result.baseMediaDecodeTime = getUint64$2(data.subarray(4));
    } else {
      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
    }
    return result;
  };
  var parseTfdt$2 = tfdt;
  var parseSampleFlags$1 = function(flags) {
    return {
      isLeading: (flags[0] & 12) >>> 2,
      dependsOn: flags[0] & 3,
      isDependedOn: (flags[1] & 192) >>> 6,
      hasRedundancy: (flags[1] & 48) >>> 4,
      paddingValue: (flags[1] & 14) >>> 1,
      isNonSyncSample: flags[1] & 1,
      degradationPriority: flags[2] << 8 | flags[3]
    };
  };
  var parseSampleFlags_1 = parseSampleFlags$1;
  var parseSampleFlags = parseSampleFlags_1;
  var trun = function(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset2 = 8, sample;
    if (dataOffsetPresent) {
      result.dataOffset = view.getInt32(offset2);
      offset2 += 4;
    }
    if (firstSampleFlagsPresent && sampleCount) {
      sample = {
        flags: parseSampleFlags(data.subarray(offset2, offset2 + 4))
      };
      offset2 += 4;
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset2);
        offset2 += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset2);
        offset2 += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset2);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset2);
        }
        offset2 += 4;
      }
      result.samples.push(sample);
      sampleCount--;
    }
    while (sampleCount--) {
      sample = {};
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset2);
        offset2 += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset2);
        offset2 += 4;
      }
      if (sampleFlagsPresent) {
        sample.flags = parseSampleFlags(data.subarray(offset2, offset2 + 4));
        offset2 += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset2);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset2);
        }
        offset2 += 4;
      }
      result.samples.push(sample);
    }
    return result;
  };
  var parseTrun$2 = trun;
  var tfhd = function(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4)
    }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i;
    i = 8;
    if (baseDataOffsetPresent) {
      i += 4;
      result.baseDataOffset = view.getUint32(12);
      i += 4;
    }
    if (sampleDescriptionIndexPresent) {
      result.sampleDescriptionIndex = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleDurationPresent) {
      result.defaultSampleDuration = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleSizePresent) {
      result.defaultSampleSize = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleFlagsPresent) {
      result.defaultSampleFlags = view.getUint32(i);
    }
    if (durationIsEmpty) {
      result.durationIsEmpty = true;
    }
    if (!baseDataOffsetPresent && defaultBaseIsMoof) {
      result.baseDataOffsetIsMoof = true;
    }
    return result;
  };
  var parseTfhd$2 = tfhd;
  var win2;
  if (typeof window !== "undefined") {
    win2 = window;
  } else if (typeof commonjsGlobal2 !== "undefined") {
    win2 = commonjsGlobal2;
  } else if (typeof self !== "undefined") {
    win2 = self;
  } else {
    win2 = {};
  }
  var window_12 = win2;
  var discardEmulationPreventionBytes3 = captionPacketParser.discardEmulationPreventionBytes;
  var CaptionStream = captionStream.CaptionStream;
  var findBox$1 = findBox_1;
  var parseTfdt$1 = parseTfdt$2;
  var parseTrun$1 = parseTrun$2;
  var parseTfhd$1 = parseTfhd$2;
  var window$22 = window_12;
  var mapToSample = function(offset2, samples) {
    var approximateOffset = offset2;
    for (var i = 0; i < samples.length; i++) {
      var sample = samples[i];
      if (approximateOffset < sample.size) {
        return sample;
      }
      approximateOffset -= sample.size;
    }
    return null;
  };
  var findSeiNals = function(avcStream, samples, trackId) {
    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
      logs: [],
      seiNals: []
    }, seiNal, i, length2, lastMatchedSample;
    for (i = 0; i + 4 < avcStream.length; i += length2) {
      length2 = avcView.getUint32(i);
      i += 4;
      if (length2 <= 0) {
        continue;
      }
      switch (avcStream[i] & 31) {
        case 6:
          var data = avcStream.subarray(i + 1, i + 1 + length2);
          var matchingSample = mapToSample(i, samples);
          seiNal = {
            nalUnitType: "sei_rbsp",
            size: length2,
            data,
            escapedRBSP: discardEmulationPreventionBytes3(data),
            trackId
          };
          if (matchingSample) {
            seiNal.pts = matchingSample.pts;
            seiNal.dts = matchingSample.dts;
            lastMatchedSample = matchingSample;
          } else if (lastMatchedSample) {
            seiNal.pts = lastMatchedSample.pts;
            seiNal.dts = lastMatchedSample.dts;
          } else {
            result.logs.push({
              level: "warn",
              message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
            });
            break;
          }
          result.seiNals.push(seiNal);
          break;
      }
    }
    return result;
  };
  var parseSamples = function(truns, baseMediaDecodeTime, tfhd2) {
    var currentDts = baseMediaDecodeTime;
    var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
    var defaultSampleSize = tfhd2.defaultSampleSize || 0;
    var trackId = tfhd2.trackId;
    var allSamples = [];
    truns.forEach(function(trun2) {
      var trackRun = parseTrun$1(trun2);
      var samples = trackRun.samples;
      samples.forEach(function(sample) {
        if (sample.duration === void 0) {
          sample.duration = defaultSampleDuration;
        }
        if (sample.size === void 0) {
          sample.size = defaultSampleSize;
        }
        sample.trackId = trackId;
        sample.dts = currentDts;
        if (sample.compositionTimeOffset === void 0) {
          sample.compositionTimeOffset = 0;
        }
        if (typeof currentDts === "bigint") {
          sample.pts = currentDts + window$22.BigInt(sample.compositionTimeOffset);
          currentDts += window$22.BigInt(sample.duration);
        } else {
          sample.pts = currentDts + sample.compositionTimeOffset;
          currentDts += sample.duration;
        }
      });
      allSamples = allSamples.concat(samples);
    });
    return allSamples;
  };
  var parseCaptionNals = function(segment, videoTrackId) {
    var trafs = findBox$1(segment, ["moof", "traf"]);
    var mdats = findBox$1(segment, ["mdat"]);
    var captionNals = {};
    var mdatTrafPairs = [];
    mdats.forEach(function(mdat2, index) {
      var matchingTraf = trafs[index];
      mdatTrafPairs.push({
        mdat: mdat2,
        traf: matchingTraf
      });
    });
    mdatTrafPairs.forEach(function(pair) {
      var mdat2 = pair.mdat;
      var traf2 = pair.traf;
      var tfhd2 = findBox$1(traf2, ["tfhd"]);
      var headerInfo = parseTfhd$1(tfhd2[0]);
      var trackId = headerInfo.trackId;
      var tfdt2 = findBox$1(traf2, ["tfdt"]);
      var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt$1(tfdt2[0]).baseMediaDecodeTime : 0;
      var truns = findBox$1(traf2, ["trun"]);
      var samples;
      var result;
      if (videoTrackId === trackId && truns.length > 0) {
        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
        result = findSeiNals(mdat2, samples, trackId);
        if (!captionNals[trackId]) {
          captionNals[trackId] = {
            seiNals: [],
            logs: []
          };
        }
        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
      }
    });
    return captionNals;
  };
  var parseEmbeddedCaptions = function(segment, trackId, timescale2) {
    var captionNals;
    if (trackId === null) {
      return null;
    }
    captionNals = parseCaptionNals(segment, trackId);
    var trackNals = captionNals[trackId] || {};
    return {
      seiNals: trackNals.seiNals,
      logs: trackNals.logs,
      timescale: timescale2
    };
  };
  var CaptionParser = function() {
    var isInitialized = false;
    var captionStream2;
    var segmentCache;
    var trackId;
    var timescale2;
    var parsedCaptions;
    var parsingPartial;
    this.isInitialized = function() {
      return isInitialized;
    };
    this.init = function(options) {
      captionStream2 = new CaptionStream();
      isInitialized = true;
      parsingPartial = options ? options.isPartial : false;
      captionStream2.on("data", function(event2) {
        event2.startTime = event2.startPts / timescale2;
        event2.endTime = event2.endPts / timescale2;
        parsedCaptions.captions.push(event2);
        parsedCaptions.captionStreams[event2.stream] = true;
      });
      captionStream2.on("log", function(log2) {
        parsedCaptions.logs.push(log2);
      });
    };
    this.isNewInit = function(videoTrackIds, timescales) {
      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
        return false;
      }
      return trackId !== videoTrackIds[0] || timescale2 !== timescales[trackId];
    };
    this.parse = function(segment, videoTrackIds, timescales) {
      var parsedData;
      if (!this.isInitialized()) {
        return null;
      } else if (!videoTrackIds || !timescales) {
        return null;
      } else if (this.isNewInit(videoTrackIds, timescales)) {
        trackId = videoTrackIds[0];
        timescale2 = timescales[trackId];
      } else if (trackId === null || !timescale2) {
        segmentCache.push(segment);
        return null;
      }
      while (segmentCache.length > 0) {
        var cachedSegment = segmentCache.shift();
        this.parse(cachedSegment, videoTrackIds, timescales);
      }
      parsedData = parseEmbeddedCaptions(segment, trackId, timescale2);
      if (parsedData && parsedData.logs) {
        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
      }
      if (parsedData === null || !parsedData.seiNals) {
        if (parsedCaptions.logs.length) {
          return {
            logs: parsedCaptions.logs,
            captions: [],
            captionStreams: []
          };
        }
        return null;
      }
      this.pushNals(parsedData.seiNals);
      this.flushStream();
      return parsedCaptions;
    };
    this.pushNals = function(nals) {
      if (!this.isInitialized() || !nals || nals.length === 0) {
        return null;
      }
      nals.forEach(function(nal) {
        captionStream2.push(nal);
      });
    };
    this.flushStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      if (!parsingPartial) {
        captionStream2.flush();
      } else {
        captionStream2.partialFlush();
      }
    };
    this.clearParsedCaptions = function() {
      parsedCaptions.captions = [];
      parsedCaptions.captionStreams = {};
      parsedCaptions.logs = [];
    };
    this.resetCaptionStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      captionStream2.reset();
    };
    this.clearAllCaptions = function() {
      this.clearParsedCaptions();
      this.resetCaptionStream();
    };
    this.reset = function() {
      segmentCache = [];
      trackId = null;
      timescale2 = null;
      if (!parsedCaptions) {
        parsedCaptions = {
          captions: [],
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          logs: []
        };
      } else {
        this.clearParsedCaptions();
      }
      this.resetCaptionStream();
    };
    this.reset();
  };
  var captionParser = CaptionParser;
  var uint8ToCString$1 = function(data) {
    var index = 0;
    var curChar = String.fromCharCode(data[index]);
    var retString = "";
    while (curChar !== "\0") {
      retString += curChar;
      index++;
      curChar = String.fromCharCode(data[index]);
    }
    retString += curChar;
    return retString;
  };
  var string = {
    uint8ToCString: uint8ToCString$1
  };
  var uint8ToCString = string.uint8ToCString;
  var getUint64$12 = numbers2.getUint64;
  var parseEmsgBox = function(boxData) {
    var offset2 = 4;
    var version2 = boxData[0];
    var scheme_id_uri, value2, timescale2, presentation_time, presentation_time_delta, event_duration, id, message_data;
    if (version2 === 0) {
      scheme_id_uri = uint8ToCString(boxData.subarray(offset2));
      offset2 += scheme_id_uri.length;
      value2 = uint8ToCString(boxData.subarray(offset2));
      offset2 += value2.length;
      var dv = new DataView(boxData.buffer);
      timescale2 = dv.getUint32(offset2);
      offset2 += 4;
      presentation_time_delta = dv.getUint32(offset2);
      offset2 += 4;
      event_duration = dv.getUint32(offset2);
      offset2 += 4;
      id = dv.getUint32(offset2);
      offset2 += 4;
    } else if (version2 === 1) {
      var dv = new DataView(boxData.buffer);
      timescale2 = dv.getUint32(offset2);
      offset2 += 4;
      presentation_time = getUint64$12(boxData.subarray(offset2));
      offset2 += 8;
      event_duration = dv.getUint32(offset2);
      offset2 += 4;
      id = dv.getUint32(offset2);
      offset2 += 4;
      scheme_id_uri = uint8ToCString(boxData.subarray(offset2));
      offset2 += scheme_id_uri.length;
      value2 = uint8ToCString(boxData.subarray(offset2));
      offset2 += value2.length;
    }
    message_data = new Uint8Array(boxData.subarray(offset2, boxData.byteLength));
    var emsgBox = {
      scheme_id_uri,
      value: value2,
      // if timescale is undefined or 0 set to 1 
      timescale: timescale2 ? timescale2 : 1,
      presentation_time,
      presentation_time_delta,
      event_duration,
      id,
      message_data
    };
    return isValidEmsgBox(version2, emsgBox) ? emsgBox : void 0;
  };
  var scaleTime = function(presentationTime, timescale2, timeDelta, offset2) {
    return presentationTime || presentationTime === 0 ? presentationTime / timescale2 : offset2 + timeDelta / timescale2;
  };
  var isValidEmsgBox = function(version2, emsg2) {
    var hasScheme = emsg2.scheme_id_uri !== "\0";
    var isValidV0Box = version2 === 0 && isDefined(emsg2.presentation_time_delta) && hasScheme;
    var isValidV1Box = version2 === 1 && isDefined(emsg2.presentation_time) && hasScheme;
    return !(version2 > 1) && isValidV0Box || isValidV1Box;
  };
  var isDefined = function(data) {
    return data !== void 0 || data !== null;
  };
  var emsg$1 = {
    parseEmsgBox,
    scaleTime
  };
  var toUnsigned = bin2.toUnsigned;
  var toHexString = bin2.toHexString;
  var findBox3 = findBox_1;
  var parseType$1 = parseType_1;
  var emsg = emsg$1;
  var parseTfhd = parseTfhd$2;
  var parseTrun = parseTrun$2;
  var parseTfdt = parseTfdt$2;
  var getUint642 = numbers2.getUint64;
  var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader, getEmsgID3;
  var window$12 = window_12;
  var parseId3Frames = parseId3.parseId3Frames;
  timescale = function(init) {
    var result = {}, traks = findBox3(init, ["moov", "trak"]);
    return traks.reduce(function(result2, trak2) {
      var tkhd2, version2, index, id, mdhd2;
      tkhd2 = findBox3(trak2, ["tkhd"])[0];
      if (!tkhd2) {
        return null;
      }
      version2 = tkhd2[0];
      index = version2 === 0 ? 12 : 20;
      id = toUnsigned(tkhd2[index] << 24 | tkhd2[index + 1] << 16 | tkhd2[index + 2] << 8 | tkhd2[index + 3]);
      mdhd2 = findBox3(trak2, ["mdia", "mdhd"])[0];
      if (!mdhd2) {
        return null;
      }
      version2 = mdhd2[0];
      index = version2 === 0 ? 12 : 20;
      result2[id] = toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
      return result2;
    }, result);
  };
  startTime = function(timescale2, fragment) {
    var trafs;
    trafs = findBox3(fragment, ["moof", "traf"]);
    var lowestTime = trafs.reduce(function(acc, traf2) {
      var tfhd2 = findBox3(traf2, ["tfhd"])[0];
      var id = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
      var scale = timescale2[id] || 9e4;
      var tfdt2 = findBox3(traf2, ["tfdt"])[0];
      var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
      var baseTime;
      if (tfdt2[0] === 1) {
        baseTime = getUint642(tfdt2.subarray(4, 12));
      } else {
        baseTime = dv.getUint32(4);
      }
      let seconds;
      if (typeof baseTime === "bigint") {
        seconds = baseTime / window$12.BigInt(scale);
      } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
        seconds = baseTime / scale;
      }
      if (seconds < Number.MAX_SAFE_INTEGER) {
        seconds = Number(seconds);
      }
      if (seconds < acc) {
        acc = seconds;
      }
      return acc;
    }, Infinity);
    return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
  };
  compositionStartTime = function(timescales, fragment) {
    var trafBoxes = findBox3(fragment, ["moof", "traf"]);
    var baseMediaDecodeTime = 0;
    var compositionTimeOffset = 0;
    var trackId;
    if (trafBoxes && trafBoxes.length) {
      var tfhd2 = findBox3(trafBoxes[0], ["tfhd"])[0];
      var trun2 = findBox3(trafBoxes[0], ["trun"])[0];
      var tfdt2 = findBox3(trafBoxes[0], ["tfdt"])[0];
      if (tfhd2) {
        var parsedTfhd = parseTfhd(tfhd2);
        trackId = parsedTfhd.trackId;
      }
      if (tfdt2) {
        var parsedTfdt = parseTfdt(tfdt2);
        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
      }
      if (trun2) {
        var parsedTrun = parseTrun(trun2);
        if (parsedTrun.samples && parsedTrun.samples.length) {
          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
        }
      }
    }
    var timescale2 = timescales[trackId] || 9e4;
    if (typeof baseMediaDecodeTime === "bigint") {
      compositionTimeOffset = window$12.BigInt(compositionTimeOffset);
      timescale2 = window$12.BigInt(timescale2);
    }
    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale2;
    if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
      result = Number(result);
    }
    return result;
  };
  getVideoTrackIds = function(init) {
    var traks = findBox3(init, ["moov", "trak"]);
    var videoTrackIds = [];
    traks.forEach(function(trak2) {
      var hdlrs = findBox3(trak2, ["mdia", "hdlr"]);
      var tkhds = findBox3(trak2, ["tkhd"]);
      hdlrs.forEach(function(hdlr2, index) {
        var handlerType = parseType$1(hdlr2.subarray(8, 12));
        var tkhd2 = tkhds[index];
        var view;
        var version2;
        var trackId;
        if (handlerType === "vide") {
          view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
          version2 = view.getUint8(0);
          trackId = version2 === 0 ? view.getUint32(12) : view.getUint32(20);
          videoTrackIds.push(trackId);
        }
      });
    });
    return videoTrackIds;
  };
  getTimescaleFromMediaHeader = function(mdhd2) {
    var version2 = mdhd2[0];
    var index = version2 === 0 ? 12 : 20;
    return toUnsigned(mdhd2[index] << 24 | mdhd2[index + 1] << 16 | mdhd2[index + 2] << 8 | mdhd2[index + 3]);
  };
  getTracks = function(init) {
    var traks = findBox3(init, ["moov", "trak"]);
    var tracks = [];
    traks.forEach(function(trak2) {
      var track = {};
      var tkhd2 = findBox3(trak2, ["tkhd"])[0];
      var view, tkhdVersion;
      if (tkhd2) {
        view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
        tkhdVersion = view.getUint8(0);
        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
      }
      var hdlr2 = findBox3(trak2, ["mdia", "hdlr"])[0];
      if (hdlr2) {
        var type2 = parseType$1(hdlr2.subarray(8, 12));
        if (type2 === "vide") {
          track.type = "video";
        } else if (type2 === "soun") {
          track.type = "audio";
        } else {
          track.type = type2;
        }
      }
      var stsd2 = findBox3(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
      if (stsd2) {
        var sampleDescriptions = stsd2.subarray(8);
        track.codec = parseType$1(sampleDescriptions.subarray(4, 8));
        var codecBox = findBox3(sampleDescriptions, [track.codec])[0];
        var codecConfig, codecConfigType;
        if (codecBox) {
          if (/^[asm]vc[1-9]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(78);
            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
            if (codecConfigType === "avcC" && codecConfig.length > 11) {
              track.codec += ".";
              track.codec += toHexString(codecConfig[9]);
              track.codec += toHexString(codecConfig[10]);
              track.codec += toHexString(codecConfig[11]);
            } else {
              track.codec = "avc1.4d400d";
            }
          } else if (/^mp4[a,v]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(28);
            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
              track.codec += "." + toHexString(codecConfig[19]);
              track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
            } else {
              track.codec = "mp4a.40.2";
            }
          } else {
            track.codec = track.codec.toLowerCase();
          }
        }
      }
      var mdhd2 = findBox3(trak2, ["mdia", "mdhd"])[0];
      if (mdhd2) {
        track.timescale = getTimescaleFromMediaHeader(mdhd2);
      }
      tracks.push(track);
    });
    return tracks;
  };
  getEmsgID3 = function(segmentData, offset2 = 0) {
    var emsgBoxes = findBox3(segmentData, ["emsg"]);
    return emsgBoxes.map((data) => {
      var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));
      var parsedId3Frames = parseId3Frames(parsedBox.message_data);
      return {
        cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset2),
        duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),
        frames: parsedId3Frames
      };
    });
  };
  var probe$2 = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: findBox3,
    parseType: parseType$1,
    timescale,
    startTime,
    compositionStartTime,
    videoTrackIds: getVideoTrackIds,
    tracks: getTracks,
    getTimescaleFromMediaHeader,
    getEmsgID3
  };
  var StreamTypes$1 = streamTypes;
  var parsePid = function(packet) {
    var pid = packet[1] & 31;
    pid <<= 8;
    pid |= packet[2];
    return pid;
  };
  var parsePayloadUnitStartIndicator = function(packet) {
    return !!(packet[1] & 64);
  };
  var parseAdaptionField = function(packet) {
    var offset2 = 0;
    if ((packet[3] & 48) >>> 4 > 1) {
      offset2 += packet[4] + 1;
    }
    return offset2;
  };
  var parseType = function(packet, pmtPid) {
    var pid = parsePid(packet);
    if (pid === 0) {
      return "pat";
    } else if (pid === pmtPid) {
      return "pmt";
    } else if (pmtPid) {
      return "pes";
    }
    return null;
  };
  var parsePat = function(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    var offset2 = 4 + parseAdaptionField(packet);
    if (pusi) {
      offset2 += packet[offset2] + 1;
    }
    return (packet[offset2 + 10] & 31) << 8 | packet[offset2 + 11];
  };
  var parsePmt = function(packet) {
    var programMapTable = {};
    var pusi = parsePayloadUnitStartIndicator(packet);
    var payloadOffset = 4 + parseAdaptionField(packet);
    if (pusi) {
      payloadOffset += packet[payloadOffset] + 1;
    }
    if (!(packet[payloadOffset + 5] & 1)) {
      return;
    }
    var sectionLength, tableEnd, programInfoLength;
    sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
    tableEnd = 3 + sectionLength - 4;
    programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
    var offset2 = 12 + programInfoLength;
    while (offset2 < tableEnd) {
      var i = payloadOffset + offset2;
      programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
      offset2 += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
    }
    return programMapTable;
  };
  var parsePesType = function(packet, programMapTable) {
    var pid = parsePid(packet);
    var type2 = programMapTable[pid];
    switch (type2) {
      case StreamTypes$1.H264_STREAM_TYPE:
        return "video";
      case StreamTypes$1.ADTS_STREAM_TYPE:
        return "audio";
      case StreamTypes$1.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  };
  var parsePesTime = function(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    if (!pusi) {
      return null;
    }
    var offset2 = 4 + parseAdaptionField(packet);
    if (offset2 >= packet.byteLength) {
      return null;
    }
    var pes = null;
    var ptsDtsFlags;
    ptsDtsFlags = packet[offset2 + 7];
    if (ptsDtsFlags & 192) {
      pes = {};
      pes.pts = (packet[offset2 + 9] & 14) << 27 | (packet[offset2 + 10] & 255) << 20 | (packet[offset2 + 11] & 254) << 12 | (packet[offset2 + 12] & 255) << 5 | (packet[offset2 + 13] & 254) >>> 3;
      pes.pts *= 4;
      pes.pts += (packet[offset2 + 13] & 6) >>> 1;
      pes.dts = pes.pts;
      if (ptsDtsFlags & 64) {
        pes.dts = (packet[offset2 + 14] & 14) << 27 | (packet[offset2 + 15] & 255) << 20 | (packet[offset2 + 16] & 254) << 12 | (packet[offset2 + 17] & 255) << 5 | (packet[offset2 + 18] & 254) >>> 3;
        pes.dts *= 4;
        pes.dts += (packet[offset2 + 18] & 6) >>> 1;
      }
    }
    return pes;
  };
  var parseNalUnitType = function(type2) {
    switch (type2) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  };
  var videoPacketContainsKeyFrame = function(packet) {
    var offset2 = 4 + parseAdaptionField(packet);
    var frameBuffer = packet.subarray(offset2);
    var frameI = 0;
    var frameSyncPoint = 0;
    var foundKeyFrame = false;
    var nalType;
    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
      if (frameBuffer[frameSyncPoint + 2] === 1) {
        frameI = frameSyncPoint + 5;
        break;
      }
    }
    while (frameI < frameBuffer.byteLength) {
      switch (frameBuffer[frameI]) {
        case 0:
          if (frameBuffer[frameI - 1] !== 0) {
            frameI += 2;
            break;
          } else if (frameBuffer[frameI - 2] !== 0) {
            frameI++;
            break;
          }
          if (frameSyncPoint + 3 !== frameI - 2) {
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
            if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
              foundKeyFrame = true;
            }
          }
          do {
            frameI++;
          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        case 1:
          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
            frameI += 3;
            break;
          }
          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
          if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
            foundKeyFrame = true;
          }
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        default:
          frameI += 3;
          break;
      }
    }
    frameBuffer = frameBuffer.subarray(frameSyncPoint);
    frameI -= frameSyncPoint;
    frameSyncPoint = 0;
    if (frameBuffer && frameBuffer.byteLength > 3) {
      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
      if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
        foundKeyFrame = true;
      }
    }
    return foundKeyFrame;
  };
  var probe$1 = {
    parseType,
    parsePat,
    parsePmt,
    parsePayloadUnitStartIndicator,
    parsePesType,
    parsePesTime,
    videoPacketContainsKeyFrame
  };
  var StreamTypes = streamTypes;
  var handleRollover = timestampRolloverStream.handleRollover;
  var probe = {};
  probe.ts = probe$1;
  probe.aac = utils2;
  var ONE_SECOND_IN_TS2 = clock$2.ONE_SECOND_IN_TS;
  var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
  var parsePsi_ = function(bytes, pmt) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2;
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type2 = probe.ts.parseType(packet, pmt.pid);
        switch (type2) {
          case "pat":
            pmt.pid = probe.ts.parsePat(packet);
            break;
          case "pmt":
            var table = probe.ts.parsePmt(packet);
            pmt.table = pmt.table || {};
            Object.keys(table).forEach(function(key) {
              pmt.table[key] = table[key];
            });
            break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
  };
  var parseAudioPes_ = function(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed;
    var endLoop = false;
    while (endIndex <= bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type2 = probe.ts.parseType(packet, pmt.pid);
        switch (type2) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type2 = probe.ts.parseType(packet, pmt.pid);
        switch (type2) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var parseVideoPes_ = function(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type2, pesType, pusi, parsed, frame, i, pes;
    var endLoop = false;
    var currentFrame = {
      data: [],
      size: 0
    };
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type2 = probe.ts.parseType(packet, pmt.pid);
        switch (type2) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video") {
              if (pusi && !endLoop) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "video";
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              if (!result.firstKeyFrame) {
                if (pusi) {
                  if (currentFrame.size !== 0) {
                    frame = new Uint8Array(currentFrame.size);
                    i = 0;
                    while (currentFrame.data.length) {
                      pes = currentFrame.data.shift();
                      frame.set(pes, i);
                      i += pes.byteLength;
                    }
                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                      var firstKeyFrame = probe.ts.parsePesTime(frame);
                      if (firstKeyFrame) {
                        result.firstKeyFrame = firstKeyFrame;
                        result.firstKeyFrame.type = "video";
                      } else {
                        console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                      }
                    }
                    currentFrame.size = 0;
                  }
                }
                currentFrame.data.push(packet);
                currentFrame.size += packet.byteLength;
              }
            }
            break;
        }
        if (endLoop && result.firstKeyFrame) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type2 = probe.ts.parseType(packet, pmt.pid);
        switch (type2) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "video";
                result.video.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var adjustTimestamp_ = function(segmentInfo, baseTimestamp) {
    if (segmentInfo.audio && segmentInfo.audio.length) {
      var audioBaseTimestamp = baseTimestamp;
      if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
        audioBaseTimestamp = segmentInfo.audio[0].dts;
      }
      segmentInfo.audio.forEach(function(info) {
        info.dts = handleRollover(info.dts, audioBaseTimestamp);
        info.pts = handleRollover(info.pts, audioBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
    }
    if (segmentInfo.video && segmentInfo.video.length) {
      var videoBaseTimestamp = baseTimestamp;
      if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
        videoBaseTimestamp = segmentInfo.video[0].dts;
      }
      segmentInfo.video.forEach(function(info) {
        info.dts = handleRollover(info.dts, videoBaseTimestamp);
        info.pts = handleRollover(info.pts, videoBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
      if (segmentInfo.firstKeyFrame) {
        var frame = segmentInfo.firstKeyFrame;
        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS2;
        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS2;
      }
    }
  };
  var inspectAac_ = function(bytes) {
    var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
    while (bytes.length - byteIndex >= 3) {
      var type2 = probe.aac.parseType(bytes, byteIndex);
      switch (type2) {
        case "timed-metadata":
          if (bytes.length - byteIndex < 10) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (timestamp === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            timestamp = probe.aac.parseAacTimestamp(packet);
          }
          byteIndex += frameSize;
          break;
        case "audio":
          if (bytes.length - byteIndex < 7) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (sampleRate === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            sampleRate = probe.aac.parseSampleRate(packet);
          }
          audioCount++;
          byteIndex += frameSize;
          break;
        default:
          byteIndex++;
          break;
      }
      if (endLoop) {
        return null;
      }
    }
    if (sampleRate === null || timestamp === null) {
      return null;
    }
    var audioTimescale = ONE_SECOND_IN_TS2 / sampleRate;
    var result = {
      audio: [{
        type: "audio",
        dts: timestamp,
        pts: timestamp
      }, {
        type: "audio",
        dts: timestamp + audioCount * 1024 * audioTimescale,
        pts: timestamp + audioCount * 1024 * audioTimescale
      }]
    };
    return result;
  };
  var inspectTs_ = function(bytes) {
    var pmt = {
      pid: null,
      table: null
    };
    var result = {};
    parsePsi_(bytes, pmt);
    for (var pid in pmt.table) {
      if (pmt.table.hasOwnProperty(pid)) {
        var type2 = pmt.table[pid];
        switch (type2) {
          case StreamTypes.H264_STREAM_TYPE:
            result.video = [];
            parseVideoPes_(bytes, pmt, result);
            if (result.video.length === 0) {
              delete result.video;
            }
            break;
          case StreamTypes.ADTS_STREAM_TYPE:
            result.audio = [];
            parseAudioPes_(bytes, pmt, result);
            if (result.audio.length === 0) {
              delete result.audio;
            }
            break;
        }
      }
    }
    return result;
  };
  var inspect = function(bytes, baseTimestamp) {
    var isAacData = probe.aac.isLikelyAacData(bytes);
    var result;
    if (isAacData) {
      result = inspectAac_(bytes);
    } else {
      result = inspectTs_(bytes);
    }
    if (!result || !result.audio && !result.video) {
      return null;
    }
    adjustTimestamp_(result, baseTimestamp);
    return result;
  };
  var tsInspector = {
    inspect,
    parseAudioPes_
  };
  const wireTransmuxerEvents = function(self2, transmuxer2) {
    transmuxer2.on("data", function(segment) {
      const initArray = segment.initSegment;
      segment.initSegment = {
        data: initArray.buffer,
        byteOffset: initArray.byteOffset,
        byteLength: initArray.byteLength
      };
      const typedArray2 = segment.data;
      segment.data = typedArray2.buffer;
      self2.postMessage({
        action: "data",
        segment,
        byteOffset: typedArray2.byteOffset,
        byteLength: typedArray2.byteLength
      }, [segment.data]);
    });
    transmuxer2.on("done", function(data) {
      self2.postMessage({
        action: "done"
      });
    });
    transmuxer2.on("gopInfo", function(gopInfo) {
      self2.postMessage({
        action: "gopInfo",
        gopInfo
      });
    });
    transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
      const videoSegmentTimingInfo = {
        start: {
          decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo
      });
    });
    transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
      const audioSegmentTimingInfo = {
        start: {
          decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo
      });
    });
    transmuxer2.on("id3Frame", function(id3Frame) {
      self2.postMessage({
        action: "id3Frame",
        id3Frame
      });
    });
    transmuxer2.on("caption", function(caption) {
      self2.postMessage({
        action: "caption",
        caption
      });
    });
    transmuxer2.on("trackinfo", function(trackInfo) {
      self2.postMessage({
        action: "trackinfo",
        trackInfo
      });
    });
    transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
      self2.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: clock$2.videoTsToSeconds(audioTimingInfo.start),
          end: clock$2.videoTsToSeconds(audioTimingInfo.end)
        }
      });
    });
    transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
      self2.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: clock$2.videoTsToSeconds(videoTimingInfo.start),
          end: clock$2.videoTsToSeconds(videoTimingInfo.end)
        }
      });
    });
    transmuxer2.on("log", function(log2) {
      self2.postMessage({
        action: "log",
        log: log2
      });
    });
  };
  class MessageHandlers {
    constructor(self2, options) {
      this.options = options || {};
      this.self = self2;
      this.init();
    }
    /**
     * initialize our web worker and wire all the events.
     */
    init() {
      if (this.transmuxer) {
        this.transmuxer.dispose();
      }
      this.transmuxer = new transmuxer.Transmuxer(this.options);
      wireTransmuxerEvents(this.self, this.transmuxer);
    }
    pushMp4Captions(data) {
      if (!this.captionParser) {
        this.captionParser = new captionParser();
        this.captionParser.init();
      }
      const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: parsed && parsed.captions || [],
        logs: parsed && parsed.logs || [],
        data: segment.buffer
      }, [segment.buffer]);
    }
    probeMp4StartTime({
      timescales,
      data
    }) {
      const startTime2 = probe$2.startTime(timescales, data);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: startTime2,
        data
      }, [data.buffer]);
    }
    probeMp4Tracks({
      data
    }) {
      const tracks = probe$2.tracks(data);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks,
        data
      }, [data.buffer]);
    }
    /**
     * Probes an mp4 segment for EMSG boxes containing ID3 data.
     * https://aomediacodec.github.io/id3-emsg/
     *
     * @param {Uint8Array} data segment data
     * @param {number} offset segment start time
     * @return {Object[]} an array of ID3 frames
     */
    probeEmsgID3({
      data,
      offset: offset2
    }) {
      const id3Frames = probe$2.getEmsgID3(data, offset2);
      this.self.postMessage({
        action: "probeEmsgID3",
        id3Frames,
        emsgData: data
      }, [data.buffer]);
    }
    /**
     * Probe an mpeg2-ts segment to determine the start time of the segment in it's
     * internal "media time," as well as whether it contains video and/or audio.
     *
     * @private
     * @param {Uint8Array} bytes - segment bytes
     * @param {number} baseStartTime
     *        Relative reference timestamp used when adjusting frame timestamps for rollover.
     *        This value should be in seconds, as it's converted to a 90khz clock within the
     *        function body.
     * @return {Object} The start time of the current segment in "media time" as well as
     *                  whether it contains video and/or audio
     */
    probeTs({
      data,
      baseStartTime
    }) {
      const tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;
      const timeInfo = tsInspector.inspect(data, tsStartTime);
      let result = null;
      if (timeInfo) {
        result = {
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
          hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
        };
        if (result.hasVideo) {
          result.videoStart = timeInfo.video[0].ptsTime;
        }
        if (result.hasAudio) {
          result.audioStart = timeInfo.audio[0].ptsTime;
        }
      }
      this.self.postMessage({
        action: "probeTs",
        result,
        data
      }, [data.buffer]);
    }
    clearAllMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearAllCaptions();
      }
    }
    clearParsedMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearParsedCaptions();
      }
    }
    /**
     * Adds data (a ts segment) to the start of the transmuxer pipeline for
     * processing.
     *
     * @param {ArrayBuffer} data data to push into the muxer
     */
    push(data) {
      const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      this.transmuxer.push(segment);
    }
    /**
     * Recreate the transmuxer so that the next segment added via `push`
     * start with a fresh transmuxer.
     */
    reset() {
      this.transmuxer.reset();
    }
    /**
     * Set the value that will be used as the `baseMediaDecodeTime` time for the
     * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`
     * set relative to the first based on the PTS values.
     *
     * @param {Object} data used to set the timestamp offset in the muxer
     */
    setTimestampOffset(data) {
      const timestampOffset = data.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));
    }
    setAudioAppendStart(data) {
      this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));
    }
    setRemux(data) {
      this.transmuxer.setRemux(data.remux);
    }
    /**
     * Forces the pipeline to finish processing the last segment and emit it's
     * results.
     *
     * @param {Object} data event data, not really used
     */
    flush(data) {
      this.transmuxer.flush();
      self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    }
    endTimeline() {
      this.transmuxer.endTimeline();
      self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    }
    alignGopsWith(data) {
      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
    }
  }
  self.onmessage = function(event2) {
    if (event2.data.action === "init" && event2.data.options) {
      this.messageHandlers = new MessageHandlers(self, event2.data.options);
      return;
    }
    if (!this.messageHandlers) {
      this.messageHandlers = new MessageHandlers(self);
    }
    if (event2.data && event2.data.action && event2.data.action !== "init") {
      if (this.messageHandlers[event2.data.action]) {
        this.messageHandlers[event2.data.action](event2.data);
      }
    }
  };
}));
var TransmuxWorker = factory(workerCode$1);
const handleData_ = (event2, transmuxedData, callback) => {
  const {
    type,
    initSegment,
    captions,
    captionStreams,
    metadata,
    videoFrameDtsTime,
    videoFramePtsTime
  } = event2.data.segment;
  transmuxedData.buffer.push({
    captions,
    captionStreams,
    metadata
  });
  const boxes = event2.data.segment.boxes || {
    data: event2.data.segment.data
  };
  const result = {
    type,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
  };
  if (typeof videoFrameDtsTime !== "undefined") {
    result.videoFrameDtsTime = videoFrameDtsTime;
  }
  if (typeof videoFramePtsTime !== "undefined") {
    result.videoFramePtsTime = videoFramePtsTime;
  }
  callback(result);
};
const handleDone_ = ({
  transmuxedData,
  callback
}) => {
  transmuxedData.buffer = [];
  callback(transmuxedData);
};
const handleGopInfo_ = (event2, transmuxedData) => {
  transmuxedData.gopInfo = event2.data.gopInfo;
};
const processTransmux = (options) => {
  const {
    transmuxer,
    bytes,
    audioAppendStart,
    gopsToAlignWith,
    remux,
    onData,
    onTrackInfo,
    onAudioTimingInfo,
    onVideoTimingInfo,
    onVideoSegmentTimingInfo,
    onAudioSegmentTimingInfo,
    onId3,
    onCaptions,
    onDone,
    onEndedTimeline,
    onTransmuxerLog,
    isEndOfTimeline,
    segment,
    triggerSegmentEventFn
  } = options;
  const transmuxedData = {
    buffer: []
  };
  let waitForEndedTimelineEvent = isEndOfTimeline;
  const handleMessage = (event2) => {
    if (transmuxer.currentTransmux !== options) {
      return;
    }
    if (event2.data.action === "data") {
      handleData_(event2, transmuxedData, onData);
    }
    if (event2.data.action === "trackinfo") {
      onTrackInfo(event2.data.trackInfo);
    }
    if (event2.data.action === "gopInfo") {
      handleGopInfo_(event2, transmuxedData);
    }
    if (event2.data.action === "audioTimingInfo") {
      onAudioTimingInfo(event2.data.audioTimingInfo);
    }
    if (event2.data.action === "videoTimingInfo") {
      onVideoTimingInfo(event2.data.videoTimingInfo);
    }
    if (event2.data.action === "videoSegmentTimingInfo") {
      onVideoSegmentTimingInfo(event2.data.videoSegmentTimingInfo);
    }
    if (event2.data.action === "audioSegmentTimingInfo") {
      onAudioSegmentTimingInfo(event2.data.audioSegmentTimingInfo);
    }
    if (event2.data.action === "id3Frame") {
      onId3([event2.data.id3Frame], event2.data.id3Frame.dispatchType);
    }
    if (event2.data.action === "caption") {
      onCaptions(event2.data.caption);
    }
    if (event2.data.action === "endedtimeline") {
      waitForEndedTimelineEvent = false;
      onEndedTimeline();
    }
    if (event2.data.action === "log") {
      onTransmuxerLog(event2.data.log);
    }
    if (event2.data.type !== "transmuxed") {
      return;
    }
    if (waitForEndedTimelineEvent) {
      return;
    }
    transmuxer.onmessage = null;
    handleDone_({
      transmuxedData,
      callback: onDone
    });
    dequeue(transmuxer);
  };
  const handleError = () => {
    const error = {
      message: "Received an error message from the transmuxer worker",
      metadata: {
        errorType: videojs$2.Error.StreamingFailedToTransmuxSegment,
        segmentInfo: segmentInfoPayload({
          segment
        })
      }
    };
    onDone(null, error);
  };
  transmuxer.onmessage = handleMessage;
  transmuxer.onerror = handleError;
  if (audioAppendStart) {
    transmuxer.postMessage({
      action: "setAudioAppendStart",
      appendStart: audioAppendStart
    });
  }
  if (Array.isArray(gopsToAlignWith)) {
    transmuxer.postMessage({
      action: "alignGopsWith",
      gopsToAlignWith
    });
  }
  if (typeof remux !== "undefined") {
    transmuxer.postMessage({
      action: "setRemux",
      remux
    });
  }
  if (bytes.byteLength) {
    const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
    const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
    triggerSegmentEventFn({
      type: "segmenttransmuxingstart",
      segment
    });
    transmuxer.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: buffer,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset,
      byteLength: bytes.byteLength
    }, [buffer]);
  }
  if (isEndOfTimeline) {
    transmuxer.postMessage({
      action: "endTimeline"
    });
  }
  transmuxer.postMessage({
    action: "flush"
  });
};
const dequeue = (transmuxer) => {
  transmuxer.currentTransmux = null;
  if (transmuxer.transmuxQueue.length) {
    transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
    if (typeof transmuxer.currentTransmux === "function") {
      transmuxer.currentTransmux();
    } else {
      processTransmux(transmuxer.currentTransmux);
    }
  }
};
const processAction = (transmuxer, action) => {
  transmuxer.postMessage({
    action
  });
  dequeue(transmuxer);
};
const enqueueAction = (action, transmuxer) => {
  if (!transmuxer.currentTransmux) {
    transmuxer.currentTransmux = action;
    processAction(transmuxer, action);
    return;
  }
  transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
};
const reset = (transmuxer) => {
  enqueueAction("reset", transmuxer);
};
const endTimeline = (transmuxer) => {
  enqueueAction("endTimeline", transmuxer);
};
const transmux = (options) => {
  if (!options.transmuxer.currentTransmux) {
    options.transmuxer.currentTransmux = options;
    processTransmux(options);
    return;
  }
  options.transmuxer.transmuxQueue.push(options);
};
const createTransmuxer = (options) => {
  const transmuxer = new TransmuxWorker();
  transmuxer.currentTransmux = null;
  transmuxer.transmuxQueue = [];
  const term = transmuxer.terminate;
  transmuxer.terminate = () => {
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue.length = 0;
    return term.call(transmuxer);
  };
  transmuxer.postMessage({
    action: "init",
    options
  });
  return transmuxer;
};
var segmentTransmuxer = {
  reset,
  endTimeline,
  transmux,
  createTransmuxer
};
const workerCallback = function(options) {
  const transmuxer = options.transmuxer;
  const endAction = options.endAction || options.action;
  const callback = options.callback;
  const message = _extends$2({}, options, {
    endAction: null,
    transmuxer: null,
    callback: null
  });
  const listenForEndEvent = (event2) => {
    if (event2.data.action !== endAction) {
      return;
    }
    transmuxer.removeEventListener("message", listenForEndEvent);
    if (event2.data.data) {
      event2.data.data = new Uint8Array(event2.data.data, options.byteOffset || 0, options.byteLength || event2.data.data.byteLength);
      if (options.data) {
        options.data = event2.data.data;
      }
    }
    callback(event2.data);
  };
  transmuxer.addEventListener("message", listenForEndEvent);
  if (options.data) {
    const isArrayBuffer = options.data instanceof ArrayBuffer;
    message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
    message.byteLength = options.data.byteLength;
    const transfers = [isArrayBuffer ? options.data : options.data.buffer];
    transmuxer.postMessage(message, transfers);
  } else {
    transmuxer.postMessage(message);
  }
};
const REQUEST_ERRORS = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
};
const abortAll = (activeXhrs) => {
  activeXhrs.forEach((xhr) => {
    xhr.abort();
  });
};
const getRequestStats = (request) => {
  return {
    bandwidth: request.bandwidth,
    bytesReceived: request.bytesReceived || 0,
    roundTripTime: request.roundTripTime || 0
  };
};
const getProgressStats = (progressEvent) => {
  const request = progressEvent.target;
  const roundTripTime = Date.now() - request.requestTime;
  const stats = {
    bandwidth: Infinity,
    bytesReceived: 0,
    roundTripTime: roundTripTime || 0
  };
  stats.bytesReceived = progressEvent.loaded;
  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
  return stats;
};
const handleErrors = (error, request) => {
  const {
    requestType
  } = request;
  const metadata = getStreamingNetworkErrorMetadata({
    requestType,
    request,
    error
  });
  if (request.timedout) {
    return {
      status: request.status,
      message: "HLS request timed-out at URL: " + request.uri,
      code: REQUEST_ERRORS.TIMEOUT,
      xhr: request,
      metadata
    };
  }
  if (request.aborted) {
    return {
      status: request.status,
      message: "HLS request aborted at URL: " + request.uri,
      code: REQUEST_ERRORS.ABORTED,
      xhr: request,
      metadata
    };
  }
  if (error) {
    return {
      status: request.status,
      message: "HLS request errored at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request,
      metadata
    };
  }
  if (request.responseType === "arraybuffer" && request.response.byteLength === 0) {
    return {
      status: request.status,
      message: "Empty HLS response at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request,
      metadata
    };
  }
  return null;
};
const handleKeyResponse = (segment, objects, finishProcessingFn, triggerSegmentEventFn) => (error, request) => {
  const response = request.response;
  const errorObj = handleErrors(error, request);
  if (errorObj) {
    return finishProcessingFn(errorObj, segment);
  }
  if (response.byteLength !== 16) {
    return finishProcessingFn({
      status: request.status,
      message: "Invalid HLS key at URL: " + request.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request
    }, segment);
  }
  const view = new DataView(response);
  const bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
  for (let i = 0; i < objects.length; i++) {
    objects[i].bytes = bytes;
  }
  const keyInfo = {
    uri: request.uri
  };
  triggerSegmentEventFn({
    type: "segmentkeyloadcomplete",
    segment,
    keyInfo
  });
  return finishProcessingFn(null, segment);
};
const parseInitSegment = (segment, callback) => {
  const type = detectContainerForBytes(segment.map.bytes);
  if (type !== "mp4") {
    const uri = segment.map.resolvedUri || segment.map.uri;
    const mediaType = type || "unknown";
    return callback({
      internal: true,
      message: `Found unsupported ${mediaType} container for initialization segment at URL: ${uri}`,
      code: REQUEST_ERRORS.FAILURE,
      metadata: {
        mediaType
      }
    });
  }
  workerCallback({
    action: "probeMp4Tracks",
    data: segment.map.bytes,
    transmuxer: segment.transmuxer,
    callback: ({
      tracks,
      data
    }) => {
      segment.map.bytes = data;
      tracks.forEach(function(track) {
        segment.map.tracks = segment.map.tracks || {};
        if (segment.map.tracks[track.type]) {
          return;
        }
        segment.map.tracks[track.type] = track;
        if (typeof track.id === "number" && track.timescale) {
          segment.map.timescales = segment.map.timescales || {};
          segment.map.timescales[track.id] = track.timescale;
        }
      });
      return callback(null);
    }
  });
};
const handleInitSegmentResponse = ({
  segment,
  finishProcessingFn,
  triggerSegmentEventFn
}) => (error, request) => {
  const errorObj = handleErrors(error, request);
  if (errorObj) {
    return finishProcessingFn(errorObj, segment);
  }
  const bytes = new Uint8Array(request.response);
  triggerSegmentEventFn({
    type: "segmentloaded",
    segment
  });
  if (segment.map.key) {
    segment.map.encryptedBytes = bytes;
    return finishProcessingFn(null, segment);
  }
  segment.map.bytes = bytes;
  parseInitSegment(segment, function(parseError) {
    if (parseError) {
      parseError.xhr = request;
      parseError.status = request.status;
      return finishProcessingFn(parseError, segment);
    }
    finishProcessingFn(null, segment);
  });
};
const handleSegmentResponse = ({
  segment,
  finishProcessingFn,
  responseType,
  triggerSegmentEventFn
}) => (error, request) => {
  const errorObj = handleErrors(error, request);
  if (errorObj) {
    return finishProcessingFn(errorObj, segment);
  }
  triggerSegmentEventFn({
    type: "segmentloaded",
    segment
  });
  const newBytes = (
    // although responseText "should" exist, this guard serves to prevent an error being
    // thrown for two primary cases:
    // 1. the mime type override stops working, or is not implemented for a specific
    //    browser
    // 2. when using mock XHR libraries like sinon that do not allow the override behavior
    responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0))
  );
  segment.stats = getRequestStats(request);
  if (segment.key) {
    segment.encryptedBytes = new Uint8Array(newBytes);
  } else {
    segment.bytes = new Uint8Array(newBytes);
  }
  return finishProcessingFn(null, segment);
};
const transmuxAndNotify = ({
  segment,
  bytes,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn,
  doneFn,
  onTransmuxerLog,
  triggerSegmentEventFn
}) => {
  const fmp4Tracks = segment.map && segment.map.tracks || {};
  const isMuxed2 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
  let audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
  const audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
  let videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
  const videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
  const finish = () => transmux({
    bytes,
    transmuxer: segment.transmuxer,
    audioAppendStart: segment.audioAppendStart,
    gopsToAlignWith: segment.gopsToAlignWith,
    remux: isMuxed2,
    onData: (result) => {
      result.type = result.type === "combined" ? "video" : result.type;
      dataFn(segment, result);
    },
    onTrackInfo: (trackInfo) => {
      if (trackInfoFn) {
        if (isMuxed2) {
          trackInfo.isMuxed = true;
        }
        trackInfoFn(segment, trackInfo);
      }
    },
    onAudioTimingInfo: (audioTimingInfo) => {
      if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
        audioStartFn(audioTimingInfo.start);
        audioStartFn = null;
      }
      if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
        audioEndFn(audioTimingInfo.end);
      }
    },
    onVideoTimingInfo: (videoTimingInfo) => {
      if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
        videoStartFn(videoTimingInfo.start);
        videoStartFn = null;
      }
      if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
        videoEndFn(videoTimingInfo.end);
      }
    },
    onVideoSegmentTimingInfo: (videoSegmentTimingInfo) => {
      const timingInfo = {
        pts: {
          start: videoSegmentTimingInfo.start.presentation,
          end: videoSegmentTimingInfo.end.presentation
        },
        dts: {
          start: videoSegmentTimingInfo.start.decode,
          end: videoSegmentTimingInfo.end.decode
        }
      };
      triggerSegmentEventFn({
        type: "segmenttransmuxingtiminginfoavailable",
        segment,
        timingInfo
      });
      videoSegmentTimingInfoFn(videoSegmentTimingInfo);
    },
    onAudioSegmentTimingInfo: (audioSegmentTimingInfo) => {
      const timingInfo = {
        pts: {
          start: audioSegmentTimingInfo.start.pts,
          end: audioSegmentTimingInfo.end.pts
        },
        dts: {
          start: audioSegmentTimingInfo.start.dts,
          end: audioSegmentTimingInfo.end.dts
        }
      };
      triggerSegmentEventFn({
        type: "segmenttransmuxingtiminginfoavailable",
        segment,
        timingInfo
      });
      audioSegmentTimingInfoFn(audioSegmentTimingInfo);
    },
    onId3: (id3Frames, dispatchType) => {
      id3Fn(segment, id3Frames, dispatchType);
    },
    onCaptions: (captions) => {
      captionsFn(segment, [captions]);
    },
    isEndOfTimeline,
    onEndedTimeline: () => {
      endedTimelineFn();
    },
    onTransmuxerLog,
    onDone: (result, error) => {
      if (!doneFn) {
        return;
      }
      result.type = result.type === "combined" ? "video" : result.type;
      triggerSegmentEventFn({
        type: "segmenttransmuxingcomplete",
        segment
      });
      doneFn(error, segment, result);
    },
    segment,
    triggerSegmentEventFn
  });
  workerCallback({
    action: "probeTs",
    transmuxer: segment.transmuxer,
    data: bytes,
    baseStartTime: segment.baseStartTime,
    callback: (data) => {
      segment.bytes = bytes = data.data;
      const probeResult = data.result;
      if (probeResult) {
        trackInfoFn(segment, {
          hasAudio: probeResult.hasAudio,
          hasVideo: probeResult.hasVideo,
          isMuxed: isMuxed2
        });
        trackInfoFn = null;
      }
      finish();
    }
  });
};
const handleSegmentBytes = ({
  segment,
  bytes,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn,
  doneFn,
  onTransmuxerLog,
  triggerSegmentEventFn
}) => {
  let bytesAsUint8Array = new Uint8Array(bytes);
  if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
    segment.isFmp4 = true;
    const {
      tracks
    } = segment.map;
    const trackInfo = {
      isFmp4: true,
      hasVideo: !!tracks.video,
      hasAudio: !!tracks.audio
    };
    if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
      trackInfo.audioCodec = tracks.audio.codec;
    }
    if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
      trackInfo.videoCodec = tracks.video.codec;
    }
    if (tracks.video && tracks.audio) {
      trackInfo.isMuxed = true;
    }
    trackInfoFn(segment, trackInfo);
    const finishLoading = (captions, id3Frames) => {
      dataFn(segment, {
        data: bytesAsUint8Array,
        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
      });
      if (id3Frames && id3Frames.length) {
        id3Fn(segment, id3Frames);
      }
      if (captions && captions.length) {
        captionsFn(segment, captions);
      }
      doneFn(null, segment, {});
    };
    workerCallback({
      action: "probeMp4StartTime",
      timescales: segment.map.timescales,
      data: bytesAsUint8Array,
      transmuxer: segment.transmuxer,
      callback: ({
        data,
        startTime
      }) => {
        bytes = data.buffer;
        segment.bytes = bytesAsUint8Array = data;
        if (trackInfo.hasAudio && !trackInfo.isMuxed) {
          timingInfoFn(segment, "audio", "start", startTime);
        }
        if (trackInfo.hasVideo) {
          timingInfoFn(segment, "video", "start", startTime);
        }
        workerCallback({
          action: "probeEmsgID3",
          data: bytesAsUint8Array,
          transmuxer: segment.transmuxer,
          offset: startTime,
          callback: ({
            emsgData,
            id3Frames
          }) => {
            bytes = emsgData.buffer;
            segment.bytes = bytesAsUint8Array = emsgData;
            if (!tracks.video || !emsgData.byteLength || !segment.transmuxer) {
              finishLoading(void 0, id3Frames);
              return;
            }
            workerCallback({
              action: "pushMp4Captions",
              endAction: "mp4Captions",
              transmuxer: segment.transmuxer,
              data: bytesAsUint8Array,
              timescales: segment.map.timescales,
              trackIds: [tracks.video.id],
              callback: (message) => {
                bytes = message.data.buffer;
                segment.bytes = bytesAsUint8Array = message.data;
                message.logs.forEach(function(log2) {
                  onTransmuxerLog(merge(log2, {
                    stream: "mp4CaptionParser"
                  }));
                });
                finishLoading(message.captions, id3Frames);
              }
            });
          }
        });
      }
    });
    return;
  }
  if (!segment.transmuxer) {
    doneFn(null, segment, {});
    return;
  }
  if (typeof segment.container === "undefined") {
    segment.container = detectContainerForBytes(bytesAsUint8Array);
  }
  if (segment.container !== "ts" && segment.container !== "aac") {
    trackInfoFn(segment, {
      hasAudio: false,
      hasVideo: false
    });
    doneFn(null, segment, {});
    return;
  }
  transmuxAndNotify({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog,
    triggerSegmentEventFn
  });
};
const decrypt = function({
  id,
  key,
  encryptedBytes,
  decryptionWorker,
  segment,
  doneFn
}, callback) {
  const decryptionHandler = (event2) => {
    if (event2.data.source === id) {
      decryptionWorker.removeEventListener("message", decryptionHandler);
      const decrypted = event2.data.decrypted;
      callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
    }
  };
  decryptionWorker.onerror = () => {
    const message = "An error occurred in the decryption worker";
    const segmentInfo = segmentInfoPayload({
      segment
    });
    const decryptError = {
      message,
      metadata: {
        error: new Error(message),
        errorType: videojs$2.Error.StreamingFailedToDecryptSegment,
        segmentInfo,
        keyInfo: {
          uri: segment.key.resolvedUri || segment.map.key.resolvedUri
        }
      }
    };
    doneFn(decryptError, segment);
  };
  decryptionWorker.addEventListener("message", decryptionHandler);
  let keyBytes;
  if (key.bytes.slice) {
    keyBytes = key.bytes.slice();
  } else {
    keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
  }
  decryptionWorker.postMessage(createTransferableMessage({
    source: id,
    encrypted: encryptedBytes,
    key: keyBytes,
    iv: key.iv
  }), [encryptedBytes.buffer, keyBytes.buffer]);
};
const decryptSegment = ({
  decryptionWorker,
  segment,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn,
  doneFn,
  onTransmuxerLog,
  triggerSegmentEventFn
}) => {
  triggerSegmentEventFn({
    type: "segmentdecryptionstart"
  });
  decrypt({
    id: segment.requestId,
    key: segment.key,
    encryptedBytes: segment.encryptedBytes,
    decryptionWorker,
    segment,
    doneFn
  }, (decryptedBytes) => {
    segment.bytes = decryptedBytes;
    triggerSegmentEventFn({
      type: "segmentdecryptioncomplete",
      segment
    });
    handleSegmentBytes({
      segment,
      bytes: segment.bytes,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog,
      triggerSegmentEventFn
    });
  });
};
const waitForCompletion = ({
  activeXhrs,
  decryptionWorker,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn,
  doneFn,
  onTransmuxerLog,
  triggerSegmentEventFn
}) => {
  let count = 0;
  let didError = false;
  return (error, segment) => {
    if (didError) {
      return;
    }
    if (error) {
      didError = true;
      abortAll(activeXhrs);
      return doneFn(error, segment);
    }
    count += 1;
    if (count === activeXhrs.length) {
      const segmentFinish = function() {
        if (segment.encryptedBytes) {
          return decryptSegment({
            decryptionWorker,
            segment,
            trackInfoFn,
            timingInfoFn,
            videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn,
            id3Fn,
            captionsFn,
            isEndOfTimeline,
            endedTimelineFn,
            dataFn,
            doneFn,
            onTransmuxerLog,
            triggerSegmentEventFn
          });
        }
        handleSegmentBytes({
          segment,
          bytes: segment.bytes,
          trackInfoFn,
          timingInfoFn,
          videoSegmentTimingInfoFn,
          audioSegmentTimingInfoFn,
          id3Fn,
          captionsFn,
          isEndOfTimeline,
          endedTimelineFn,
          dataFn,
          doneFn,
          onTransmuxerLog,
          triggerSegmentEventFn
        });
      };
      segment.endOfAllRequests = Date.now();
      if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
        triggerSegmentEventFn({
          type: "segmentdecryptionstart",
          segment
        });
        return decrypt({
          decryptionWorker,
          // add -init to the "id" to differentiate between segment
          // and init segment decryption, just in case they happen
          // at the same time at some point in the future.
          id: segment.requestId + "-init",
          encryptedBytes: segment.map.encryptedBytes,
          key: segment.map.key,
          segment,
          doneFn
        }, (decryptedBytes) => {
          segment.map.bytes = decryptedBytes;
          triggerSegmentEventFn({
            type: "segmentdecryptioncomplete",
            segment
          });
          parseInitSegment(segment, (parseError) => {
            if (parseError) {
              abortAll(activeXhrs);
              return doneFn(parseError, segment);
            }
            segmentFinish();
          });
        });
      }
      segmentFinish();
    }
  };
};
const handleLoadEnd = ({
  loadendState,
  abortFn
}) => (event2) => {
  const request = event2.target;
  if (request.aborted && abortFn && !loadendState.calledAbortFn) {
    abortFn();
    loadendState.calledAbortFn = true;
  }
};
const handleProgress = ({
  segment,
  progressFn,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn
}) => (event2) => {
  const request = event2.target;
  if (request.aborted) {
    return;
  }
  segment.stats = merge(segment.stats, getProgressStats(event2));
  if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
    segment.stats.firstBytesReceivedAt = Date.now();
  }
  return progressFn(event2, segment);
};
const mediaSegmentRequest = ({
  xhr,
  xhrOptions,
  decryptionWorker,
  segment,
  abortFn,
  progressFn,
  trackInfoFn,
  timingInfoFn,
  videoSegmentTimingInfoFn,
  audioSegmentTimingInfoFn,
  id3Fn,
  captionsFn,
  isEndOfTimeline,
  endedTimelineFn,
  dataFn,
  doneFn,
  onTransmuxerLog,
  triggerSegmentEventFn
}) => {
  const activeXhrs = [];
  const finishProcessingFn = waitForCompletion({
    activeXhrs,
    decryptionWorker,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog,
    triggerSegmentEventFn
  });
  if (segment.key && !segment.key.bytes) {
    const objects = [segment.key];
    if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
      objects.push(segment.map.key);
    }
    const keyRequestOptions = merge(xhrOptions, {
      uri: segment.key.resolvedUri,
      responseType: "arraybuffer",
      requestType: "segment-key"
    });
    const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn, triggerSegmentEventFn);
    const keyInfo = {
      uri: segment.key.resolvedUri
    };
    triggerSegmentEventFn({
      type: "segmentkeyloadstart",
      segment,
      keyInfo
    });
    const keyXhr = xhr(keyRequestOptions, keyRequestCallback);
    activeXhrs.push(keyXhr);
  }
  if (segment.map && !segment.map.bytes) {
    const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
    if (differentMapKey) {
      const mapKeyRequestOptions = merge(xhrOptions, {
        uri: segment.map.key.resolvedUri,
        responseType: "arraybuffer",
        requestType: "segment-key"
      });
      const mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn, triggerSegmentEventFn);
      const keyInfo = {
        uri: segment.map.key.resolvedUri
      };
      triggerSegmentEventFn({
        type: "segmentkeyloadstart",
        segment,
        keyInfo
      });
      const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
      activeXhrs.push(mapKeyXhr);
    }
    const initSegmentOptions = merge(xhrOptions, {
      uri: segment.map.resolvedUri,
      responseType: "arraybuffer",
      headers: segmentXhrHeaders(segment.map),
      requestType: "segment-media-initialization"
    });
    const initSegmentRequestCallback = handleInitSegmentResponse({
      segment,
      finishProcessingFn,
      triggerSegmentEventFn
    });
    triggerSegmentEventFn({
      type: "segmentloadstart",
      segment
    });
    const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
    activeXhrs.push(initSegmentXhr);
  }
  const segmentRequestOptions = merge(xhrOptions, {
    uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
    responseType: "arraybuffer",
    headers: segmentXhrHeaders(segment),
    requestType: "segment"
  });
  const segmentRequestCallback = handleSegmentResponse({
    segment,
    finishProcessingFn,
    responseType: segmentRequestOptions.responseType,
    triggerSegmentEventFn
  });
  triggerSegmentEventFn({
    type: "segmentloadstart",
    segment
  });
  const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
  segmentXhr.addEventListener("progress", handleProgress({
    segment,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn
  }));
  activeXhrs.push(segmentXhr);
  const loadendState = {};
  activeXhrs.forEach((activeXhr) => {
    activeXhr.addEventListener("loadend", handleLoadEnd({
      loadendState,
      abortFn
    }));
  });
  return () => abortAll(activeXhrs);
};
const logFn$1 = logger("CodecUtils");
const getCodecs = function(media) {
  const mediaAttributes = media.attributes || {};
  if (mediaAttributes.CODECS) {
    return parseCodecs(mediaAttributes.CODECS);
  }
};
const isMaat = (main2, media) => {
  const mediaAttributes = media.attributes || {};
  return main2 && main2.mediaGroups && main2.mediaGroups.AUDIO && mediaAttributes.AUDIO && main2.mediaGroups.AUDIO[mediaAttributes.AUDIO];
};
const isMuxed = (main2, media) => {
  if (!isMaat(main2, media)) {
    return true;
  }
  const mediaAttributes = media.attributes || {};
  const audioGroup = main2.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  for (const groupId in audioGroup) {
    if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
      return true;
    }
  }
  return false;
};
const unwrapCodecList = function(codecList) {
  const codecs = {};
  codecList.forEach(({
    mediaType,
    type,
    details
  }) => {
    codecs[mediaType] = codecs[mediaType] || [];
    codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));
  });
  Object.keys(codecs).forEach(function(mediaType) {
    if (codecs[mediaType].length > 1) {
      logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);
      codecs[mediaType] = null;
      return;
    }
    codecs[mediaType] = codecs[mediaType][0];
  });
  return codecs;
};
const codecCount = function(codecObj) {
  let count = 0;
  if (codecObj.audio) {
    count++;
  }
  if (codecObj.video) {
    count++;
  }
  return count;
};
const codecsForPlaylist = function(main2, media) {
  const mediaAttributes = media.attributes || {};
  const codecInfo = unwrapCodecList(getCodecs(media) || []);
  if (isMaat(main2, media) && !codecInfo.audio) {
    if (!isMuxed(main2, media)) {
      const defaultCodecs = unwrapCodecList(codecsFromDefault(main2, mediaAttributes.AUDIO) || []);
      if (defaultCodecs.audio) {
        codecInfo.audio = defaultCodecs.audio;
      }
    }
  }
  return codecInfo;
};
const logFn = logger("PlaylistSelector");
const representationToString = function(representation) {
  if (!representation || !representation.playlist) {
    return;
  }
  const playlist = representation.playlist;
  return JSON.stringify({
    id: playlist.id,
    bandwidth: representation.bandwidth,
    width: representation.width,
    height: representation.height,
    codecs: playlist.attributes && playlist.attributes.CODECS || ""
  });
};
const safeGetComputedStyle = function(el, property) {
  if (!el) {
    return "";
  }
  const result = window$1$1.getComputedStyle(el);
  if (!result) {
    return "";
  }
  return result[property];
};
const stableSort = function(array, sortFn) {
  const newArray = array.slice();
  array.sort(function(left2, right2) {
    const cmp = sortFn(left2, right2);
    if (cmp === 0) {
      return newArray.indexOf(left2) - newArray.indexOf(right2);
    }
    return cmp;
  });
};
const comparePlaylistBandwidth = function(left2, right2) {
  let leftBandwidth;
  let rightBandwidth;
  if (left2.attributes.BANDWIDTH) {
    leftBandwidth = left2.attributes.BANDWIDTH;
  }
  leftBandwidth = leftBandwidth || window$1$1.Number.MAX_VALUE;
  if (right2.attributes.BANDWIDTH) {
    rightBandwidth = right2.attributes.BANDWIDTH;
  }
  rightBandwidth = rightBandwidth || window$1$1.Number.MAX_VALUE;
  return leftBandwidth - rightBandwidth;
};
const comparePlaylistResolution = function(left2, right2) {
  let leftWidth;
  let rightWidth;
  if (left2.attributes.RESOLUTION && left2.attributes.RESOLUTION.width) {
    leftWidth = left2.attributes.RESOLUTION.width;
  }
  leftWidth = leftWidth || window$1$1.Number.MAX_VALUE;
  if (right2.attributes.RESOLUTION && right2.attributes.RESOLUTION.width) {
    rightWidth = right2.attributes.RESOLUTION.width;
  }
  rightWidth = rightWidth || window$1$1.Number.MAX_VALUE;
  if (leftWidth === rightWidth && left2.attributes.BANDWIDTH && right2.attributes.BANDWIDTH) {
    return left2.attributes.BANDWIDTH - right2.attributes.BANDWIDTH;
  }
  return leftWidth - rightWidth;
};
let simpleSelector = function(main2, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {
  if (!main2) {
    return;
  }
  const options = {
    bandwidth: playerBandwidth,
    width: playerWidth,
    height: playerHeight,
    limitRenditionByPlayerDimensions
  };
  let playlists = main2.playlists;
  if (Playlist.isAudioOnly(main2)) {
    playlists = playlistController.getAudioTrackPlaylists_();
    options.audioOnly = true;
  }
  let sortedPlaylistReps = playlists.map((playlist) => {
    let bandwidth;
    const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
    const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
    bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
    bandwidth = bandwidth || window$1$1.Number.MAX_VALUE;
    return {
      bandwidth,
      width,
      height,
      playlist
    };
  });
  stableSort(sortedPlaylistReps, (left2, right2) => left2.bandwidth - right2.bandwidth);
  sortedPlaylistReps = sortedPlaylistReps.filter((rep) => !Playlist.isIncompatible(rep.playlist));
  let enabledPlaylistReps = sortedPlaylistReps.filter((rep) => Playlist.isEnabled(rep.playlist));
  if (!enabledPlaylistReps.length) {
    enabledPlaylistReps = sortedPlaylistReps.filter((rep) => !Playlist.isDisabled(rep.playlist));
  }
  const bandwidthPlaylistReps = enabledPlaylistReps.filter((rep) => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth);
  let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
  const bandwidthBestRep = bandwidthPlaylistReps.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
  if (limitRenditionByPlayerDimensions === false) {
    const chosenRep2 = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (chosenRep2 && chosenRep2.playlist) {
      let type = "sortedPlaylistReps";
      if (bandwidthBestRep) {
        type = "bandwidthBestRep";
      }
      if (enabledPlaylistReps[0]) {
        type = "enabledPlaylistReps";
      }
      logFn(`choosing ${representationToString(chosenRep2)} using ${type} with options`, options);
      return chosenRep2.playlist;
    }
    logFn("could not choose a playlist with options", options);
    return null;
  }
  const haveResolution = bandwidthPlaylistReps.filter((rep) => rep.width && rep.height);
  stableSort(haveResolution, (left2, right2) => left2.width - right2.width);
  const resolutionBestRepList = haveResolution.filter((rep) => rep.width === playerWidth && rep.height === playerHeight);
  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
  const resolutionBestRep = resolutionBestRepList.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
  let resolutionPlusOneList;
  let resolutionPlusOneSmallest;
  let resolutionPlusOneRep;
  if (!resolutionBestRep) {
    resolutionPlusOneList = haveResolution.filter((rep) => rep.width > playerWidth || rep.height > playerHeight);
    resolutionPlusOneSmallest = resolutionPlusOneList.filter((rep) => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height);
    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
    resolutionPlusOneRep = resolutionPlusOneSmallest.filter((rep) => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];
  }
  let leastPixelDiffRep;
  if (playlistController.leastPixelDiffSelector) {
    const leastPixelDiffList = haveResolution.map((rep) => {
      rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
      return rep;
    });
    stableSort(leastPixelDiffList, (left2, right2) => {
      if (left2.pixelDiff === right2.pixelDiff) {
        return right2.bandwidth - left2.bandwidth;
      }
      return left2.pixelDiff - right2.pixelDiff;
    });
    leastPixelDiffRep = leastPixelDiffList[0];
  }
  const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
  if (chosenRep && chosenRep.playlist) {
    let type = "sortedPlaylistReps";
    if (leastPixelDiffRep) {
      type = "leastPixelDiffRep";
    } else if (resolutionPlusOneRep) {
      type = "resolutionPlusOneRep";
    } else if (resolutionBestRep) {
      type = "resolutionBestRep";
    } else if (bandwidthBestRep) {
      type = "bandwidthBestRep";
    } else if (enabledPlaylistReps[0]) {
      type = "enabledPlaylistReps";
    }
    logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);
    return chosenRep.playlist;
  }
  logFn("could not choose a playlist with options", options);
  return null;
};
const lastBandwidthSelector = function() {
  let pixelRatio = this.useDevicePixelRatio ? window$1$1.devicePixelRatio || 1 : 1;
  if (!isNaN(this.customPixelRatio)) {
    pixelRatio = this.customPixelRatio;
  }
  return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
};
const movingAverageBandwidthSelector = function(decay) {
  let average = -1;
  let lastSystemBandwidth = -1;
  if (decay < 0 || decay > 1) {
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  }
  return function() {
    let pixelRatio = this.useDevicePixelRatio ? window$1$1.devicePixelRatio || 1 : 1;
    if (!isNaN(this.customPixelRatio)) {
      pixelRatio = this.customPixelRatio;
    }
    if (average < 0) {
      average = this.systemBandwidth;
      lastSystemBandwidth = this.systemBandwidth;
    }
    if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
      average = decay * this.systemBandwidth + (1 - decay) * average;
      lastSystemBandwidth = this.systemBandwidth;
    }
    return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
  };
};
const minRebufferMaxBandwidthSelector = function(settings) {
  const {
    main: main2,
    currentTime,
    bandwidth,
    duration: duration2,
    segmentDuration,
    timeUntilRebuffer: timeUntilRebuffer2,
    currentTimeline,
    syncController
  } = settings;
  const compatiblePlaylists = main2.playlists.filter((playlist) => !Playlist.isIncompatible(playlist));
  let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
  if (!enabledPlaylists.length) {
    enabledPlaylists = compatiblePlaylists.filter((playlist) => !Playlist.isDisabled(playlist));
  }
  const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
  const rebufferingEstimates = bandwidthPlaylists.map((playlist) => {
    const syncPoint = syncController.getSyncPoint(playlist, duration2, currentTimeline, currentTime);
    const numRequests = syncPoint ? 1 : 2;
    const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
    const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer2;
    return {
      playlist,
      rebufferingImpact
    };
  });
  const noRebufferingPlaylists = rebufferingEstimates.filter((estimate) => estimate.rebufferingImpact <= 0);
  stableSort(noRebufferingPlaylists, (a, b) => comparePlaylistBandwidth(b.playlist, a.playlist));
  if (noRebufferingPlaylists.length) {
    return noRebufferingPlaylists[0];
  }
  stableSort(rebufferingEstimates, (a, b) => a.rebufferingImpact - b.rebufferingImpact);
  return rebufferingEstimates[0] || null;
};
const lowestBitrateCompatibleVariantSelector = function() {
  const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled);
  stableSort(playlists, (a, b) => comparePlaylistBandwidth(a, b));
  const playlistsWithVideo = playlists.filter((playlist) => !!codecsForPlaylist(this.playlists.main, playlist).video);
  return playlistsWithVideo[0] || null;
};
const concatSegments = (segmentObj) => {
  let offset2 = 0;
  let tempBuffer;
  if (segmentObj.bytes) {
    tempBuffer = new Uint8Array(segmentObj.bytes);
    segmentObj.segments.forEach((segment) => {
      tempBuffer.set(segment, offset2);
      offset2 += segment.byteLength;
    });
  }
  return tempBuffer;
};
function compactSegmentUrlDescription(resolvedUri) {
  try {
    return new URL(resolvedUri).pathname.split("/").slice(-2).join("/");
  } catch (e) {
    return "";
  }
}
const createCaptionsTrackIfNotExists = function(inbandTextTracks, tech, captionStream) {
  if (!inbandTextTracks[captionStream]) {
    tech.trigger({
      type: "usage",
      name: "vhs-608"
    });
    let instreamId = captionStream;
    if (/^cc708_/.test(captionStream)) {
      instreamId = "SERVICE" + captionStream.split("_")[1];
    }
    const track = tech.textTracks().getTrackById(instreamId);
    if (track) {
      inbandTextTracks[captionStream] = track;
    } else {
      const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
      let label = captionStream;
      let language = captionStream;
      let def = false;
      const captionService = captionServices[instreamId];
      if (captionService) {
        label = captionService.label;
        language = captionService.language;
        def = captionService.default;
      }
      inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
        kind: "captions",
        id: instreamId,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        default: def,
        label,
        language
      }, false).track;
    }
  }
};
const addCaptionData = function({
  inbandTextTracks,
  captionArray,
  timestampOffset
}) {
  if (!captionArray) {
    return;
  }
  const Cue = window$1$1.WebKitDataCue || window$1$1.VTTCue;
  captionArray.forEach((caption) => {
    const track = caption.stream;
    if (caption.content) {
      caption.content.forEach((value2) => {
        const cue = new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, value2.text);
        cue.line = value2.line;
        cue.align = "left";
        cue.position = value2.position;
        cue.positionAlign = "line-left";
        inbandTextTracks[track].addCue(cue);
      });
    } else {
      inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
    }
  });
};
const deprecateOldCue = function(cue) {
  Object.defineProperties(cue.frame, {
    id: {
      get() {
        videojs$2.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
        return cue.value.key;
      }
    },
    value: {
      get() {
        videojs$2.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    },
    privateData: {
      get() {
        videojs$2.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    }
  });
};
const addMetadata = ({
  inbandTextTracks,
  metadataArray,
  timestampOffset,
  videoDuration
}) => {
  if (!metadataArray) {
    return;
  }
  const Cue = window$1$1.WebKitDataCue || window$1$1.VTTCue;
  const metadataTrack = inbandTextTracks.metadataTrack_;
  if (!metadataTrack) {
    return;
  }
  metadataArray.forEach((metadata) => {
    const time = metadata.cueTime + timestampOffset;
    if (typeof time !== "number" || window$1$1.isNaN(time) || time < 0 || !(time < Infinity)) {
      return;
    }
    if (!metadata.frames || !metadata.frames.length) {
      return;
    }
    metadata.frames.forEach((frame) => {
      const cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
      cue.frame = frame;
      cue.value = frame;
      deprecateOldCue(cue);
      metadataTrack.addCue(cue);
    });
  });
  if (!metadataTrack.cues || !metadataTrack.cues.length) {
    return;
  }
  const cues = metadataTrack.cues;
  const cuesArray = [];
  for (let i = 0; i < cues.length; i++) {
    if (cues[i]) {
      cuesArray.push(cues[i]);
    }
  }
  const cuesGroupedByStartTime = cuesArray.reduce((obj, cue) => {
    const timeSlot = obj[cue.startTime] || [];
    timeSlot.push(cue);
    obj[cue.startTime] = timeSlot;
    return obj;
  }, {});
  const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort((a, b) => Number(a) - Number(b));
  sortedStartTimes.forEach((startTime, idx) => {
    const cueGroup = cuesGroupedByStartTime[startTime];
    const finiteDuration = isFinite(videoDuration) ? videoDuration : startTime;
    const nextTime = Number(sortedStartTimes[idx + 1]) || finiteDuration;
    cueGroup.forEach((cue) => {
      cue.endTime = nextTime;
    });
  });
};
const dateRangeAttr = {
  id: "ID",
  class: "CLASS",
  startDate: "START-DATE",
  duration: "DURATION",
  endDate: "END-DATE",
  endOnNext: "END-ON-NEXT",
  plannedDuration: "PLANNED-DURATION",
  scte35Out: "SCTE35-OUT",
  scte35In: "SCTE35-IN"
};
const dateRangeKeysToOmit = /* @__PURE__ */ new Set(["id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange"]);
const addDateRangeMetadata = ({
  inbandTextTracks,
  dateRanges
}) => {
  const metadataTrack = inbandTextTracks.metadataTrack_;
  if (!metadataTrack) {
    return;
  }
  const Cue = window$1$1.WebKitDataCue || window$1$1.VTTCue;
  dateRanges.forEach((dateRange) => {
    for (const key of Object.keys(dateRange)) {
      if (dateRangeKeysToOmit.has(key)) {
        continue;
      }
      const cue = new Cue(dateRange.startTime, dateRange.endTime, "");
      cue.id = dateRange.id;
      cue.type = "com.apple.quicktime.HLS";
      cue.value = {
        key: dateRangeAttr[key],
        data: dateRange[key]
      };
      if (key === "scte35Out" || key === "scte35In") {
        cue.value.data = new Uint8Array(cue.value.data.match(/[\da-f]{2}/gi)).buffer;
      }
      metadataTrack.addCue(cue);
    }
    dateRange.processDateRange();
  });
};
const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {
  if (inbandTextTracks.metadataTrack_) {
    return;
  }
  inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, false).track;
  if (!videojs$2.browser.IS_ANY_SAFARI) {
    inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
  }
};
const removeCuesFromTrack = function(start2, end2, track) {
  let i;
  let cue;
  if (!track) {
    return;
  }
  if (!track.cues) {
    return;
  }
  i = track.cues.length;
  while (i--) {
    cue = track.cues[i];
    if (cue.startTime >= start2 && cue.endTime <= end2) {
      track.removeCue(cue);
    }
  }
};
const removeDuplicateCuesFromTrack = function(track) {
  const cues = track.cues;
  if (!cues) {
    return;
  }
  const uniqueCues = {};
  for (let i = cues.length - 1; i >= 0; i--) {
    const cue = cues[i];
    const cueKey = `${cue.startTime}-${cue.endTime}-${cue.text}`;
    if (uniqueCues[cueKey]) {
      track.removeCue(cue);
    } else {
      uniqueCues[cueKey] = cue;
    }
  }
};
const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {
  if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
    return [];
  }
  const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock.ONE_SECOND_IN_TS);
  let i;
  for (i = 0; i < buffer.length; i++) {
    if (buffer[i].pts > currentTimePts) {
      break;
    }
  }
  return buffer.slice(i);
};
const updateGopBuffer = (buffer, gops, replace) => {
  if (!gops.length) {
    return buffer;
  }
  if (replace) {
    return gops.slice();
  }
  const start2 = gops[0].pts;
  let i = 0;
  for (i; i < buffer.length; i++) {
    if (buffer[i].pts >= start2) {
      break;
    }
  }
  return buffer.slice(0, i).concat(gops);
};
const removeGopBuffer = (buffer, start2, end2, mapping) => {
  const startPts = Math.ceil((start2 - mapping) * clock.ONE_SECOND_IN_TS);
  const endPts = Math.ceil((end2 - mapping) * clock.ONE_SECOND_IN_TS);
  const updatedBuffer = buffer.slice();
  let i = buffer.length;
  while (i--) {
    if (buffer[i].pts <= endPts) {
      break;
    }
  }
  if (i === -1) {
    return updatedBuffer;
  }
  let j = i + 1;
  while (j--) {
    if (buffer[j].pts <= startPts) {
      break;
    }
  }
  j = Math.max(j, 0);
  updatedBuffer.splice(j, i - j + 1);
  return updatedBuffer;
};
const shallowEqual = function(a, b) {
  if (!a && !b || !a && b || a && !b) {
    return false;
  }
  if (a === b) {
    return true;
  }
  const akeys = Object.keys(a).sort();
  const bkeys = Object.keys(b).sort();
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (let i = 0; i < akeys.length; i++) {
    const key = akeys[i];
    if (key !== bkeys[i]) {
      return false;
    }
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
};
const getSyncSegmentCandidate = function(currentTimeline, segments, targetTime) {
  segments = segments || [];
  const timelineSegments = [];
  let time = 0;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (currentTimeline === segment.timeline) {
      timelineSegments.push(i);
      time += segment.duration;
      if (time > targetTime) {
        return i;
      }
    }
  }
  if (timelineSegments.length === 0) {
    return 0;
  }
  return timelineSegments[timelineSegments.length - 1];
};
const MIN_BACK_BUFFER = 1;
const CHECK_BUFFER_DELAY = 500;
const finite = (num) => typeof num === "number" && isFinite(num);
const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {
  if (loaderType !== "main" || !startingMedia || !trackInfo) {
    return null;
  }
  if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
    return "Neither audio nor video found in segment.";
  }
  if (startingMedia.hasVideo && !trackInfo.hasVideo) {
    return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
  }
  if (!startingMedia.hasVideo && trackInfo.hasVideo) {
    return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
  }
  return null;
};
const safeBackBufferTrimTime = (seekable2, currentTime, targetDuration) => {
  let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
  if (seekable2.length) {
    trimTime = Math.max(trimTime, seekable2.start(0));
  }
  const maxTrimTime = currentTime - targetDuration;
  return Math.min(maxTrimTime, trimTime);
};
const segmentInfoString = (segmentInfo) => {
  const {
    startOfSegment,
    duration: duration2,
    segment,
    part,
    playlist: {
      mediaSequence: seq,
      id,
      segments = []
    },
    mediaIndex: index,
    partIndex,
    timeline
  } = segmentInfo;
  const segmentLen = segments.length - 1;
  let selection = "mediaIndex/partIndex increment";
  if (segmentInfo.getMediaInfoForTime) {
    selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`;
  } else if (segmentInfo.isSyncRequest) {
    selection = "getSyncSegmentCandidate (isSyncRequest)";
  }
  if (segmentInfo.independent) {
    selection += ` with independent ${segmentInfo.independent}`;
  }
  const hasPartIndex = typeof partIndex === "number";
  const name = segmentInfo.segment.uri ? "segment" : "pre-segment";
  const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
    preloadSegment: segment
  }) - 1 : 0;
  return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : "") + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : "") + ` startOfSegment [${startOfSegment}] duration [${duration2}] timeline [${timeline}] selected by [${selection}] playlist [${id}]`;
};
const timingInfoPropertyForMedia = (mediaType) => `${mediaType}TimingInfo`;
const timestampOffsetForSegment = ({
  segmentTimeline,
  currentTimeline,
  startOfSegment,
  buffered,
  overrideCheck
}) => {
  if (!overrideCheck && segmentTimeline === currentTimeline) {
    return null;
  }
  if (segmentTimeline < currentTimeline) {
    return startOfSegment;
  }
  return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
};
const shouldWaitForTimelineChange = ({
  timelineChangeController,
  currentTimeline,
  segmentTimeline,
  loaderType,
  audioDisabled
}) => {
  if (currentTimeline === segmentTimeline) {
    return false;
  }
  if (loaderType === "audio") {
    const lastMainTimelineChange = timelineChangeController.lastTimelineChange({
      type: "main"
    });
    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
  }
  if (loaderType === "main" && audioDisabled) {
    const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
      type: "audio"
    });
    if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
      return false;
    }
    return true;
  }
  return false;
};
const shouldFixBadTimelineChanges = (timelineChangeController) => {
  if (!timelineChangeController) {
    return false;
  }
  const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
    type: "audio"
  });
  const pendingMainTimelineChange = timelineChangeController.pendingTimelineChange({
    type: "main"
  });
  const hasPendingTimelineChanges = pendingAudioTimelineChange && pendingMainTimelineChange;
  const differentPendingChanges = hasPendingTimelineChanges && pendingAudioTimelineChange.to !== pendingMainTimelineChange.to;
  const isNotInitialPendingTimelineChange = hasPendingTimelineChanges && pendingAudioTimelineChange.from !== -1 && pendingMainTimelineChange.from !== -1;
  if (isNotInitialPendingTimelineChange && differentPendingChanges) {
    return true;
  }
  return false;
};
const fixBadTimelineChange = (segmentLoader) => {
  if (!segmentLoader) {
    return;
  }
  segmentLoader.pause();
  segmentLoader.resetEverything();
  segmentLoader.load();
};
const mediaDuration = (timingInfos) => {
  let maxDuration = 0;
  ["video", "audio"].forEach(function(type) {
    const typeTimingInfo = timingInfos[`${type}TimingInfo`];
    if (!typeTimingInfo) {
      return;
    }
    const {
      start: start2,
      end: end2
    } = typeTimingInfo;
    let duration2;
    if (typeof start2 === "bigint" || typeof end2 === "bigint") {
      duration2 = window$1$1.BigInt(end2) - window$1$1.BigInt(start2);
    } else if (typeof start2 === "number" && typeof end2 === "number") {
      duration2 = end2 - start2;
    }
    if (typeof duration2 !== "undefined" && duration2 > maxDuration) {
      maxDuration = duration2;
    }
  });
  if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
    maxDuration = Number(maxDuration);
  }
  return maxDuration;
};
const segmentTooLong = ({
  segmentDuration,
  maxDuration
}) => {
  if (!segmentDuration) {
    return false;
  }
  return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
};
const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {
  if (sourceType !== "hls") {
    return null;
  }
  const segmentDuration = mediaDuration({
    audioTimingInfo: segmentInfo.audioTimingInfo,
    videoTimingInfo: segmentInfo.videoTimingInfo
  });
  if (!segmentDuration) {
    return null;
  }
  const targetDuration = segmentInfo.playlist.targetDuration;
  const isSegmentWayTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration * 2
  });
  const isSegmentSlightlyTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration
  });
  const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} from playlist ${segmentInfo.playlist.id} has a duration of ${segmentDuration} when the reported duration is ${segmentInfo.duration} and the target duration is ${targetDuration}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
  if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
    return {
      severity: isSegmentWayTooLong ? "warn" : "info",
      message: segmentTooLongMessage
    };
  }
  return null;
};
const segmentInfoPayload = ({
  type,
  segment
}) => {
  if (!segment) {
    return;
  }
  const isEncrypted = Boolean(segment.key || segment.map && segment.map.ke);
  const isMediaInitialization = Boolean(segment.map && !segment.map.bytes);
  const start2 = segment.startOfSegment === void 0 ? segment.start : segment.startOfSegment;
  return {
    type: type || segment.type,
    uri: segment.resolvedUri || segment.uri,
    start: start2,
    duration: segment.duration,
    isEncrypted,
    isMediaInitialization
  };
};
class SegmentLoader extends videojs$2.EventTarget {
  constructor(settings, options = {}) {
    super();
    if (!settings) {
      throw new TypeError("Initialization settings are required");
    }
    if (typeof settings.currentTime !== "function") {
      throw new TypeError("No currentTime getter specified");
    }
    if (!settings.mediaSource) {
      throw new TypeError("No MediaSource specified");
    }
    this.bandwidth = settings.bandwidth;
    this.throughput = {
      rate: 0,
      count: 0
    };
    this.roundTrip = NaN;
    this.resetStats_();
    this.mediaIndex = null;
    this.partIndex = null;
    this.hasPlayed_ = settings.hasPlayed;
    this.currentTime_ = settings.currentTime;
    this.seekable_ = settings.seekable;
    this.seeking_ = settings.seeking;
    this.duration_ = settings.duration;
    this.mediaSource_ = settings.mediaSource;
    this.vhs_ = settings.vhs;
    this.loaderType_ = settings.loaderType;
    this.currentMediaInfo_ = void 0;
    this.startingMediaInfo_ = void 0;
    this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
    this.goalBufferLength_ = settings.goalBufferLength;
    this.sourceType_ = settings.sourceType;
    this.sourceUpdater_ = settings.sourceUpdater;
    this.inbandTextTracks_ = settings.inbandTextTracks;
    this.state_ = "INIT";
    this.timelineChangeController_ = settings.timelineChangeController;
    this.shouldSaveSegmentTimingInfo_ = true;
    this.parse708captions_ = settings.parse708captions;
    this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
    this.captionServices_ = settings.captionServices;
    this.exactManifestTimings = settings.exactManifestTimings;
    this.addMetadataToTextTrack = settings.addMetadataToTextTrack;
    this.checkBufferTimeout_ = null;
    this.error_ = void 0;
    this.currentTimeline_ = -1;
    this.shouldForceTimestampOffsetAfterResync_ = false;
    this.pendingSegment_ = null;
    this.xhrOptions_ = null;
    this.pendingSegments_ = [];
    this.audioDisabled_ = false;
    this.isPendingTimestampOffset_ = false;
    this.gopBuffer_ = [];
    this.timeMapping_ = 0;
    this.safeAppend_ = false;
    this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    };
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_ = {
      id3: [],
      caption: []
    };
    this.waitingOnRemove_ = false;
    this.quotaExceededErrorRetryTimeout_ = null;
    this.activeInitSegmentId_ = null;
    this.initSegments_ = {};
    this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
    this.keyCache_ = {};
    this.decrypter_ = settings.decrypter;
    this.syncController_ = settings.syncController;
    this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    };
    this.transmuxer_ = this.createTransmuxer_();
    this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate");
    this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_);
    this.mediaSource_.addEventListener("sourceopen", () => {
      if (!this.isEndOfStream_()) {
        this.ended_ = false;
      }
    });
    this.fetchAtBuffer_ = false;
    this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);
    Object.defineProperty(this, "state", {
      get() {
        return this.state_;
      },
      set(newState) {
        if (newState !== this.state_) {
          this.logger_(`${this.state_} -> ${newState}`);
          this.state_ = newState;
          this.trigger("statechange");
        }
      }
    });
    this.sourceUpdater_.on("ready", () => {
      if (this.hasEnoughInfoToAppend_()) {
        this.processCallQueue_();
      }
    });
    this.sourceUpdater_.on("codecschange", (metadata) => {
      this.trigger(_extends$2({
        type: "codecschange"
      }, metadata));
    });
    if (this.loaderType_ === "main") {
      this.timelineChangeController_.on("pendingtimelinechange", () => {
        if (this.hasEnoughInfoToAppend_()) {
          this.processCallQueue_();
        }
      });
    }
    if (this.loaderType_ === "audio") {
      this.timelineChangeController_.on("timelinechange", (metadata) => {
        this.trigger(_extends$2({
          type: "timelinechange"
        }, metadata));
        if (this.hasEnoughInfoToLoad_()) {
          this.processLoadQueue_();
        }
        if (this.hasEnoughInfoToAppend_()) {
          this.processCallQueue_();
        }
      });
    }
  }
  /**
   * TODO: Current sync controller consists of many hls-specific strategies
   * media sequence sync is also hls-specific, and we would like to be protocol-agnostic on this level
   * this should be a part of the sync-controller and sync controller should expect different strategy list based on the protocol.
   *
   * @return {MediaSequenceSync|null}
   * @private
   */
  get mediaSequenceSync_() {
    return this.syncController_.getMediaSequenceSync(this.loaderType_);
  }
  createTransmuxer_() {
    return segmentTransmuxer.createTransmuxer({
      remux: false,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: true,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  }
  /**
   * reset all of our media stats
   *
   * @private
   */
  resetStats_() {
    this.mediaBytesTransferred = 0;
    this.mediaRequests = 0;
    this.mediaRequestsAborted = 0;
    this.mediaRequestsTimedout = 0;
    this.mediaRequestsErrored = 0;
    this.mediaTransferDuration = 0;
    this.mediaSecondsLoaded = 0;
    this.mediaAppends = 0;
  }
  /**
   * dispose of the SegmentLoader and reset to the default state
   */
  dispose() {
    this.trigger("dispose");
    this.state = "DISPOSED";
    this.pause();
    this.abort_();
    if (this.transmuxer_) {
      this.transmuxer_.terminate();
    }
    this.resetStats_();
    if (this.checkBufferTimeout_) {
      window$1$1.clearTimeout(this.checkBufferTimeout_);
    }
    if (this.syncController_ && this.triggerSyncInfoUpdate_) {
      this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
    }
    this.off();
  }
  setAudio(enable) {
    this.audioDisabled_ = !enable;
    if (enable) {
      this.appendInitSegment_.audio = true;
    } else {
      this.sourceUpdater_.removeAudio(0, this.duration_());
    }
  }
  /**
   * abort anything that is currently doing on with the SegmentLoader
   * and reset to a default state
   */
  abort() {
    if (this.state !== "WAITING") {
      if (this.pendingSegment_) {
        this.pendingSegment_ = null;
      }
      return;
    }
    this.abort_();
    this.state = "READY";
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  }
  /**
   * abort all pending xhr requests and null any pending segements
   *
   * @private
   */
  abort_() {
    if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
      this.pendingSegment_.abortRequests();
    }
    this.pendingSegment_ = null;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
    this.waitingOnRemove_ = false;
    window$1$1.clearTimeout(this.quotaExceededErrorRetryTimeout_);
    this.quotaExceededErrorRetryTimeout_ = null;
  }
  checkForAbort_(requestId) {
    if (this.state === "APPENDING" && !this.pendingSegment_) {
      this.state = "READY";
      return true;
    }
    if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
      return true;
    }
    return false;
  }
  /**
   * set an error on the segment loader and null out any pending segements
   *
   * @param {Error} error the error to set on the SegmentLoader
   * @return {Error} the error that was set or that is currently set
   */
  error(error) {
    if (typeof error !== "undefined") {
      this.logger_("error occurred:", error);
      this.error_ = error;
    }
    this.pendingSegment_ = null;
    return this.error_;
  }
  endOfStream() {
    this.ended_ = true;
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.gopBuffer_.length = 0;
    this.pause();
    this.trigger("ended");
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    const trackInfo = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !trackInfo) {
      return createTimeRanges();
    }
    if (this.loaderType_ === "main") {
      const {
        hasAudio,
        hasVideo,
        isMuxed: isMuxed2
      } = trackInfo;
      if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed2) {
        return this.sourceUpdater_.buffered();
      }
      if (hasVideo) {
        return this.sourceUpdater_.videoBuffered();
      }
    }
    return this.sourceUpdater_.audioBuffered();
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(map2, set2 = false) {
    if (!map2) {
      return null;
    }
    const id = initSegmentId(map2);
    let storedMap = this.initSegments_[id];
    if (set2 && !storedMap && map2.bytes) {
      this.initSegments_[id] = storedMap = {
        resolvedUri: map2.resolvedUri,
        byterange: map2.byterange,
        bytes: map2.bytes,
        tracks: map2.tracks,
        timescales: map2.timescales
      };
    }
    return storedMap || map2;
  }
  /**
   * Gets and sets key for the provided key
   *
   * @param {Object} key
   *        The key object representing the key to get or set
   * @param {boolean=} set
   *        If true, the key for the provided key should be saved
   * @return {Object}
   *         Key object for desired key
   */
  segmentKey(key, set2 = false) {
    if (!key) {
      return null;
    }
    const id = segmentKeyId(key);
    let storedKey = this.keyCache_[id];
    if (this.cacheEncryptionKeys_ && set2 && !storedKey && key.bytes) {
      this.keyCache_[id] = storedKey = {
        resolvedUri: key.resolvedUri,
        bytes: key.bytes
      };
    }
    const result = {
      resolvedUri: (storedKey || key).resolvedUri
    };
    if (storedKey) {
      result.bytes = storedKey.bytes;
    }
    return result;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  }
  /**
   * load a playlist and start to fill the buffer
   */
  load() {
    this.monitorBuffer_();
    if (!this.playlist_) {
      return;
    }
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
      return;
    }
    this.state = "READY";
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  }
  /**
   * set a playlist on the segment loader
   *
   * @param {PlaylistLoader} media the playlist to set on the segment loader
   */
  playlist(newPlaylist, options = {}) {
    if (!newPlaylist) {
      return;
    }
    const oldPlaylist = this.playlist_;
    const segmentInfo = this.pendingSegment_;
    this.playlist_ = newPlaylist;
    this.xhrOptions_ = options;
    if (this.state === "INIT") {
      newPlaylist.syncInfo = {
        mediaSequence: newPlaylist.mediaSequence,
        time: 0
      };
      if (this.loaderType_ === "main") {
        this.syncController_.setDateTimeMappingForStart(newPlaylist);
      }
    }
    let oldId = null;
    if (oldPlaylist) {
      if (oldPlaylist.id) {
        oldId = oldPlaylist.id;
      } else if (oldPlaylist.uri) {
        oldId = oldPlaylist.uri;
      }
    }
    this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`);
    if (this.mediaSequenceSync_) {
      this.mediaSequenceSync_.update(newPlaylist, this.currentTime_());
      this.logger_(`Playlist update:
currentTime: ${this.currentTime_()}
bufferedEnd: ${lastBufferedEnd(this.buffered_())}
`, this.mediaSequenceSync_.diagnostics);
    }
    this.trigger("syncinfoupdate");
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
      if (this.mediaIndex !== null) {
        const isLLHLS = !newPlaylist.endList && typeof newPlaylist.partTargetDuration === "number";
        if (isLLHLS) {
          this.resetLoader();
        } else {
          this.resyncLoader();
        }
      }
      this.currentMediaInfo_ = void 0;
      this.trigger("playlistupdate");
      return;
    }
    const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    this.logger_(`live window shift [${mediaSequenceDiff}]`);
    if (this.mediaIndex !== null) {
      this.mediaIndex -= mediaSequenceDiff;
      if (this.mediaIndex < 0) {
        this.mediaIndex = null;
        this.partIndex = null;
      } else {
        const segment = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
          const mediaIndex = this.mediaIndex;
          this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);
          this.resetLoader();
          this.mediaIndex = mediaIndex;
        }
      }
    }
    if (segmentInfo) {
      segmentInfo.mediaIndex -= mediaSequenceDiff;
      if (segmentInfo.mediaIndex < 0) {
        segmentInfo.mediaIndex = null;
        segmentInfo.partIndex = null;
      } else {
        if (segmentInfo.mediaIndex >= 0) {
          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
        }
        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
          segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
        }
      }
    }
    this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
  }
  /**
   * Prevent the loader from fetching additional segments. If there
   * is a segment request outstanding, it will finish processing
   * before the loader halts. A segment loader can be unpaused by
   * calling load().
   */
  pause() {
    if (this.checkBufferTimeout_) {
      window$1$1.clearTimeout(this.checkBufferTimeout_);
      this.checkBufferTimeout_ = null;
    }
  }
  /**
   * Returns whether the segment loader is fetching additional
   * segments when given the opportunity. This property can be
   * modified through calls to pause() and load().
   */
  paused() {
    return this.checkBufferTimeout_ === null;
  }
  /**
   * Delete all the buffered data and reset the SegmentLoader
   *
   * @param {Function} [done] an optional callback to be executed when the remove
   * operation is complete
   */
  resetEverything(done) {
    this.ended_ = false;
    this.activeInitSegmentId_ = null;
    this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    this.resetLoader();
    this.remove(0, Infinity, done);
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearAllMp4Captions"
      });
      this.transmuxer_.postMessage({
        action: "reset"
      });
    }
  }
  /**
   * Force the SegmentLoader to resync and start loading around the currentTime instead
   * of starting at the end of the buffer
   *
   * Useful for fast quality changes
   */
  resetLoader() {
    this.fetchAtBuffer_ = false;
    if (this.mediaSequenceSync_) {
      this.mediaSequenceSync_.resetAppendedStatus();
    }
    this.resyncLoader();
  }
  /**
   * Force the SegmentLoader to restart synchronization and make a conservative guess
   * before returning to the simple walk-forward method
   */
  resyncLoader() {
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.mediaIndex = null;
    this.partIndex = null;
    this.syncPoint_ = null;
    this.isPendingTimestampOffset_ = false;
    const isFmp4 = this.currentMediaInfo_ && this.currentMediaInfo_.isFmp4;
    const isHlsTs = this.sourceType_ === "hls" && !isFmp4;
    if (isHlsTs) {
      this.shouldForceTimestampOffsetAfterResync_ = true;
    }
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.abort();
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   * @param {Function} [done] - an optional callback to be executed when the remove
   * @param {boolean} force - force all remove operations to happen
   * operation is complete
   */
  remove(start2, end2, done = () => {
  }, force = false) {
    if (end2 === Infinity) {
      end2 = this.duration_();
    }
    if (end2 <= start2) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    let removesRemaining = 1;
    const removeFinished = () => {
      removesRemaining--;
      if (removesRemaining === 0) {
        done();
      }
    };
    if (force || !this.audioDisabled_) {
      removesRemaining++;
      this.sourceUpdater_.removeAudio(start2, end2, removeFinished);
    }
    if (force || this.loaderType_ === "main") {
      this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start2, end2, this.timeMapping_);
      removesRemaining++;
      this.sourceUpdater_.removeVideo(start2, end2, removeFinished);
    }
    for (const track in this.inbandTextTracks_) {
      removeCuesFromTrack(start2, end2, this.inbandTextTracks_[track]);
    }
    removeCuesFromTrack(start2, end2, this.segmentMetadataTrack_);
    removeFinished();
  }
  /**
   * (re-)schedule monitorBufferTick_ to run as soon as possible
   *
   * @private
   */
  monitorBuffer_() {
    if (this.checkBufferTimeout_) {
      window$1$1.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = window$1$1.setTimeout(this.monitorBufferTick_.bind(this), 1);
  }
  /**
   * As long as the SegmentLoader is in the READY state, periodically
   * invoke fillBuffer_().
   *
   * @private
   */
  monitorBufferTick_() {
    if (this.state === "READY") {
      this.fillBuffer_();
    }
    if (this.checkBufferTimeout_) {
      window$1$1.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = window$1$1.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    if (this.sourceUpdater_.updating()) {
      return;
    }
    const segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    const metadata = {
      segmentInfo: segmentInfoPayload({
        type: this.loaderType_,
        segment: segmentInfo
      })
    };
    this.trigger({
      type: "segmentselected",
      metadata
    });
    if (typeof segmentInfo.timestampOffset === "number") {
      this.isPendingTimestampOffset_ = false;
      this.timelineChangeController_.pendingTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
    }
    this.loadSegment_(segmentInfo);
  }
  /**
   * Determines if we should call endOfStream on the media source based
   * on the state of the buffer or if appened segment was the final
   * segment in the playlist.
   *
   * @param {number} [mediaIndex] the media index of segment we last appended
   * @param {Object} [playlist] a media playlist object
   * @return {boolean} do we need to call endOfStream on the MediaSource
   */
  isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {
    if (!playlist || !this.mediaSource_) {
      return false;
    }
    const segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
    const appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
    const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
    return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
  }
  /**
   * Determines what request should be made given current segment loader state.
   *
   * @return {Object} a request object that describes the segment/part to load
   */
  chooseNextRequest_() {
    const buffered = this.buffered_();
    const bufferedEnd = lastBufferedEnd(buffered) || 0;
    const bufferedTime = timeAheadOf(buffered, this.currentTime_());
    const preloaded = !this.hasPlayed_() && bufferedTime >= 1;
    const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
    const segments = this.playlist_.segments;
    if (!segments.length || preloaded || haveEnoughBuffer) {
      return null;
    }
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
    const next = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: Boolean(!this.syncPoint_)
    };
    if (next.isSyncRequest) {
      next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
      this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${next.mediaIndex}`);
    } else if (this.mediaIndex !== null) {
      const segment = segments[this.mediaIndex];
      const partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
      next.startOfSegment = segment.end ? segment.end : bufferedEnd;
      if (segment.parts && segment.parts[partIndex + 1]) {
        next.mediaIndex = this.mediaIndex;
        next.partIndex = partIndex + 1;
      } else {
        next.mediaIndex = this.mediaIndex + 1;
      }
    } else {
      let segmentIndex;
      let partIndex;
      let startTime;
      const targetTime = this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_();
      if (this.mediaSequenceSync_) {
        this.logger_(`chooseNextRequest_ request after Quality Switch:
For TargetTime: ${targetTime}.
CurrentTime: ${this.currentTime_()}
BufferedEnd: ${bufferedEnd}
Fetch At Buffer: ${this.fetchAtBuffer_}
`, this.mediaSequenceSync_.diagnostics);
      }
      if (this.mediaSequenceSync_ && this.mediaSequenceSync_.isReliable) {
        const syncInfo = this.getSyncInfoFromMediaSequenceSync_(targetTime);
        if (!syncInfo) {
          const message = "No sync info found while using media sequence sync";
          this.error({
            message,
            metadata: {
              errorType: videojs$2.Error.StreamingFailedToSelectNextSegment,
              error: new Error(message)
            }
          });
          this.logger_("chooseNextRequest_ - no sync info found using media sequence sync");
          return null;
        }
        this.logger_(`chooseNextRequest_ mediaSequence syncInfo (${syncInfo.start} --> ${syncInfo.end})`);
        segmentIndex = syncInfo.segmentIndex;
        partIndex = syncInfo.partIndex;
        startTime = syncInfo.start;
      } else {
        this.logger_("chooseNextRequest_ - fallback to a regular segment selection algorithm, based on a syncPoint.");
        const mediaInfoForTime = Playlist.getMediaInfoForTime({
          exactManifestTimings: this.exactManifestTimings,
          playlist: this.playlist_,
          currentTime: targetTime,
          startingPartIndex: this.syncPoint_.partIndex,
          startingSegmentIndex: this.syncPoint_.segmentIndex,
          startTime: this.syncPoint_.time
        });
        segmentIndex = mediaInfoForTime.segmentIndex;
        partIndex = mediaInfoForTime.partIndex;
        startTime = mediaInfoForTime.startTime;
      }
      next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${targetTime}` : `currentTime ${targetTime}`;
      next.mediaIndex = segmentIndex;
      next.startOfSegment = startTime;
      next.partIndex = partIndex;
      this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${next.mediaIndex} `);
    }
    const nextSegment = segments[next.mediaIndex];
    let nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
    if (!nextSegment || typeof next.partIndex === "number" && !nextPart) {
      return null;
    }
    if (typeof next.partIndex !== "number" && nextSegment.parts) {
      next.partIndex = 0;
      nextPart = nextSegment.parts[0];
    }
    const hasIndependentSegments = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
    if (!bufferedTime && nextPart && !hasIndependentSegments && !nextPart.independent) {
      if (next.partIndex === 0) {
        const lastSegment = segments[next.mediaIndex - 1];
        const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
        if (lastSegmentLastPart && lastSegmentLastPart.independent) {
          next.mediaIndex -= 1;
          next.partIndex = lastSegment.parts.length - 1;
          next.independent = "previous segment";
        }
      } else if (nextSegment.parts[next.partIndex - 1].independent) {
        next.partIndex -= 1;
        next.independent = "previous part";
      }
    }
    const ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
      return null;
    }
    if (this.shouldForceTimestampOffsetAfterResync_) {
      this.shouldForceTimestampOffsetAfterResync_ = false;
      next.forceTimestampOffset = true;
      this.logger_("choose next request. Force timestamp offset after loader resync");
    }
    return this.generateSegmentInfo_(next);
  }
  getSyncInfoFromMediaSequenceSync_(targetTime) {
    if (!this.mediaSequenceSync_) {
      return null;
    }
    const finalTargetTime = Math.max(targetTime, this.mediaSequenceSync_.start);
    if (targetTime !== finalTargetTime) {
      this.logger_(`getSyncInfoFromMediaSequenceSync_. Pulled target time from ${targetTime} to ${finalTargetTime}`);
    }
    const mediaSequenceSyncInfo = this.mediaSequenceSync_.getSyncInfoForTime(finalTargetTime);
    if (!mediaSequenceSyncInfo) {
      return null;
    }
    if (!mediaSequenceSyncInfo.isAppended) {
      return mediaSequenceSyncInfo;
    }
    const nextMediaSequenceSyncInfo = this.mediaSequenceSync_.getSyncInfoForTime(mediaSequenceSyncInfo.end);
    if (!nextMediaSequenceSyncInfo) {
      return null;
    }
    if (nextMediaSequenceSyncInfo.isAppended) {
      this.logger_("getSyncInfoFromMediaSequenceSync_: We encounter unexpected scenario where next media sequence sync info is also appended!");
    }
    return nextMediaSequenceSyncInfo;
  }
  generateSegmentInfo_(options) {
    const {
      independent,
      playlist,
      mediaIndex,
      startOfSegment,
      isSyncRequest,
      partIndex,
      forceTimestampOffset,
      getMediaInfoForTime: getMediaInfoForTime2
    } = options;
    const segment = playlist.segments[mediaIndex];
    const part = typeof partIndex === "number" && segment.parts[partIndex];
    const segmentInfo = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: part && part.resolvedUri || segment.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex,
      partIndex: part ? partIndex : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest,
      startOfSegment,
      // the segment's playlist
      playlist,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: segment.timeline,
      // The expected duration of the segment in seconds
      duration: part && part.duration || segment.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment,
      part,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: getMediaInfoForTime2,
      independent
    };
    const overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
    segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: segment.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment,
      buffered: this.buffered_(),
      overrideCheck
    });
    const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
    if (typeof audioBufferedEnd === "number") {
      segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
    }
    if (this.sourceUpdater_.videoBuffered().length) {
      segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(
        this.gopBuffer_,
        // since the transmuxer is using the actual timing values, but the time is
        // adjusted by the timestmap offset, we must adjust the value here
        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
        this.timeMapping_
      );
    }
    return segmentInfo;
  }
  // get the timestampoffset for a segment,
  // added so that vtt segment loader can override and prevent
  // adding timestamp offsets.
  timestampOffsetForSegment_(options) {
    return timestampOffsetForSegment(options);
  }
  /**
   * Determines if the network has enough bandwidth to complete the current segment
   * request in a timely manner. If not, the request will be aborted early and bandwidth
   * updated to trigger a playlist switch.
   *
   * @param {Object} stats
   *        Object containing stats about the request timing and size
   * @private
   */
  earlyAbortWhenNeeded_(stats) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) {
      return;
    }
    if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
      return;
    }
    const currentTime = this.currentTime_();
    const measuredBandwidth = stats.bandwidth;
    const segmentDuration = this.pendingSegment_.duration;
    const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
    const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
    if (requestTimeRemaining <= timeUntilRebuffer$1) {
      return;
    }
    const switchCandidate = minRebufferMaxBandwidthSelector({
      main: this.vhs_.playlists.main,
      currentTime,
      bandwidth: measuredBandwidth,
      duration: this.duration_(),
      segmentDuration,
      timeUntilRebuffer: timeUntilRebuffer$1,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!switchCandidate) {
      return;
    }
    const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
    const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
    let minimumTimeSaving = 0.5;
    if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
      minimumTimeSaving = 1;
    }
    if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
      return;
    }
    this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
    this.trigger("earlyabort");
  }
  handleAbort_(segmentInfo) {
    this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);
    this.mediaRequestsAborted += 1;
  }
  /**
   * XHR `progress` event handler
   *
   * @param {Event}
   *        The XHR `progress` event
   * @param {Object} simpleSegment
   *        A simplified segment object copy
   * @private
   */
  handleProgress_(event2, simpleSegment) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.trigger("progress");
  }
  handleTrackInfo_(simpleSegment, trackInfo) {
    const {
      hasAudio,
      hasVideo
    } = trackInfo;
    const metadata = {
      segmentInfo: segmentInfoPayload({
        type: this.loaderType_,
        segment: simpleSegment
      }),
      trackInfo: {
        hasAudio,
        hasVideo
      }
    };
    this.trigger({
      type: "segmenttransmuxingtrackinfoavailable",
      metadata
    });
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.checkForIllegalMediaSwitch(trackInfo)) {
      return;
    }
    trackInfo = trackInfo || {};
    if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.startingMediaInfo_ = trackInfo;
      this.currentMediaInfo_ = trackInfo;
      this.logger_("trackinfo update", trackInfo);
      this.trigger("trackinfo");
    }
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.pendingSegment_.trackInfo = trackInfo;
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  }
  handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    const segmentInfo = this.pendingSegment_;
    const timingInfoProperty = timingInfoPropertyForMedia(mediaType);
    segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
    segmentInfo[timingInfoProperty][timeType] = time;
    this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`);
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  }
  handleCaptions_(simpleSegment, captionData) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (captionData.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    const segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
      return;
    }
    const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    const captionTracks = {};
    captionData.forEach((caption) => {
      captionTracks[caption.stream] = captionTracks[caption.stream] || {
        // Infinity, as any other value will be less than this
        startTime: Infinity,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      const captionTrack = captionTracks[caption.stream];
      captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
      captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
      captionTrack.captions.push(caption);
    });
    Object.keys(captionTracks).forEach((trackName) => {
      const {
        startTime,
        endTime,
        captions
      } = captionTracks[trackName];
      const inbandTextTracks = this.inbandTextTracks_;
      this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);
      createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName);
      removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
      addCaptionData({
        captionArray: captions,
        inbandTextTracks,
        timestampOffset
      });
    });
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  }
  handleId3_(simpleSegment, id3Frames, dispatchType) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    const segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
      return;
    }
    this.addMetadataToTextTrack(dispatchType, id3Frames, this.duration_());
  }
  processMetadataQueue_() {
    this.metadataQueue_.id3.forEach((fn2) => fn2());
    this.metadataQueue_.caption.forEach((fn2) => fn2());
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
  }
  processCallQueue_() {
    const callQueue = this.callQueue_;
    this.callQueue_ = [];
    callQueue.forEach((fun) => fun());
  }
  processLoadQueue_() {
    const loadQueue = this.loadQueue_;
    this.loadQueue_ = [];
    loadQueue.forEach((fun) => fun());
  }
  /**
   * Determines whether the loader has enough info to load the next segment.
   *
   * @return {boolean}
   *         Whether or not the loader has enough info to load the next segment
   */
  hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio") {
      return true;
    }
    const segmentInfo = this.pendingSegment_;
    if (!segmentInfo) {
      return false;
    }
    if (!this.getCurrentMediaInfo_()) {
      return true;
    }
    if (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) {
      if (shouldFixBadTimelineChanges(this.timelineChangeController_)) {
        fixBadTimelineChange(this);
      }
      return false;
    }
    return true;
  }
  getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {
    return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
  }
  getMediaInfo_(segmentInfo = this.pendingSegment_) {
    return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
  }
  getPendingSegmentPlaylist() {
    return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
  }
  hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready()) {
      return false;
    }
    if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
      return false;
    }
    const segmentInfo = this.pendingSegment_;
    const trackInfo = this.getCurrentMediaInfo_();
    if (!segmentInfo || !trackInfo) {
      return false;
    }
    const {
      hasAudio,
      hasVideo,
      isMuxed: isMuxed2
    } = trackInfo;
    if (hasVideo && !segmentInfo.videoTimingInfo) {
      return false;
    }
    if (hasAudio && !this.audioDisabled_ && !isMuxed2 && !segmentInfo.audioTimingInfo) {
      return false;
    }
    if (shouldWaitForTimelineChange({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: segmentInfo.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    })) {
      if (shouldFixBadTimelineChanges(this.timelineChangeController_)) {
        fixBadTimelineChange(this);
      }
      return false;
    }
    return true;
  }
  handleData_(simpleSegment, result) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
      return;
    }
    const segmentInfo = this.pendingSegment_;
    this.setTimeMapping_(segmentInfo.timeline);
    this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
    if (this.mediaSource_.readyState === "closed") {
      return;
    }
    if (simpleSegment.map) {
      simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
      segmentInfo.segment.map = simpleSegment.map;
    }
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    segmentInfo.isFmp4 = simpleSegment.isFmp4;
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    if (segmentInfo.isFmp4) {
      this.trigger("fmp4");
      segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
    } else {
      const trackInfo = this.getCurrentMediaInfo_();
      const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
      let firstVideoFrameTimeForData;
      if (useVideoTimingInfo) {
        firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
      }
      segmentInfo.timingInfo.start = this.trueSegmentStart_({
        currentStart: segmentInfo.timingInfo.start,
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex,
        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
        useVideoTimingInfo,
        firstVideoFrameTimeForData,
        videoTimingInfo: segmentInfo.videoTimingInfo,
        audioTimingInfo: segmentInfo.audioTimingInfo
      });
    }
    this.updateAppendInitSegmentStatus(segmentInfo, result.type);
    this.updateSourceBufferTimestampOffset_(segmentInfo);
    if (segmentInfo.isSyncRequest) {
      this.updateTimingInfoEnd_(segmentInfo);
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
      const next = this.chooseNextRequest_();
      if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
        this.logger_("sync segment was incorrect, not appending");
        return;
      }
      this.logger_("sync segment was correct, appending");
    }
    segmentInfo.hasAppendedData_ = true;
    this.processMetadataQueue_();
    this.appendData_(segmentInfo, result);
  }
  updateAppendInitSegmentStatus(segmentInfo, type) {
    if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !segmentInfo.changedTimestampOffset) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
    }
    if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {
      this.appendInitSegment_[type] = true;
    }
  }
  getInitSegmentAndUpdateState_({
    type,
    initSegment,
    map: map2,
    playlist
  }) {
    if (map2) {
      const id = initSegmentId(map2);
      if (this.activeInitSegmentId_ === id) {
        return null;
      }
      initSegment = this.initSegmentForMap(map2, true).bytes;
      this.activeInitSegmentId_ = id;
    }
    if (initSegment && this.appendInitSegment_[type]) {
      this.playlistOfLastInitSegment_[type] = playlist;
      this.appendInitSegment_[type] = false;
      this.activeInitSegmentId_ = null;
      return initSegment;
    }
    return null;
  }
  handleQuotaExceededError_({
    segmentInfo,
    type,
    bytes
  }, error) {
    const audioBuffered = this.sourceUpdater_.audioBuffered();
    const videoBuffered = this.sourceUpdater_.videoBuffered();
    if (audioBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
    }
    if (videoBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
    }
    const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
    const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
    const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
    const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
    if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
      this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${bytes.byteLength}, audio buffer: ${timeRangesToArray(audioBuffered).join(", ")}, video buffer: ${timeRangesToArray(videoBuffered).join(", ")}, `);
      this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: Infinity
      });
      this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = true;
    this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo,
      type,
      bytes
    }));
    const currentTime = this.currentTime_();
    const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
    this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);
    this.remove(0, timeToRemoveUntil, () => {
      this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);
      this.waitingOnRemove_ = false;
      this.quotaExceededErrorRetryTimeout_ = window$1$1.setTimeout(() => {
        this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
        this.quotaExceededErrorRetryTimeout_ = null;
        this.processCallQueue_();
      }, MIN_BACK_BUFFER * 1e3);
    }, true);
  }
  handleAppendError_({
    segmentInfo,
    type,
    bytes
  }, error) {
    if (!error) {
      return;
    }
    if (error.code === QUOTA_EXCEEDED_ERR) {
      this.handleQuotaExceededError_({
        segmentInfo,
        type,
        bytes
      });
      return;
    }
    this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
    this.error({
      message: `${type} append of ${bytes.length}b failed for segment #${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`,
      metadata: {
        errorType: videojs$2.Error.StreamingFailedToAppendSegment
      }
    });
    this.trigger("appenderror");
  }
  appendToSourceBuffer_({
    segmentInfo,
    type,
    initSegment,
    data,
    bytes
  }) {
    if (!bytes) {
      const segments = [data];
      let byteLength2 = data.byteLength;
      if (initSegment) {
        segments.unshift(initSegment);
        byteLength2 += initSegment.byteLength;
      }
      bytes = concatSegments({
        bytes: byteLength2,
        segments
      });
    }
    const metadata = {
      segmentInfo: segmentInfoPayload({
        type: this.loaderType_,
        segment: segmentInfo
      })
    };
    this.trigger({
      type: "segmentappendstart",
      metadata
    });
    this.sourceUpdater_.appendBuffer({
      segmentInfo,
      type,
      bytes
    }, this.handleAppendError_.bind(this, {
      segmentInfo,
      type,
      bytes
    }));
  }
  handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
    if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
      return;
    }
    const segment = this.pendingSegment_.segment;
    const timingInfoProperty = `${type}TimingInfo`;
    if (!segment[timingInfoProperty]) {
      segment[timingInfoProperty] = {};
    }
    segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
    segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
    segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
    segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
    segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
    segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
  }
  appendData_(segmentInfo, result) {
    const {
      type,
      data
    } = result;
    if (!data || !data.byteLength) {
      return;
    }
    if (type === "audio" && this.audioDisabled_) {
      return;
    }
    const initSegment = this.getInitSegmentAndUpdateState_({
      type,
      initSegment: result.initSegment,
      playlist: segmentInfo.playlist,
      map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo,
      type,
      initSegment,
      data
    });
  }
  /**
   * load a specific segment from a request into the buffer
   *
   * @private
   */
  loadSegment_(segmentInfo) {
    this.state = "WAITING";
    this.pendingSegment_ = segmentInfo;
    this.trimBackBuffer_(segmentInfo);
    if (typeof segmentInfo.timestampOffset === "number") {
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearAllMp4Captions"
        });
      }
    }
    if (!this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(() => {
        const options = _extends$2({}, segmentInfo, {
          forceTimestampOffset: true
        });
        _extends$2(segmentInfo, this.generateSegmentInfo_(options));
        this.isPendingTimestampOffset_ = false;
        this.updateTransmuxerAndRequestSegment_(segmentInfo);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(segmentInfo);
  }
  updateTransmuxerAndRequestSegment_(segmentInfo) {
    if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
      this.gopBuffer_.length = 0;
      segmentInfo.gopsToAlignWith = [];
      this.timeMapping_ = 0;
      this.transmuxer_.postMessage({
        action: "reset"
      });
      this.transmuxer_.postMessage({
        action: "setTimestampOffset",
        timestampOffset: segmentInfo.timestampOffset
      });
    }
    const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
    const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
    const isWalkingForward = this.mediaIndex !== null;
    const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    segmentInfo.timeline > 0;
    const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
    this.logger_(`Requesting
${compactSegmentUrlDescription(segmentInfo.uri)}
${segmentInfoString(segmentInfo)}`);
    if (simpleSegment.map && !simpleSegment.map.bytes) {
      this.logger_("going to request init segment.");
      this.appendInitSegment_ = {
        video: true,
        audio: true
      };
    }
    segmentInfo.abortRequests = mediaSegmentRequest({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: simpleSegment,
      abortFn: this.handleAbort_.bind(this, segmentInfo),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline,
      endedTimelineFn: () => {
        this.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: ({
        message,
        level,
        stream
      }) => {
        this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);
      },
      triggerSegmentEventFn: ({
        type,
        segment,
        keyInfo,
        trackInfo,
        timingInfo
      }) => {
        const segInfo = segmentInfoPayload({
          segment
        });
        const metadata = {
          segmentInfo: segInfo
        };
        if (keyInfo) {
          metadata.keyInfo = keyInfo;
        }
        if (trackInfo) {
          metadata.trackInfo = trackInfo;
        }
        if (timingInfo) {
          metadata.timingInfo = timingInfo;
        }
        this.trigger({
          type,
          metadata
        });
      }
    });
  }
  /**
   * trim the back buffer so that we don't have too much data
   * in the source buffer
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   */
  trimBackBuffer_(segmentInfo) {
    const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    if (removeToTime > 0) {
      this.remove(0, removeToTime);
    }
  }
  /**
   * created a simplified copy of the segment object with just the
   * information necessary to perform the XHR and decryption
   *
   * @private
   *
   * @param {Object} segmentInfo - the current segment
   * @return {Object} a simplified segment object copy
   */
  createSimplifiedSegmentObj_(segmentInfo) {
    const segment = segmentInfo.segment;
    const part = segmentInfo.part;
    const isEncrypted = segmentInfo.segment.key || segmentInfo.segment.map && segmentInfo.segment.map.key;
    const isMediaInitialization = segmentInfo.segment.map && !segmentInfo.segment.map.bytes;
    const simpleSegment = {
      resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
      byterange: part ? part.byterange : segment.byterange,
      requestId: segmentInfo.requestId,
      transmuxer: segmentInfo.transmuxer,
      audioAppendStart: segmentInfo.audioAppendStart,
      gopsToAlignWith: segmentInfo.gopsToAlignWith,
      part: segmentInfo.part,
      type: this.loaderType_,
      start: segmentInfo.startOfSegment,
      duration: segmentInfo.duration,
      isEncrypted,
      isMediaInitialization
    };
    const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
    if (previousSegment && previousSegment.timeline === segment.timeline) {
      if (previousSegment.videoTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
      } else if (previousSegment.audioTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
      }
    }
    if (segment.key) {
      const iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
      simpleSegment.key = this.segmentKey(segment.key);
      simpleSegment.key.iv = iv;
    }
    if (segment.map) {
      simpleSegment.map = this.initSegmentForMap(segment.map);
    }
    return simpleSegment;
  }
  saveTransferStats_(stats) {
    this.mediaRequests += 1;
    if (stats) {
      this.mediaBytesTransferred += stats.bytesReceived;
      this.mediaTransferDuration += stats.roundTripTime;
    }
  }
  saveBandwidthRelatedStats_(duration2, stats) {
    this.pendingSegment_.byteLength = stats.bytesReceived;
    if (duration2 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_(`Ignoring segment's bandwidth because its duration of ${duration2} is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
      return;
    }
    const metadata = {
      bandwidthInfo: {
        from: this.bandwidth,
        to: stats.bandwidth
      }
    };
    this.trigger({
      type: "bandwidthupdated",
      metadata
    });
    this.bandwidth = stats.bandwidth;
    this.roundTrip = stats.roundTripTime;
  }
  handleTimeout_() {
    this.mediaRequestsTimedout += 1;
    this.bandwidth = 1;
    this.roundTrip = NaN;
    this.trigger("bandwidthupdate");
    this.trigger("timeout");
  }
  /**
   * Handle the callback from the segmentRequest function and set the
   * associated SegmentLoader state and errors if necessary
   *
   * @private
   */
  segmentRequestFinished_(error, simpleSegment, result) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      return;
    }
    if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
      return;
    }
    if (error) {
      this.pendingSegment_ = null;
      this.state = "READY";
      if (error.code === REQUEST_ERRORS.ABORTED) {
        return;
      }
      this.pause();
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1;
      this.error(error);
      this.trigger("error");
      return;
    }
    const segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
    if (result.gopInfo) {
      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    this.waitForAppendsToComplete_(segmentInfo);
  }
  setTimeMapping_(timeline) {
    const timelineMapping = this.syncController_.mappingForTimeline(timeline);
    if (timelineMapping !== null) {
      this.timeMapping_ = timelineMapping;
    }
  }
  updateMediaSecondsLoaded_(segment) {
    if (typeof segment.start === "number" && typeof segment.end === "number") {
      this.mediaSecondsLoaded += segment.end - segment.start;
    } else {
      this.mediaSecondsLoaded += segment.duration;
    }
  }
  shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
    if (timestampOffset === null) {
      return false;
    }
    if (this.loaderType_ === "main" && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
      return true;
    }
    if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
      return true;
    }
    return false;
  }
  trueSegmentStart_({
    currentStart,
    playlist,
    mediaIndex,
    firstVideoFrameTimeForData,
    currentVideoTimestampOffset,
    useVideoTimingInfo,
    videoTimingInfo,
    audioTimingInfo
  }) {
    if (typeof currentStart !== "undefined") {
      return currentStart;
    }
    if (!useVideoTimingInfo) {
      return audioTimingInfo.start;
    }
    const previousSegment = playlist.segments[mediaIndex - 1];
    if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
      return firstVideoFrameTimeForData;
    }
    return videoTimingInfo.start;
  }
  waitForAppendsToComplete_(segmentInfo) {
    const trackInfo = this.getCurrentMediaInfo_(segmentInfo);
    if (!trackInfo) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        playlistExclusionDuration: Infinity
      });
      this.trigger("error");
      return;
    }
    const {
      hasAudio,
      hasVideo,
      isMuxed: isMuxed2
    } = trackInfo;
    const waitForVideo = this.loaderType_ === "main" && hasVideo;
    const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed2;
    segmentInfo.waitingOnAppends = 0;
    if (!segmentInfo.hasAppendedData_) {
      if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
        this.isPendingTimestampOffset_ = true;
      }
      segmentInfo.timingInfo = {
        start: 0
      };
      segmentInfo.waitingOnAppends++;
      if (!this.isPendingTimestampOffset_) {
        this.updateSourceBufferTimestampOffset_(segmentInfo);
        this.processMetadataQueue_();
      }
      this.checkAppendsDone_(segmentInfo);
      return;
    }
    if (waitForVideo) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForAudio) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForVideo) {
      this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
    if (waitForAudio) {
      this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
  }
  checkAppendsDone_(segmentInfo) {
    if (this.checkForAbort_(segmentInfo.requestId)) {
      return;
    }
    segmentInfo.waitingOnAppends--;
    if (segmentInfo.waitingOnAppends === 0) {
      this.handleAppendsDone_();
    }
  }
  checkForIllegalMediaSwitch(trackInfo) {
    const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
    if (illegalMediaSwitchError) {
      this.error({
        message: illegalMediaSwitchError,
        playlistExclusionDuration: Infinity
      });
      this.trigger("error");
      return true;
    }
    return false;
  }
  updateSourceBufferTimestampOffset_(segmentInfo) {
    if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof segmentInfo.timingInfo.start !== "number" || // already updated the timestamp offset for this segment
    segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main") {
      return;
    }
    let didChange = false;
    segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: segmentInfo.segment.videoTimingInfo,
      audioTimingInfo: segmentInfo.segment.audioTimingInfo,
      timingInfo: segmentInfo.timingInfo
    });
    segmentInfo.changedTimestampOffset = true;
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
      this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
      this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (didChange) {
      this.trigger("timestampoffset");
    }
  }
  getSegmentStartTimeForTimestampOffsetCalculation_({
    videoTimingInfo,
    audioTimingInfo,
    timingInfo
  }) {
    if (!this.useDtsForTimestampOffset_) {
      return timingInfo.start;
    }
    if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
      return videoTimingInfo.transmuxedDecodeStart;
    }
    if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
      return audioTimingInfo.transmuxedDecodeStart;
    }
    return timingInfo.start;
  }
  updateTimingInfoEnd_(segmentInfo) {
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    const trackInfo = this.getMediaInfo_();
    const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
    const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
    if (!prioritizedTimingInfo) {
      return;
    }
    segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      prioritizedTimingInfo.end
    ) : prioritizedTimingInfo.start + segmentInfo.duration;
  }
  /**
   * callback to run when appendBuffer is finished. detects if we are
   * in a good state to do things with the data we got, or if we need
   * to wait for more
   *
   * @private
   */
  handleAppendsDone_() {
    if (this.pendingSegment_) {
      const metadata = {
        segmentInfo: segmentInfoPayload({
          type: this.loaderType_,
          segment: this.pendingSegment_
        })
      };
      this.trigger({
        type: "appendsdone",
        metadata
      });
    }
    if (!this.pendingSegment_) {
      this.state = "READY";
      if (!this.paused()) {
        this.monitorBuffer_();
      }
      return;
    }
    const segmentInfo = this.pendingSegment_;
    if (segmentInfo.part && segmentInfo.part.syncInfo) {
      segmentInfo.part.syncInfo.markAppended();
    } else if (segmentInfo.segment.syncInfo) {
      segmentInfo.segment.syncInfo.markAppended();
    }
    this.updateTimingInfoEnd_(segmentInfo);
    if (this.shouldSaveSegmentTimingInfo_) {
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
    }
    const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
    if (segmentDurationMessage) {
      if (segmentDurationMessage.severity === "warn") {
        videojs$2.log.warn(segmentDurationMessage.message);
      } else {
        this.logger_(segmentDurationMessage.message);
      }
    }
    this.recordThroughput_(segmentInfo);
    this.pendingSegment_ = null;
    this.state = "READY";
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      if (!segmentInfo.hasAppendedData_) {
        this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);
        return;
      }
    }
    this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);
    this.addSegmentMetadataCue_(segmentInfo);
    this.fetchAtBuffer_ = true;
    if (this.currentTimeline_ !== segmentInfo.timeline) {
      this.timelineChangeController_.lastTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
      if (this.loaderType_ === "main" && !this.audioDisabled_) {
        this.timelineChangeController_.lastTimelineChange({
          type: "audio",
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
    }
    this.currentTimeline_ = segmentInfo.timeline;
    this.trigger("syncinfoupdate");
    const segment = segmentInfo.segment;
    const part = segmentInfo.part;
    const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
    const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
    if (badSegmentGuess || badPartGuess) {
      this.logger_(`bad ${badSegmentGuess ? "segment" : "part"} ${segmentInfoString(segmentInfo)}`);
      this.resetEverything();
      return;
    }
    const isWalkingForward = this.mediaIndex !== null;
    if (isWalkingForward) {
      this.trigger("bandwidthupdate");
    }
    this.trigger("progress");
    this.mediaIndex = segmentInfo.mediaIndex;
    this.partIndex = segmentInfo.partIndex;
    if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
      this.endOfStream();
    }
    this.trigger("appended");
    if (segmentInfo.hasAppendedData_) {
      this.mediaAppends++;
    }
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  }
  /**
   * Records the current throughput of the decrypt, transmux, and append
   * portion of the semgment pipeline. `throughput.rate` is a the cumulative
   * moving average of the throughput. `throughput.count` is the number of
   * data points in the average.
   *
   * @private
   * @param {Object} segmentInfo the object returned by loadSegment
   */
  recordThroughput_(segmentInfo) {
    if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration} is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
      return;
    }
    const rate = this.throughput.rate;
    const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
    const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
  }
  /**
   * Adds a cue to the segment-metadata track with some metadata information about the
   * segment
   *
   * @private
   * @param {Object} segmentInfo
   *        the object returned by loadSegment
   * @method addSegmentMetadataCue_
   */
  addSegmentMetadataCue_(segmentInfo) {
    if (!this.segmentMetadataTrack_) {
      return;
    }
    const segment = segmentInfo.segment;
    const start2 = segment.start;
    const end2 = segment.end;
    if (!finite(start2) || !finite(end2)) {
      return;
    }
    removeCuesFromTrack(start2, end2, this.segmentMetadataTrack_);
    const Cue = window$1$1.WebKitDataCue || window$1$1.VTTCue;
    const value2 = {
      custom: segment.custom,
      dateTimeObject: segment.dateTimeObject,
      dateTimeString: segment.dateTimeString,
      programDateTime: segment.programDateTime,
      bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
      resolution: segmentInfo.playlist.attributes.RESOLUTION,
      codecs: segmentInfo.playlist.attributes.CODECS,
      byteLength: segmentInfo.byteLength,
      uri: segmentInfo.uri,
      timeline: segmentInfo.timeline,
      playlist: segmentInfo.playlist.id,
      start: start2,
      end: end2
    };
    const data = JSON.stringify(value2);
    const cue = new Cue(start2, end2, data);
    cue.value = value2;
    this.segmentMetadataTrack_.addCue(cue);
  }
}
function noop() {
}
const toTitleCase = function(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, (w) => w.toUpperCase());
};
const bufferTypes = ["video", "audio"];
const updating = (type, sourceUpdater) => {
  const sourceBuffer = sourceUpdater[`${type}Buffer`];
  return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
};
const nextQueueIndexOfType = (type, queue) => {
  for (let i = 0; i < queue.length; i++) {
    const queueEntry = queue[i];
    if (queueEntry.type === "mediaSource") {
      return null;
    }
    if (queueEntry.type === type) {
      return i;
    }
  }
  return null;
};
const shiftQueue = (type, sourceUpdater) => {
  if (sourceUpdater.queue.length === 0) {
    return;
  }
  let queueIndex = 0;
  let queueEntry = sourceUpdater.queue[queueIndex];
  if (queueEntry.type === "mediaSource") {
    if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
      sourceUpdater.queue.shift();
      queueEntry.action(sourceUpdater);
      if (queueEntry.doneFn) {
        queueEntry.doneFn();
      }
      shiftQueue("audio", sourceUpdater);
      shiftQueue("video", sourceUpdater);
    }
    return;
  }
  if (type === "mediaSource") {
    return;
  }
  if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || updating(type, sourceUpdater)) {
    return;
  }
  if (queueEntry.type !== type) {
    queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);
    if (queueIndex === null) {
      return;
    }
    queueEntry = sourceUpdater.queue[queueIndex];
  }
  sourceUpdater.queue.splice(queueIndex, 1);
  sourceUpdater.queuePending[type] = queueEntry;
  queueEntry.action(type, sourceUpdater);
  if (!queueEntry.doneFn) {
    sourceUpdater.queuePending[type] = null;
    shiftQueue(type, sourceUpdater);
    return;
  }
};
const cleanupBuffer = (type, sourceUpdater) => {
  const buffer = sourceUpdater[`${type}Buffer`];
  const titleType = toTitleCase(type);
  if (!buffer) {
    return;
  }
  buffer.removeEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
  buffer.removeEventListener("error", sourceUpdater[`on${titleType}Error_`]);
  sourceUpdater.codecs[type] = null;
  sourceUpdater[`${type}Buffer`] = null;
};
const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
const actions = {
  appendBuffer: (bytes, segmentInfo, onError2) => (type, sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);
    try {
      sourceBuffer.appendBuffer(bytes);
    } catch (e) {
      sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);
      sourceUpdater.queuePending[type] = null;
      onError2(e);
    }
  },
  remove: (start2, end2) => (type, sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    sourceUpdater.logger_(`Removing ${start2} to ${end2} from ${type}Buffer`);
    try {
      sourceBuffer.remove(start2, end2);
    } catch (e) {
      sourceUpdater.logger_(`Remove ${start2} to ${end2} from ${type}Buffer failed`);
    }
  },
  timestampOffset: (offset2) => (type, sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset2}`);
    sourceBuffer.timestampOffset = offset2;
  },
  callback: (callback) => (type, sourceUpdater) => {
    callback();
  },
  endOfStream: (error) => (sourceUpdater) => {
    if (sourceUpdater.mediaSource.readyState !== "open") {
      return;
    }
    sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ""})`);
    try {
      sourceUpdater.mediaSource.endOfStream(error);
    } catch (e) {
      videojs$2.log.warn("Failed to call media source endOfStream", e);
    }
  },
  duration: (duration2) => (sourceUpdater) => {
    sourceUpdater.logger_(`Setting mediaSource duration to ${duration2}`);
    try {
      sourceUpdater.mediaSource.duration = duration2;
    } catch (e) {
      videojs$2.log.warn("Failed to set media source duration", e);
    }
  },
  abort: () => (type, sourceUpdater) => {
    if (sourceUpdater.mediaSource.readyState !== "open") {
      return;
    }
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    sourceUpdater.logger_(`calling abort on ${type}Buffer`);
    try {
      sourceBuffer.abort();
    } catch (e) {
      videojs$2.log.warn(`Failed to abort on ${type}Buffer`, e);
    }
  },
  addSourceBuffer: (type, codec) => (sourceUpdater) => {
    const titleType = toTitleCase(type);
    const mime = getMimeForCodec(codec);
    sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);
    const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
    sourceBuffer.addEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
    sourceBuffer.addEventListener("error", sourceUpdater[`on${titleType}Error_`]);
    sourceUpdater.codecs[type] = codec;
    sourceUpdater[`${type}Buffer`] = sourceBuffer;
  },
  removeSourceBuffer: (type) => (sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    cleanupBuffer(type, sourceUpdater);
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);
    try {
      sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
    } catch (e) {
      videojs$2.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);
    }
  },
  changeType: (codec) => (type, sourceUpdater) => {
    const sourceBuffer = sourceUpdater[`${type}Buffer`];
    const mime = getMimeForCodec(codec);
    if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
      return;
    }
    const newCodecBase = codec.substring(0, codec.indexOf("."));
    const oldCodec = sourceUpdater.codecs[type];
    const oldCodecBase = oldCodec.substring(0, oldCodec.indexOf("."));
    if (oldCodecBase === newCodecBase) {
      return;
    }
    const metadata = {
      codecsChangeInfo: {
        from: oldCodec,
        to: codec
      }
    };
    sourceUpdater.trigger({
      type: "codecschange",
      metadata
    });
    sourceUpdater.logger_(`changing ${type}Buffer codec from ${oldCodec} to ${codec}`);
    try {
      sourceBuffer.changeType(mime);
      sourceUpdater.codecs[type] = codec;
    } catch (e) {
      metadata.errorType = videojs$2.Error.StreamingCodecsChangeError;
      metadata.error = e;
      e.metadata = metadata;
      sourceUpdater.error_ = e;
      sourceUpdater.trigger("error");
      videojs$2.log.warn(`Failed to changeType on ${type}Buffer`, e);
    }
  }
};
const pushQueue = ({
  type,
  sourceUpdater,
  action,
  doneFn,
  name
}) => {
  sourceUpdater.queue.push({
    type,
    action,
    doneFn,
    name
  });
  shiftQueue(type, sourceUpdater);
};
const onUpdateend = (type, sourceUpdater) => (e) => {
  const bufferedRangesForType = sourceUpdater[`${type}Buffered`]();
  const descriptiveString = bufferedRangesToString(bufferedRangesForType);
  sourceUpdater.logger_(`received "updateend" event for ${type} Source Buffer: `, descriptiveString);
  if (sourceUpdater.queuePending[type]) {
    const doneFn = sourceUpdater.queuePending[type].doneFn;
    sourceUpdater.queuePending[type] = null;
    if (doneFn) {
      doneFn(sourceUpdater[`${type}Error_`]);
    }
  }
  shiftQueue(type, sourceUpdater);
};
class SourceUpdater extends videojs$2.EventTarget {
  constructor(mediaSource) {
    super();
    this.mediaSource = mediaSource;
    this.sourceopenListener_ = () => shiftQueue("mediaSource", this);
    this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_);
    this.logger_ = logger("SourceUpdater");
    this.audioTimestampOffset_ = 0;
    this.videoTimestampOffset_ = 0;
    this.queue = [];
    this.queuePending = {
      audio: null,
      video: null
    };
    this.delayedAudioAppendQueue_ = [];
    this.videoAppendQueued_ = false;
    this.codecs = {};
    this.onVideoUpdateEnd_ = onUpdateend("video", this);
    this.onAudioUpdateEnd_ = onUpdateend("audio", this);
    this.onVideoError_ = (e) => {
      this.videoError_ = e;
    };
    this.onAudioError_ = (e) => {
      this.audioError_ = e;
    };
    this.createdSourceBuffers_ = false;
    this.initializedEme_ = false;
    this.triggeredReady_ = false;
  }
  initializedEme() {
    this.initializedEme_ = true;
    this.triggerReady();
  }
  hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  }
  hasInitializedAnyEme() {
    return this.initializedEme_;
  }
  ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  }
  createSourceBuffers(codecs) {
    if (this.hasCreatedSourceBuffers()) {
      return;
    }
    this.addOrChangeSourceBuffers(codecs);
    this.createdSourceBuffers_ = true;
    this.trigger("createdsourcebuffers");
    this.triggerReady();
  }
  triggerReady() {
    if (this.ready() && !this.triggeredReady_) {
      this.triggeredReady_ = true;
      this.trigger("ready");
    }
  }
  /**
   * Add a type of source buffer to the media source.
   *
   * @param {string} type
   *        The type of source buffer to add.
   *
   * @param {string} codec
   *        The codec to add the source buffer with.
   */
  addSourceBuffer(type, codec) {
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.addSourceBuffer(type, codec),
      name: "addSourceBuffer"
    });
  }
  /**
   * call abort on a source buffer.
   *
   * @param {string} type
   *        The type of source buffer to call abort on.
   */
  abort(type) {
    pushQueue({
      type,
      sourceUpdater: this,
      action: actions.abort(type),
      name: "abort"
    });
  }
  /**
   * Call removeSourceBuffer and remove a specific type
   * of source buffer on the mediaSource.
   *
   * @param {string} type
   *        The type of source buffer to remove.
   */
  removeSourceBuffer(type) {
    if (!this.canRemoveSourceBuffer()) {
      videojs$2.log.error("removeSourceBuffer is not supported!");
      return;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.removeSourceBuffer(type),
      name: "removeSourceBuffer"
    });
  }
  /**
   * Whether or not the removeSourceBuffer function is supported
   * on the mediaSource.
   *
   * @return {boolean}
   *          if removeSourceBuffer can be called.
   */
  canRemoveSourceBuffer() {
    return !videojs$2.browser.IS_FIREFOX && window$1$1.MediaSource && window$1$1.MediaSource.prototype && typeof window$1$1.MediaSource.prototype.removeSourceBuffer === "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  static canChangeType() {
    return window$1$1.SourceBuffer && window$1$1.SourceBuffer.prototype && typeof window$1$1.SourceBuffer.prototype.changeType === "function";
  }
  /**
   * Whether or not the changeType function is supported
   * on our SourceBuffers.
   *
   * @return {boolean}
   *         if changeType can be called.
   */
  canChangeType() {
    return this.constructor.canChangeType();
  }
  /**
   * Call the changeType function on a source buffer, given the code and type.
   *
   * @param {string} type
   *        The type of source buffer to call changeType on.
   *
   * @param {string} codec
   *        The codec string to change type with on the source buffer.
   */
  changeType(type, codec) {
    if (!this.canChangeType()) {
      videojs$2.log.error("changeType is not supported!");
      return;
    }
    pushQueue({
      type,
      sourceUpdater: this,
      action: actions.changeType(codec),
      name: "changeType"
    });
  }
  /**
   * Add source buffers with a codec or, if they are already created,
   * call changeType on source buffers using changeType.
   *
   * @param {Object} codecs
   *        Codecs to switch to
   */
  addOrChangeSourceBuffers(codecs) {
    if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    }
    Object.keys(codecs).forEach((type) => {
      const codec = codecs[type];
      if (!this.hasCreatedSourceBuffers()) {
        return this.addSourceBuffer(type, codec);
      }
      if (this.canChangeType()) {
        this.changeType(type, codec);
      }
    });
  }
  /**
   * Queue an update to append an ArrayBuffer.
   *
   * @param {MediaObject} object containing audioBytes and/or videoBytes
   * @param {Function} done the function to call when done
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data
   */
  appendBuffer(options, doneFn) {
    const {
      segmentInfo,
      type,
      bytes
    } = options;
    this.processedAppend_ = true;
    if (type === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([options, doneFn]);
      this.logger_(`delayed audio append of ${bytes.length} until video append`);
      return;
    }
    const onError2 = doneFn;
    pushQueue({
      type,
      sourceUpdater: this,
      action: actions.appendBuffer(bytes, segmentInfo || {
        mediaIndex: -1
      }, onError2),
      doneFn,
      name: "appendBuffer"
    });
    if (type === "video") {
      this.videoAppendQueued_ = true;
      if (!this.delayedAudioAppendQueue_.length) {
        return;
      }
      const queue = this.delayedAudioAppendQueue_.slice();
      this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);
      this.delayedAudioAppendQueue_.length = 0;
      queue.forEach((que) => {
        this.appendBuffer.apply(this, que);
      });
    }
  }
  /**
   * Get the audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The audio buffer's buffered time range
   */
  audioBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
      return createTimeRanges();
    }
    return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();
  }
  /**
   * Get the video buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         The video buffer's buffered time range
   */
  videoBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
      return createTimeRanges();
    }
    return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();
  }
  /**
   * Get a combined video/audio buffer's buffered timerange.
   *
   * @return {TimeRange}
   *         the combined time range
   */
  buffered() {
    const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
    const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    if (audio && !video) {
      return this.audioBuffered();
    }
    if (video && !audio) {
      return this.videoBuffered();
    }
    return bufferIntersection(this.audioBuffered(), this.videoBuffered());
  }
  /**
   * Add a callback to the queue that will set duration on the mediaSource.
   *
   * @param {number} duration
   *        The duration to set
   *
   * @param {Function} [doneFn]
   *        function to run after duration has been set.
   */
  setDuration(duration2, doneFn = noop) {
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.duration(duration2),
      name: "duration",
      doneFn
    });
  }
  /**
   * Add a mediaSource endOfStream call to the queue
   *
   * @param {Error} [error]
   *        Call endOfStream with an error
   *
   * @param {Function} [doneFn]
   *        A function that should be called when the
   *        endOfStream call has finished.
   */
  endOfStream(error = null, doneFn = noop) {
    if (typeof error !== "string") {
      error = void 0;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.endOfStream(error),
      name: "endOfStream",
      doneFn
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeAudio(start2, end2, done = noop) {
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.remove(start2, end2),
      doneFn: done,
      name: "remove"
    });
  }
  /**
   * Queue an update to remove a time range from the buffer.
   *
   * @param {number} start where to start the removal
   * @param {number} end where to end the removal
   * @param {Function} [done=noop] optional callback to be executed when the remove
   * operation is complete
   * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end
   */
  removeVideo(start2, end2, done = noop) {
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.remove(start2, end2),
      doneFn: done,
      name: "remove"
    });
  }
  /**
   * Whether the underlying sourceBuffer is updating or not
   *
   * @return {boolean} the updating status of the SourceBuffer
   */
  updating() {
    if (updating("audio", this) || updating("video", this)) {
      return true;
    }
    return false;
  }
  /**
   * Set/get the timestampoffset on the audio SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  audioTimestampOffset(offset2) {
    if (typeof offset2 !== "undefined" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== offset2) {
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.timestampOffset(offset2),
        name: "timestampOffset"
      });
      this.audioTimestampOffset_ = offset2;
    }
    return this.audioTimestampOffset_;
  }
  /**
   * Set/get the timestampoffset on the video SourceBuffer
   *
   * @return {number} the timestamp offset
   */
  videoTimestampOffset(offset2) {
    if (typeof offset2 !== "undefined" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset_ !== offset2) {
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.timestampOffset(offset2),
        name: "timestampOffset"
      });
      this.videoTimestampOffset_ = offset2;
    }
    return this.videoTimestampOffset_;
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the audio queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  audioQueueCallback(callback) {
    if (!this.audioBuffer) {
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.callback(callback),
      name: "callback"
    });
  }
  /**
   * Add a function to the queue that will be called
   * when it is its turn to run in the video queue.
   *
   * @param {Function} callback
   *        The callback to queue.
   */
  videoQueueCallback(callback) {
    if (!this.videoBuffer) {
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.callback(callback),
      name: "callback"
    });
  }
  /**
   * dispose of the source updater and the underlying sourceBuffer
   */
  dispose() {
    this.trigger("dispose");
    bufferTypes.forEach((type) => {
      this.abort(type);
      if (this.canRemoveSourceBuffer()) {
        this.removeSourceBuffer(type);
      } else {
        this[`${type}QueueCallback`](() => cleanupBuffer(type, this));
      }
    });
    this.videoAppendQueued_ = false;
    this.delayedAudioAppendQueue_.length = 0;
    if (this.sourceopenListener_) {
      this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
    }
    this.off();
  }
}
const uint8ToUtf8 = (uintArray) => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
const bufferToHexString = (buffer) => {
  const uInt8Buffer = new Uint8Array(buffer);
  return Array.from(uInt8Buffer).map((byte) => byte.toString(16).padStart(2, "0")).join("");
};
const VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map((char) => char.charCodeAt(0)));
class NoVttJsError extends Error {
  constructor() {
    super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
  }
}
class VTTSegmentLoader extends SegmentLoader {
  constructor(settings, options = {}) {
    super(settings, options);
    this.mediaSource_ = null;
    this.subtitlesTrack_ = null;
    this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
    this.loadVttJs = settings.loadVttJs;
    this.shouldSaveSegmentTimingInfo_ = false;
  }
  createTransmuxer_() {
    return null;
  }
  /**
   * Indicates which time ranges are buffered
   *
   * @return {TimeRange}
   *         TimeRange object representing the current buffered ranges
   */
  buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
      return createTimeRanges();
    }
    const cues = this.subtitlesTrack_.cues;
    const start2 = cues[0].startTime;
    const end2 = cues[cues.length - 1].startTime;
    return createTimeRanges([[start2, end2]]);
  }
  /**
   * Gets and sets init segment for the provided map
   *
   * @param {Object} map
   *        The map object representing the init segment to get or set
   * @param {boolean=} set
   *        If true, the init segment for the provided map should be saved
   * @return {Object}
   *         map object for desired init segment
   */
  initSegmentForMap(map2, set2 = false) {
    if (!map2) {
      return null;
    }
    const id = initSegmentId(map2);
    let storedMap = this.initSegments_[id];
    if (set2 && !storedMap && map2.bytes) {
      const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map2.bytes.byteLength;
      const combinedSegment = new Uint8Array(combinedByteLength);
      combinedSegment.set(map2.bytes);
      combinedSegment.set(VTT_LINE_TERMINATORS, map2.bytes.byteLength);
      this.initSegments_[id] = storedMap = {
        resolvedUri: map2.resolvedUri,
        byterange: map2.byterange,
        bytes: combinedSegment
      };
    }
    return storedMap || map2;
  }
  /**
   * Returns true if all configuration required for loading is present, otherwise false.
   *
   * @return {boolean} True if the all configuration is ready for loading
   * @private
   */
  couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  }
  /**
   * Once all the starting parameters have been specified, begin
   * operation. This method should only be invoked from the INIT
   * state.
   *
   * @private
   */
  init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  }
  /**
   * Set a subtitle track on the segment loader to add subtitles to
   *
   * @param {TextTrack=} track
   *        The text track to add loaded subtitles to
   * @return {TextTrack}
   *        Returns the subtitles track
   */
  track(track) {
    if (typeof track === "undefined") {
      return this.subtitlesTrack_;
    }
    this.subtitlesTrack_ = track;
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      this.init_();
    }
    return this.subtitlesTrack_;
  }
  /**
   * Remove any data in the source buffer between start and end times
   *
   * @param {number} start - the start time of the region to remove from the buffer
   * @param {number} end - the end time of the region to remove from the buffer
   */
  remove(start2, end2) {
    removeCuesFromTrack(start2, end2, this.subtitlesTrack_);
  }
  /**
   * fill the buffer with segements unless the sourceBuffers are
   * currently updating
   *
   * Note: this function should only ever be called by monitorBuffer_
   * and never directly
   *
   * @private
   */
  fillBuffer_() {
    const segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
      const checkTimestampOffset = () => {
        this.state = "READY";
        if (!this.paused()) {
          this.monitorBuffer_();
        }
      };
      this.syncController_.one("timestampoffset", checkTimestampOffset);
      this.state = "WAITING_ON_TIMELINE";
      return;
    }
    this.loadSegment_(segmentInfo);
  }
  // never set a timestamp offset for vtt segments.
  timestampOffsetForSegment_() {
    return null;
  }
  chooseNextRequest_() {
    return this.skipEmptySegments_(super.chooseNextRequest_());
  }
  /**
   * Prevents the segment loader from requesting segments we know contain no subtitles
   * by walking forward until we find the next segment that we don't know whether it is
   * empty or not.
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @return {Object}
   *         a segment info object that describes the current segment
   */
  skipEmptySegments_(segmentInfo) {
    while (segmentInfo && segmentInfo.segment.empty) {
      if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
        segmentInfo = null;
        break;
      }
      segmentInfo = this.generateSegmentInfo_({
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex + 1,
        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
        isSyncRequest: segmentInfo.isSyncRequest
      });
    }
    return segmentInfo;
  }
  stopForError(error) {
    this.error(error);
    this.state = "READY";
    this.pause();
    this.trigger("error");
  }
  /**
   * append a decrypted segement to the SourceBuffer through a SourceUpdater
   *
   * @private
   */
  segmentRequestFinished_(error, simpleSegment, result) {
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      this.state = "READY";
      this.mediaRequestsAborted += 1;
      return;
    }
    if (error) {
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
      }
      if (error.code === REQUEST_ERRORS.ABORTED) {
        this.mediaRequestsAborted += 1;
      } else {
        this.mediaRequestsErrored += 1;
      }
      this.stopForError(error);
      return;
    }
    const segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    const segment = segmentInfo.segment;
    if (segment.map) {
      segment.map.bytes = simpleSegment.map.bytes;
    }
    segmentInfo.bytes = simpleSegment.bytes;
    if (typeof window$1$1.WebVTT !== "function" && typeof this.loadVttJs === "function") {
      this.state = "WAITING_ON_VTTJS";
      this.loadVttJs().then(() => this.segmentRequestFinished_(error, simpleSegment, result), () => this.stopForError({
        message: "Error loading vtt.js"
      }));
      return;
    }
    segment.requested = true;
    try {
      this.parseVTTCues_(segmentInfo);
    } catch (e) {
      this.stopForError({
        message: e.message,
        metadata: {
          errorType: videojs$2.Error.StreamingVttParserError,
          error: e
        }
      });
      return;
    }
    this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
    if (segmentInfo.cues.length) {
      segmentInfo.timingInfo = {
        start: segmentInfo.cues[0].startTime,
        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
      };
    } else {
      segmentInfo.timingInfo = {
        start: segmentInfo.startOfSegment,
        end: segmentInfo.startOfSegment + segmentInfo.duration
      };
    }
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      this.pendingSegment_ = null;
      this.state = "READY";
      return;
    }
    segmentInfo.byteLength = segmentInfo.bytes.byteLength;
    this.mediaSecondsLoaded += segment.duration;
    segmentInfo.cues.forEach((cue) => {
      this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window$1$1.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
    });
    removeDuplicateCuesFromTrack(this.subtitlesTrack_);
    this.handleAppendsDone_();
  }
  handleData_() {
  }
  updateTimingInfoEnd_() {
  }
  /**
   * Uses the WebVTT parser to parse the segment response
   *
   * @throws NoVttJsError
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @private
   */
  parseVTTCues_(segmentInfo) {
    let decoder;
    let decodeBytesToString = false;
    if (typeof window$1$1.WebVTT !== "function") {
      throw new NoVttJsError();
    }
    if (typeof window$1$1.TextDecoder === "function") {
      decoder = new window$1$1.TextDecoder("utf8");
    } else {
      decoder = window$1$1.WebVTT.StringDecoder();
      decodeBytesToString = true;
    }
    const parser2 = new window$1$1.WebVTT.Parser(window$1$1, window$1$1.vttjs, decoder);
    segmentInfo.cues = [];
    segmentInfo.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    };
    parser2.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
    parser2.ontimestampmap = (map2) => {
      segmentInfo.timestampmap = map2;
    };
    parser2.onparsingerror = (error) => {
      videojs$2.log.warn("Error encountered when parsing cues: " + error.message);
    };
    if (segmentInfo.segment.map) {
      let mapData = segmentInfo.segment.map.bytes;
      if (decodeBytesToString) {
        mapData = uint8ToUtf8(mapData);
      }
      parser2.parse(mapData);
    }
    let segmentData = segmentInfo.bytes;
    if (decodeBytesToString) {
      segmentData = uint8ToUtf8(segmentData);
    }
    parser2.parse(segmentData);
    parser2.flush();
  }
  /**
   * Updates the start and end times of any cues parsed by the WebVTT parser using
   * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping
   * from the SyncController
   *
   * @param {Object} segmentInfo
   *        a segment info object that describes the current segment
   * @param {Object} mappingObj
   *        object containing a mapping from TS to media time
   * @param {Object} playlist
   *        the playlist object containing the segment
   * @private
   */
  updateTimeMapping_(segmentInfo, mappingObj, playlist) {
    const segment = segmentInfo.segment;
    if (!mappingObj) {
      return;
    }
    if (!segmentInfo.cues.length) {
      segment.empty = true;
      return;
    }
    const {
      MPEGTS,
      LOCAL
    } = segmentInfo.timestampmap;
    const mpegTsInSeconds = MPEGTS / clock.ONE_SECOND_IN_TS;
    const diff = mpegTsInSeconds - LOCAL + mappingObj.mapping;
    segmentInfo.cues.forEach((cue) => {
      const duration2 = cue.endTime - cue.startTime;
      const startTime = MPEGTS === 0 ? cue.startTime + diff : this.handleRollover_(cue.startTime + diff, mappingObj.time);
      cue.startTime = Math.max(startTime, 0);
      cue.endTime = Math.max(startTime + duration2, 0);
    });
    if (!playlist.syncInfo) {
      const firstStart = segmentInfo.cues[0].startTime;
      const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
      playlist.syncInfo = {
        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
        time: Math.min(firstStart, lastStart - segment.duration)
      };
    }
  }
  /**
   * MPEG-TS PES timestamps are limited to 2^33.
   * Once they reach 2^33, they roll over to 0.
   * mux.js handles PES timestamp rollover for the following scenarios:
   * [forward rollover(right)] ->
   *    PES timestamps monotonically increase, and once they reach 2^33, they roll over to 0
   * [backward rollover(left)] -->
   *    we seek back to position before rollover.
   *
   * According to the HLS SPEC:
   * When synchronizing WebVTT with PES timestamps, clients SHOULD account
   * for cases where the 33-bit PES timestamps have wrapped and the WebVTT
   * cue times have not.  When the PES timestamp wraps, the WebVTT Segment
   * SHOULD have a X-TIMESTAMP-MAP header that maps the current WebVTT
   * time to the new (low valued) PES timestamp.
   *
   * So we want to handle rollover here and align VTT Cue start/end time to the player's time.
   */
  handleRollover_(value2, reference2) {
    if (reference2 === null) {
      return value2;
    }
    let valueIn90khz = value2 * clock.ONE_SECOND_IN_TS;
    const referenceIn90khz = reference2 * clock.ONE_SECOND_IN_TS;
    let offset2;
    if (referenceIn90khz < valueIn90khz) {
      offset2 = -8589934592;
    } else {
      offset2 = 8589934592;
    }
    while (Math.abs(valueIn90khz - referenceIn90khz) > 4294967296) {
      valueIn90khz += offset2;
    }
    return valueIn90khz / clock.ONE_SECOND_IN_TS;
  }
}
const findAdCue = function(track, mediaTime) {
  const cues = track.cues;
  for (let i = 0; i < cues.length; i++) {
    const cue = cues[i];
    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
      return cue;
    }
  }
  return null;
};
const updateAdCues = function(media, track, offset2 = 0) {
  if (!media.segments) {
    return;
  }
  let mediaTime = offset2;
  let cue;
  for (let i = 0; i < media.segments.length; i++) {
    const segment = media.segments[i];
    if (!cue) {
      cue = findAdCue(track, mediaTime + segment.duration / 2);
    }
    if (cue) {
      if ("cueIn" in segment) {
        cue.endTime = mediaTime;
        cue.adEndTime = mediaTime;
        mediaTime += segment.duration;
        cue = null;
        continue;
      }
      if (mediaTime < cue.endTime) {
        mediaTime += segment.duration;
        continue;
      }
      cue.endTime += segment.duration;
    } else {
      if ("cueOut" in segment) {
        cue = new window$1$1.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
        cue.adStartTime = mediaTime;
        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
        track.addCue(cue);
      }
      if ("cueOutCont" in segment) {
        const [adOffset, adTotal] = segment.cueOutCont.split("/").map(parseFloat);
        cue = new window$1$1.VTTCue(mediaTime, mediaTime + segment.duration, "");
        cue.adStartTime = mediaTime - adOffset;
        cue.adEndTime = cue.adStartTime + adTotal;
        track.addCue(cue);
      }
    }
    mediaTime += segment.duration;
  }
};
class SyncInfo {
  /**
   * @param {number} start - media sequence start
   * @param {number} end - media sequence end
   * @param {number} segmentIndex - index for associated segment
   * @param {number|null} [partIndex] - index for associated part
   * @param {boolean} [appended] - appended indicator
   *
   */
  constructor({
    start: start2,
    end: end2,
    segmentIndex,
    partIndex = null,
    appended = false
  }) {
    this.start_ = start2;
    this.end_ = end2;
    this.segmentIndex_ = segmentIndex;
    this.partIndex_ = partIndex;
    this.appended_ = appended;
  }
  isInRange(targetTime) {
    return targetTime >= this.start && targetTime < this.end;
  }
  markAppended() {
    this.appended_ = true;
  }
  resetAppendedStatus() {
    this.appended_ = false;
  }
  get isAppended() {
    return this.appended_;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get segmentIndex() {
    return this.segmentIndex_;
  }
  get partIndex() {
    return this.partIndex_;
  }
}
class SyncInfoData {
  /**
   *
   * @param {SyncInfo} segmentSyncInfo - sync info for a given segment
   * @param {Array<SyncInfo>} [partsSyncInfo] - sync infos for a list of parts for a given segment
   */
  constructor(segmentSyncInfo, partsSyncInfo = []) {
    this.segmentSyncInfo_ = segmentSyncInfo;
    this.partsSyncInfo_ = partsSyncInfo;
  }
  get segmentSyncInfo() {
    return this.segmentSyncInfo_;
  }
  get partsSyncInfo() {
    return this.partsSyncInfo_;
  }
  get hasPartsSyncInfo() {
    return this.partsSyncInfo_.length > 0;
  }
  resetAppendStatus() {
    this.segmentSyncInfo_.resetAppendedStatus();
    this.partsSyncInfo_.forEach((partSyncInfo) => partSyncInfo.resetAppendedStatus());
  }
}
class MediaSequenceSync {
  constructor() {
    this.storage_ = /* @__PURE__ */ new Map();
    this.diagnostics_ = "";
    this.isReliable_ = false;
    this.start_ = -Infinity;
    this.end_ = Infinity;
  }
  get start() {
    return this.start_;
  }
  get end() {
    return this.end_;
  }
  get diagnostics() {
    return this.diagnostics_;
  }
  get isReliable() {
    return this.isReliable_;
  }
  resetAppendedStatus() {
    this.storage_.forEach((syncInfoData) => syncInfoData.resetAppendStatus());
  }
  /**
   * update sync storage
   *
   * @param {Object} playlist
   * @param {number} currentTime
   *
   * @return {void}
   */
  update(playlist, currentTime) {
    const {
      mediaSequence,
      segments
    } = playlist;
    this.isReliable_ = this.isReliablePlaylist_(mediaSequence, segments);
    if (!this.isReliable_) {
      return;
    }
    return this.updateStorage_(segments, mediaSequence, this.calculateBaseTime_(mediaSequence, currentTime));
  }
  /**
   * @param {number} targetTime
   * @return {SyncInfo|null}
   */
  getSyncInfoForTime(targetTime) {
    for (const {
      segmentSyncInfo,
      partsSyncInfo
    } of this.storage_.values()) {
      if (!partsSyncInfo.length) {
        if (segmentSyncInfo.isInRange(targetTime)) {
          return segmentSyncInfo;
        }
      } else {
        for (const partSyncInfo of partsSyncInfo) {
          if (partSyncInfo.isInRange(targetTime)) {
            return partSyncInfo;
          }
        }
      }
    }
    return null;
  }
  getSyncInfoForMediaSequence(mediaSequence) {
    return this.storage_.get(mediaSequence);
  }
  updateStorage_(segments, startingMediaSequence, startingTime) {
    const newStorage = /* @__PURE__ */ new Map();
    let newDiagnostics = "\n";
    let currentStart = startingTime;
    let currentMediaSequence = startingMediaSequence;
    this.start_ = currentStart;
    segments.forEach((segment, segmentIndex) => {
      const prevSyncInfoData = this.storage_.get(currentMediaSequence);
      const segmentStart = currentStart;
      const segmentEnd = segmentStart + segment.duration;
      const segmentIsAppended = Boolean(prevSyncInfoData && prevSyncInfoData.segmentSyncInfo && prevSyncInfoData.segmentSyncInfo.isAppended);
      const segmentSyncInfo = new SyncInfo({
        start: segmentStart,
        end: segmentEnd,
        appended: segmentIsAppended,
        segmentIndex
      });
      segment.syncInfo = segmentSyncInfo;
      let currentPartStart = currentStart;
      const partsSyncInfo = (segment.parts || []).map((part, partIndex) => {
        const partStart = currentPartStart;
        const partEnd = currentPartStart + part.duration;
        const partIsAppended = Boolean(prevSyncInfoData && prevSyncInfoData.partsSyncInfo && prevSyncInfoData.partsSyncInfo[partIndex] && prevSyncInfoData.partsSyncInfo[partIndex].isAppended);
        const partSyncInfo = new SyncInfo({
          start: partStart,
          end: partEnd,
          appended: partIsAppended,
          segmentIndex,
          partIndex
        });
        currentPartStart = partEnd;
        newDiagnostics += `Media Sequence: ${currentMediaSequence}.${partIndex} | Range: ${partStart} --> ${partEnd} | Appended: ${partIsAppended}
`;
        part.syncInfo = partSyncInfo;
        return partSyncInfo;
      });
      newStorage.set(currentMediaSequence, new SyncInfoData(segmentSyncInfo, partsSyncInfo));
      newDiagnostics += `${compactSegmentUrlDescription(segment.resolvedUri)} | Media Sequence: ${currentMediaSequence} | Range: ${segmentStart} --> ${segmentEnd} | Appended: ${segmentIsAppended}
`;
      currentMediaSequence++;
      currentStart = segmentEnd;
    });
    this.end_ = currentStart;
    this.storage_ = newStorage;
    this.diagnostics_ = newDiagnostics;
  }
  calculateBaseTime_(mediaSequence, fallback) {
    if (!this.storage_.size) {
      return 0;
    }
    if (this.storage_.has(mediaSequence)) {
      return this.storage_.get(mediaSequence).segmentSyncInfo.start;
    }
    return fallback;
  }
  isReliablePlaylist_(mediaSequence, segments) {
    return mediaSequence !== void 0 && mediaSequence !== null && Array.isArray(segments) && segments.length;
  }
}
class DependantMediaSequenceSync extends MediaSequenceSync {
  constructor(parent) {
    super();
    this.parent_ = parent;
  }
  calculateBaseTime_(mediaSequence, fallback) {
    if (!this.storage_.size) {
      const info = this.parent_.getSyncInfoForMediaSequence(mediaSequence);
      if (info) {
        return info.segmentSyncInfo.start;
      }
      return 0;
    }
    return super.calculateBaseTime_(mediaSequence, fallback);
  }
}
const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
const syncPointStrategies = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
      if (duration2 !== Infinity) {
        const syncPoint = {
          time: 0,
          segmentIndex: 0,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  },
  {
    name: "MediaSequence",
    /**
     * run media sequence strategy
     *
     * @param {SyncController} syncController
     * @param {Object} playlist
     * @param {number} duration
     * @param {number} currentTimeline
     * @param {number} currentTime
     * @param {string} type
     */
    run: (syncController, playlist, duration2, currentTimeline, currentTime, type) => {
      const mediaSequenceSync = syncController.getMediaSequenceSync(type);
      if (!mediaSequenceSync) {
        return null;
      }
      if (!mediaSequenceSync.isReliable) {
        return null;
      }
      const syncInfo = mediaSequenceSync.getSyncInfoForTime(currentTime);
      if (!syncInfo) {
        return null;
      }
      return {
        time: syncInfo.start,
        partIndex: syncInfo.partIndex,
        segmentIndex: syncInfo.segmentIndex
      };
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
        return null;
      }
      let syncPoint = null;
      let lastDistance = null;
      const partsAndSegments = getPartsAndSegments(playlist);
      currentTime = currentTime || 0;
      for (let i = 0; i < partsAndSegments.length; i++) {
        const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        const partAndSegment = partsAndSegments[index];
        const segment = partAndSegment.segment;
        const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
        if (!datetimeMapping || !segment.dateTimeObject) {
          continue;
        }
        const segmentTime = segment.dateTimeObject.getTime() / 1e3;
        let start2 = segmentTime + datetimeMapping;
        if (segment.parts && typeof partAndSegment.partIndex === "number") {
          for (let z = 0; z < partAndSegment.partIndex; z++) {
            start2 += segment.parts[z].duration;
          }
        }
        const distance = Math.abs(currentTime - start2);
        if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {
          break;
        }
        lastDistance = distance;
        syncPoint = {
          time: start2,
          segmentIndex: partAndSegment.segmentIndex,
          partIndex: partAndSegment.partIndex
        };
      }
      return syncPoint;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
      let syncPoint = null;
      let lastDistance = null;
      currentTime = currentTime || 0;
      const partsAndSegments = getPartsAndSegments(playlist);
      for (let i = 0; i < partsAndSegments.length; i++) {
        const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        const partAndSegment = partsAndSegments[index];
        const segment = partAndSegment.segment;
        const start2 = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
        if (segment.timeline === currentTimeline && typeof start2 !== "undefined") {
          const distance = Math.abs(currentTime - start2);
          if (lastDistance !== null && lastDistance < distance) {
            break;
          }
          if (!syncPoint || lastDistance === null || lastDistance >= distance) {
            lastDistance = distance;
            syncPoint = {
              time: start2,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
      let syncPoint = null;
      currentTime = currentTime || 0;
      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        let lastDistance = null;
        for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
          const segmentIndex = playlist.discontinuityStarts[i];
          const discontinuity = playlist.discontinuitySequence + i + 1;
          const discontinuitySync = syncController.discontinuities[discontinuity];
          if (discontinuitySync) {
            const distance = Math.abs(currentTime - discontinuitySync.time);
            if (lastDistance !== null && lastDistance < distance) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
              lastDistance = distance;
              syncPoint = {
                time: discontinuitySync.time,
                segmentIndex,
                partIndex: null
              };
            }
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: (syncController, playlist, duration2, currentTimeline, currentTime) => {
      if (playlist.syncInfo) {
        const syncPoint = {
          time: playlist.syncInfo.time,
          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  }
];
class SyncController extends videojs$2.EventTarget {
  constructor(options = {}) {
    super();
    this.timelines = [];
    this.discontinuities = [];
    this.timelineToDatetimeMappings = {};
    const main2 = new MediaSequenceSync();
    const audio = new DependantMediaSequenceSync(main2);
    const vtt2 = new DependantMediaSequenceSync(main2);
    this.mediaSequenceStorage_ = {
      main: main2,
      audio,
      vtt: vtt2
    };
    this.logger_ = logger("SyncController");
  }
  /**
   *
   * @param {string} loaderType
   * @return {MediaSequenceSync|null}
   */
  getMediaSequenceSync(loaderType) {
    return this.mediaSequenceStorage_[loaderType] || null;
  }
  /**
   * Find a sync-point for the playlist specified
   *
   * A sync-point is defined as a known mapping from display-time to
   * a segment-index in the current playlist.
   *
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinite if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Object}
   *          A sync-point object
   */
  getSyncPoint(playlist, duration2, currentTimeline, currentTime, type) {
    if (duration2 !== Infinity) {
      const vodSyncPointStrategy = syncPointStrategies.find(({
        name
      }) => name === "VOD");
      return vodSyncPointStrategy.run(this, playlist, duration2);
    }
    const syncPoints = this.runStrategies_(playlist, duration2, currentTimeline, currentTime, type);
    if (!syncPoints.length) {
      return null;
    }
    for (const syncPointInfo of syncPoints) {
      const {
        syncPoint,
        strategy
      } = syncPointInfo;
      const {
        segmentIndex,
        time
      } = syncPoint;
      if (segmentIndex < 0) {
        continue;
      }
      const selectedSegment = playlist.segments[segmentIndex];
      const start2 = time;
      const end2 = start2 + selectedSegment.duration;
      this.logger_(`Strategy: ${strategy}. Current time: ${currentTime}. selected segment: ${segmentIndex}. Time: [${start2} -> ${end2}]}`);
      if (currentTime >= start2 && currentTime < end2) {
        this.logger_("Found sync point with exact match: ", syncPoint);
        return syncPoint;
      }
    }
    return this.selectSyncPoint_(syncPoints, {
      key: "time",
      value: currentTime
    });
  }
  /**
   * Calculate the amount of time that has expired off the playlist during playback
   *
   * @param {Playlist} playlist
   *        Playlist object to calculate expired from
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playling a live source)
   * @return {number|null}
   *          The amount of time that has expired off the playlist during playback. Null
   *          if no sync-points for the playlist can be found.
   */
  getExpiredTime(playlist, duration2) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    const syncPoints = this.runStrategies_(playlist, duration2, playlist.discontinuitySequence, 0);
    if (!syncPoints.length) {
      return null;
    }
    const syncPoint = this.selectSyncPoint_(syncPoints, {
      key: "segmentIndex",
      value: 0
    });
    if (syncPoint.segmentIndex > 0) {
      syncPoint.time *= -1;
    }
    return Math.abs(syncPoint.time + sumDurations({
      defaultDuration: playlist.targetDuration,
      durationList: playlist.segments,
      startIndex: syncPoint.segmentIndex,
      endIndex: 0
    }));
  }
  /**
   * Runs each sync-point strategy and returns a list of sync-points returned by the
   * strategies
   *
   * @private
   * @param {Playlist} playlist
   *        The playlist that needs a sync-point
   * @param {number} duration
   *        Duration of the MediaSource (Infinity if playing a live source)
   * @param {number} currentTimeline
   *        The last timeline from which a segment was loaded
   * @param {number} currentTime
   *        Current player's time
   * @param {string} type
   *        Segment loader type
   * @return {Array}
   *          A list of sync-point objects
   */
  runStrategies_(playlist, duration2, currentTimeline, currentTime, type) {
    const syncPoints = [];
    for (let i = 0; i < syncPointStrategies.length; i++) {
      const strategy = syncPointStrategies[i];
      const syncPoint = strategy.run(this, playlist, duration2, currentTimeline, currentTime, type);
      if (syncPoint) {
        syncPoint.strategy = strategy.name;
        syncPoints.push({
          strategy: strategy.name,
          syncPoint
        });
      }
    }
    return syncPoints;
  }
  /**
   * Selects the sync-point nearest the specified target
   *
   * @private
   * @param {Array} syncPoints
   *        List of sync-points to select from
   * @param {Object} target
   *        Object specifying the property and value we are targeting
   * @param {string} target.key
   *        Specifies the property to target. Must be either 'time' or 'segmentIndex'
   * @param {number} target.value
   *        The value to target for the specified key.
   * @return {Object}
   *          The sync-point nearest the target
   */
  selectSyncPoint_(syncPoints, target) {
    let bestSyncPoint = syncPoints[0].syncPoint;
    let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
    let bestStrategy = syncPoints[0].strategy;
    for (let i = 1; i < syncPoints.length; i++) {
      const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
      if (newDistance < bestDistance) {
        bestDistance = newDistance;
        bestSyncPoint = syncPoints[i].syncPoint;
        bestStrategy = syncPoints[i].strategy;
      }
    }
    this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy [${bestStrategy}]: [time:${bestSyncPoint.time}, segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === "number" ? `,partIndex:${bestSyncPoint.partIndex}` : "") + "]");
    return bestSyncPoint;
  }
  /**
   * Save any meta-data present on the segments when segments leave
   * the live window to the playlist to allow for synchronization at the
   * playlist level later.
   *
   * @param {Playlist} oldPlaylist - The previous active playlist
   * @param {Playlist} newPlaylist - The updated and most current playlist
   */
  saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
    const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
      videojs$2.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);
      return;
    }
    for (let i = mediaSequenceDiff - 1; i >= 0; i--) {
      const lastRemovedSegment = oldPlaylist.segments[i];
      if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
        newPlaylist.syncInfo = {
          mediaSequence: oldPlaylist.mediaSequence + i,
          time: lastRemovedSegment.start
        };
        this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time}, mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);
        this.trigger("syncinfoupdate");
        break;
      }
    }
  }
  /**
   * Save the mapping from playlist's ProgramDateTime to display. This should only happen
   * before segments start to load.
   *
   * @param {Playlist} playlist - The currently active playlist
   */
  setDateTimeMappingForStart(playlist) {
    this.timelineToDatetimeMappings = {};
    if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
      const firstSegment = playlist.segments[0];
      const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
    }
  }
  /**
   * Calculates and saves timeline mappings, playlist sync info, and segment timing values
   * based on the latest timing information.
   *
   * @param {Object} options
   *        Options object
   * @param {SegmentInfo} options.segmentInfo
   *        The current active request information
   * @param {boolean} options.shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved for timeline mapping and program date time mappings.
   */
  saveSegmentTimingInfo({
    segmentInfo,
    shouldSaveTimelineMapping
  }) {
    const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
    const segment = segmentInfo.segment;
    if (didCalculateSegmentTimeMapping) {
      this.saveDiscontinuitySyncInfo_(segmentInfo);
      if (!segmentInfo.playlist.syncInfo) {
        segmentInfo.playlist.syncInfo = {
          mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
          time: segment.start
        };
      }
    }
    const dateTime = segment.dateTimeObject;
    if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
      this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
    }
  }
  timestampOffsetForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].time;
  }
  mappingForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].mapping;
  }
  /**
   * Use the "media time" for a segment to generate a mapping to "display time" and
   * save that display time to the segment.
   *
   * @private
   * @param {SegmentInfo} segmentInfo
   *        The current active request information
   * @param {Object} timingInfo
   *        The start and end time of the current segment in "media time"
   * @param {boolean} shouldSaveTimelineMapping
   *        If there's a timeline change, determines if the timeline mapping should be
   *        saved in timelines.
   * @return {boolean}
   *          Returns false if segment time mapping could not be calculated
   */
  calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
    const segment = segmentInfo.segment;
    const part = segmentInfo.part;
    let mappingObj = this.timelines[segmentInfo.timeline];
    let start2;
    let end2;
    if (typeof segmentInfo.timestampOffset === "number") {
      mappingObj = {
        time: segmentInfo.startOfSegment,
        mapping: segmentInfo.startOfSegment - timingInfo.start
      };
      if (shouldSaveTimelineMapping) {
        this.timelines[segmentInfo.timeline] = mappingObj;
        this.trigger("timestampoffset");
        this.logger_(`time mapping for timeline ${segmentInfo.timeline}: [time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);
      }
      start2 = segmentInfo.startOfSegment;
      end2 = timingInfo.end + mappingObj.mapping;
    } else if (mappingObj) {
      start2 = timingInfo.start + mappingObj.mapping;
      end2 = timingInfo.end + mappingObj.mapping;
    } else {
      return false;
    }
    if (part) {
      part.start = start2;
      part.end = end2;
    }
    if (!segment.start || start2 < segment.start) {
      segment.start = start2;
    }
    segment.end = end2;
    return true;
  }
  /**
   * Each time we have discontinuity in the playlist, attempt to calculate the location
   * in display of the start of the discontinuity and save that. We also save an accuracy
   * value so that we save values with the most accuracy (closest to 0.)
   *
   * @private
   * @param {SegmentInfo} segmentInfo - The current active request information
   */
  saveDiscontinuitySyncInfo_(segmentInfo) {
    const playlist = segmentInfo.playlist;
    const segment = segmentInfo.segment;
    if (segment.discontinuity) {
      this.discontinuities[segment.timeline] = {
        time: segment.start,
        accuracy: 0
      };
    } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
      for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
        const segmentIndex = playlist.discontinuityStarts[i];
        const discontinuity = playlist.discontinuitySequence + i + 1;
        const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
        const accuracy = Math.abs(mediaIndexDiff);
        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
          let time;
          if (mediaIndexDiff < 0) {
            time = segment.start - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex,
              endIndex: segmentIndex
            });
          } else {
            time = segment.end + sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex + 1,
              endIndex: segmentIndex
            });
          }
          this.discontinuities[discontinuity] = {
            time,
            accuracy
          };
        }
      }
    }
  }
  dispose() {
    this.trigger("dispose");
    this.off();
  }
}
class TimelineChangeController extends videojs$2.EventTarget {
  constructor() {
    super();
    this.pendingTimelineChanges_ = {};
    this.lastTimelineChanges_ = {};
  }
  clearPendingTimelineChange(type) {
    this.pendingTimelineChanges_[type] = null;
    this.trigger("pendingtimelinechange");
  }
  pendingTimelineChange({
    type,
    from: from2,
    to
  }) {
    if (typeof from2 === "number" && typeof to === "number") {
      this.pendingTimelineChanges_[type] = {
        type,
        from: from2,
        to
      };
      this.trigger("pendingtimelinechange");
    }
    return this.pendingTimelineChanges_[type];
  }
  lastTimelineChange({
    type,
    from: from2,
    to
  }) {
    if (typeof from2 === "number" && typeof to === "number") {
      this.lastTimelineChanges_[type] = {
        type,
        from: from2,
        to
      };
      delete this.pendingTimelineChanges_[type];
      const metadata = {
        timelineChangeInfo: {
          from: from2,
          to
        }
      };
      this.trigger({
        type: "timelinechange",
        metadata
      });
    }
    return this.lastTimelineChanges_[type];
  }
  dispose() {
    this.trigger("dispose");
    this.pendingTimelineChanges_ = {};
    this.lastTimelineChanges_ = {};
    this.off();
  }
}
const workerCode = transform(getWorkerString(function() {
  var Stream2 = /* @__PURE__ */ function() {
    function Stream3() {
      this.listeners = {};
    }
    var _proto = Stream3.prototype;
    _proto.on = function on2(type, listener) {
      if (!this.listeners[type]) {
        this.listeners[type] = [];
      }
      this.listeners[type].push(listener);
    };
    _proto.off = function off2(type, listener) {
      if (!this.listeners[type]) {
        return false;
      }
      var index = this.listeners[type].indexOf(listener);
      this.listeners[type] = this.listeners[type].slice(0);
      this.listeners[type].splice(index, 1);
      return index > -1;
    };
    _proto.trigger = function trigger2(type) {
      var callbacks = this.listeners[type];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length2 = callbacks.length;
        for (var i = 0; i < length2; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    };
    _proto.dispose = function dispose() {
      this.listeners = {};
    };
    _proto.pipe = function pipe(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
    };
    return Stream3;
  }();
  /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
  function unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
  /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */
  const precompute = function() {
    const tables = [[[], [], [], [], []], [[], [], [], [], []]];
    const encTable = tables[0];
    const decTable = tables[1];
    const sbox = encTable[4];
    const sboxInv = decTable[4];
    let i;
    let x;
    let xInv;
    const d = [];
    const th = [];
    let x2;
    let x4;
    let x8;
    let s;
    let tEnc;
    let tDec;
    for (i = 0; i < 256; i++) {
      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d[x4 = d[x2 = d[x]]];
      tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      tEnc = d[s] * 257 ^ s * 16843008;
      for (i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
    return tables;
  };
  let aesTables = null;
  class AES {
    constructor(key) {
      if (!aesTables) {
        aesTables = precompute();
      }
      this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
      let i;
      let j;
      let tmp;
      const sbox = this._tables[0][4];
      const decTable = this._tables[1];
      const keyLen = key.length;
      let rcon = 1;
      if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
        throw new Error("Invalid aes key size");
      }
      const encKey = key.slice(0);
      const decKey = [];
      this._key = [encKey, decKey];
      for (i = keyLen; i < 4 * keyLen + 28; i++) {
        tmp = encKey[i - 1];
        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
          tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
          if (i % keyLen === 0) {
            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
            rcon = rcon << 1 ^ (rcon >> 7) * 283;
          }
        }
        encKey[i] = encKey[i - keyLen] ^ tmp;
      }
      for (j = 0; i; j++, i--) {
        tmp = encKey[j & 3 ? i : i - 4];
        if (i <= 4 || j < 4) {
          decKey[j] = tmp;
        } else {
          decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
        }
      }
    }
    /**
     * Decrypt 16 bytes, specified as four 32-bit words.
     *
     * @param {number} encrypted0 the first word to decrypt
     * @param {number} encrypted1 the second word to decrypt
     * @param {number} encrypted2 the third word to decrypt
     * @param {number} encrypted3 the fourth word to decrypt
     * @param {Int32Array} out the array to write the decrypted words
     * into
     * @param {number} offset the offset into the output array to start
     * writing results
     * @return {Array} The plaintext.
     */
    decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset2) {
      const key = this._key[1];
      let a = encrypted0 ^ key[0];
      let b = encrypted3 ^ key[1];
      let c = encrypted2 ^ key[2];
      let d = encrypted1 ^ key[3];
      let a2;
      let b2;
      let c2;
      const nInnerRounds = key.length / 4 - 2;
      let i;
      let kIndex = 4;
      const table = this._tables[1];
      const table0 = table[0];
      const table1 = table[1];
      const table2 = table[2];
      const table3 = table[3];
      const sbox = table[4];
      for (i = 0; i < nInnerRounds; i++) {
        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a = a2;
        b = b2;
        c = c2;
      }
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset2] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
        a2 = a;
        a = b;
        b = c;
        c = d;
        d = a2;
      }
    }
  }
  class AsyncStream extends Stream2 {
    constructor() {
      super(Stream2);
      this.jobs = [];
      this.delay = 1;
      this.timeout_ = null;
    }
    /**
     * process an async job
     *
     * @private
     */
    processJob_() {
      this.jobs.shift()();
      if (this.jobs.length) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      } else {
        this.timeout_ = null;
      }
    }
    /**
     * push a job into the stream
     *
     * @param {Function} job the job to push into the stream
     */
    push(job) {
      this.jobs.push(job);
      if (!this.timeout_) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      }
    }
  }
  const ntoh = function(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  };
  const decrypt2 = function(encrypted, key, initVector) {
    const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
    const decipher = new AES(Array.prototype.slice.call(key));
    const decrypted = new Uint8Array(encrypted.byteLength);
    const decrypted32 = new Int32Array(decrypted.buffer);
    let init0;
    let init1;
    let init2;
    let init3;
    let encrypted0;
    let encrypted1;
    let encrypted2;
    let encrypted3;
    let wordIx;
    init0 = initVector[0];
    init1 = initVector[1];
    init2 = initVector[2];
    init3 = initVector[3];
    for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
      encrypted0 = ntoh(encrypted32[wordIx]);
      encrypted1 = ntoh(encrypted32[wordIx + 1]);
      encrypted2 = ntoh(encrypted32[wordIx + 2]);
      encrypted3 = ntoh(encrypted32[wordIx + 3]);
      decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
      decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
      decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
      decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
      decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
      init0 = encrypted0;
      init1 = encrypted1;
      init2 = encrypted2;
      init3 = encrypted3;
    }
    return decrypted;
  };
  class Decrypter2 {
    constructor(encrypted, key, initVector, done) {
      const step = Decrypter2.STEP;
      const encrypted32 = new Int32Array(encrypted.buffer);
      const decrypted = new Uint8Array(encrypted.byteLength);
      let i = 0;
      this.asyncStream_ = new AsyncStream();
      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      }
      this.asyncStream_.push(function() {
        done(null, unpad(decrypted));
      });
    }
    /**
     * a getter for step the maximum number of bytes to process at one time
     *
     * @return {number} the value of step 32000
     */
    static get STEP() {
      return 32e3;
    }
    /**
     * @private
     */
    decryptChunk_(encrypted, key, initVector, decrypted) {
      return function() {
        const bytes = decrypt2(encrypted, key, initVector);
        decrypted.set(bytes, encrypted.byteOffset);
      };
    }
  }
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var win2;
  if (typeof window !== "undefined") {
    win2 = window;
  } else if (typeof commonjsGlobal2 !== "undefined") {
    win2 = commonjsGlobal2;
  } else if (typeof self !== "undefined") {
    win2 = self;
  } else {
    win2 = {};
  }
  var window_12 = win2;
  var isArrayBufferView3 = function isArrayBufferView4(obj) {
    if (ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(obj);
    }
    return obj && obj.buffer instanceof ArrayBuffer;
  };
  var BigInt2 = window_12.BigInt || Number;
  [BigInt2("0x1"), BigInt2("0x100"), BigInt2("0x10000"), BigInt2("0x1000000"), BigInt2("0x100000000"), BigInt2("0x10000000000"), BigInt2("0x1000000000000"), BigInt2("0x100000000000000"), BigInt2("0x10000000000000000")];
  (function() {
    var a = new Uint16Array([65484]);
    var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
    if (b[0] === 255) {
      return "big";
    }
    if (b[0] === 204) {
      return "little";
    }
    return "unknown";
  })();
  const createTransferableMessage2 = function(message) {
    const transferable = {};
    Object.keys(message).forEach((key) => {
      const value2 = message[key];
      if (isArrayBufferView3(value2)) {
        transferable[key] = {
          bytes: value2.buffer,
          byteOffset: value2.byteOffset,
          byteLength: value2.byteLength
        };
      } else {
        transferable[key] = value2;
      }
    });
    return transferable;
  };
  self.onmessage = function(event2) {
    const data = event2.data;
    const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
    const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
    const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
    new Decrypter2(encrypted, key, iv, function(err, bytes) {
      self.postMessage(createTransferableMessage2({
        source: data.source,
        decrypted: bytes
      }), [bytes.buffer]);
    });
  };
}));
var Decrypter = factory(workerCode);
const audioTrackKind_ = (properties) => {
  let kind = properties.default ? "main" : "alternative";
  if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
    kind = "main-desc";
  }
  return kind;
};
const stopLoaders = (segmentLoader, mediaType) => {
  segmentLoader.abort();
  segmentLoader.pause();
  if (mediaType && mediaType.activePlaylistLoader) {
    mediaType.activePlaylistLoader.pause();
    mediaType.activePlaylistLoader = null;
  }
};
const startLoaders = (playlistLoader, mediaType) => {
  mediaType.activePlaylistLoader = playlistLoader;
  playlistLoader.load();
};
const onGroupChanged = (type, settings) => () => {
  const {
    segmentLoaders: {
      [type]: segmentLoader,
      main: mainSegmentLoader
    },
    mediaTypes: {
      [type]: mediaType
    }
  } = settings;
  const activeTrack2 = mediaType.activeTrack();
  const activeGroup2 = mediaType.getActiveGroup();
  const previousActiveLoader = mediaType.activePlaylistLoader;
  const lastGroup = mediaType.lastGroup_;
  if (activeGroup2 && lastGroup && activeGroup2.id === lastGroup.id) {
    return;
  }
  mediaType.lastGroup_ = activeGroup2;
  mediaType.lastTrack_ = activeTrack2;
  stopLoaders(segmentLoader, mediaType);
  if (!activeGroup2 || activeGroup2.isMainPlaylist) {
    return;
  }
  if (!activeGroup2.playlistLoader) {
    if (previousActiveLoader) {
      mainSegmentLoader.resetEverything();
    }
    return;
  }
  segmentLoader.resyncLoader();
  startLoaders(activeGroup2.playlistLoader, mediaType);
};
const onGroupChanging = (type, settings) => () => {
  const {
    segmentLoaders: {
      [type]: segmentLoader
    },
    mediaTypes: {
      [type]: mediaType
    }
  } = settings;
  mediaType.lastGroup_ = null;
  segmentLoader.abort();
  segmentLoader.pause();
};
const onTrackChanged = (type, settings) => () => {
  const {
    mainPlaylistLoader,
    segmentLoaders: {
      [type]: segmentLoader,
      main: mainSegmentLoader
    },
    mediaTypes: {
      [type]: mediaType
    }
  } = settings;
  const activeTrack2 = mediaType.activeTrack();
  const activeGroup2 = mediaType.getActiveGroup();
  const previousActiveLoader = mediaType.activePlaylistLoader;
  const lastTrack = mediaType.lastTrack_;
  if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
    return;
  }
  mediaType.lastGroup_ = activeGroup2;
  mediaType.lastTrack_ = activeTrack2;
  stopLoaders(segmentLoader, mediaType);
  if (!activeGroup2) {
    return;
  }
  if (activeGroup2.isMainPlaylist) {
    if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
      return;
    }
    const pc = settings.vhs.playlistController_;
    const newPlaylist = pc.selectPlaylist();
    if (pc.media() === newPlaylist) {
      return;
    }
    mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack2.id}`);
    mainPlaylistLoader.pause();
    mainSegmentLoader.resetEverything();
    pc.fastQualityChange_(newPlaylist);
    return;
  }
  if (type === "AUDIO") {
    if (!activeGroup2.playlistLoader) {
      mainSegmentLoader.setAudio(true);
      mainSegmentLoader.resetEverything();
      return;
    }
    segmentLoader.setAudio(true);
    mainSegmentLoader.setAudio(false);
  }
  if (previousActiveLoader === activeGroup2.playlistLoader) {
    startLoaders(activeGroup2.playlistLoader, mediaType);
    return;
  }
  if (segmentLoader.track) {
    segmentLoader.track(activeTrack2);
  }
  segmentLoader.resetEverything();
  startLoaders(activeGroup2.playlistLoader, mediaType);
};
const onError = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is excluded) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: (type, settings) => () => {
    const {
      mediaTypes: {
        [type]: mediaType
      },
      excludePlaylist
    } = settings;
    const activeTrack2 = mediaType.activeTrack();
    const activeGroup2 = mediaType.activeGroup();
    const id = (activeGroup2.filter((group) => group.default)[0] || activeGroup2[0]).id;
    const defaultTrack = mediaType.tracks[id];
    if (activeTrack2 === defaultTrack) {
      excludePlaylist({
        error: {
          message: "Problem encountered loading the default audio track."
        }
      });
      return;
    }
    videojs$2.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
    for (const trackId in mediaType.tracks) {
      mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
    }
    mediaType.onTrackChanged();
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: (type, settings) => () => {
    const {
      mediaTypes: {
        [type]: mediaType
      }
    } = settings;
    videojs$2.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
    const track = mediaType.activeTrack();
    if (track) {
      track.mode = "disabled";
    }
    mediaType.onTrackChanged();
  }
};
const setupListeners = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: (type, playlistLoader, settings) => {
    if (!playlistLoader) {
      return;
    }
    const {
      tech,
      requestOptions,
      segmentLoaders: {
        [type]: segmentLoader
      }
    } = settings;
    playlistLoader.on("loadedmetadata", () => {
      const media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", () => {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type](type, settings));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: (type, playlistLoader, settings) => {
    const {
      tech,
      requestOptions,
      segmentLoaders: {
        [type]: segmentLoader
      },
      mediaTypes: {
        [type]: mediaType
      }
    } = settings;
    playlistLoader.on("loadedmetadata", () => {
      const media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      segmentLoader.track(mediaType.activeTrack());
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", () => {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type](type, settings));
  }
};
const initialize = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  "AUDIO": (type, settings) => {
    const {
      vhs,
      sourceType,
      segmentLoaders: {
        [type]: segmentLoader
      },
      requestOptions,
      main: {
        mediaGroups
      },
      mediaTypes: {
        [type]: {
          groups,
          tracks,
          logger_
        }
      },
      mainPlaylistLoader
    } = settings;
    const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main);
    if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
      mediaGroups[type] = {
        main: {
          default: {
            default: true
          }
        }
      };
      if (audioOnlyMain) {
        mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;
      }
    }
    for (const groupId in mediaGroups[type]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (const variantLabel in mediaGroups[type][groupId]) {
        let properties = mediaGroups[type][groupId][variantLabel];
        let playlistLoader;
        if (audioOnlyMain) {
          logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);
          properties.isMainPlaylist = true;
          playlistLoader = null;
        } else if (sourceType === "vhs-json" && properties.playlists) {
          playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);
        } else if (properties.resolvedUri) {
          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
        } else if (properties.playlists && sourceType === "dash") {
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
        } else {
          playlistLoader = null;
        }
        properties = merge({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type](type, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          const track = new videojs$2.AudioTrack({
            id: variantLabel,
            kind: audioTrackKind_(properties),
            enabled: false,
            language: properties.language,
            default: properties.default,
            label: variantLabel
          });
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type](type, settings));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  "SUBTITLES": (type, settings) => {
    const {
      tech,
      vhs,
      sourceType,
      segmentLoaders: {
        [type]: segmentLoader
      },
      requestOptions,
      main: {
        mediaGroups
      },
      mediaTypes: {
        [type]: {
          groups,
          tracks
        }
      },
      mainPlaylistLoader
    } = settings;
    for (const groupId in mediaGroups[type]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (const variantLabel in mediaGroups[type][groupId]) {
        if (!vhs.options_.useForcedSubtitles && mediaGroups[type][groupId][variantLabel].forced) {
          continue;
        }
        let properties = mediaGroups[type][groupId][variantLabel];
        let playlistLoader;
        if (sourceType === "hls") {
          playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);
        } else if (sourceType === "dash") {
          const playlists = properties.playlists.filter((p) => p.excludeUntil !== Infinity);
          if (!playlists.length) {
            return;
          }
          playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
        } else if (sourceType === "vhs-json") {
          playlistLoader = new PlaylistLoader(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            properties.playlists ? properties.playlists[0] : properties.resolvedUri,
            vhs,
            requestOptions
          );
        }
        properties = merge({
          id: variantLabel,
          playlistLoader
        }, properties);
        setupListeners[type](type, properties.playlistLoader, settings);
        groups[groupId].push(properties);
        if (typeof tracks[variantLabel] === "undefined") {
          const track = tech.addRemoteTextTrack({
            id: variantLabel,
            kind: "subtitles",
            default: properties.default && properties.autoselect,
            language: properties.language,
            label: variantLabel
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type](type, settings));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": (type, settings) => {
    const {
      tech,
      main: {
        mediaGroups
      },
      mediaTypes: {
        [type]: {
          groups,
          tracks
        }
      }
    } = settings;
    for (const groupId in mediaGroups[type]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (const variantLabel in mediaGroups[type][groupId]) {
        const properties = mediaGroups[type][groupId][variantLabel];
        if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {
          continue;
        }
        const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        let newProps = {
          label: variantLabel,
          language: properties.language,
          instreamId: properties.instreamId,
          default: properties.default && properties.autoselect
        };
        if (captionServices[newProps.instreamId]) {
          newProps = merge(newProps, captionServices[newProps.instreamId]);
        }
        if (newProps.default === void 0) {
          delete newProps.default;
        }
        groups[groupId].push(merge({
          id: variantLabel
        }, properties));
        if (typeof tracks[variantLabel] === "undefined") {
          const track = tech.addRemoteTextTrack({
            id: newProps.instreamId,
            kind: "captions",
            default: newProps.default,
            language: newProps.language,
            label: newProps.label
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
  }
};
const groupMatch = (list, media) => {
  for (let i = 0; i < list.length; i++) {
    if (playlistMatch(media, list[i])) {
      return true;
    }
    if (list[i].playlists && groupMatch(list[i].playlists, media)) {
      return true;
    }
  }
  return false;
};
const activeGroup = (type, settings) => (track) => {
  const {
    mainPlaylistLoader,
    mediaTypes: {
      [type]: {
        groups
      }
    }
  } = settings;
  const media = mainPlaylistLoader.media();
  if (!media) {
    return null;
  }
  let variants = null;
  if (media.attributes[type]) {
    variants = groups[media.attributes[type]];
  }
  const groupKeys = Object.keys(groups);
  if (!variants) {
    if (type === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.main)) {
      for (let i = 0; i < groupKeys.length; i++) {
        const groupPropertyList = groups[groupKeys[i]];
        if (groupMatch(groupPropertyList, media)) {
          variants = groupPropertyList;
          break;
        }
      }
    } else if (groups.main) {
      variants = groups.main;
    } else if (groupKeys.length === 1) {
      variants = groups[groupKeys[0]];
    }
  }
  if (typeof track === "undefined") {
    return variants;
  }
  if (track === null || !variants) {
    return null;
  }
  return variants.filter((props) => props.id === track.id)[0] || null;
};
const activeTrack = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: (type, settings) => () => {
    const {
      mediaTypes: {
        [type]: {
          tracks
        }
      }
    } = settings;
    for (const id in tracks) {
      if (tracks[id].enabled) {
        return tracks[id];
      }
    }
    return null;
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: (type, settings) => () => {
    const {
      mediaTypes: {
        [type]: {
          tracks
        }
      }
    } = settings;
    for (const id in tracks) {
      if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") {
        return tracks[id];
      }
    }
    return null;
  }
};
const getActiveGroup = (type, {
  mediaTypes: mediaTypes2
}) => () => {
  const activeTrack_ = mediaTypes2[type].activeTrack();
  if (!activeTrack_) {
    return null;
  }
  return mediaTypes2[type].activeGroup(activeTrack_);
};
const setupMediaGroups = (settings) => {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
    initialize[type](type, settings);
  });
  const {
    mediaTypes: mediaTypes2,
    mainPlaylistLoader,
    tech,
    vhs,
    segmentLoaders: {
      ["AUDIO"]: audioSegmentLoader,
      main: mainSegmentLoader
    }
  } = settings;
  ["AUDIO", "SUBTITLES"].forEach((type) => {
    mediaTypes2[type].activeGroup = activeGroup(type, settings);
    mediaTypes2[type].activeTrack = activeTrack[type](type, settings);
    mediaTypes2[type].onGroupChanged = onGroupChanged(type, settings);
    mediaTypes2[type].onGroupChanging = onGroupChanging(type, settings);
    mediaTypes2[type].onTrackChanged = onTrackChanged(type, settings);
    mediaTypes2[type].getActiveGroup = getActiveGroup(type, settings);
  });
  const audioGroup = mediaTypes2.AUDIO.activeGroup();
  if (audioGroup) {
    const groupId = (audioGroup.filter((group) => group.default)[0] || audioGroup[0]).id;
    mediaTypes2.AUDIO.tracks[groupId].enabled = true;
    mediaTypes2.AUDIO.onGroupChanged();
    mediaTypes2.AUDIO.onTrackChanged();
    const activeAudioGroup = mediaTypes2.AUDIO.getActiveGroup();
    if (!activeAudioGroup.playlistLoader) {
      mainSegmentLoader.setAudio(true);
    } else {
      mainSegmentLoader.setAudio(false);
      audioSegmentLoader.setAudio(true);
    }
  }
  mainPlaylistLoader.on("mediachange", () => {
    ["AUDIO", "SUBTITLES"].forEach((type) => mediaTypes2[type].onGroupChanged());
  });
  mainPlaylistLoader.on("mediachanging", () => {
    ["AUDIO", "SUBTITLES"].forEach((type) => mediaTypes2[type].onGroupChanging());
  });
  const onAudioTrackChanged = () => {
    mediaTypes2.AUDIO.onTrackChanged();
    tech.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
  };
  tech.audioTracks().addEventListener("change", onAudioTrackChanged);
  tech.remoteTextTracks().addEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  vhs.on("dispose", () => {
    tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
    tech.remoteTextTracks().removeEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  });
  tech.clearTracks("audio");
  for (const id in mediaTypes2.AUDIO.tracks) {
    tech.audioTracks().addTrack(mediaTypes2.AUDIO.tracks[id]);
  }
};
const createMediaTypes = () => {
  const mediaTypes2 = {};
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
    mediaTypes2[type] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: noop,
      activeTrack: noop,
      getActiveGroup: noop,
      onGroupChanged: noop,
      onTrackChanged: noop,
      lastTrack_: null,
      logger_: logger(`MediaGroups[${type}]`)
    };
  });
  return mediaTypes2;
};
class SteeringManifest {
  constructor() {
    this.priority_ = [];
    this.pathwayClones_ = /* @__PURE__ */ new Map();
  }
  set version(number) {
    if (number === 1) {
      this.version_ = number;
    }
  }
  set ttl(seconds) {
    this.ttl_ = seconds || 300;
  }
  set reloadUri(uri) {
    if (uri) {
      this.reloadUri_ = resolveUrl22(this.reloadUri_, uri);
    }
  }
  set priority(array) {
    if (array && array.length) {
      this.priority_ = array;
    }
  }
  set pathwayClones(array) {
    if (array && array.length) {
      this.pathwayClones_ = new Map(array.map((clone) => [clone.ID, clone]));
    }
  }
  get version() {
    return this.version_;
  }
  get ttl() {
    return this.ttl_;
  }
  get reloadUri() {
    return this.reloadUri_;
  }
  get priority() {
    return this.priority_;
  }
  get pathwayClones() {
    return this.pathwayClones_;
  }
}
class ContentSteeringController extends videojs$2.EventTarget {
  constructor(xhr, bandwidth) {
    super();
    this.currentPathway = null;
    this.defaultPathway = null;
    this.queryBeforeStart = false;
    this.availablePathways_ = /* @__PURE__ */ new Set();
    this.steeringManifest = new SteeringManifest();
    this.proxyServerUrl_ = null;
    this.manifestType_ = null;
    this.ttlTimeout_ = null;
    this.request_ = null;
    this.currentPathwayClones = /* @__PURE__ */ new Map();
    this.nextPathwayClones = /* @__PURE__ */ new Map();
    this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set();
    this.logger_ = logger("Content Steering");
    this.xhr_ = xhr;
    this.getBandwidth_ = bandwidth;
  }
  /**
   * Assigns the content steering tag properties to the steering controller
   *
   * @param {string} baseUrl the baseURL from the main manifest for resolving the steering manifest url
   * @param {Object} steeringTag the content steering tag from the main manifest
   */
  assignTagProperties(baseUrl, steeringTag) {
    this.manifestType_ = steeringTag.serverUri ? "HLS" : "DASH";
    const steeringUri = steeringTag.serverUri || steeringTag.serverURL;
    if (!steeringUri) {
      this.logger_(`steering manifest URL is ${steeringUri}, cannot request steering manifest.`);
      this.trigger("error");
      return;
    }
    if (steeringUri.startsWith("data:")) {
      this.decodeDataUriManifest_(steeringUri.substring(steeringUri.indexOf(",") + 1));
      return;
    }
    this.steeringManifest.reloadUri = resolveUrl22(baseUrl, steeringUri);
    this.defaultPathway = steeringTag.pathwayId || steeringTag.defaultServiceLocation;
    this.queryBeforeStart = steeringTag.queryBeforeStart;
    this.proxyServerUrl_ = steeringTag.proxyServerURL;
    if (this.defaultPathway && !this.queryBeforeStart) {
      this.trigger("content-steering");
    }
  }
  /**
   * Requests the content steering manifest and parse the response. This should only be called after
   * assignTagProperties was called with a content steering tag.
   *
   * @param {string} initialUri The optional uri to make the request with.
   *    If set, the request should be made with exactly what is passed in this variable.
   *    This scenario should only happen once on initalization.
   */
  requestSteeringManifest(initial) {
    const reloadUri = this.steeringManifest.reloadUri;
    if (!reloadUri) {
      return;
    }
    const uri = initial ? reloadUri : this.getRequestURI(reloadUri);
    if (!uri) {
      this.logger_("No valid content steering manifest URIs. Stopping content steering.");
      this.trigger("error");
      this.dispose();
      return;
    }
    const metadata = {
      contentSteeringInfo: {
        uri
      }
    };
    this.trigger({
      type: "contentsteeringloadstart",
      metadata
    });
    this.request_ = this.xhr_({
      uri,
      requestType: "content-steering-manifest"
    }, (error, errorInfo) => {
      if (error) {
        if (errorInfo.status === 410) {
          this.logger_(`manifest request 410 ${error}.`);
          this.logger_(`There will be no more content steering requests to ${uri} this session.`);
          this.excludedSteeringManifestURLs.add(uri);
          return;
        }
        if (errorInfo.status === 429) {
          const retrySeconds = errorInfo.responseHeaders["retry-after"];
          this.logger_(`manifest request 429 ${error}.`);
          this.logger_(`content steering will retry in ${retrySeconds} seconds.`);
          this.startTTLTimeout_(parseInt(retrySeconds, 10));
          return;
        }
        this.logger_(`manifest failed to load ${error}.`);
        this.startTTLTimeout_();
        return;
      }
      this.trigger({
        type: "contentsteeringloadcomplete",
        metadata
      });
      let steeringManifestJson;
      try {
        steeringManifestJson = JSON.parse(this.request_.responseText);
      } catch (parseError) {
        const errorMetadata = {
          errorType: videojs$2.Error.StreamingContentSteeringParserError,
          error: parseError
        };
        this.trigger({
          type: "error",
          metadata: errorMetadata
        });
      }
      this.assignSteeringProperties_(steeringManifestJson);
      const parsedMetadata = {
        contentSteeringInfo: metadata.contentSteeringInfo,
        contentSteeringManifest: {
          version: this.steeringManifest.version,
          reloadUri: this.steeringManifest.reloadUri,
          priority: this.steeringManifest.priority
        }
      };
      this.trigger({
        type: "contentsteeringparsed",
        metadata: parsedMetadata
      });
      this.startTTLTimeout_();
    });
  }
  /**
   * Set the proxy server URL and add the steering manifest url as a URI encoded parameter.
   *
   * @param {string} steeringUrl the steering manifest url
   * @return the steering manifest url to a proxy server with all parameters set
   */
  setProxyServerUrl_(steeringUrl) {
    const steeringUrlObject = new window$1$1.URL(steeringUrl);
    const proxyServerUrlObject = new window$1$1.URL(this.proxyServerUrl_);
    proxyServerUrlObject.searchParams.set("url", encodeURI(steeringUrlObject.toString()));
    return this.setSteeringParams_(proxyServerUrlObject.toString());
  }
  /**
   * Decodes and parses the data uri encoded steering manifest
   *
   * @param {string} dataUri the data uri to be decoded and parsed.
   */
  decodeDataUriManifest_(dataUri) {
    const steeringManifestJson = JSON.parse(window$1$1.atob(dataUri));
    this.assignSteeringProperties_(steeringManifestJson);
  }
  /**
   * Set the HLS or DASH content steering manifest request query parameters. For example:
   * _HLS_pathway="<CURRENT-PATHWAY-ID>" and _HLS_throughput=<THROUGHPUT>
   * _DASH_pathway and _DASH_throughput
   *
   * @param {string} uri to add content steering server parameters to.
   * @return a new uri as a string with the added steering query parameters.
   */
  setSteeringParams_(url2) {
    const urlObject = new window$1$1.URL(url2);
    const path2 = this.getPathway();
    const networkThroughput = this.getBandwidth_();
    if (path2) {
      const pathwayKey = `_${this.manifestType_}_pathway`;
      urlObject.searchParams.set(pathwayKey, path2);
    }
    if (networkThroughput) {
      const throughputKey = `_${this.manifestType_}_throughput`;
      urlObject.searchParams.set(throughputKey, networkThroughput);
    }
    return urlObject.toString();
  }
  /**
   * Assigns the current steering manifest properties and to the SteeringManifest object
   *
   * @param {Object} steeringJson the raw JSON steering manifest
   */
  assignSteeringProperties_(steeringJson) {
    this.steeringManifest.version = steeringJson.VERSION;
    if (!this.steeringManifest.version) {
      this.logger_(`manifest version is ${steeringJson.VERSION}, which is not supported.`);
      this.trigger("error");
      return;
    }
    this.steeringManifest.ttl = steeringJson.TTL;
    this.steeringManifest.reloadUri = steeringJson["RELOAD-URI"];
    this.steeringManifest.priority = steeringJson["PATHWAY-PRIORITY"] || steeringJson["SERVICE-LOCATION-PRIORITY"];
    this.steeringManifest.pathwayClones = steeringJson["PATHWAY-CLONES"];
    this.nextPathwayClones = this.steeringManifest.pathwayClones;
    if (!this.availablePathways_.size) {
      this.logger_("There are no available pathways for content steering. Ending content steering.");
      this.trigger("error");
      this.dispose();
    }
    const chooseNextPathway = (pathwaysByPriority) => {
      for (const path2 of pathwaysByPriority) {
        if (this.availablePathways_.has(path2)) {
          return path2;
        }
      }
      return [...this.availablePathways_][0];
    };
    const nextPathway = chooseNextPathway(this.steeringManifest.priority);
    if (this.currentPathway !== nextPathway) {
      this.currentPathway = nextPathway;
      this.trigger("content-steering");
    }
  }
  /**
   * Returns the pathway to use for steering decisions
   *
   * @return {string} returns the current pathway or the default
   */
  getPathway() {
    return this.currentPathway || this.defaultPathway;
  }
  /**
   * Chooses the manifest request URI based on proxy URIs and server URLs.
   * Also accounts for exclusion on certain manifest URIs.
   *
   * @param {string} reloadUri the base uri before parameters
   *
   * @return {string} the final URI for the request to the manifest server.
   */
  getRequestURI(reloadUri) {
    if (!reloadUri) {
      return null;
    }
    const isExcluded2 = (uri) => this.excludedSteeringManifestURLs.has(uri);
    if (this.proxyServerUrl_) {
      const proxyURI = this.setProxyServerUrl_(reloadUri);
      if (!isExcluded2(proxyURI)) {
        return proxyURI;
      }
    }
    const steeringURI = this.setSteeringParams_(reloadUri);
    if (!isExcluded2(steeringURI)) {
      return steeringURI;
    }
    return null;
  }
  /**
   * Start the timeout for re-requesting the steering manifest at the TTL interval.
   *
   * @param {number} ttl time in seconds of the timeout. Defaults to the
   *        ttl interval in the steering manifest
   */
  startTTLTimeout_(ttl = this.steeringManifest.ttl) {
    const ttlMS = ttl * 1e3;
    this.ttlTimeout_ = window$1$1.setTimeout(() => {
      this.requestSteeringManifest();
    }, ttlMS);
  }
  /**
   * Clear the TTL timeout if necessary.
   */
  clearTTLTimeout_() {
    window$1$1.clearTimeout(this.ttlTimeout_);
    this.ttlTimeout_ = null;
  }
  /**
   * aborts any current steering xhr and sets the current request object to null
   */
  abort() {
    if (this.request_) {
      this.request_.abort();
    }
    this.request_ = null;
  }
  /**
   * aborts steering requests clears the ttl timeout and resets all properties.
   */
  dispose() {
    this.off("content-steering");
    this.off("error");
    this.abort();
    this.clearTTLTimeout_();
    this.currentPathway = null;
    this.defaultPathway = null;
    this.queryBeforeStart = null;
    this.proxyServerUrl_ = null;
    this.manifestType_ = null;
    this.ttlTimeout_ = null;
    this.request_ = null;
    this.excludedSteeringManifestURLs = /* @__PURE__ */ new Set();
    this.availablePathways_ = /* @__PURE__ */ new Set();
    this.steeringManifest = new SteeringManifest();
  }
  /**
   * adds a pathway to the available pathways set
   *
   * @param {string} pathway the pathway string to add
   */
  addAvailablePathway(pathway) {
    if (pathway) {
      this.availablePathways_.add(pathway);
    }
  }
  /**
   * Clears all pathways from the available pathways set
   */
  clearAvailablePathways() {
    this.availablePathways_.clear();
  }
  /**
   * Removes a pathway from the available pathways set.
   */
  excludePathway(pathway) {
    return this.availablePathways_.delete(pathway);
  }
  /**
   * Checks the refreshed DASH manifest content steering tag for changes.
   *
   * @param {string} baseURL new steering tag on DASH manifest refresh
   * @param {Object} newTag the new tag to check for changes
   * @return a true or false whether the new tag has different values
   */
  didDASHTagChange(baseURL, newTag) {
    return !newTag && this.steeringManifest.reloadUri || newTag && (resolveUrl22(baseURL, newTag.serverURL) !== this.steeringManifest.reloadUri || newTag.defaultServiceLocation !== this.defaultPathway || newTag.queryBeforeStart !== this.queryBeforeStart || newTag.proxyServerURL !== this.proxyServerUrl_);
  }
  getAvailablePathways() {
    return this.availablePathways_;
  }
}
const ABORT_EARLY_EXCLUSION_SECONDS = 10;
let Vhs$1;
const loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
const sumLoaderStat = function(stat) {
  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
};
const shouldSwitchToMedia = function({
  currentPlaylist,
  buffered,
  currentTime,
  nextPlaylist,
  bufferLowWaterLine,
  bufferHighWaterLine,
  duration: duration2,
  bufferBasedABR,
  log: log2
}) {
  if (!nextPlaylist) {
    videojs$2.log.warn("We received no playlist to switch to. Please check your stream.");
    return false;
  }
  const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || "null"} -> ${nextPlaylist.id}`;
  if (!currentPlaylist) {
    log2(`${sharedLogLine} as current playlist is not set`);
    return true;
  }
  if (nextPlaylist.id === currentPlaylist.id) {
    return false;
  }
  const isBuffered = Boolean(findRange(buffered, currentTime).length);
  if (!currentPlaylist.endList) {
    if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
      log2(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);
      return false;
    }
    log2(`${sharedLogLine} as current playlist is live`);
    return true;
  }
  const forwardBuffer = timeAheadOf(buffered, currentTime);
  const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
  if (duration2 < maxBufferLowWaterLine) {
    log2(`${sharedLogLine} as duration < max low water line (${duration2} < ${maxBufferLowWaterLine})`);
    return true;
  }
  const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
  const currBandwidth = currentPlaylist.attributes.BANDWIDTH;
  if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
    let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;
    if (bufferBasedABR) {
      logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;
    }
    log2(logLine);
    return true;
  }
  if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
    let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;
    if (bufferBasedABR) {
      logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;
    }
    log2(logLine);
    return true;
  }
  log2(`not ${sharedLogLine} as no switching criteria met`);
  return false;
};
class PlaylistController extends videojs$2.EventTarget {
  constructor(options) {
    super();
    const {
      src,
      withCredentials,
      tech,
      bandwidth,
      externVhs,
      useCueTags,
      playlistExclusionDuration,
      enableLowInitialPlaylist,
      sourceType,
      cacheEncryptionKeys,
      bufferBasedABR,
      leastPixelDiffSelector,
      captionServices
    } = options;
    if (!src) {
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    }
    let {
      maxPlaylistRetries
    } = options;
    if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
      maxPlaylistRetries = Infinity;
    }
    Vhs$1 = externVhs;
    this.bufferBasedABR = Boolean(bufferBasedABR);
    this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);
    this.withCredentials = withCredentials;
    this.tech_ = tech;
    this.vhs_ = tech.vhs;
    this.player_ = options.player_;
    this.sourceType_ = sourceType;
    this.useCueTags_ = useCueTags;
    this.playlistExclusionDuration = playlistExclusionDuration;
    this.maxPlaylistRetries = maxPlaylistRetries;
    this.enableLowInitialPlaylist = enableLowInitialPlaylist;
    if (this.useCueTags_) {
      this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues");
      this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
    }
    this.requestOptions_ = {
      withCredentials,
      maxPlaylistRetries,
      timeout: null
    };
    this.on("error", this.pauseLoading);
    this.mediaTypes_ = createMediaTypes();
    this.mediaSource = new window$1$1.MediaSource();
    this.handleDurationChange_ = this.handleDurationChange_.bind(this);
    this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);
    this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);
    this.mediaSource.addEventListener("durationchange", this.handleDurationChange_);
    this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_);
    this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_);
    this.seekable_ = createTimeRanges();
    this.hasPlayed_ = false;
    this.syncController_ = new SyncController(options);
    this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, false).track;
    this.decrypter_ = new Decrypter();
    this.sourceUpdater_ = new SourceUpdater(this.mediaSource);
    this.inbandTextTracks_ = {};
    this.timelineChangeController_ = new TimelineChangeController();
    this.keyStatusMap_ = /* @__PURE__ */ new Map();
    const segmentLoaderSettings = {
      vhs: this.vhs_,
      parse708captions: options.parse708captions,
      useDtsForTimestampOffset: options.useDtsForTimestampOffset,
      captionServices,
      mediaSource: this.mediaSource,
      currentTime: this.tech_.currentTime.bind(this.tech_),
      seekable: () => this.seekable(),
      seeking: () => this.tech_.seeking(),
      duration: () => this.duration(),
      hasPlayed: () => this.hasPlayed_,
      goalBufferLength: () => this.goalBufferLength(),
      bandwidth,
      syncController: this.syncController_,
      decrypter: this.decrypter_,
      sourceType: this.sourceType_,
      inbandTextTracks: this.inbandTextTracks_,
      cacheEncryptionKeys,
      sourceUpdater: this.sourceUpdater_,
      timelineChangeController: this.timelineChangeController_,
      exactManifestTimings: options.exactManifestTimings,
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    };
    this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new DashPlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {
      addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
    })) : new PlaylistLoader(src, this.vhs_, merge(this.requestOptions_, {
      addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
    }));
    this.setupMainPlaylistLoaderListeners_();
    this.mainSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {
      segmentMetadataTrack: this.segmentMetadataTrack_,
      loaderType: "main"
    }), options);
    this.audioSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {
      loaderType: "audio"
    }), options);
    this.subtitleSegmentLoader_ = new VTTSegmentLoader(merge(segmentLoaderSettings, {
      loaderType: "vtt",
      featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
      loadVttJs: () => new Promise((resolve, reject) => {
        function onLoad2() {
          tech.off("vttjserror", onError2);
          resolve();
        }
        function onError2() {
          tech.off("vttjsloaded", onLoad2);
          reject();
        }
        tech.one("vttjsloaded", onLoad2);
        tech.one("vttjserror", onError2);
        tech.addWebVttScript_();
      })
    }), options);
    const getBandwidth = () => {
      return this.mainSegmentLoader_.bandwidth;
    };
    this.contentSteeringController_ = new ContentSteeringController(this.vhs_.xhr, getBandwidth);
    this.setupSegmentLoaderListeners_();
    if (this.bufferBasedABR) {
      this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_());
      this.tech_.on("pause", () => this.stopABRTimer_());
      this.tech_.on("play", () => this.startABRTimer_());
    }
    loaderStats.forEach((stat) => {
      this[stat + "_"] = sumLoaderStat.bind(this, stat);
    });
    this.logger_ = logger("pc");
    this.triggeredFmp4Usage = false;
    if (this.tech_.preload() === "none") {
      this.loadOnPlay_ = () => {
        this.loadOnPlay_ = null;
        this.mainPlaylistLoader_.load();
      };
      this.tech_.one("play", this.loadOnPlay_);
    } else {
      this.mainPlaylistLoader_.load();
    }
    this.timeToLoadedData__ = -1;
    this.mainAppendsToLoadedData__ = -1;
    this.audioAppendsToLoadedData__ = -1;
    const event2 = this.tech_.preload() === "none" ? "play" : "loadstart";
    this.tech_.one(event2, () => {
      const timeToLoadedDataStart = Date.now();
      this.tech_.one("loadeddata", () => {
        this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
        this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;
        this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
      });
    });
  }
  mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  }
  audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  }
  appendsToLoadedData_() {
    const main2 = this.mainAppendsToLoadedData_();
    const audio = this.audioAppendsToLoadedData_();
    if (main2 === -1 || audio === -1) {
      return -1;
    }
    return main2 + audio;
  }
  timeToLoadedData_() {
    return this.timeToLoadedData__;
  }
  /**
   * Run selectPlaylist and switch to the new playlist if we should
   *
   * @param {string} [reason=abr] a reason for why the ABR check is made
   * @private
   */
  checkABR_(reason = "abr") {
    const nextPlaylist = this.selectPlaylist();
    if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
      this.switchMedia_(nextPlaylist, reason);
    }
  }
  switchMedia_(playlist, cause, delay) {
    const oldMedia = this.media();
    const oldId = oldMedia && (oldMedia.id || oldMedia.uri);
    const newId = playlist && (playlist.id || playlist.uri);
    if (oldId && oldId !== newId) {
      this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);
      const metadata = {
        renditionInfo: {
          id: newId,
          bandwidth: playlist.attributes.BANDWIDTH,
          resolution: playlist.attributes.RESOLUTION,
          codecs: playlist.attributes.CODECS
        },
        cause
      };
      this.trigger({
        type: "renditionselected",
        metadata
      });
      this.tech_.trigger({
        type: "usage",
        name: `vhs-rendition-change-${cause}`
      });
    }
    this.mainPlaylistLoader_.media(playlist, delay);
  }
  /**
   * A function that ensures we switch our playlists inside of `mediaTypes`
   * to match the current `serviceLocation` provided by the contentSteering controller.
   * We want to check media types of `AUDIO`, `SUBTITLES`, and `CLOSED-CAPTIONS`.
   *
   * This should only be called on a DASH playback scenario while using content steering.
   * This is necessary due to differences in how media in HLS manifests are generally tied to
   * a video playlist, where in DASH that is not always the case.
   */
  switchMediaForDASHContentSteering_() {
    ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach((type) => {
      const mediaType = this.mediaTypes_[type];
      const activeGroup2 = mediaType ? mediaType.activeGroup() : null;
      const pathway = this.contentSteeringController_.getPathway();
      if (activeGroup2 && pathway) {
        const mediaPlaylists = activeGroup2.length ? activeGroup2[0].playlists : activeGroup2.playlists;
        const dashMediaPlaylists = mediaPlaylists.filter((p) => p.attributes.serviceLocation === pathway);
        if (dashMediaPlaylists.length) {
          this.mediaTypes_[type].activePlaylistLoader.media(dashMediaPlaylists[0]);
        }
      }
    });
  }
  /**
   * Start a timer that periodically calls checkABR_
   *
   * @private
   */
  startABRTimer_() {
    this.stopABRTimer_();
    this.abrTimer_ = window$1$1.setInterval(() => this.checkABR_(), 250);
  }
  /**
   * Stop the timer that periodically calls checkABR_
   *
   * @private
   */
  stopABRTimer_() {
    if (this.tech_.scrubbing && this.tech_.scrubbing()) {
      return;
    }
    window$1$1.clearInterval(this.abrTimer_);
    this.abrTimer_ = null;
  }
  /**
   * Get a list of playlists for the currently selected audio playlist
   *
   * @return {Array} the array of audio playlists
   */
  getAudioTrackPlaylists_() {
    const main2 = this.main();
    const defaultPlaylists = main2 && main2.playlists || [];
    if (!main2 || !main2.mediaGroups || !main2.mediaGroups.AUDIO) {
      return defaultPlaylists;
    }
    const AUDIO = main2.mediaGroups.AUDIO;
    const groupKeys = Object.keys(AUDIO);
    let track;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
      track = this.mediaTypes_.AUDIO.activeTrack();
    } else {
      const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
      for (const label in defaultGroup) {
        if (defaultGroup[label].default) {
          track = {
            label
          };
          break;
        }
      }
    }
    if (!track) {
      return defaultPlaylists;
    }
    const playlists = [];
    for (const group in AUDIO) {
      if (AUDIO[group][track.label]) {
        const properties = AUDIO[group][track.label];
        if (properties.playlists && properties.playlists.length) {
          playlists.push.apply(playlists, properties.playlists);
        } else if (properties.uri) {
          playlists.push(properties);
        } else if (main2.playlists.length) {
          for (let i = 0; i < main2.playlists.length; i++) {
            const playlist = main2.playlists[i];
            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
              playlists.push(playlist);
            }
          }
        }
      }
    }
    if (!playlists.length) {
      return defaultPlaylists;
    }
    return playlists;
  }
  /**
   * Register event handlers on the main playlist loader. A helper
   * function for construction time.
   *
   * @private
   */
  setupMainPlaylistLoaderListeners_() {
    this.mainPlaylistLoader_.on("loadedmetadata", () => {
      const media = this.mainPlaylistLoader_.media();
      const requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {
        this.requestOptions_.timeout = 0;
      } else {
        this.requestOptions_.timeout = requestTimeout;
      }
      if (media.endList && this.tech_.preload() !== "none") {
        this.mainSegmentLoader_.playlist(media, this.requestOptions_);
        this.mainSegmentLoader_.load();
      }
      setupMediaGroups({
        sourceType: this.sourceType_,
        segmentLoaders: {
          AUDIO: this.audioSegmentLoader_,
          SUBTITLES: this.subtitleSegmentLoader_,
          main: this.mainSegmentLoader_
        },
        tech: this.tech_,
        requestOptions: this.requestOptions_,
        mainPlaylistLoader: this.mainPlaylistLoader_,
        vhs: this.vhs_,
        main: this.main(),
        mediaTypes: this.mediaTypes_,
        excludePlaylist: this.excludePlaylist.bind(this)
      });
      this.triggerPresenceUsage_(this.main(), media);
      this.setupFirstPlay();
      if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
        this.trigger("selectedinitialmedia");
      } else {
        this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => {
          this.trigger("selectedinitialmedia");
        });
      }
    });
    this.mainPlaylistLoader_.on("loadedplaylist", () => {
      if (this.loadOnPlay_) {
        this.tech_.off("play", this.loadOnPlay_);
      }
      let updatedPlaylist = this.mainPlaylistLoader_.media();
      if (!updatedPlaylist) {
        this.attachContentSteeringListeners_();
        this.initContentSteeringController_();
        this.excludeUnsupportedVariants_();
        let selectedMedia;
        if (this.enableLowInitialPlaylist) {
          selectedMedia = this.selectInitialPlaylist();
        }
        if (!selectedMedia) {
          selectedMedia = this.selectPlaylist();
        }
        if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) {
          return;
        }
        this.initialMedia_ = selectedMedia;
        this.switchMedia_(this.initialMedia_, "initial");
        const haveJsonSource = this.sourceType_ === "vhs-json" && this.initialMedia_.segments;
        if (!haveJsonSource) {
          return;
        }
        updatedPlaylist = this.initialMedia_;
      }
      this.handleUpdatedMediaPlaylist(updatedPlaylist);
    });
    this.mainPlaylistLoader_.on("error", () => {
      const error = this.mainPlaylistLoader_.error;
      this.excludePlaylist({
        playlistToExclude: error.playlist,
        error
      });
    });
    this.mainPlaylistLoader_.on("mediachanging", () => {
      this.mainSegmentLoader_.abort();
      this.mainSegmentLoader_.pause();
    });
    this.mainPlaylistLoader_.on("mediachange", () => {
      const media = this.mainPlaylistLoader_.media();
      const requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {
        this.requestOptions_.timeout = 0;
      } else {
        this.requestOptions_.timeout = requestTimeout;
      }
      if (this.sourceType_ === "dash") {
        this.mainPlaylistLoader_.load();
      }
      this.mainSegmentLoader_.pause();
      this.mainSegmentLoader_.playlist(media, this.requestOptions_);
      if (this.waitingForFastQualityPlaylistReceived_) {
        this.runFastQualitySwitch_();
      } else {
        this.mainSegmentLoader_.load();
      }
      this.tech_.trigger({
        type: "mediachange",
        bubbles: true
      });
    });
    this.mainPlaylistLoader_.on("playlistunchanged", () => {
      const updatedPlaylist = this.mainPlaylistLoader_.media();
      if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
        return;
      }
      const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);
      if (playlistOutdated) {
        this.excludePlaylist({
          error: {
            message: "Playlist no longer updating.",
            reason: "playlist-unchanged"
          }
        });
        this.tech_.trigger("playliststuck");
      }
    });
    this.mainPlaylistLoader_.on("renditiondisabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
    });
    this.mainPlaylistLoader_.on("renditionenabled", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
    });
    const playlistLoaderEvents = ["manifestrequeststart", "manifestrequestcomplete", "manifestparsestart", "manifestparsecomplete", "playlistrequeststart", "playlistrequestcomplete", "playlistparsestart", "playlistparsecomplete", "renditiondisabled", "renditionenabled"];
    playlistLoaderEvents.forEach((eventName) => {
      this.mainPlaylistLoader_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
    });
  }
  /**
   * Given an updated media playlist (whether it was loaded for the first time, or
   * refreshed for live playlists), update any relevant properties and state to reflect
   * changes in the media that should be accounted for (e.g., cues and duration).
   *
   * @param {Object} updatedPlaylist the updated media playlist object
   *
   * @private
   */
  handleUpdatedMediaPlaylist(updatedPlaylist) {
    if (this.useCueTags_) {
      this.updateAdCues_(updatedPlaylist);
    }
    this.mainSegmentLoader_.pause();
    this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
    if (this.waitingForFastQualityPlaylistReceived_) {
      this.runFastQualitySwitch_();
    }
    this.updateDuration(!updatedPlaylist.endList);
    if (!this.tech_.paused()) {
      this.mainSegmentLoader_.load();
      if (this.audioSegmentLoader_) {
        this.audioSegmentLoader_.load();
      }
    }
  }
  /**
   * A helper function for triggerring presence usage events once per source
   *
   * @private
   */
  triggerPresenceUsage_(main2, media) {
    const mediaGroups = main2.mediaGroups || {};
    let defaultDemuxed = true;
    const audioGroupKeys = Object.keys(mediaGroups.AUDIO);
    for (const mediaGroup in mediaGroups.AUDIO) {
      for (const label in mediaGroups.AUDIO[mediaGroup]) {
        const properties = mediaGroups.AUDIO[mediaGroup][label];
        if (!properties.uri) {
          defaultDemuxed = false;
        }
      }
    }
    if (defaultDemuxed) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-demuxed"
      });
    }
    if (Object.keys(mediaGroups.SUBTITLES).length) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-webvtt"
      });
    }
    if (Vhs$1.Playlist.isAes(media)) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-aes"
      });
    }
    if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-alternate-audio"
      });
    }
    if (this.useCueTags_) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-playlist-cue-tags"
      });
    }
  }
  shouldSwitchToMedia_(nextPlaylist) {
    const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;
    const currentTime = this.tech_.currentTime();
    const bufferLowWaterLine = this.bufferLowWaterLine();
    const bufferHighWaterLine = this.bufferHighWaterLine();
    const buffered = this.tech_.buffered();
    return shouldSwitchToMedia({
      buffered,
      currentTime,
      currentPlaylist,
      nextPlaylist,
      bufferLowWaterLine,
      bufferHighWaterLine,
      duration: this.duration(),
      bufferBasedABR: this.bufferBasedABR,
      log: this.logger_
    });
  }
  /**
   * Register event handlers on the segment loaders. A helper function
   * for construction time.
   *
   * @private
   */
  setupSegmentLoaderListeners_() {
    this.mainSegmentLoader_.on("bandwidthupdate", () => {
      this.checkABR_("bandwidthupdate");
      this.tech_.trigger("bandwidthupdate");
    });
    this.mainSegmentLoader_.on("timeout", () => {
      if (this.bufferBasedABR) {
        this.mainSegmentLoader_.load();
      }
    });
    if (!this.bufferBasedABR) {
      this.mainSegmentLoader_.on("progress", () => {
        this.trigger("progress");
      });
    }
    this.mainSegmentLoader_.on("error", () => {
      const error = this.mainSegmentLoader_.error();
      this.excludePlaylist({
        playlistToExclude: error.playlist,
        error
      });
    });
    this.mainSegmentLoader_.on("appenderror", () => {
      this.error = this.mainSegmentLoader_.error_;
      this.trigger("error");
    });
    this.mainSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    });
    this.mainSegmentLoader_.on("timestampoffset", () => {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
    });
    this.audioSegmentLoader_.on("syncinfoupdate", () => {
      this.onSyncInfoUpdate_();
    });
    this.audioSegmentLoader_.on("appenderror", () => {
      this.error = this.audioSegmentLoader_.error_;
      this.trigger("error");
    });
    this.mainSegmentLoader_.on("ended", () => {
      this.logger_("main segment loader ended");
      this.onEndOfStream();
    });
    this.mainSegmentLoader_.on("earlyabort", (event2) => {
      if (this.bufferBasedABR) {
        return;
      }
      this.delegateLoaders_("all", ["abort"]);
      this.excludePlaylist({
        error: {
          message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
        },
        playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS
      });
    });
    const updateCodecs = () => {
      if (!this.sourceUpdater_.hasCreatedSourceBuffers()) {
        return this.tryToCreateSourceBuffers_();
      }
      const codecs = this.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      this.sourceUpdater_.addOrChangeSourceBuffers(codecs);
    };
    this.mainSegmentLoader_.on("trackinfo", updateCodecs);
    this.audioSegmentLoader_.on("trackinfo", updateCodecs);
    this.mainSegmentLoader_.on("fmp4", () => {
      if (!this.triggeredFmp4Usage) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        this.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("fmp4", () => {
      if (!this.triggeredFmp4Usage) {
        this.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        this.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("ended", () => {
      this.logger_("audioSegmentLoader ended");
      this.onEndOfStream();
    });
    const segmentLoaderEvents = ["segmentselected", "segmentloadstart", "segmentloaded", "segmentkeyloadstart", "segmentkeyloadcomplete", "segmentdecryptionstart", "segmentdecryptioncomplete", "segmenttransmuxingstart", "segmenttransmuxingcomplete", "segmenttransmuxingtrackinfoavailable", "segmenttransmuxingtiminginfoavailable", "segmentappendstart", "appendsdone", "bandwidthupdated", "timelinechange", "codecschange"];
    segmentLoaderEvents.forEach((eventName) => {
      this.mainSegmentLoader_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
      this.audioSegmentLoader_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
      this.subtitleSegmentLoader_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
    });
  }
  mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  }
  /**
   * Call load on our SegmentLoaders
   */
  load() {
    this.mainSegmentLoader_.load();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.load();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.load();
    }
  }
  /**
   * Re-tune playback quality level for the current player
   * conditions. This method will perform destructive actions like removing
   * already buffered content in order to readjust the currently active
   * playlist quickly. This is good for manual quality changes
   *
   * @private
   */
  fastQualityChange_(media = this.selectPlaylist()) {
    if (media && media === this.mainPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(media, "fast-quality");
    this.waitingForFastQualityPlaylistReceived_ = true;
  }
  runFastQualitySwitch_() {
    this.waitingForFastQualityPlaylistReceived_ = false;
    this.mainSegmentLoader_.pause();
    this.mainSegmentLoader_.resetEverything(() => {
      this.mainSegmentLoader_.load();
    });
  }
  /**
   * Begin playback.
   */
  play() {
    if (this.setupFirstPlay()) {
      return;
    }
    if (this.tech_.ended()) {
      this.tech_.setCurrentTime(0);
    }
    if (this.hasPlayed_) {
      this.load();
    }
    const seekable2 = this.tech_.seekable();
    if (this.tech_.duration() === Infinity) {
      if (this.tech_.currentTime() < seekable2.start(0)) {
        return this.tech_.setCurrentTime(seekable2.end(seekable2.length - 1));
      }
    }
  }
  /**
   * Seek to the latest media position if this is a live video and the
   * player and video are loaded and initialized.
   */
  setupFirstPlay() {
    const media = this.mainPlaylistLoader_.media();
    if (!media || this.tech_.paused() || this.hasPlayed_) {
      return false;
    }
    if (!media.endList || media.start) {
      const seekable2 = this.seekable();
      if (!seekable2.length) {
        return false;
      }
      const seekableEnd = seekable2.end(0);
      let startPoint = seekableEnd;
      if (media.start) {
        const offset2 = media.start.timeOffset;
        if (offset2 < 0) {
          startPoint = Math.max(seekableEnd + offset2, seekable2.start(0));
        } else {
          startPoint = Math.min(seekableEnd, offset2);
        }
      }
      this.trigger("firstplay");
      this.tech_.setCurrentTime(startPoint);
    }
    this.hasPlayed_ = true;
    this.load();
    return true;
  }
  /**
   * handle the sourceopen event on the MediaSource
   *
   * @private
   */
  handleSourceOpen_() {
    this.tryToCreateSourceBuffers_();
    if (this.tech_.autoplay()) {
      const playPromise = this.tech_.play();
      if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
        playPromise.then(null, (e) => {
        });
      }
    }
    this.trigger("sourceopen");
  }
  /**
   * handle the sourceended event on the MediaSource
   *
   * @private
   */
  handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_) {
      return;
    }
    const cues = this.inbandTextTracks_.metadataTrack_.cues;
    if (!cues || !cues.length) {
      return;
    }
    const duration2 = this.duration();
    cues[cues.length - 1].endTime = isNaN(duration2) || Math.abs(duration2) === Infinity ? Number.MAX_VALUE : duration2;
  }
  /**
   * handle the durationchange event on the MediaSource
   *
   * @private
   */
  handleDurationChange_() {
    this.tech_.trigger("durationchange");
  }
  /**
   * Calls endOfStream on the media source when all active stream types have called
   * endOfStream
   *
   * @param {string} streamType
   *        Stream type of the segment loader that called endOfStream
   * @private
   */
  onEndOfStream() {
    let isEndOfStream = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
      if (!mainMediaInfo || mainMediaInfo.hasVideo) {
        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
      } else {
        isEndOfStream = this.audioSegmentLoader_.ended_;
      }
    }
    if (!isEndOfStream) {
      return;
    }
    this.stopABRTimer_();
    this.sourceUpdater_.endOfStream();
  }
  /**
   * Check if a playlist has stopped being updated
   *
   * @param {Object} playlist the media playlist object
   * @return {boolean} whether the playlist has stopped being updated or not
   */
  stuckAtPlaylistEnd_(playlist) {
    const seekable2 = this.seekable();
    if (!seekable2.length) {
      return false;
    }
    const expired = this.syncController_.getExpiredTime(playlist, this.duration());
    if (expired === null) {
      return false;
    }
    const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
    const currentTime = this.tech_.currentTime();
    const buffered = this.tech_.buffered();
    if (!buffered.length) {
      return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
    }
    const bufferedEnd = buffered.end(buffered.length - 1);
    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
  }
  /**
   * Exclude a playlist for a set amount of time, making it unavailable for selection by
   * the rendition selection algorithm, then force a new playlist (rendition) selection.
   *
   * @param {Object=} playlistToExclude
   *                  the playlist to exclude, defaults to the currently selected playlist
   * @param {Object=} error
   *                  an optional error
   * @param {number=} playlistExclusionDuration
   *                  an optional number of seconds to exclude the playlist
   */
  excludePlaylist({
    playlistToExclude = this.mainPlaylistLoader_.media(),
    error = {},
    playlistExclusionDuration
  }) {
    playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();
    playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration;
    if (!playlistToExclude) {
      this.error = error;
      if (this.mediaSource.readyState !== "open") {
        this.trigger("error");
      } else {
        this.sourceUpdater_.endOfStream("network");
      }
      return;
    }
    playlistToExclude.playlistErrors_++;
    const playlists = this.mainPlaylistLoader_.main.playlists;
    const enabledPlaylists = playlists.filter(isEnabled);
    const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude;
    if (playlists.length === 1 && playlistExclusionDuration !== Infinity) {
      videojs$2.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. Trying again since it is the only playlist.`);
      this.tech_.trigger("retryplaylist");
      return this.mainPlaylistLoader_.load(isFinalRendition);
    }
    if (isFinalRendition) {
      if (this.main().contentSteering) {
        const pathway = this.pathwayAttribute_(playlistToExclude);
        const reIncludeDelay = this.contentSteeringController_.steeringManifest.ttl * 1e3;
        this.contentSteeringController_.excludePathway(pathway);
        this.excludeThenChangePathway_();
        setTimeout(() => {
          this.contentSteeringController_.addAvailablePathway(pathway);
        }, reIncludeDelay);
        return;
      }
      let reincluded = false;
      playlists.forEach((playlist) => {
        if (playlist === playlistToExclude) {
          return;
        }
        const excludeUntil2 = playlist.excludeUntil;
        if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
          reincluded = true;
          delete playlist.excludeUntil;
        }
      });
      if (reincluded) {
        videojs$2.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
        this.tech_.trigger("retryplaylist");
      }
    }
    let excludeUntil;
    if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) {
      excludeUntil = Infinity;
    } else {
      excludeUntil = Date.now() + playlistExclusionDuration * 1e3;
    }
    playlistToExclude.excludeUntil = excludeUntil;
    if (error.reason) {
      playlistToExclude.lastExcludeReason_ = error.reason;
    }
    this.tech_.trigger("excludeplaylist");
    this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-excluded"
    });
    const nextPlaylist = this.selectPlaylist();
    if (!nextPlaylist) {
      this.error = "Playback cannot continue. No available working or supported playlists.";
      this.trigger("error");
      return;
    }
    const logFn2 = error.internal ? this.logger_ : videojs$2.log.warn;
    const errorMessage = error.message ? " " + error.message : "";
    logFn2(`${error.internal ? "Internal problem" : "Problem"} encountered with playlist ${playlistToExclude.id}.${errorMessage} Switching to playlist ${nextPlaylist.id}.`);
    if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) {
      this.delegateLoaders_("audio", ["abort", "pause"]);
    }
    if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) {
      this.delegateLoaders_("subtitle", ["abort", "pause"]);
    }
    this.delegateLoaders_("main", ["abort", "pause"]);
    const delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
    const shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
    return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
  }
  /**
   * Pause all segment/playlist loaders
   */
  pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]);
    this.stopABRTimer_();
  }
  /**
   * Call a set of functions in order on playlist loaders, segment loaders,
   * or both types of loaders.
   *
   * @param {string} filter
   *        Filter loaders that should call fnNames using a string. Can be:
   *        * all - run on all loaders
   *        * audio - run on all audio loaders
   *        * subtitle - run on all subtitle loaders
   *        * main - run on the main loaders
   *
   * @param {Array|string} fnNames
   *        A string or array of function names to call.
   */
  delegateLoaders_(filter, fnNames) {
    const loaders = [];
    const dontFilterPlaylist = filter === "all";
    if (dontFilterPlaylist || filter === "main") {
      loaders.push(this.mainPlaylistLoader_);
    }
    const mediaTypes2 = [];
    if (dontFilterPlaylist || filter === "audio") {
      mediaTypes2.push("AUDIO");
    }
    if (dontFilterPlaylist || filter === "subtitle") {
      mediaTypes2.push("CLOSED-CAPTIONS");
      mediaTypes2.push("SUBTITLES");
    }
    mediaTypes2.forEach((mediaType) => {
      const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;
      if (loader) {
        loaders.push(loader);
      }
    });
    ["main", "audio", "subtitle"].forEach((name) => {
      const loader = this[`${name}SegmentLoader_`];
      if (loader && (filter === name || filter === "all")) {
        loaders.push(loader);
      }
    });
    loaders.forEach((loader) => fnNames.forEach((fnName) => {
      if (typeof loader[fnName] === "function") {
        loader[fnName]();
      }
    }));
  }
  /**
   * set the current time on all segment loaders
   *
   * @param {TimeRange} currentTime the current time to set
   * @return {TimeRange} the current time
   */
  setCurrentTime(currentTime) {
    const buffered = findRange(this.tech_.buffered(), currentTime);
    if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) {
      return 0;
    }
    if (!this.mainPlaylistLoader_.media().segments) {
      return 0;
    }
    if (buffered && buffered.length) {
      return currentTime;
    }
    this.mainSegmentLoader_.pause();
    this.mainSegmentLoader_.resetEverything();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.pause();
      this.audioSegmentLoader_.resetEverything();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.pause();
      this.subtitleSegmentLoader_.resetEverything();
    }
    this.load();
  }
  /**
   * get the current duration
   *
   * @return {TimeRange} the duration
   */
  duration() {
    if (!this.mainPlaylistLoader_) {
      return 0;
    }
    const media = this.mainPlaylistLoader_.media();
    if (!media) {
      return 0;
    }
    if (!media.endList) {
      return Infinity;
    }
    if (this.mediaSource) {
      return this.mediaSource.duration;
    }
    return Vhs$1.Playlist.duration(media);
  }
  /**
   * check the seekable range
   *
   * @return {TimeRange} the seekable range
   */
  seekable() {
    return this.seekable_;
  }
  onSyncInfoUpdate_() {
    let audioSeekable;
    if (!this.mainPlaylistLoader_) {
      return;
    }
    let media = this.mainPlaylistLoader_.media();
    if (!media) {
      return;
    }
    let expired = this.syncController_.getExpiredTime(media, this.duration());
    if (expired === null) {
      return;
    }
    const main2 = this.mainPlaylistLoader_.main;
    const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main2, media));
    if (mainSeekable.length === 0) {
      return;
    }
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
      expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main2, media));
      if (audioSeekable.length === 0) {
        return;
      }
    }
    let oldEnd;
    let oldStart;
    if (this.seekable_ && this.seekable_.length) {
      oldEnd = this.seekable_.end(0);
      oldStart = this.seekable_.start(0);
    }
    if (!audioSeekable) {
      this.seekable_ = mainSeekable;
    } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
      this.seekable_ = mainSeekable;
    } else {
      this.seekable_ = createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
    }
    if (this.seekable_ && this.seekable_.length) {
      if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
        return;
      }
    }
    this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);
    const metadata = {
      seekableRanges: this.seekable_
    };
    this.trigger({
      type: "seekablerangeschanged",
      metadata
    });
    this.tech_.trigger("seekablechanged");
  }
  /**
   * Update the player duration
   */
  updateDuration(isLive) {
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
      this.updateDuration_ = null;
    }
    if (this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, isLive);
      this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (isLive) {
      const seekable2 = this.seekable();
      if (!seekable2.length) {
        return;
      }
      if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable2.end(seekable2.length - 1)) {
        this.sourceUpdater_.setDuration(seekable2.end(seekable2.length - 1));
      }
      return;
    }
    const buffered = this.tech_.buffered();
    let duration2 = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());
    if (buffered.length > 0) {
      duration2 = Math.max(duration2, buffered.end(buffered.length - 1));
    }
    if (this.mediaSource.duration !== duration2) {
      this.sourceUpdater_.setDuration(duration2);
    }
  }
  /**
   * dispose of the PlaylistController and everything
   * that it controls
   */
  dispose() {
    this.trigger("dispose");
    this.decrypter_.terminate();
    this.mainPlaylistLoader_.dispose();
    this.mainSegmentLoader_.dispose();
    this.contentSteeringController_.dispose();
    this.keyStatusMap_.clear();
    if (this.loadOnPlay_) {
      this.tech_.off("play", this.loadOnPlay_);
    }
    ["AUDIO", "SUBTITLES"].forEach((type) => {
      const groups = this.mediaTypes_[type].groups;
      for (const id in groups) {
        groups[id].forEach((group) => {
          if (group.playlistLoader) {
            group.playlistLoader.dispose();
          }
        });
      }
    });
    this.audioSegmentLoader_.dispose();
    this.subtitleSegmentLoader_.dispose();
    this.sourceUpdater_.dispose();
    this.timelineChangeController_.dispose();
    this.stopABRTimer_();
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
    }
    this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
    this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
    this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
    this.off();
  }
  /**
   * return the main playlist object if we have one
   *
   * @return {Object} the main playlist object that we parsed
   */
  main() {
    return this.mainPlaylistLoader_.main;
  }
  /**
   * return the currently selected playlist
   *
   * @return {Object} the currently selected playlist object that we parsed
   */
  media() {
    return this.mainPlaylistLoader_.media() || this.initialMedia_;
  }
  areMediaTypesKnown_() {
    const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
    const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
    if (!hasMainMediaInfo || !hasAudioMediaInfo) {
      return false;
    }
    return true;
  }
  // find from and to for codec switch event
  getCodecsOrExclude_() {
    const media = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    };
    const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
    media.video = media.main;
    const playlistCodecs = codecsForPlaylist(this.main(), playlist);
    const codecs = {};
    const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (media.main.hasVideo) {
      codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
    }
    if (media.main.isMuxed) {
      codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;
    }
    if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
      codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
      media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
    }
    if (!codecs.audio && !codecs.video) {
      this.excludePlaylist({
        playlistToExclude: playlist,
        error: {
          message: "Could not determine codecs for playlist."
        },
        playlistExclusionDuration: Infinity
      });
      return;
    }
    const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
    const unsupportedCodecs = {};
    let unsupportedAudio;
    ["video", "audio"].forEach(function(type) {
      if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
        const supporter = media[type].isFmp4 ? "browser" : "muxer";
        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
        unsupportedCodecs[supporter].push(codecs[type]);
        if (type === "audio") {
          unsupportedAudio = supporter;
        }
      }
    });
    if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
      const audioGroup = playlist.attributes.AUDIO;
      this.main().playlists.forEach((variant) => {
        const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
        if (variantAudioGroup === audioGroup && variant !== playlist) {
          variant.excludeUntil = Infinity;
        }
      });
      this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): "${codecs.audio}"`);
    }
    if (Object.keys(unsupportedCodecs).length) {
      const message = Object.keys(unsupportedCodecs).reduce((acc, supporter) => {
        if (acc) {
          acc += ", ";
        }
        acc += `${supporter} does not support codec(s): "${unsupportedCodecs[supporter].join(",")}"`;
        return acc;
      }, "") + ".";
      this.excludePlaylist({
        playlistToExclude: playlist,
        error: {
          internal: true,
          message
        },
        playlistExclusionDuration: Infinity
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      const switchMessages = [];
      ["video", "audio"].forEach((type) => {
        const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || "")[0] || {}).type;
        const oldCodec = (parseCodecs(codecs[type] || "")[0] || {}).type;
        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
          switchMessages.push(`"${this.sourceUpdater_.codecs[type]}" -> "${codecs[type]}"`);
        }
      });
      if (switchMessages.length) {
        this.excludePlaylist({
          playlistToExclude: playlist,
          error: {
            message: `Codec switching not supported: ${switchMessages.join(", ")}.`,
            internal: true
          },
          playlistExclusionDuration: Infinity
        });
        return;
      }
    }
    return codecs;
  }
  /**
   * Create source buffers and exlude any incompatible renditions.
   *
   * @private
   */
  tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
      return;
    }
    if (!this.areMediaTypesKnown_()) {
      return;
    }
    const codecs = this.getCodecsOrExclude_();
    if (!codecs) {
      return;
    }
    this.sourceUpdater_.createSourceBuffers(codecs);
    const codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(codecString);
  }
  /**
   * Excludes playlists with codecs that are unsupported by the muxer and browser.
   */
  excludeUnsupportedVariants_() {
    const playlists = this.main().playlists;
    const ids = [];
    Object.keys(playlists).forEach((key) => {
      const variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1) {
        return;
      }
      ids.push(variant.id);
      const codecs = codecsForPlaylist(this.main, variant);
      const unsupported = [];
      if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
        unsupported.push(`audio codec ${codecs.audio}`);
      }
      if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
        unsupported.push(`video codec ${codecs.video}`);
      }
      if (codecs.text && codecs.text === "stpp.ttml.im1t") {
        unsupported.push(`text codec ${codecs.text}`);
      }
      if (unsupported.length) {
        variant.excludeUntil = Infinity;
        this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(", ")}`);
      }
    });
  }
  /**
   * Exclude playlists that are known to be codec or
   * stream-incompatible with the SourceBuffer configuration. For
   * instance, Media Source Extensions would cause the video element to
   * stall waiting for video data if you switched from a variant with
   * video and audio to an audio-only one.
   *
   * @param {Object} media a media playlist compatible with the current
   * set of SourceBuffers. Variants in the current main playlist that
   * do not appear to have compatible codec or stream configurations
   * will be excluded from the default playlist selection algorithm
   * indefinitely.
   * @private
   */
  excludeIncompatibleVariants_(codecString) {
    const ids = [];
    const playlists = this.main().playlists;
    const codecs = unwrapCodecList(parseCodecs(codecString));
    const codecCount_ = codecCount(codecs);
    const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
    const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
    Object.keys(playlists).forEach((key) => {
      const variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
        return;
      }
      ids.push(variant.id);
      const exclusionReasons = [];
      const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);
      const variantCodecCount = codecCount(variantCodecs);
      if (!variantCodecs.audio && !variantCodecs.video) {
        return;
      }
      if (variantCodecCount !== codecCount_) {
        exclusionReasons.push(`codec count "${variantCodecCount}" !== "${codecCount_}"`);
      }
      if (!this.sourceUpdater_.canChangeType()) {
        const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
        const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
          exclusionReasons.push(`video codec "${variantVideoDetails.type}" !== "${videoDetails.type}"`);
        }
        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
          exclusionReasons.push(`audio codec "${variantAudioDetails.type}" !== "${audioDetails.type}"`);
        }
      }
      if (exclusionReasons.length) {
        variant.excludeUntil = Infinity;
        this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(" && ")}`);
      }
    });
  }
  updateAdCues_(media) {
    let offset2 = 0;
    const seekable2 = this.seekable();
    if (seekable2.length) {
      offset2 = seekable2.start(0);
    }
    updateAdCues(media, this.cueTagsTrack_, offset2);
  }
  /**
   * Calculates the desired forward buffer length based on current time
   *
   * @return {number} Desired forward buffer length in seconds
   */
  goalBufferLength() {
    const currentTime = this.tech_.currentTime();
    const initial = Config.GOAL_BUFFER_LENGTH;
    const rate = Config.GOAL_BUFFER_LENGTH_RATE;
    const max2 = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(initial + currentTime * rate, max2);
  }
  /**
   * Calculates the desired buffer low water line based on current time
   *
   * @return {number} Desired buffer low water line in seconds
   */
  bufferLowWaterLine() {
    const currentTime = this.tech_.currentTime();
    const initial = Config.BUFFER_LOW_WATER_LINE;
    const rate = Config.BUFFER_LOW_WATER_LINE_RATE;
    const max2 = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
    const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max2);
  }
  bufferHighWaterLine() {
    return Config.BUFFER_HIGH_WATER_LINE;
  }
  addDateRangesToTextTrack_(dateRanges) {
    createMetadataTrackIfNotExists(this.inbandTextTracks_, "com.apple.streaming", this.tech_);
    addDateRangeMetadata({
      inbandTextTracks: this.inbandTextTracks_,
      dateRanges
    });
  }
  addMetadataToTextTrack(dispatchType, metadataArray, videoDuration) {
    const timestampOffset = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
    createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.tech_);
    addMetadata({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray,
      timestampOffset,
      videoDuration
    });
  }
  /**
   * Utility for getting the pathway or service location from an HLS or DASH playlist.
   *
   * @param {Object} playlist for getting pathway from.
   * @return the pathway attribute of a playlist
   */
  pathwayAttribute_(playlist) {
    return playlist.attributes["PATHWAY-ID"] || playlist.attributes.serviceLocation;
  }
  /**
   * Initialize available pathways and apply the tag properties.
   */
  initContentSteeringController_() {
    const main2 = this.main();
    if (!main2.contentSteering) {
      return;
    }
    for (const playlist of main2.playlists) {
      this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(playlist));
    }
    this.contentSteeringController_.assignTagProperties(main2.uri, main2.contentSteering);
    if (this.contentSteeringController_.queryBeforeStart) {
      this.contentSteeringController_.requestSteeringManifest(true);
      return;
    }
    this.tech_.one("canplay", () => {
      this.contentSteeringController_.requestSteeringManifest();
    });
  }
  /**
   * Reset the content steering controller and re-init.
   */
  resetContentSteeringController_() {
    this.contentSteeringController_.clearAvailablePathways();
    this.contentSteeringController_.dispose();
    this.initContentSteeringController_();
  }
  /**
   * Attaches the listeners for content steering.
   */
  attachContentSteeringListeners_() {
    this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this));
    const contentSteeringEvents = ["contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"];
    contentSteeringEvents.forEach((eventName) => {
      this.contentSteeringController_.on(eventName, (metadata) => {
        this.trigger(_extends$2({}, metadata));
      });
    });
    if (this.sourceType_ === "dash") {
      this.mainPlaylistLoader_.on("loadedplaylist", () => {
        const main2 = this.main();
        const didDashTagChange = this.contentSteeringController_.didDASHTagChange(main2.uri, main2.contentSteering);
        const didPathwaysChange = () => {
          const availablePathways = this.contentSteeringController_.getAvailablePathways();
          const newPathways = [];
          for (const playlist of main2.playlists) {
            const serviceLocation = playlist.attributes.serviceLocation;
            if (serviceLocation) {
              newPathways.push(serviceLocation);
              if (!availablePathways.has(serviceLocation)) {
                return true;
              }
            }
          }
          if (!newPathways.length && availablePathways.size) {
            return true;
          }
          return false;
        };
        if (didDashTagChange || didPathwaysChange()) {
          this.resetContentSteeringController_();
        }
      });
    }
  }
  /**
   * Simple exclude and change playlist logic for content steering.
   */
  excludeThenChangePathway_() {
    const currentPathway = this.contentSteeringController_.getPathway();
    if (!currentPathway) {
      return;
    }
    this.handlePathwayClones_();
    const main2 = this.main();
    const playlists = main2.playlists;
    const ids = /* @__PURE__ */ new Set();
    let didEnablePlaylists = false;
    Object.keys(playlists).forEach((key) => {
      const variant = playlists[key];
      const pathwayId = this.pathwayAttribute_(variant);
      const differentPathwayId = pathwayId && currentPathway !== pathwayId;
      const steeringExclusion = variant.excludeUntil === Infinity && variant.lastExcludeReason_ === "content-steering";
      if (steeringExclusion && !differentPathwayId) {
        delete variant.excludeUntil;
        delete variant.lastExcludeReason_;
        didEnablePlaylists = true;
      }
      const noExcludeUntil = !variant.excludeUntil && variant.excludeUntil !== Infinity;
      const shouldExclude = !ids.has(variant.id) && differentPathwayId && noExcludeUntil;
      if (!shouldExclude) {
        return;
      }
      ids.add(variant.id);
      variant.excludeUntil = Infinity;
      variant.lastExcludeReason_ = "content-steering";
      this.logger_(`excluding ${variant.id} for ${variant.lastExcludeReason_}`);
    });
    if (this.contentSteeringController_.manifestType_ === "DASH") {
      Object.keys(this.mediaTypes_).forEach((key) => {
        const type = this.mediaTypes_[key];
        if (type.activePlaylistLoader) {
          const currentPlaylist = type.activePlaylistLoader.media_;
          if (currentPlaylist && currentPlaylist.attributes.serviceLocation !== currentPathway) {
            didEnablePlaylists = true;
          }
        }
      });
    }
    if (didEnablePlaylists) {
      this.changeSegmentPathway_();
    }
  }
  /**
   * Add, update, or delete playlists and media groups for
   * the pathway clones for HLS Content Steering.
   *
   * See https://datatracker.ietf.org/doc/draft-pantos-hls-rfc8216bis/
   *
   * NOTE: Pathway cloning does not currently support the `PER_VARIANT_URIS` and
   * `PER_RENDITION_URIS` as we do not handle `STABLE-VARIANT-ID` or
   * `STABLE-RENDITION-ID` values.
   */
  handlePathwayClones_() {
    const main2 = this.main();
    const playlists = main2.playlists;
    const currentPathwayClones = this.contentSteeringController_.currentPathwayClones;
    const nextPathwayClones = this.contentSteeringController_.nextPathwayClones;
    const hasClones = currentPathwayClones && currentPathwayClones.size || nextPathwayClones && nextPathwayClones.size;
    if (!hasClones) {
      return;
    }
    for (const [id, clone] of currentPathwayClones.entries()) {
      const newClone = nextPathwayClones.get(id);
      if (!newClone) {
        this.mainPlaylistLoader_.updateOrDeleteClone(clone);
        this.contentSteeringController_.excludePathway(id);
      }
    }
    for (const [id, clone] of nextPathwayClones.entries()) {
      const oldClone = currentPathwayClones.get(id);
      if (!oldClone) {
        const playlistsToClone = playlists.filter((p) => {
          return p.attributes["PATHWAY-ID"] === clone["BASE-ID"];
        });
        playlistsToClone.forEach((p) => {
          this.mainPlaylistLoader_.addClonePathway(clone, p);
        });
        this.contentSteeringController_.addAvailablePathway(id);
        continue;
      }
      if (this.equalPathwayClones_(oldClone, clone)) {
        continue;
      }
      this.mainPlaylistLoader_.updateOrDeleteClone(clone, true);
      this.contentSteeringController_.addAvailablePathway(id);
    }
    this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...nextPathwayClones])));
  }
  /**
   * Determines whether two pathway clone objects are equivalent.
   *
   * @param {Object} a The first pathway clone object.
   * @param {Object} b The second pathway clone object.
   * @return {boolean} True if the pathway clone objects are equal, false otherwise.
   */
  equalPathwayClones_(a, b) {
    if (a["BASE-ID"] !== b["BASE-ID"] || a.ID !== b.ID || a["URI-REPLACEMENT"].HOST !== b["URI-REPLACEMENT"].HOST) {
      return false;
    }
    const aParams = a["URI-REPLACEMENT"].PARAMS;
    const bParams = b["URI-REPLACEMENT"].PARAMS;
    for (const p in aParams) {
      if (aParams[p] !== bParams[p]) {
        return false;
      }
    }
    for (const p in bParams) {
      if (aParams[p] !== bParams[p]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Changes the current playlists for audio, video and subtitles after a new pathway
   * is chosen from content steering.
   */
  changeSegmentPathway_() {
    const nextPlaylist = this.selectPlaylist();
    this.pauseLoading();
    if (this.contentSteeringController_.manifestType_ === "DASH") {
      this.switchMediaForDASHContentSteering_();
    }
    this.switchMedia_(nextPlaylist, "content-steering");
  }
  /**
   * Iterates through playlists and check their keyId set and compare with the
   * keyStatusMap, only enable playlists that have a usable key. If the playlist
   * has no keyId leave it enabled by default.
   */
  excludeNonUsablePlaylistsByKeyId_() {
    if (!this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main) {
      return;
    }
    let nonUsableKeyStatusCount = 0;
    const NON_USABLE = "non-usable";
    this.mainPlaylistLoader_.main.playlists.forEach((playlist) => {
      const keyIdSet = this.mainPlaylistLoader_.getKeyIdSet(playlist);
      if (!keyIdSet || !keyIdSet.size) {
        return;
      }
      keyIdSet.forEach((key) => {
        const USABLE = "usable";
        const hasUsableKeyStatus = this.keyStatusMap_.has(key) && this.keyStatusMap_.get(key) === USABLE;
        const nonUsableExclusion = playlist.lastExcludeReason_ === NON_USABLE && playlist.excludeUntil === Infinity;
        if (!hasUsableKeyStatus) {
          if (playlist.excludeUntil !== Infinity && playlist.lastExcludeReason_ !== NON_USABLE) {
            playlist.excludeUntil = Infinity;
            playlist.lastExcludeReason_ = NON_USABLE;
            this.logger_(`excluding playlist ${playlist.id} because the key ID ${key} doesn't exist in the keyStatusMap or is not ${USABLE}`);
          }
          nonUsableKeyStatusCount++;
        } else if (hasUsableKeyStatus && nonUsableExclusion) {
          delete playlist.excludeUntil;
          delete playlist.lastExcludeReason_;
          this.logger_(`enabling playlist ${playlist.id} because key ID ${key} is ${USABLE}`);
        }
      });
    });
    if (nonUsableKeyStatusCount >= this.mainPlaylistLoader_.main.playlists.length) {
      this.mainPlaylistLoader_.main.playlists.forEach((playlist) => {
        const isNonHD = playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height < 720;
        const excludedForNonUsableKey = playlist.excludeUntil === Infinity && playlist.lastExcludeReason_ === NON_USABLE;
        if (isNonHD && excludedForNonUsableKey) {
          delete playlist.excludeUntil;
          videojs$2.log.warn(`enabling non-HD playlist ${playlist.id} because all playlists were excluded due to ${NON_USABLE} key IDs`);
        }
      });
    }
  }
  /**
   * Adds a keystatus to the keystatus map, tries to convert to string if necessary.
   *
   * @param {any} keyId the keyId to add a status for
   * @param {string} status the status of the keyId
   */
  addKeyStatus_(keyId, status) {
    const isString = typeof keyId === "string";
    const keyIdHexString = isString ? keyId : bufferToHexString(keyId);
    const formattedKeyIdString = keyIdHexString.slice(0, 32).toLowerCase();
    this.logger_(`KeyStatus '${status}' with key ID ${formattedKeyIdString} added to the keyStatusMap`);
    this.keyStatusMap_.set(formattedKeyIdString, status);
  }
  /**
   * Utility function for adding key status to the keyStatusMap and filtering usable encrypted playlists.
   *
   * @param {any} keyId the keyId from the keystatuschange event
   * @param {string} status the key status string
   */
  updatePlaylistByKeyStatus(keyId, status) {
    this.addKeyStatus_(keyId, status);
    if (!this.waitingForFastQualityPlaylistReceived_) {
      this.excludeNonUsableThenChangePlaylist_();
    }
    this.mainPlaylistLoader_.off("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
    this.mainPlaylistLoader_.on("loadedplaylist", this.excludeNonUsableThenChangePlaylist_.bind(this));
  }
  excludeNonUsableThenChangePlaylist_() {
    this.excludeNonUsablePlaylistsByKeyId_();
    this.fastQualityChange_();
  }
}
const enableFunction = (loader, playlistID, changePlaylistFn) => (enable) => {
  const playlist = loader.main.playlists[playlistID];
  const incompatible = isIncompatible(playlist);
  const currentlyEnabled = isEnabled(playlist);
  if (typeof enable === "undefined") {
    return currentlyEnabled;
  }
  if (enable) {
    delete playlist.disabled;
  } else {
    playlist.disabled = true;
  }
  const metadata = {
    renditionInfo: {
      id: playlistID,
      bandwidth: playlist.attributes.BANDWIDTH,
      resolution: playlist.attributes.RESOLUTION,
      codecs: playlist.attributes.CODECS
    },
    cause: "fast-quality"
  };
  if (enable !== currentlyEnabled && !incompatible) {
    changePlaylistFn(playlist);
    if (enable) {
      loader.trigger({
        type: "renditionenabled",
        metadata
      });
    } else {
      loader.trigger({
        type: "renditiondisabled",
        metadata
      });
    }
  }
  return enable;
};
class Representation {
  constructor(vhsHandler, playlist, id) {
    const {
      playlistController_: pc
    } = vhsHandler;
    const qualityChangeFunction = pc.fastQualityChange_.bind(pc);
    if (playlist.attributes) {
      const resolution = playlist.attributes.RESOLUTION;
      this.width = resolution && resolution.width;
      this.height = resolution && resolution.height;
      this.bandwidth = playlist.attributes.BANDWIDTH;
      this.frameRate = playlist.attributes["FRAME-RATE"];
    }
    this.codecs = codecsForPlaylist(pc.main(), playlist);
    this.playlist = playlist;
    this.id = id;
    this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
  }
}
const renditionSelectionMixin = function(vhsHandler) {
  vhsHandler.representations = () => {
    const main2 = vhsHandler.playlistController_.main();
    const playlists = isAudioOnly(main2) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main2.playlists;
    if (!playlists) {
      return [];
    }
    return playlists.filter((media) => !isIncompatible(media)).map((e, i) => new Representation(vhsHandler, e, e.id));
  };
};
const timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
class PlaybackWatcher extends videojs$2.EventTarget {
  /**
   * Represents an PlaybackWatcher object.
   *
   * @class
   * @param {Object} options an object that includes the tech and settings
   */
  constructor(options) {
    super();
    this.playlistController_ = options.playlistController;
    this.tech_ = options.tech;
    this.seekable = options.seekable;
    this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
    this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
    this.media = options.media;
    this.playedRanges_ = [];
    this.consecutiveUpdates = 0;
    this.lastRecordedTime = null;
    this.checkCurrentTimeTimeout_ = null;
    this.logger_ = logger("PlaybackWatcher");
    this.logger_("initialize");
    const playHandler = () => this.monitorCurrentTime_();
    const canPlayHandler = () => this.monitorCurrentTime_();
    const waitingHandler = () => this.techWaiting_();
    const cancelTimerHandler = () => this.resetTimeUpdate_();
    const pc = this.playlistController_;
    const loaderTypes = ["main", "subtitle", "audio"];
    const loaderChecks = {};
    loaderTypes.forEach((type) => {
      loaderChecks[type] = {
        reset: () => this.resetSegmentDownloads_(type),
        updateend: () => this.checkSegmentDownloads_(type)
      };
      pc[`${type}SegmentLoader_`].on("appendsdone", loaderChecks[type].updateend);
      pc[`${type}SegmentLoader_`].on("playlistupdate", loaderChecks[type].reset);
      this.tech_.on(["seeked", "seeking"], loaderChecks[type].reset);
    });
    const setSeekingHandlers = (fn2) => {
      ["main", "audio"].forEach((type) => {
        pc[`${type}SegmentLoader_`][fn2]("appended", this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = () => {
      if (this.fixesBadSeeks_()) {
        this.consecutiveUpdates = 0;
        this.lastRecordedTime = this.tech_.currentTime();
        setSeekingHandlers("off");
      }
    };
    this.clearSeekingAppendCheck_ = () => setSeekingHandlers("off");
    this.watchForBadSeeking_ = () => {
      this.clearSeekingAppendCheck_();
      setSeekingHandlers("on");
    };
    this.tech_.on("seeked", this.clearSeekingAppendCheck_);
    this.tech_.on("seeking", this.watchForBadSeeking_);
    this.tech_.on("waiting", waitingHandler);
    this.tech_.on(timerCancelEvents, cancelTimerHandler);
    this.tech_.on("canplay", canPlayHandler);
    this.tech_.one("play", playHandler);
    this.dispose = () => {
      this.clearSeekingAppendCheck_();
      this.logger_("dispose");
      this.tech_.off("waiting", waitingHandler);
      this.tech_.off(timerCancelEvents, cancelTimerHandler);
      this.tech_.off("canplay", canPlayHandler);
      this.tech_.off("play", playHandler);
      this.tech_.off("seeking", this.watchForBadSeeking_);
      this.tech_.off("seeked", this.clearSeekingAppendCheck_);
      loaderTypes.forEach((type) => {
        pc[`${type}SegmentLoader_`].off("appendsdone", loaderChecks[type].updateend);
        pc[`${type}SegmentLoader_`].off("playlistupdate", loaderChecks[type].reset);
        this.tech_.off(["seeked", "seeking"], loaderChecks[type].reset);
      });
      if (this.checkCurrentTimeTimeout_) {
        window$1$1.clearTimeout(this.checkCurrentTimeTimeout_);
      }
      this.resetTimeUpdate_();
    };
  }
  /**
   * Periodically check current time to see if playback stopped
   *
   * @private
   */
  monitorCurrentTime_() {
    this.checkCurrentTime_();
    if (this.checkCurrentTimeTimeout_) {
      window$1$1.clearTimeout(this.checkCurrentTimeTimeout_);
    }
    this.checkCurrentTimeTimeout_ = window$1$1.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  }
  /**
   * Reset stalled download stats for a specific type of loader
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#playlistupdate
   * @listens Tech#seeking
   * @listens Tech#seeked
   */
  resetSegmentDownloads_(type) {
    const loader = this.playlistController_[`${type}SegmentLoader_`];
    if (this[`${type}StalledDownloads_`] > 0) {
      this.logger_(`resetting possible stalled download count for ${type} loader`);
    }
    this[`${type}StalledDownloads_`] = 0;
    this[`${type}Buffered_`] = loader.buffered_();
  }
  /**
   * Checks on every segment `appendsdone` to see
   * if segment appends are making progress. If they are not
   * and we are still downloading bytes. We exclude the playlist.
   *
   * @param {string} type
   *        The segment loader type to check.
   *
   * @listens SegmentLoader#appendsdone
   */
  checkSegmentDownloads_(type) {
    const pc = this.playlistController_;
    const loader = pc[`${type}SegmentLoader_`];
    const buffered = loader.buffered_();
    const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);
    this[`${type}Buffered_`] = buffered;
    if (isBufferedDifferent) {
      const metadata = {
        bufferedRanges: buffered
      };
      pc.trigger({
        type: "bufferedrangeschanged",
        metadata
      });
      this.resetSegmentDownloads_(type);
      return;
    }
    this[`${type}StalledDownloads_`]++;
    this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {
      playlistId: loader.playlist_ && loader.playlist_.id,
      buffered: timeRangesToArray(buffered)
    });
    if (this[`${type}StalledDownloads_`] < 10) {
      return;
    }
    this.logger_(`${type} loader stalled download exclusion`);
    this.resetSegmentDownloads_(type);
    this.tech_.trigger({
      type: "usage",
      name: `vhs-${type}-download-exclusion`
    });
    if (type === "subtitle") {
      return;
    }
    pc.excludePlaylist({
      error: {
        message: `Excessive ${type} segment downloading detected.`
      },
      playlistExclusionDuration: Infinity
    });
  }
  /**
   * The purpose of this function is to emulate the "waiting" event on
   * browsers that do not emit it when they are waiting for more
   * data to continue playback
   *
   * @private
   */
  checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking()) {
      return;
    }
    const currentTime = this.tech_.currentTime();
    const buffered = this.tech_.buffered();
    if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
      return this.techWaiting_();
    }
    if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
      this.waiting_();
    } else if (currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
    } else {
      this.playedRanges_.push(createTimeRanges([this.lastRecordedTime, currentTime]));
      const metadata = {
        playedRanges: this.playedRanges_
      };
      this.playlistController_.trigger({
        type: "playedrangeschanged",
        metadata
      });
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = currentTime;
    }
  }
  /**
   * Resets the 'timeupdate' mechanism designed to detect that we are stalled
   *
   * @private
   */
  resetTimeUpdate_() {
    this.consecutiveUpdates = 0;
  }
  /**
   * Fixes situations where there's a bad seek
   *
   * @return {boolean} whether an action was taken to fix the seek
   * @private
   */
  fixesBadSeeks_() {
    const seeking = this.tech_.seeking();
    if (!seeking) {
      return false;
    }
    const seekable2 = this.seekable();
    const currentTime = this.tech_.currentTime();
    const isAfterSeekableRange = this.afterSeekableWindow_(seekable2, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    let seekTo;
    if (isAfterSeekableRange) {
      const seekableEnd = seekable2.end(seekable2.length - 1);
      seekTo = seekableEnd;
    }
    if (this.beforeSeekableWindow_(seekable2, currentTime)) {
      const seekableStart = seekable2.start(0);
      seekTo = seekableStart + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (seekableStart === seekable2.end(0) ? 0 : SAFE_TIME_DELTA);
    }
    if (typeof seekTo !== "undefined") {
      this.logger_(`Trying to seek outside of seekable at time ${currentTime} with seekable range ${printableRange(seekable2)}. Seeking to ${seekTo}.`);
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    const sourceUpdater = this.playlistController_.sourceUpdater_;
    const buffered = this.tech_.buffered();
    const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
    const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
    const media = this.media();
    const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
    const bufferedToCheck = [audioBuffered, videoBuffered];
    for (let i = 0; i < bufferedToCheck.length; i++) {
      if (!bufferedToCheck[i]) {
        continue;
      }
      const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
      if (timeAhead < minAppendedDuration) {
        return false;
      }
    }
    const nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length === 0) {
      return false;
    }
    seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
    this.logger_(`Buffered region starts (${nextRange.start(0)})  just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);
    this.tech_.setCurrentTime(seekTo);
    return true;
  }
  /**
   * Handler for situations when we determine the player is waiting.
   *
   * @private
   */
  waiting_() {
    if (this.techWaiting_()) {
      return;
    }
    const currentTime = this.tech_.currentTime();
    const buffered = this.tech_.buffered();
    const currentRange = findRange(buffered, currentTime);
    if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
      this.resetTimeUpdate_();
      this.tech_.setCurrentTime(currentTime);
      this.logger_(`Stopped at ${currentTime} while inside a buffered region [${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume playback by seeking to the current time.`);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      return;
    }
  }
  /**
   * Handler for situations when the tech fires a `waiting` event
   *
   * @return {boolean}
   *         True if an action (or none) was needed to correct the waiting. False if no
   *         checks passed
   * @private
   */
  techWaiting_() {
    const seekable2 = this.seekable();
    const currentTime = this.tech_.currentTime();
    if (this.tech_.seeking()) {
      return true;
    }
    if (this.beforeSeekableWindow_(seekable2, currentTime)) {
      const livePoint = seekable2.end(seekable2.length - 1);
      this.logger_(`Fell out of live window at time ${currentTime}. Seeking to live point (seekable end) ${livePoint}`);
      this.resetTimeUpdate_();
      this.tech_.setCurrentTime(livePoint);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      });
      return true;
    }
    const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;
    const buffered = this.tech_.buffered();
    const videoUnderflow = this.videoUnderflow_({
      audioBuffered: sourceUpdater.audioBuffered(),
      videoBuffered: sourceUpdater.videoBuffered(),
      currentTime
    });
    if (videoUnderflow) {
      this.resetTimeUpdate_();
      this.tech_.setCurrentTime(currentTime);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      });
      return true;
    }
    const nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length > 0) {
      this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);
      this.resetTimeUpdate_();
      this.skipTheGap_(currentTime);
      return true;
    }
    return false;
  }
  afterSeekableWindow_(seekable2, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {
    if (!seekable2.length) {
      return false;
    }
    let allowedEnd = seekable2.end(seekable2.length - 1) + SAFE_TIME_DELTA;
    const isLive = !playlist.endList;
    const isLLHLS = typeof playlist.partTargetDuration === "number";
    if (isLive && (isLLHLS || allowSeeksWithinUnsafeLiveWindow)) {
      allowedEnd = seekable2.end(seekable2.length - 1) + playlist.targetDuration * 3;
    }
    if (currentTime > allowedEnd) {
      return true;
    }
    return false;
  }
  beforeSeekableWindow_(seekable2, currentTime) {
    if (seekable2.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    seekable2.start(0) > 0 && currentTime < seekable2.start(0) - this.liveRangeSafeTimeDelta) {
      return true;
    }
    return false;
  }
  videoUnderflow_({
    videoBuffered,
    audioBuffered,
    currentTime
  }) {
    if (!videoBuffered) {
      return;
    }
    let gap;
    if (videoBuffered.length && audioBuffered.length) {
      const lastVideoRange = findRange(videoBuffered, currentTime - 3);
      const videoRange = findRange(videoBuffered, currentTime);
      const audioRange = findRange(audioBuffered, currentTime);
      if (audioRange.length && !videoRange.length && lastVideoRange.length) {
        gap = {
          start: lastVideoRange.end(0),
          end: audioRange.end(0)
        };
      }
    } else {
      const nextRange = findNextRange(videoBuffered, currentTime);
      if (!nextRange.length) {
        gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
      }
    }
    if (gap) {
      this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. Seeking to current time ${currentTime}`);
      return true;
    }
    return false;
  }
  /**
   * Timer callback. If playback still has not proceeded, then we seek
   * to the start of the next buffered region.
   *
   * @private
   */
  skipTheGap_(scheduledCurrentTime) {
    const buffered = this.tech_.buffered();
    const currentTime = this.tech_.currentTime();
    const nextRange = findNextRange(buffered, currentTime);
    this.resetTimeUpdate_();
    if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
      return;
    }
    this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
    this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
    const metadata = {
      gapInfo: {
        from: currentTime,
        to: nextRange.start(0)
      }
    };
    this.playlistController_.trigger({
      type: "gapjumped",
      metadata
    });
    this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
  }
  gapFromVideoUnderflow_(buffered, currentTime) {
    const gaps = findGaps(buffered);
    for (let i = 0; i < gaps.length; i++) {
      const start2 = gaps.start(i);
      const end2 = gaps.end(i);
      if (currentTime - start2 < 4 && currentTime - start2 > 2) {
        return {
          start: start2,
          end: end2
        };
      }
    }
    return null;
  }
}
const defaultOptions = {
  errorInterval: 30,
  getSource(next) {
    const tech = this.tech({
      IWillNotUseThisInPlugins: true
    });
    const sourceObj = tech.currentSource_ || this.currentSource();
    return next(sourceObj);
  }
};
const initPlugin = function(player, options) {
  let lastCalled = 0;
  let seekTo = 0;
  const localOptions = merge(defaultOptions, options);
  player.ready(() => {
    player.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
  });
  const loadedMetadataHandler = function() {
    if (seekTo) {
      player.currentTime(seekTo);
    }
  };
  const setSource2 = function(sourceObj) {
    if (sourceObj === null || sourceObj === void 0) {
      return;
    }
    seekTo = player.duration() !== Infinity && player.currentTime() || 0;
    player.one("loadedmetadata", loadedMetadataHandler);
    player.src(sourceObj);
    player.trigger({
      type: "usage",
      name: "vhs-error-reload"
    });
    player.play();
  };
  const errorHandler = function() {
    if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
      player.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      return;
    }
    if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
      videojs$2.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    lastCalled = Date.now();
    return localOptions.getSource.call(player, setSource2);
  };
  const cleanupEvents = function() {
    player.off("loadedmetadata", loadedMetadataHandler);
    player.off("error", errorHandler);
    player.off("dispose", cleanupEvents);
  };
  const reinitPlugin = function(newOptions) {
    cleanupEvents();
    initPlugin(player, newOptions);
  };
  player.on("error", errorHandler);
  player.on("dispose", cleanupEvents);
  player.reloadSourceOnError = reinitPlugin;
};
const reloadSourceOnError = function(options) {
  initPlugin(this, options);
};
var version$4 = "3.13.2";
var version$3 = "7.0.3";
var version$2 = "1.3.0";
var version$1 = "7.1.0";
var version = "4.0.1";
const Vhs = {
  PlaylistLoader,
  Playlist,
  utils,
  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
  lastBandwidthSelector,
  movingAverageBandwidthSelector,
  comparePlaylistBandwidth,
  comparePlaylistResolution,
  xhr: xhrFactory()
};
Object.keys(Config).forEach((prop) => {
  Object.defineProperty(Vhs, prop, {
    get() {
      videojs$2.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
      return Config[prop];
    },
    set(value2) {
      videojs$2.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
      if (typeof value2 !== "number" || value2 < 0) {
        videojs$2.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);
        return;
      }
      Config[prop] = value2;
    }
  });
});
const LOCAL_STORAGE_KEY = "videojs-vhs";
const handleVhsMediaChange = function(qualityLevels2, playlistLoader) {
  const newPlaylist = playlistLoader.media();
  let selectedIndex = -1;
  for (let i = 0; i < qualityLevels2.length; i++) {
    if (qualityLevels2[i].id === newPlaylist.id) {
      selectedIndex = i;
      break;
    }
  }
  qualityLevels2.selectedIndex_ = selectedIndex;
  qualityLevels2.trigger({
    selectedIndex,
    type: "change"
  });
};
const handleVhsLoadedMetadata = function(qualityLevels2, vhs) {
  vhs.representations().forEach((rep) => {
    qualityLevels2.addQualityLevel(rep);
  });
  handleVhsMediaChange(qualityLevels2, vhs.playlists);
};
Vhs.canPlaySource = function() {
  return videojs$2.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {
  if (!keySystemOptions) {
    return keySystemOptions;
  }
  let codecs = {};
  if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
    codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
  }
  if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
    codecs.audio = audioPlaylist.attributes.CODECS;
  }
  const videoContentType = getMimeForCodec(codecs.video);
  const audioContentType = getMimeForCodec(codecs.audio);
  const keySystemContentTypes = {};
  for (const keySystem in keySystemOptions) {
    keySystemContentTypes[keySystem] = {};
    if (audioContentType) {
      keySystemContentTypes[keySystem].audioContentType = audioContentType;
    }
    if (videoContentType) {
      keySystemContentTypes[keySystem].videoContentType = videoContentType;
    }
    if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
      keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
    }
    if (typeof keySystemOptions[keySystem] === "string") {
      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
    }
  }
  return merge(keySystemOptions, keySystemContentTypes);
};
const getAllPsshKeySystemsOptions = (playlists, keySystems) => {
  return playlists.reduce((keySystemsArr, playlist) => {
    if (!playlist.contentProtection) {
      return keySystemsArr;
    }
    const keySystemsOptions = keySystems.reduce((keySystemsObj, keySystem) => {
      const keySystemOptions = playlist.contentProtection[keySystem];
      if (keySystemOptions && keySystemOptions.pssh) {
        keySystemsObj[keySystem] = {
          pssh: keySystemOptions.pssh
        };
      }
      return keySystemsObj;
    }, {});
    if (Object.keys(keySystemsOptions).length) {
      keySystemsArr.push(keySystemsOptions);
    }
    return keySystemsArr;
  }, []);
};
const waitForKeySessionCreation = ({
  player,
  sourceKeySystems,
  audioMedia,
  mainPlaylists
}) => {
  if (!player.eme.initializeMediaKeys) {
    return Promise.resolve();
  }
  const playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
  const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
  const initializationFinishedPromises = [];
  const keySessionCreatedPromises = [];
  keySystemsOptionsArr.forEach((keySystemsOptions) => {
    keySessionCreatedPromises.push(new Promise((resolve, reject) => {
      player.tech_.one("keysessioncreated", resolve);
    }));
    initializationFinishedPromises.push(new Promise((resolve, reject) => {
      player.eme.initializeMediaKeys({
        keySystems: keySystemsOptions
      }, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }));
  });
  return Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(initializationFinishedPromises),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(keySessionCreatedPromises)
  ]);
};
const setupEmeOptions = ({
  player,
  sourceKeySystems,
  media,
  audioMedia
}) => {
  const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
  if (!sourceOptions) {
    return false;
  }
  player.currentSource().keySystems = sourceOptions;
  if (sourceOptions && !player.eme) {
    videojs$2.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
    return false;
  }
  return true;
};
const getVhsLocalStorage = () => {
  if (!window$1$1.localStorage) {
    return null;
  }
  const storedObject = window$1$1.localStorage.getItem(LOCAL_STORAGE_KEY);
  if (!storedObject) {
    return null;
  }
  try {
    return JSON.parse(storedObject);
  } catch (e) {
    return null;
  }
};
const updateVhsLocalStorage = (options) => {
  if (!window$1$1.localStorage) {
    return false;
  }
  let objectToStore = getVhsLocalStorage();
  objectToStore = objectToStore ? merge(objectToStore, options) : options;
  try {
    window$1$1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
  } catch (e) {
    return false;
  }
  return objectToStore;
};
const expandDataUri = (dataUri) => {
  if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
    return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
  }
  return dataUri;
};
const addOnRequestHook = (xhr, callback) => {
  if (!xhr._requestCallbackSet) {
    xhr._requestCallbackSet = /* @__PURE__ */ new Set();
  }
  xhr._requestCallbackSet.add(callback);
};
const addOnResponseHook = (xhr, callback) => {
  if (!xhr._responseCallbackSet) {
    xhr._responseCallbackSet = /* @__PURE__ */ new Set();
  }
  xhr._responseCallbackSet.add(callback);
};
const removeOnRequestHook = (xhr, callback) => {
  if (!xhr._requestCallbackSet) {
    return;
  }
  xhr._requestCallbackSet.delete(callback);
  if (!xhr._requestCallbackSet.size) {
    delete xhr._requestCallbackSet;
  }
};
const removeOnResponseHook = (xhr, callback) => {
  if (!xhr._responseCallbackSet) {
    return;
  }
  xhr._responseCallbackSet.delete(callback);
  if (!xhr._responseCallbackSet.size) {
    delete xhr._responseCallbackSet;
  }
};
Vhs.supportsNativeHls = function() {
  if (!document$1$1 || !document$1$1.createElement) {
    return false;
  }
  const video = document$1$1.createElement("video");
  if (!videojs$2.getTech("Html5").isSupported()) {
    return false;
  }
  const canPlay = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return canPlay.some(function(canItPlay) {
    return /maybe|probably/i.test(video.canPlayType(canItPlay));
  });
}();
Vhs.supportsNativeDash = function() {
  if (!document$1$1 || !document$1$1.createElement || !videojs$2.getTech("Html5").isSupported()) {
    return false;
  }
  return /maybe|probably/i.test(document$1$1.createElement("video").canPlayType("application/dash+xml"));
}();
Vhs.supportsTypeNatively = (type) => {
  if (type === "hls") {
    return Vhs.supportsNativeHls;
  }
  if (type === "dash") {
    return Vhs.supportsNativeDash;
  }
  return false;
};
Vhs.isSupported = function() {
  return videojs$2.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.");
};
Vhs.xhr.onRequest = function(callback) {
  addOnRequestHook(Vhs.xhr, callback);
};
Vhs.xhr.onResponse = function(callback) {
  addOnResponseHook(Vhs.xhr, callback);
};
Vhs.xhr.offRequest = function(callback) {
  removeOnRequestHook(Vhs.xhr, callback);
};
Vhs.xhr.offResponse = function(callback) {
  removeOnResponseHook(Vhs.xhr, callback);
};
const Component = videojs$2.getComponent("Component");
class VhsHandler extends Component {
  constructor(source, tech, options) {
    super(tech, options.vhs);
    if (typeof options.initialBandwidth === "number") {
      this.options_.bandwidth = options.initialBandwidth;
    }
    this.logger_ = logger("VhsHandler");
    if (tech.options_ && tech.options_.playerId) {
      const _player = videojs$2.getPlayer(tech.options_.playerId);
      this.player_ = _player;
    }
    this.tech_ = tech;
    this.source_ = source;
    this.stats = {};
    this.ignoreNextSeekingEvent_ = false;
    this.setOptions_();
    if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
      tech.overrideNativeAudioTracks(true);
      tech.overrideNativeVideoTracks(true);
    } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
      throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
    }
    this.on(document$1$1, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], (event2) => {
      const fullscreenElement = document$1$1.fullscreenElement || document$1$1.webkitFullscreenElement || document$1$1.mozFullScreenElement || document$1$1.msFullscreenElement;
      if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) {
        this.playlistController_.fastQualityChange_();
      } else {
        this.playlistController_.checkABR_();
      }
    });
    this.on(this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = false;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    });
    this.on(this.tech_, "error", function() {
      if (this.tech_.error() && this.playlistController_) {
        this.playlistController_.pauseLoading();
      }
    });
    this.on(this.tech_, "play", this.play);
  }
  /**
   * Set VHS options based on options from configuration, as well as partial
   * options to be passed at a later time.
   *
   * @param {Object} options A partial chunk of config options
   */
  setOptions_(options = {}) {
    this.options_ = merge(this.options_, options);
    this.options_.withCredentials = this.options_.withCredentials || false;
    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
    this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || false;
    this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
    this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
    this.options_.customTagParsers = this.options_.customTagParsers || [];
    this.options_.customTagMappers = this.options_.customTagMappers || [];
    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
    this.options_.llhls = this.options_.llhls === false ? false : true;
    this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;
    if (typeof this.options_.playlistExclusionDuration !== "number") {
      this.options_.playlistExclusionDuration = 60;
    }
    if (typeof this.options_.bandwidth !== "number") {
      if (this.options_.useBandwidthFromLocalStorage) {
        const storedObject = getVhsLocalStorage();
        if (storedObject && storedObject.bandwidth) {
          this.options_.bandwidth = storedObject.bandwidth;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-bandwidth-from-local-storage"
          });
        }
        if (storedObject && storedObject.throughput) {
          this.options_.throughput = storedObject.throughput;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-throughput-from-local-storage"
          });
        }
      }
    }
    if (typeof this.options_.bandwidth !== "number") {
      this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
    }
    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
    ["withCredentials", "useDevicePixelRatio", "customPixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach((option) => {
      if (typeof this.source_[option] !== "undefined") {
        this.options_[option] = this.source_[option];
      }
    });
    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
    this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
    const customPixelRatio = this.options_.customPixelRatio;
    if (typeof customPixelRatio === "number" && customPixelRatio >= 0) {
      this.customPixelRatio = customPixelRatio;
    }
  }
  // alias for public method to set options
  setOptions(options = {}) {
    this.setOptions_(options);
  }
  /**
   * called when player.src gets called, handle a new source
   *
   * @param {Object} src the source object to handle
   */
  src(src, type) {
    if (!src) {
      return;
    }
    this.setOptions_();
    this.options_.src = expandDataUri(this.source_.src);
    this.options_.tech = this.tech_;
    this.options_.externVhs = Vhs;
    this.options_.sourceType = simpleTypeFromSourceType(type);
    this.options_.seekTo = (time) => {
      this.tech_.setCurrentTime(time);
    };
    this.options_.player_ = this.player_;
    this.playlistController_ = new PlaylistController(this.options_);
    const playbackWatcherOptions = merge({
      liveRangeSafeTimeDelta: SAFE_TIME_DELTA
    }, this.options_, {
      seekable: () => this.seekable(),
      media: () => this.playlistController_.media(),
      playlistController: this.playlistController_
    });
    this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
    this.attachStreamingEventListeners_();
    this.playlistController_.on("error", () => {
      const player = videojs$2.players[this.tech_.options_.playerId];
      let error = this.playlistController_.error;
      if (typeof error === "object" && !error.code) {
        error.code = 3;
      } else if (typeof error === "string") {
        error = {
          message: error,
          code: 3
        };
      }
      player.error(error);
    });
    const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
    this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
    this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
    this.playlists = this.playlistController_.mainPlaylistLoader_;
    this.mediaSource = this.playlistController_.mediaSource;
    Object.defineProperties(this, {
      selectPlaylist: {
        get() {
          return this.playlistController_.selectPlaylist;
        },
        set(selectPlaylist) {
          this.playlistController_.selectPlaylist = selectPlaylist.bind(this);
        }
      },
      throughput: {
        get() {
          return this.playlistController_.mainSegmentLoader_.throughput.rate;
        },
        set(throughput) {
          this.playlistController_.mainSegmentLoader_.throughput.rate = throughput;
          this.playlistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get() {
          let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;
          const networkInformation = window$1$1.navigator.connection || window$1$1.navigator.mozConnection || window$1$1.navigator.webkitConnection;
          const tenMbpsAsBitsPerSecond = 1e7;
          if (this.options_.useNetworkInformationApi && networkInformation) {
            const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
              playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
            } else {
              playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
            }
          }
          return playerBandwidthEst;
        },
        set(bandwidth) {
          this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth;
          this.playlistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get() {
          const invBandwidth = 1 / (this.bandwidth || 1);
          let invThroughput;
          if (this.throughput > 0) {
            invThroughput = 1 / this.throughput;
          } else {
            invThroughput = 0;
          }
          const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
          return systemBitrate;
        },
        set() {
          videojs$2.log.error('The "systemBandwidth" property is read-only');
        }
      }
    });
    if (this.options_.bandwidth) {
      this.bandwidth = this.options_.bandwidth;
    }
    if (this.options_.throughput) {
      this.throughput = this.options_.throughput;
    }
    Object.defineProperties(this.stats, {
      bandwidth: {
        get: () => this.bandwidth || 0,
        enumerable: true
      },
      mediaRequests: {
        get: () => this.playlistController_.mediaRequests_() || 0,
        enumerable: true
      },
      mediaRequestsAborted: {
        get: () => this.playlistController_.mediaRequestsAborted_() || 0,
        enumerable: true
      },
      mediaRequestsTimedout: {
        get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
        enumerable: true
      },
      mediaRequestsErrored: {
        get: () => this.playlistController_.mediaRequestsErrored_() || 0,
        enumerable: true
      },
      mediaTransferDuration: {
        get: () => this.playlistController_.mediaTransferDuration_() || 0,
        enumerable: true
      },
      mediaBytesTransferred: {
        get: () => this.playlistController_.mediaBytesTransferred_() || 0,
        enumerable: true
      },
      mediaSecondsLoaded: {
        get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
        enumerable: true
      },
      mediaAppends: {
        get: () => this.playlistController_.mediaAppends_() || 0,
        enumerable: true
      },
      mainAppendsToLoadedData: {
        get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
        enumerable: true
      },
      audioAppendsToLoadedData: {
        get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
        enumerable: true
      },
      appendsToLoadedData: {
        get: () => this.playlistController_.appendsToLoadedData_() || 0,
        enumerable: true
      },
      timeToLoadedData: {
        get: () => this.playlistController_.timeToLoadedData_() || 0,
        enumerable: true
      },
      buffered: {
        get: () => timeRangesToArray(this.tech_.buffered()),
        enumerable: true
      },
      currentTime: {
        get: () => this.tech_.currentTime(),
        enumerable: true
      },
      currentSource: {
        get: () => this.tech_.currentSource_,
        enumerable: true
      },
      currentTech: {
        get: () => this.tech_.name_,
        enumerable: true
      },
      duration: {
        get: () => this.tech_.duration(),
        enumerable: true
      },
      main: {
        get: () => this.playlists.main,
        enumerable: true
      },
      playerDimensions: {
        get: () => this.tech_.currentDimensions(),
        enumerable: true
      },
      seekable: {
        get: () => timeRangesToArray(this.tech_.seekable()),
        enumerable: true
      },
      timestamp: {
        get: () => Date.now(),
        enumerable: true
      },
      videoPlaybackQuality: {
        get: () => this.tech_.getVideoPlaybackQuality(),
        enumerable: true
      }
    });
    this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_));
    this.tech_.on("bandwidthupdate", () => {
      if (this.options_.useBandwidthFromLocalStorage) {
        updateVhsLocalStorage({
          bandwidth: this.bandwidth,
          throughput: Math.round(this.throughput)
        });
      }
    });
    this.playlistController_.on("selectedinitialmedia", () => {
      renditionSelectionMixin(this);
    });
    this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => {
      this.setupEme_();
    });
    this.on(this.playlistController_, "progress", function() {
      this.tech_.trigger("progress");
    });
    this.on(this.playlistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = true;
    });
    this.setupQualityLevels_();
    if (!this.tech_.el()) {
      return;
    }
    this.mediaSourceUrl_ = window$1$1.URL.createObjectURL(this.playlistController_.mediaSource);
    this.tech_.src(this.mediaSourceUrl_);
  }
  createKeySessions_() {
    const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation");
    waitForKeySessionCreation({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
      mainPlaylists: this.playlists.main.playlists
    }).then(() => {
      this.logger_("created EME key session");
      this.playlistController_.sourceUpdater_.initializedEme();
    }).catch((err) => {
      this.logger_("error while creating EME key session", err);
      this.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  }
  handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions");
    this.createKeySessions_();
  }
  /**
   * If necessary and EME is available, sets up EME options and waits for key session
   * creation.
   *
   * This function also updates the source updater so taht it can be used, as for some
   * browsers, EME must be configured before content is appended (if appending unencrypted
   * content before encrypted content).
   */
  setupEme_() {
    const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    const didSetupEmeOptions = setupEmeOptions({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
    });
    this.player_.tech_.on("keystatuschange", (e) => {
      this.playlistController_.updatePlaylistByKeyStatus(e.keyId, e.status);
    });
    this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
    this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
    if (!didSetupEmeOptions) {
      this.playlistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  }
  /**
   * Initializes the quality levels and sets listeners to update them.
   *
   * @method setupQualityLevels_
   * @private
   */
  setupQualityLevels_() {
    const player = videojs$2.players[this.tech_.options_.playerId];
    if (!player || !player.qualityLevels || this.qualityLevels_) {
      return;
    }
    this.qualityLevels_ = player.qualityLevels();
    this.playlistController_.on("selectedinitialmedia", () => {
      handleVhsLoadedMetadata(this.qualityLevels_, this);
    });
    this.playlists.on("mediachange", () => {
      handleVhsMediaChange(this.qualityLevels_, this.playlists);
    });
  }
  /**
   * return the version
   */
  static version() {
    return {
      "@videojs/http-streaming": version$4,
      "mux.js": version$3,
      "mpd-parser": version$2,
      "m3u8-parser": version$1,
      "aes-decrypter": version
    };
  }
  /**
   * return the version
   */
  version() {
    return this.constructor.version();
  }
  canChangeType() {
    return SourceUpdater.canChangeType();
  }
  /**
   * Begin playing the video.
   */
  play() {
    this.playlistController_.play();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  setCurrentTime(currentTime) {
    this.playlistController_.setCurrentTime(currentTime);
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  duration() {
    return this.playlistController_.duration();
  }
  /**
   * a wrapper around the function in PlaylistController
   */
  seekable() {
    return this.playlistController_.seekable();
  }
  /**
   * Abort all outstanding work and cleanup.
   */
  dispose() {
    if (this.playbackWatcher_) {
      this.playbackWatcher_.dispose();
    }
    if (this.playlistController_) {
      this.playlistController_.dispose();
    }
    if (this.qualityLevels_) {
      this.qualityLevels_.dispose();
    }
    if (this.tech_ && this.tech_.vhs) {
      delete this.tech_.vhs;
    }
    if (this.mediaSourceUrl_ && window$1$1.URL.revokeObjectURL) {
      window$1$1.URL.revokeObjectURL(this.mediaSourceUrl_);
      this.mediaSourceUrl_ = null;
    }
    if (this.tech_) {
      this.tech_.off("waitingforkey", this.handleWaitingForKey_);
    }
    super.dispose();
  }
  convertToProgramTime(time, callback) {
    return getProgramTime({
      playlist: this.playlistController_.media(),
      time,
      callback
    });
  }
  // the player must be playing before calling this
  seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {
    return seekToProgramTime({
      programTime,
      playlist: this.playlistController_.media(),
      retryCount,
      pauseAfterSeek,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback
    });
  }
  /**
   * Adds the onRequest, onResponse, offRequest and offResponse functions
   * to the VhsHandler xhr Object.
   */
  setupXhrHooks_() {
    this.xhr.onRequest = (callback) => {
      addOnRequestHook(this.xhr, callback);
    };
    this.xhr.onResponse = (callback) => {
      addOnResponseHook(this.xhr, callback);
    };
    this.xhr.offRequest = (callback) => {
      removeOnRequestHook(this.xhr, callback);
    };
    this.xhr.offResponse = (callback) => {
      removeOnResponseHook(this.xhr, callback);
    };
    this.player_.trigger("xhr-hooks-ready");
  }
  attachStreamingEventListeners_() {
    const playlistControllerEvents = ["seekablerangeschanged", "bufferedrangeschanged", "contentsteeringloadstart", "contentsteeringloadcomplete", "contentsteeringparsed"];
    const playbackWatcher = ["gapjumped", "playedrangeschanged"];
    playlistControllerEvents.forEach((eventName) => {
      this.playlistController_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
    });
    playbackWatcher.forEach((eventName) => {
      this.playbackWatcher_.on(eventName, (metadata) => {
        this.player_.trigger(_extends$2({}, metadata));
      });
    });
  }
}
const VhsSourceHandler = {
  name: "videojs-http-streaming",
  VERSION: version$4,
  canHandleSource(srcObj, options = {}) {
    const localOptions = merge(videojs$2.options, options);
    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
  },
  handleSource(source, tech, options = {}) {
    const localOptions = merge(videojs$2.options, options);
    tech.vhs = new VhsHandler(source, tech, localOptions);
    tech.vhs.xhr = xhrFactory();
    tech.vhs.setupXhrHooks_();
    tech.vhs.src(source.src, source.type);
    return tech.vhs;
  },
  canPlayType(type, options) {
    const simpleType = simpleTypeFromSourceType(type);
    if (!simpleType) {
      return "";
    }
    const overrideNative = VhsSourceHandler.getOverrideNative(options);
    const supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);
    const canUseMsePlayback = !supportsTypeNatively || overrideNative;
    return canUseMsePlayback ? "maybe" : "";
  },
  getOverrideNative(options = {}) {
    const {
      vhs = {}
    } = options;
    const defaultOverrideNative = !(videojs$2.browser.IS_ANY_SAFARI || videojs$2.browser.IS_IOS);
    const {
      overrideNative = defaultOverrideNative
    } = vhs;
    return overrideNative;
  }
};
const supportsNativeMediaSources = () => {
  return browserSupportsCodec("avc1.4d400d,mp4a.40.2");
};
if (supportsNativeMediaSources()) {
  videojs$2.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
}
videojs$2.VhsHandler = VhsHandler;
videojs$2.VhsSourceHandler = VhsSourceHandler;
videojs$2.Vhs = Vhs;
if (!videojs$2.use) {
  videojs$2.registerComponent("Vhs", Vhs);
}
videojs$2.options.vhs = videojs$2.options.vhs || {};
if (!videojs$2.getPlugin || !videojs$2.getPlugin("reloadSourceOnError")) {
  videojs$2.registerPlugin("reloadSourceOnError", reloadSourceOnError);
}
function usePlayer(emit, props) {
  const playerState = vue.reactive({
    playing: false,
    volume: 1,
    videoMuted: props.muted,
    time: props.startAt,
    duration: 0,
    percentagePlayed: 0,
    playBackRate: props.defaultPlayBackRate
  });
  const player = vue.ref(null);
  const getSource = () => {
    const src = props.streamUrl;
    const type = "application/x-mpegURL";
    return { src, type };
  };
  const events2 = [
    "play",
    "pause",
    "ended",
    "loadeddata",
    "waiting",
    "playing",
    "timeupdate",
    "canplay",
    "canplaythrough"
  ];
  const initializePlayer = (playerRef) => {
    if (playerRef) {
      try {
        const source = getSource();
        player.value = videojs$2(playerRef.value, {
          autoplay: props.autoPlay,
          controls: false,
          html5: {
            nativeTextTracks: false
          },
          preload: true,
          poster: props.thumbnailUrl,
          sources: [source],
          crossorigin: "anonymous"
        });
        bindEvents(events2, emit);
      } catch (err) {
        if (err)
          emit("videoerror", true);
        console.error("Error in initializing player ", err);
        return;
      }
    }
  };
  const play = () => {
    player.value.play();
    playerState.playing = true;
  };
  const pause = () => {
    player.value.pause();
    playerState.playing = false;
  };
  const togglePlay = () => {
    if (playerState.playing) {
      pause();
    } else {
      play();
    }
  };
  const setMuted = (state) => {
    player.value.muted = state;
    playerState.videoMuted = state;
  };
  const toggleMute = () => {
    if (playerState.videoMuted) {
      setMuted(false);
    } else {
      setMuted(true);
    }
  };
  const setVolume = (percentAsDecimal) => {
    if (player.value) {
      player.value.volume(percentAsDecimal);
      playerState.volume = percentAsDecimal;
    }
  };
  const seekTo = (time) => {
    if (player.value) {
      let newTime = parseInt(time);
      if (isNaN(newTime) && !isFinite(newTime))
        return;
      if (newTime < 0) {
        newTime = 0;
      }
      if (newTime > playerState.duration) {
        newTime = playerState.duration;
        pause();
      }
      player.value.currentTime(time);
    }
  };
  const seekToPercentage = (percentage) => {
    percentage / 100 * playerState.duration;
  };
  const setPlayBackRate = (value2) => {
    playerState.playBackRate = value2;
    player.value.playbackRate(value2);
  };
  const convertTimeToDuration = (seconds) => {
    return [Math.floor(seconds / 60 % 60), Math.floor(seconds % 60)].map((num) => num.toString().padStart(2, "0")).join(":");
  };
  const togglePictureInPicture = () => {
    if (document.pictureInPictureElement) {
      document.exitPictureInPicture();
    } else if (document.pictureInPictureEnabled) {
      player.value.requestPictureInPicture();
    }
  };
  const bindEvents = (events3, emit2) => {
    if (player.value) {
      events3.forEach((customEvent) => {
        (function() {
          player.value.on(customEvent, (event2) => {
            if (props.debug)
              console.log("Player event ", customEvent, event2);
            switch (customEvent) {
              case "loadeddata":
                playerState.duration = player.value.duration();
                seekTo(props.startAt);
                break;
              case "canplay":
                playerState.duration = player.value.duration();
                break;
              case "timeupdate":
                const _time = player.value.currentTime();
                playerState.percentagePlayed = _time / player.value.duration() * 100;
                playerState.time = _time;
                break;
              case "play":
                playerState.playing = true;
                break;
              case "ended":
                togglePlay();
                break;
            }
            emit2(customEvent, { event: event2 });
          });
        })();
      });
    }
  };
  return {
    ...vue.toRefs(playerState),
    events: events2,
    play,
    pause,
    togglePlay,
    toggleMute,
    setVolume,
    seekTo,
    seekToPercentage,
    setPlayBackRate,
    convertTimeToDuration,
    togglePictureInPicture,
    bindEvents,
    initializePlayer
  };
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _withScopeId$c = (n) => (vue.pushScopeId("data-v-e665a38c"), n = n(), vue.popScopeId(), n);
const _hoisted_1$l$1 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M10.1751 2.97135C7.85552 1.34603 4.66663 3.00538 4.66663 5.83772V22.1626C4.66663 24.995 7.85555 26.6543 10.1751 25.029L21.8513 16.8473C23.8267 15.4631 23.8267 12.537 21.8513 11.1528L10.1751 2.97135Z",
  fill: "white"
}, null, -1));
const _hoisted_2$g$1 = [
  _hoisted_1$l$1
];
const _sfc_main$p$1 = {
  __name: "play",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "28",
        height: "28",
        viewBox: "0 0 28 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_2$g$1, 2);
    };
  }
};
const PlayIcon = /* @__PURE__ */ _export_sfc(_sfc_main$p$1, [["__scopeId", "data-v-e665a38c"]]);
const _withScopeId$b = (n) => (vue.pushScopeId("data-v-b069220b"), n = n(), vue.popScopeId(), n);
const _hoisted_1$k$1 = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M3.21799 4.09202C3 4.51984 3 5.0799 3 6.2V17.8C3 18.9201 3 19.4802 3.21799 19.908C3.40973 20.2843 3.71569 20.5903 4.09202 20.782C4.51984 21 5.0799 21 6.2 21H6.8C7.9201 21 8.48016 21 8.90798 20.782C9.28431 20.5903 9.59027 20.2843 9.78201 19.908C10 19.4802 10 18.9201 10 17.8V6.2C10 5.0799 10 4.51984 9.78201 4.09202C9.59027 3.71569 9.28431 3.40973 8.90798 3.21799C8.48016 3 7.9201 3 6.8 3H6.2C5.0799 3 4.51984 3 4.09202 3.21799C3.71569 3.40973 3.40973 3.71569 3.21799 4.09202Z",
  fill: "white"
}, null, -1));
const _hoisted_2$f$1 = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M14.218 4.09202C14 4.51984 14 5.0799 14 6.2V17.8C14 18.9201 14 19.4802 14.218 19.908C14.4097 20.2843 14.7157 20.5903 15.092 20.782C15.5198 21 16.0799 21 17.2 21H17.8C18.9201 21 19.4802 21 19.908 20.782C20.2843 20.5903 20.5903 20.2843 20.782 19.908C21 19.4802 21 18.9201 21 17.8V6.2C21 5.0799 21 4.51984 20.782 4.09202C20.5903 3.71569 20.2843 3.40973 19.908 3.21799C19.4802 3 18.9201 3 17.8 3H17.2C16.0799 3 15.5198 3 15.092 3.21799C14.7157 3.40973 14.4097 3.71569 14.218 4.09202Z",
  fill: "white"
}, null, -1));
const _hoisted_3$b$1 = [
  _hoisted_1$k$1,
  _hoisted_2$f$1
];
const _sfc_main$o$1 = {
  __name: "pause",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_3$b$1, 2);
    };
  }
};
const PauseButton = /* @__PURE__ */ _export_sfc(_sfc_main$o$1, [["__scopeId", "data-v-b069220b"]]);
const useVideoDBPlayer = () => vue.inject("videodb-player");
const _sfc_main$n$1 = {
  __name: "TransparentButton",
  props: {
    buttonState: {
      type: String,
      default: "default"
    },
    defaultStateCss: {
      type: String,
      default: "vdb-p-bg-black-45 vdb-p-border vdb-p-border-yellow vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200"
    },
    activeStateCss: {
      type: String,
      default: "chapter-button-active-lg vdb-p-border vdb-p-border-yellow pale-yellow"
    },
    disabledStateCss: {
      type: String,
      default: "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-border vdb-p-border-yellow vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none"
    }
  },
  emits: ["clickAction"],
  setup(__props) {
    const props = __props;
    const customCss = vue.computed(() => {
      switch (props.buttonState) {
        case "active":
          return props.activeStateCss;
        case "disabled":
          return props.disabledStateCss;
        case "hidden":
          return "vdb-p-hidden";
        default:
          return props.defaultStateCss;
      }
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("button", {
        class: vue.normalizeClass(`vdb-p-flex vdb-p-items-center vdb-p-justify-center vdb-p-rounded-8 vdb-p-font-semibold vdb-p-text-white focus:vdb-p-outline-none ${customCss.value} `),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("clickAction"))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    };
  }
};
const TransparentButton = /* @__PURE__ */ _export_sfc(_sfc_main$n$1, [["__scopeId", "data-v-783478cd"]]);
const _sfc_main$m$1 = {
  __name: "BigCenterButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    isPlaying: {
      type: Boolean,
      default: false
    },
    buttonState: {
      type: String,
      default: "default"
    },
    showPauseButton: {
      type: Boolean,
      default: false
    },
    shiftUp: {
      type: Boolean,
      default: false
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const props = __props;
    const { playing, togglePlay, showElements } = useVideoDBPlayer();
    const buttonStyle = vue.computed(() => {
      return `transform: translate(-50%, ${props.shiftUp ? "-350%" : "-50%"})`;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(TransparentButton, {
        class: vue.normalizeClass([
          "vdb-p-h-72 vdb-p-w-72 vdb-p-rounded-full",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ]),
        style: vue.normalizeStyle(buttonStyle.value),
        "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
        "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
        "button-state": __props.isActive ? "default" : "hidden",
        onClick: vue.unref(togglePlay)
      }, {
        default: vue.withCtx(() => [
          vue.unref(playing) ? (vue.openBlock(), vue.createBlock(PauseButton, {
            key: 0,
            class: "vdb-p-h-[38.89%] vdb-p-w-[38.89%]"
          })) : (vue.openBlock(), vue.createBlock(PlayIcon, {
            key: 1,
            class: "vdb-p-h-[38.89%] vdb-p-w-[38.89%]"
          }))
        ]),
        _: 1
      }, 8, ["class", "style", "button-state", "onClick"]);
    };
  }
};
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now$1 = function() {
  return root.Date.now();
};
function debounce$2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$3(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject$3(value2) {
  var type = typeof value2;
  return !!value2 && (type == "object" || type == "function");
}
function isObjectLike(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
}
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject$3(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$3(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = value2.replace(reTrim, "");
  var isBinary2 = reIsBinary.test(value2);
  return isBinary2 || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var lodash_debounce = debounce$2;
const debounce$3 = /* @__PURE__ */ getDefaultExportFromCjs(lodash_debounce);
const _hoisted_1$j$1 = { class: "vdb-p-w-full" };
const _hoisted_2$e$1 = { class: "vdb-p-relative vdb-p-w-full" };
const _hoisted_3$a$1 = {
  class: "vdb-p-relative vdb-p-mb-4 vdb-p-w-full sm:vdb-p-mb-4",
  style: { "padding-bottom": "56.25%" }
};
const _hoisted_4$7$1 = {
  key: 0,
  class: "chapter-title-cont vdb-p-relative vdb-p-flex vdb-p-items-center vdb-p-justify-center vdb-p-transition-all"
};
const _hoisted_5$6$1 = { class: "three-line-ellipses title-blur vdb-p-h-auto vdb-p-max-h-full vdb-p-w-full vdb-p-rounded-8 vdb-p-p-8 vdb-p-text-center vdb-p-font-primary vdb-p-text-lg vdb-p-capitalize vdb-p-text-white" };
const _hoisted_6$4$1 = { class: "text-shadow vdb-p-w-full vdb-p-whitespace-nowrap vdb-p-text-center vdb-p-text-xs vdb-p-font-medium vdb-p-text-white" };
const _hoisted_7$4$1 = { class: "main-timeline vdb-p-absolute vdb-p-left-0 vdb-p-top-2 vdb-p-w-full" };
const _hoisted_8$3$1 = {
  key: 1,
  class: "chaptersCont vdb-p-flex vdb-p-items-center vdb-p-gap-2"
};
const _hoisted_9$2$1 = { class: "vdb-p-text-white" };
const _hoisted_10$2$1 = { class: "vdb-p-text-kilvish-500" };
const _hoisted_11$1$1 = { class: "progress-bar vdb-p-mb-12 vdb-p-h-4 vdb-p-w-full vdb-p-bg-black-16 vdb-p-opacity-0" };
const _sfc_main$l$1 = {
  __name: "ProgressBar",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    autoHide: {
      type: Boolean,
      default: true
    },
    streamUrl: {
      type: String,
      default: ""
    },
    chaptersList: {
      type: Array,
      default: () => []
    },
    persistentChapter: {
      type: Boolean,
      default: false
    },
    manualSlide: {
      type: Number,
      default: null
    },
    activeChapterProp: {
      type: String,
      default: null
    },
    showChapters: {
      type: Boolean,
      default: false
    },
    previewPlayer: {
      type: String,
      default: "video"
    },
    isChapterExpanded: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "setActiveChapter",
    "hideChapterSummary",
    "setPreviewVisibility"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { playing, time, duration: duration2, seekTo, showElements } = useVideoDBPlayer();
    const feedbackPlayer = vue.ref(null);
    const moveToRatio = vue.ref(0);
    const videoDrag = vue.ref(false);
    const seekGoToPoint = vue.reactive({
      ratio: 0,
      timePosition: 0
    });
    const isTimestampVisible = vue.ref(false);
    const showSummaryInfo = vue.ref(true);
    const videoPreviewData = vue.ref(null);
    vue.ref(null);
    const progressBar = vue.ref(null);
    const videoPreview = vue.ref(null);
    const progressBarInteract = vue.ref(null);
    const head = vue.ref(null);
    const videoFeedbackPlayer = vue.ref(null);
    const videoDateVal = vue.computed(() => {
      if (!duration2.value || !moveToRatio.value)
        return 0;
      return parseFloat(moveToRatio.value * duration2.value) * 1e3;
    });
    const shouldNotShowVideoPopover = vue.computed(() => {
      if (props.showChapters) {
        return !props.activeChapterProp || moveToRatio.value === 0 || innerWidth() < 640 && props.persistentChapter;
      } else {
        return moveToRatio.value === 0;
      }
    });
    const activeChapter = vue.computed({
      get: () => Number(props.activeChapterProp),
      set: (val) => emit("setActiveChapter", val)
    });
    const summaryCardVisible = vue.computed(() => {
      const overlapThreshold = props.isChapterExpanded ? 0.22 : 0.52;
      const initBool = props.activeChapterProp;
      if (!initBool)
        return false;
      if (props.persistentChapter) {
        if (moveToRatio.value > overlapThreshold)
          return true;
        else {
          return false;
        }
      } else {
        return true;
      }
    });
    const isSummaryCardOverlapping = vue.computed(() => {
      return summaryCardVisible.value && props.persistentChapter;
    });
    vue.computed(() => {
      if (activeChapter.value === null) {
        return false;
      }
      const currentPosition = videoDrag.value ? seekGoToPoint.ratio * duration2.value : time.value;
      const activeChapterData = props.chaptersList[activeChapter.value];
      return currentPosition >= activeChapterData.start && currentPosition < activeChapterData.start + activeChapterData.length;
    });
    vue.watch(isSummaryCardOverlapping, (val) => {
      emit("hideChapterSummary", val);
    });
    vue.watch(moveToRatio, (val) => {
      if (showSummaryInfo.value === true) {
        setTimeout(() => {
          showSummaryInfo.value = false;
        }, 2e3);
      }
      videoPreviewData.value = getVideoPreviewPosition();
      emit("setPreviewVisibility", val > 0);
    });
    vue.onMounted(() => {
      const getSource = () => {
        let src = props.streamUrl;
        let type = "video/mp4";
        if (src.endsWith("m3u8")) {
          type = "application/x-mpegURL";
        }
        return {
          src,
          type
        };
      };
      const source = getSource();
      window.addEventListener("mousemove", onMouseMoveOnScreen);
      window.addEventListener("touchmove", onTouchMoveOnScreen);
      progressBarInteract.value.addEventListener("mousedown", onSeekHeadMouseDown);
      progressBarInteract.value.addEventListener(
        "touchstart",
        onSeekHeadTouchStart
      );
      progressBarInteract.value.addEventListener("touchmove", onTouchMove2);
      progressBarInteract.value.addEventListener("touchstart", () => {
        isTimestampVisible.value = true;
      });
      progressBarInteract.value.addEventListener("touchend", () => {
        isTimestampVisible.value = false;
      });
      videoPreviewData.value = getVideoPreviewPosition();
      if (videoFeedbackPlayer.value && source) {
        feedbackPlayer.value = videojs$2(videoFeedbackPlayer.value, {
          autoplay: false,
          controls: false,
          currentTime: 0,
          html5: {
            nativeTextTracks: false
          },
          preload: true,
          sources: [source]
        });
      }
    });
    const isManuallySlid = (key) => {
      return props.persistentChapter && props.manualSlide === key && !moveToRatio.value;
    };
    const isActiveChapter = (key) => {
      return props.activeChapterProp && activeChapter.value === key;
    };
    const updateFeedbackPlayer = debounce$3((time2) => {
      feedbackPlayer.value.currentTime(time2);
    }, 300);
    const innerWidth = () => {
      return window.innerWidth;
    };
    const getVideoPreviewPosition = () => {
      if (!videoPreview.value)
        return;
      const left2 = videoPreview.value.offsetLeft;
      const width = videoPreview.value.offsetWidth;
      const height = videoPreview.value.offsetHeight;
      return {
        left: left2,
        width,
        height
      };
    };
    const getActiveChapterTitle = () => {
      if (!props.chaptersList[activeChapter.value])
        return "";
      return props.chaptersList[activeChapter.value].title || "";
    };
    const onMouseMove = (e) => {
      if (!progressBar.value) {
        return;
      }
      const moveToTemp = (e.clientX - progressBar.value.getBoundingClientRect().x) / progressBar.value.clientWidth;
      if (moveToTemp && !isNaN(moveToTemp) && isFinite(moveToTemp))
        moveToRatio.value = Math.min(Math.abs(moveToTemp), 1);
      const newTime = duration2.value * moveToRatio.value;
      if (feedbackPlayer.value) {
        updateFeedbackPlayer(newTime);
      }
      if (props.chaptersList.length > 0) {
        activeChapter.value = findCurrentChapter(newTime);
      } else {
        activeChapter.value = null;
      }
    };
    const onMouseLeave = () => {
      activeChapter.value = null;
      moveToRatio.value = 0;
    };
    const onProgressClick = () => {
      const goTo = duration2.value * moveToRatio.value;
      seekTo(goTo);
    };
    const onMouseMoveOnScreen = (e) => {
      if (videoDrag.value) {
        seekVideoTime(e.pageX);
      }
    };
    const onTouchMoveOnScreen = (e) => {
      if (videoDrag.value) {
        seekVideoTime(Math.floor(e.touches[0].clientX));
      }
    };
    const seekVideoTime = (x) => {
      if (!x)
        return;
      if (!progressBar.value) {
        return;
      }
      let position2 = x - progressBar.value.getBoundingClientRect().left;
      const totalWidth = progressBar.value.clientWidth;
      if (position2 < 0) {
        position2 = 0;
      } else if (position2 > totalWidth) {
        position2 = totalWidth;
      }
      seekGoToPoint.ratio = position2 / totalWidth;
      seekGoToPoint.timePosition = Math.round(
        duration2.value * (position2 / totalWidth)
      );
    };
    const onSeekHeadMouseDown = (e) => {
      videoDrag.value = true;
      seekVideoTime(e.pageX);
      window.addEventListener("mouseup", onSeekHeadMouseUp);
    };
    const onSeekHeadTouchStart = (e) => {
      videoDrag.value = true;
      seekVideoTime(e.pageX);
      window.addEventListener("touchend", onSeekHeadTouchEnd);
    };
    const onSeekHeadMouseUp = () => {
      if (videoDrag.value) {
        videoDrag.value = false;
        seekTo(seekGoToPoint.timePosition);
        if (props.persistentChapter) {
          activeChapter.value = findCurrentChapter(seekGoToPoint.timePosition);
        }
      }
    };
    const onSeekHeadTouchEnd = () => {
      if (videoDrag.value) {
        videoDrag.value = false;
        seekTo(Math.floor(seekGoToPoint.timePosition));
        moveToRatio.value = 0;
      }
      if (!props.persistentChapter) {
        activeChapter.value = null;
      }
    };
    const findCurrentChapter = (time2) => {
      const referenceTime = Math.min(Math.max(time2, 0), duration2.value);
      for (let i = 0; i < props.chaptersList.length; i++) {
        const chapter = props.chaptersList[i];
        if (chapter.start <= referenceTime && chapter.start + chapter.length >= referenceTime) {
          return i;
        }
      }
    };
    const onTouchMove2 = (e) => {
      e.preventDefault();
      const clientX = e.touches[0].clientX;
      if (!progressBar.value)
        return;
      const moveToTemp = (clientX - progressBar.value.getBoundingClientRect().left) / progressBar.value.clientWidth;
      if (moveToTemp && !isNaN(moveToTemp) && isFinite(moveToTemp))
        moveToRatio.value = Math.min(Math.abs(moveToTemp), 1);
      const newTime = Math.round(duration2.value * moveToRatio.value);
      if (feedbackPlayer.value) {
        updateFeedbackPlayer(newTime);
      }
      if (props.chaptersList.length > 0) {
        activeChapter.value = findCurrentChapter(newTime);
      } else {
        activeChapter.value = true;
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$j$1, [
        vue.withDirectives(vue.createElementVNode("div", {
          ref_key: "progressBar",
          ref: progressBar,
          class: vue.normalizeClass([
            "progress-bar vdb-p-relative vdb-p-flex vdb-p-h-8 vdb-p-items-center vdb-p-transition-opacity",
            __props.autoHide && !vue.unref(showElements) || vue.unref(duration2) === 0 ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
          ])
        }, [
          vue.createElementVNode("div", {
            ref_key: "videoPreview",
            ref: videoPreview,
            class: vue.normalizeClass(["vdb-p-pointer-events-none vdb-p-absolute vdb-p-bottom-28 vdb-p-left-0 vdb-p-w-2/12 vdb-p-min-w-112 vdb-p--translate-x-1/2 vdb-p-transform vdb-p-rounded-b-8 vdb-p-pb-2 sm:vdb-p-bottom-16 sm:vdb-p-pb-4", {
              "vdb-p-opacity-0": shouldNotShowVideoPopover.value
            }]),
            style: vue.normalizeStyle({
              left: `${Math.max(
                Math.min(moveToRatio.value, innerWidth() > 640 ? 11 / 12 : 10.5 / 12),
                innerWidth() > 640 ? 1 / 12 : 1.5 / 12
              ) * 100}%`,
              zIndex: 29
            })
          }, [
            vue.createElementVNode("div", _hoisted_2$e$1, [
              vue.createElementVNode("div", _hoisted_3$a$1, [
                vue.createElementVNode("video", {
                  ref_key: "videoFeedbackPlayer",
                  ref: videoFeedbackPlayer,
                  class: "video-js vdb-p-bottom-0 vdb-p-left-0 vdb-p-h-full vdb-p-w-full vdb-p-rounded-4 vdb-p-border-2 vdb-p-border-white",
                  style: { "position": "absolute" },
                  playsinline: "",
                  preload: ""
                }, null, 512)
              ])
            ]),
            __props.showChapters ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$7$1, [
              vue.createElementVNode("p", _hoisted_5$6$1, vue.toDisplayString(activeChapter.value + 1) + ". " + vue.toDisplayString(getActiveChapterTitle()), 1)
            ])) : vue.createCommentVNode("", true),
            vue.createElementVNode("p", _hoisted_6$4$1, [
              vue.createElementVNode("span", null, vue.toDisplayString(new Date(videoDateVal.value || 0).toISOString().substring(11, 19)), 1)
            ])
          ], 6),
          vue.createElementVNode("div", _hoisted_7$4$1, [
            __props.chaptersList.length === 0 ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              class: vue.normalizeClass(["chapter vdb-p-w-full vdb-p-backdrop-blur-lg", { active: activeChapter.value }])
            }, [
              vue.createElementVNode("div", {
                class: "vdb-p-absolute vdb-p-left-0 vdb-p-top-0 vdb-p-h-full vdb-p-bg-white vdb-p-shadow-2",
                style: vue.normalizeStyle({
                  width: videoDrag.value ? `${100 * seekGoToPoint.ratio}%` : `${100 * vue.unref(time) / vue.unref(duration2)}%`
                })
              }, null, 4),
              vue.createElementVNode("div", {
                class: vue.normalizeClass([
                  "vdb-p-pointer-events-none vdb-p-absolute vdb-p-left-0 vdb-p-top-0 vdb-p-h-full vdb-p-bg-white vdb-p-shadow-2",
                  activeChapter.value !== null ? "vdb-p-opacity-40" : "vdb-p-opacity-0"
                ]),
                style: vue.normalizeStyle({
                  width: `${100 * moveToRatio.value}%`
                })
              }, null, 6)
            ], 2)) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_8$3$1, [
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.chaptersList, (chapter, key) => {
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: `${chapter.id || String(chapter.end)}`,
                  class: vue.normalizeClass(["chapter", {
                    active: isActiveChapter(key) && (__props.persistentChapter && __props.manualSlide && !moveToRatio.value ? isManuallySlid(key) : true) || isManuallySlid(key),
                    manualSlid: __props.persistentChapter && __props.manualSlide >= key && !moveToRatio.value
                  }]),
                  style: vue.normalizeStyle({
                    width: `${100 * chapter.length / vue.unref(duration2)}%`,
                    maxWidth: `${100 * chapter.length / vue.unref(duration2)}%`
                  })
                }, [
                  vue.createElementVNode("div", {
                    class: "vdb-p-pointer-events-none vdb-p-absolute vdb-p-left-0 vdb-p-top-0 vdb-p-hidden vdb-p-h-full vdb-p-bg-white vdb-p-shadow-2 md:vdb-p-block",
                    style: vue.normalizeStyle({
                      width: `${100 * Math.max(
                        Math.min(
                          (moveToRatio.value * vue.unref(duration2) - chapter.start) / chapter.length,
                          1
                        ),
                        0
                      )}%`
                    })
                  }, null, 4),
                  vue.createElementVNode("div", {
                    class: "vdb-p-absolute vdb-p-left-0 vdb-p-top-0 vdb-p-h-full vdb-p-bg-primary",
                    style: vue.normalizeStyle({
                      width: videoDrag.value ? `${100 * Math.max(
                        Math.min(
                          (seekGoToPoint.ratio * vue.unref(duration2) - chapter.start) / chapter.length,
                          1
                        ),
                        0
                      )}%` : `${100 * Math.max(
                        Math.min((vue.unref(time) - chapter.start) / chapter.length, 1),
                        0
                      )}%`
                    })
                  }, null, 4)
                ], 6);
              }), 128))
            ]))
          ]),
          vue.createElementVNode("div", {
            ref_key: "progressBarInteract",
            ref: progressBarInteract,
            class: "vdb-p-absolute vdb-p--bottom-2 vdb-p-left-0 vdb-p-right-0 vdb-p-top-4 vdb-p-cursor-pointer sm:vdb-p--bottom-3 sm:vdb-p-top-3",
            onMousemove: onMouseMove,
            onMouseleave: onMouseLeave,
            onClick: onProgressClick
          }, [
            vue.createElementVNode("div", {
              ref_key: "head",
              ref: head,
              class: vue.normalizeClass(["head vdb-p-align-center vdb-p-absolute vdb-p-top-0 vdb-p-z-10 vdb-p-flex vdb-p-h-10 vdb-p-w-10 vdb-p--translate-x-1/2 vdb-p--translate-y-1/2 vdb-p-transform vdb-p-cursor-pointer vdb-p-overflow-visible vdb-p-rounded-full vdb-p-border-2 vdb-p-border-outline-light vdb-p-bg-primary vdb-p-shadow-3 vdb-p-transition sm:vdb-p-h-14 sm:vdb-p-w-14 sm:vdb-p--translate-y-1/4", {
                "vdb-p-justify-start": vue.unref(time) / vue.unref(duration2) <= 0.1,
                "vdb-p-justify-center": !(vue.unref(time) / vue.unref(duration2) <= 0.1 || vue.unref(time) / vue.unref(duration2) >= 0.9),
                "vdb-p-justify-end": vue.unref(time) / vue.unref(duration2) >= 0.9
              }]),
              style: vue.normalizeStyle({
                left: videoDrag.value ? `${100 * seekGoToPoint.ratio}%` : `${100 * vue.unref(time) / vue.unref(duration2)}%`
              })
            }, [
              vue.createElementVNode("span", {
                class: vue.normalizeClass(["vdb-p-pointer-events-none vdb-p-absolute vdb-p-flex vdb-p--translate-y-20 vdb-p-transform vdb-p-text-caption2 vdb-p-opacity-0 vdb-p-transition-opacity sm:vdb-p-hidden", {
                  "vdb-p-opacity-100": __props.isActive && !__props.persistentChapter && !videoDrag.value
                }])
              }, [
                vue.createElementVNode("span", _hoisted_9$2$1, vue.toDisplayString(new Date(vue.unref(time) * 1e3).toISOString().substring(11, 19)), 1),
                vue.createElementVNode("span", _hoisted_10$2$1, "  / " + vue.toDisplayString(new Date(parseFloat(vue.unref(duration2) * 1e3)).toISOString().substring(11, 19)), 1)
              ], 2)
            ], 6)
          ], 544)
        ], 2), [
          [vue.vShow, __props.isActive]
        ]),
        vue.withDirectives(vue.createElementVNode("div", _hoisted_11$1$1, null, 512), [
          [vue.vShow, !__props.isActive]
        ])
      ]);
    };
  }
};
const ProgressBar = /* @__PURE__ */ _export_sfc(_sfc_main$l$1, [["__scopeId", "data-v-257c8a6c"]]);
function debounce$1(func, wait, immediate) {
  var timeout, args, context, timestamp, result;
  if (null == wait)
    wait = 100;
  function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  }
  var debounced = function() {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout)
      timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }
    return result;
  };
  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}
debounce$1.debounce = debounce$1;
var debounce_1 = debounce$1;
function useEventListener(target, event2, handler) {
  if (vue.isRef(target)) {
    vue.watch(target, (value2, oldValue) => {
      oldValue === null || oldValue === void 0 ? void 0 : oldValue.removeEventListener(event2, handler);
      value2 === null || value2 === void 0 ? void 0 : value2.addEventListener(event2, handler);
    });
  } else {
    vue.onMounted(() => {
      target.addEventListener(event2, handler);
    });
  }
  vue.onBeforeUnmount(() => {
    var _unref;
    (_unref = vue.unref(target)) === null || _unref === void 0 ? void 0 : _unref.removeEventListener(event2, handler);
  });
}
function useClickAway(target, handler) {
  const event2 = "pointerdown";
  if (typeof window === "undefined" || !window) {
    return;
  }
  const listener = (event3) => {
    const el = vue.unref(target);
    if (!el) {
      return;
    }
    if (el === event3.target || event3.composedPath().includes(el)) {
      return;
    }
    handler(event3);
  };
  return useEventListener(window, event2, listener);
}
function useContent(slots, popperNode, content) {
  let observer = null;
  const hasContent = vue.ref(false);
  vue.onMounted(() => {
    if (slots.content !== void 0 || content.value) {
      hasContent.value = true;
    }
    observer = new MutationObserver(checkContent);
    observer.observe(popperNode.value, {
      childList: true,
      subtree: true
    });
  });
  vue.onBeforeUnmount(() => observer.disconnect());
  vue.watch(content, (content2) => {
    if (content2) {
      hasContent.value = true;
    } else {
      hasContent.value = false;
    }
  });
  const checkContent = () => {
    if (slots.content) {
      hasContent.value = true;
    } else {
      hasContent.value = false;
    }
  };
  return {
    hasContent
  };
}
function getBoundingClientRect(element, includeScale) {
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getWindowScroll(node) {
  var win2 = getWindow$1(node);
  var scrollLeft = win2.pageXOffset;
  var scrollTop = win2.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function isElement(node) {
  var OwnElement = getWindow$1(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow$1(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow$1(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = rect.width / element.offsetWidth || 1;
  var scaleY = rect.height / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win2 = getWindow$1(scrollParent);
  var target = isBody ? [win2].concat(win2.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
function getViewportRect(element) {
  var win2 = getWindow$1(element);
  var html = getDocumentElement(element);
  var visualViewport = win2.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function contains2(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function getVariation(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value2, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value2;
    return hashMap;
  }, {});
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var passive = {
  passive: true
};
function effect$2(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect$2,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win2 = window;
  var dpr = win2.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win2 = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win2.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value2 = attributes[name2];
      if (value2 === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value2 === true ? "" : value2);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$1,
  requires: ["computeStyles"]
};
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function within(min$1, value2, max$1) {
  return max(min$1, min(value2, max$1));
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis || checkAltAxis) {
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = popperOffsets2[mainAxis] + overflow[mainSide];
    var max$1 = popperOffsets2[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets2[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets2[mainAxis] + maxOffset - offsetModifierValue;
    if (checkMainAxis) {
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains2(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
const toInt = (x) => parseInt(x, 10);
function usePopper({
  arrowPadding,
  emit,
  locked,
  offsetDistance,
  offsetSkid,
  placement,
  popperNode,
  triggerNode
}) {
  const state = vue.reactive({
    isOpen: false,
    popperInstance: null
  });
  const setPopperEventListeners = (enabled) => {
    var _state$popperInstance;
    (_state$popperInstance = state.popperInstance) === null || _state$popperInstance === void 0 ? void 0 : _state$popperInstance.setOptions((options) => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: "eventListeners",
        enabled
      }]
    }));
  };
  const enablePopperEventListeners = () => setPopperEventListeners(true);
  const disablePopperEventListeners = () => setPopperEventListeners(false);
  const close2 = () => {
    if (!state.isOpen) {
      return;
    }
    state.isOpen = false;
    emit("close:popper");
  };
  const open2 = () => {
    if (state.isOpen) {
      return;
    }
    state.isOpen = true;
    emit("open:popper");
  };
  vue.watch([() => state.isOpen, placement], async ([isOpen]) => {
    if (isOpen) {
      await initializePopper();
      enablePopperEventListeners();
    } else {
      disablePopperEventListeners();
    }
  });
  const initializePopper = async () => {
    await vue.nextTick();
    state.popperInstance = createPopper(triggerNode.value, popperNode.value, {
      placement: placement.value,
      modifiers: [preventOverflow$1, flip$1, {
        name: "flip",
        enabled: !locked.value
      }, arrow$1, {
        name: "arrow",
        options: {
          padding: toInt(arrowPadding.value)
        }
      }, offset$1, {
        name: "offset",
        options: {
          offset: [toInt(offsetSkid.value), toInt(offsetDistance.value)]
        }
      }]
    });
    state.popperInstance.update();
  };
  vue.onBeforeUnmount(() => {
    var _state$popperInstance2;
    (_state$popperInstance2 = state.popperInstance) === null || _state$popperInstance2 === void 0 ? void 0 : _state$popperInstance2.destroy();
  });
  return {
    ...vue.toRefs(state),
    open: open2,
    close: close2
  };
}
const _hoisted_1$1$1 = {
  id: "arrow",
  "data-popper-arrow": ""
};
function render2(_ctx, _cache) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1$1);
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style2, head.firstChild);
    } else {
      head.appendChild(style2);
    }
  } else {
    head.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css;
  } else {
    style2.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = '\n#arrow[data-v-20b7fd4a],\n  #arrow[data-v-20b7fd4a]::before {\n    transition: background 250ms ease-in-out;\n    position: absolute;\n    width: calc(10px - var(--popper-theme-border-width, 0px));\n    height: calc(10px - var(--popper-theme-border-width, 0px));\n    box-sizing: border-box;\n    background: var(--popper-theme-background-color);\n}\n#arrow[data-v-20b7fd4a] {\n    visibility: hidden;\n}\n#arrow[data-v-20b7fd4a]::before {\n    visibility: visible;\n    content: "";\n    transform: rotate(45deg);\n}\n\n  /* Top arrow */\n.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a] {\n    bottom: -5px;\n}\n.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a]::before {\n    border-right: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-bottom: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Bottom arrow */\n.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a] {\n    top: -5px;\n}\n.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a]::before {\n    border-left: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-top: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Left arrow */\n.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a] {\n    right: -5px;\n}\n.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a]::before {\n    border-right: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n    border-top: var(--popper-theme-border-width)\n      var(--popper-theme-border-style) var(--popper-theme-border-color);\n}\n\n  /* Right arrow */\n.popper[data-popper-placement^="right"] > #arrow[data-v-20b7fd4a] {\n    left: -5px;\n}\n';
styleInject(css_248z$1);
const script$1 = {};
script$1.render = render2;
script$1.__scopeId = "data-v-20b7fd4a";
var Arrow = script$1;
const _hoisted_1$i$1 = ["onKeyup"];
var script = {
  props: {
    /**
     * Preferred placement (the "auto" placements will choose the side with most space.)
     */
    placement: {
      type: String,
      default: "bottom",
      validator: function(value2) {
        return ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"].includes(value2);
      }
    },
    /**
     * Disables automatically closing the popover when the user clicks away from it
     */
    disableClickAway: {
      type: Boolean,
      default: false
    },
    /**
     * Offset in pixels along the trigger element
     */
    offsetSkid: {
      type: String,
      default: "0"
    },
    /**
     * Offset in pixels away from the trigger element
     */
    offsetDistance: {
      type: String,
      default: "12"
    },
    /**
     * Trigger the popper on hover
     */
    hover: {
      type: Boolean,
      default: false
    },
    /**
     * Manually open/close the Popper, other events are ignored if this prop is set
     */
    show: {
      type: Boolean,
      default: null
    },
    /**
     * Disables the Popper. If it was already open, it will be closed.
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Open the Popper after a delay (ms).
     */
    openDelay: {
      type: [Number, String],
      default: 0
    },
    /**
     * Close the Popper after a delay (ms).
     */
    closeDelay: {
      type: [Number, String],
      default: 0
    },
    /**
     * The z-index of the Popper.
     */
    zIndex: {
      type: [Number, String],
      default: 9999
    },
    /**
     * Display an arrow on the popper
     */
    arrow: {
      type: Boolean,
      default: false
    },
    /**
     * Stop arrow from reaching the edge of the popper
     */
    arrowPadding: {
      type: String,
      default: "0"
    },
    /**
     * If the Popper should be interactive, it will close when clicked/hovered if false
     */
    interactive: {
      type: Boolean,
      default: true
    },
    /**
     * Lock the Popper into place, it will not flip dynamically when it runs out of space if true
     */
    locked: {
      type: Boolean,
      default: false
    },
    /**
     * If the content is just a simple string, it can be passed in as a prop
     */
    content: {
      type: String,
      default: null
    }
  },
  emits: ["open:popper", "close:popper"],
  setup(__props, {
    emit
  }) {
    const props = __props;
    vue.useCssVars((_ctx) => ({
      "c81fc0a4": __props.zIndex
    }));
    const slots = vue.useSlots();
    const popperContainerNode = vue.ref(null);
    const popperNode = vue.ref(null);
    const triggerNode = vue.ref(null);
    const modifiedIsOpen = vue.ref(false);
    vue.onMounted(() => {
      const children = slots.default();
      if (children && children.length > 1) {
        return console.error(`[Popper]: The <Popper> component expects only one child element at its root. You passed ${children.length} child nodes.`);
      }
    });
    const {
      arrowPadding,
      closeDelay,
      content,
      disableClickAway,
      disabled,
      interactive,
      locked,
      offsetDistance,
      offsetSkid,
      openDelay,
      placement,
      show
    } = vue.toRefs(props);
    const {
      isOpen,
      open: open2,
      close: close2
    } = usePopper({
      arrowPadding,
      emit,
      locked,
      offsetDistance,
      offsetSkid,
      placement,
      popperNode,
      triggerNode
    });
    const {
      hasContent
    } = useContent(slots, popperNode, content);
    const manualMode = vue.computed(() => show.value !== null);
    const invalid = vue.computed(() => disabled.value || !hasContent.value);
    const shouldShowPopper = vue.computed(() => isOpen.value && !invalid.value);
    const enableClickAway = vue.computed(() => !disableClickAway.value && !manualMode.value);
    const interactiveStyle = vue.computed(() => interactive.value ? `border: ${offsetDistance.value}px solid transparent; margin: -${offsetDistance.value}px;` : null);
    const openPopperDebounce = debounce_1.debounce(open2, openDelay.value);
    const closePopperDebounce = debounce_1.debounce(close2, closeDelay.value);
    const openPopper = async () => {
      if (invalid.value || manualMode.value) {
        return;
      }
      closePopperDebounce.clear();
      openPopperDebounce();
    };
    const closePopper = async () => {
      if (manualMode.value) {
        return;
      }
      openPopperDebounce.clear();
      closePopperDebounce();
    };
    const togglePopper = () => {
      isOpen.value ? closePopper() : openPopper();
    };
    vue.watch([hasContent, disabled], ([hasContent2, disabled2]) => {
      if (isOpen.value && (!hasContent2 || disabled2)) {
        close2();
      }
    });
    vue.watch(isOpen, (isOpen2) => {
      if (isOpen2) {
        modifiedIsOpen.value = true;
      } else {
        debounce_1.debounce(() => {
          modifiedIsOpen.value = false;
        }, 200);
      }
    });
    vue.watchEffect(() => {
      if (manualMode.value) {
        show.value ? openPopperDebounce() : closePopperDebounce();
      }
    });
    vue.watchEffect(() => {
      if (enableClickAway.value) {
        useClickAway(popperContainerNode, closePopper);
      }
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "inline-block",
        style: vue.normalizeStyle(vue.unref(interactiveStyle)),
        onMouseleave: _cache[2] || (_cache[2] = ($event) => __props.hover && closePopper()),
        ref: (_value, _refs) => {
          _refs["popperContainerNode"] = _value;
          popperContainerNode.value = _value;
        }
      }, [vue.createElementVNode("div", {
        ref: (_value, _refs) => {
          _refs["triggerNode"] = _value;
          triggerNode.value = _value;
        },
        onMouseover: _cache[0] || (_cache[0] = ($event) => __props.hover && openPopper()),
        onClick: togglePopper,
        onFocus: openPopper,
        onKeyup: vue.withKeys(closePopper, ["esc"])
      }, [vue.renderSlot(_ctx.$slots, "default")], 40, _hoisted_1$i$1), vue.createVNode(vue.Transition, {
        name: "fade"
      }, {
        default: vue.withCtx(() => [vue.withDirectives(vue.createElementVNode("div", {
          onClick: _cache[1] || (_cache[1] = ($event) => !vue.unref(interactive) && closePopper()),
          class: "popper",
          ref: (_value, _refs) => {
            _refs["popperNode"] = _value;
            popperNode.value = _value;
          }
        }, [vue.renderSlot(_ctx.$slots, "content", {
          close: vue.unref(close2),
          isOpen: modifiedIsOpen.value
        }, () => [vue.createTextVNode(vue.toDisplayString(vue.unref(content)), 1)]), __props.arrow ? (vue.openBlock(), vue.createBlock(Arrow, {
          key: 0
        })) : vue.createCommentVNode("", true)], 512), [[vue.vShow, vue.unref(shouldShowPopper)]])]),
        _: 3
      })], 36);
    };
  }
};
var css_248z = "\n.inline-block[data-v-5784ed69] {\n    display: inline-block;\n}\n.popper[data-v-5784ed69] {\n    transition: background 250ms ease-in-out;\n    background: var(--popper-theme-background-color);\n    padding: var(--popper-theme-padding);\n    color: var(--popper-theme-text-color);\n    border-radius: var(--popper-theme-border-radius);\n    border-width: var(--popper-theme-border-width);\n    border-style: var(--popper-theme-border-style);\n    border-color: var(--popper-theme-border-color);\n    box-shadow: var(--popper-theme-box-shadow);\n    z-index: var(--c81fc0a4);\n}\n.popper[data-v-5784ed69]:hover,\n  .popper:hover > #arrow[data-v-5784ed69]::before {\n    background: var(--popper-theme-background-color-hover);\n}\n.inline-block[data-v-5784ed69] {\n    display: inline-block;\n}\n.fade-enter-active[data-v-5784ed69],\n  .fade-leave-active[data-v-5784ed69] {\n    transition: opacity 0.2s ease;\n}\n.fade-enter-from[data-v-5784ed69],\n  .fade-leave-to[data-v-5784ed69] {\n    opacity: 0;\n}\n";
styleInject(css_248z);
script.__scopeId = "data-v-5784ed69";
var entry_esm = /* @__PURE__ */ (() => {
  const installable = script;
  installable.install = (app) => {
    app.component("Popper", installable);
  };
  return installable;
})();
const _hoisted_1$h$1 = { slot: "reference" };
const _sfc_main$k$1 = {
  __name: "WithPopper",
  props: {
    popperText: {
      type: String,
      default: ""
    },
    isPopperActive: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(vue.unref(entry_esm), {
        hover: "",
        arrow: "",
        placement: "top",
        modifiers: { offset: { offset: "0,10px" } },
        "boundaries-selector": ".video-player",
        boundaries: "30px"
      }, {
        content: vue.withCtx(() => [
          vue.createTextVNode(vue.toDisplayString(__props.popperText), 1)
        ]),
        default: vue.withCtx(() => [
          vue.createElementVNode("div", _hoisted_1$h$1, [
            vue.renderSlot(_ctx.$slots, "button")
          ])
        ]),
        _: 3
      });
    };
  }
};
const _sfc_main$j$1 = {
  __name: "PlayPauseButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const { playing, togglePlay, showElements } = useVideoDBPlayer();
    const isPopperActive = vue.ref(true);
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(_sfc_main$k$1, {
        "popper-text": vue.unref(playing) ? "Pause" : "Play",
        "is-popper-active": isPopperActive.value,
        class: vue.normalizeClass([
          "vdb-p-transition-opacity",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ])
      }, {
        button: vue.withCtx(() => [
          vue.createVNode(TransparentButton, {
            class: "vdb-p-h-40 vdb-p-w-56",
            "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
            "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
            "button-state": __props.isActive ? "default" : "hidden",
            onClick: vue.unref(togglePlay)
          }, {
            default: vue.withCtx(() => [
              vue.unref(playing) ? (vue.openBlock(), vue.createBlock(PauseButton, {
                key: 0,
                class: "vdb-p-h-20 vdb-p-w-20"
              })) : (vue.openBlock(), vue.createBlock(PlayIcon, {
                key: 1,
                class: "vdb-p-h-20 vdb-p-w-20"
              }))
            ]),
            _: 1
          }, 8, ["button-state", "onClick"])
        ]),
        _: 1
      }, 8, ["popper-text", "is-popper-active", "class"]);
    };
  }
};
const _withScopeId$a = (n) => (vue.pushScopeId("data-v-6c23127e"), n = n(), vue.popScopeId(), n);
const _hoisted_1$g$1 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M17.7071 9.29289C17.3166 8.90237 16.6834 8.90237 16.2929 9.29289C15.9024 9.68342 15.9024 10.3166 16.2929 10.7071L17.5858 12L16.2929 13.2929C15.9024 13.6834 15.9024 14.3166 16.2929 14.7071C16.6834 15.0976 17.3166 15.0976 17.7071 14.7071L19 13.4142L20.2929 14.7071C20.6834 15.0976 21.3166 15.0976 21.7071 14.7071C22.0976 14.3166 22.0976 13.6834 21.7071 13.2929L20.4142 12L21.7071 10.7071C22.0976 10.3166 22.0976 9.68342 21.7071 9.29289C21.3166 8.90237 20.6834 8.90237 20.2929 9.29289L19 10.5858L17.7071 9.29289Z",
  fill: "white"
}, null, -1));
const _hoisted_2$d$1 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ vue.createElementVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11 7.00376C11 6.04306 9.77725 5.63506 9.20036 6.40328L6.49962 9.99976H5C4.44772 9.99976 4 10.4475 4 10.9998V12.9998C4 13.552 4.44772 13.9998 5 13.9998H6.49963L9.20035 17.5963C9.77723 18.3646 11 17.9566 11 16.9959V7.00376ZM7.60108 5.20232C9.33174 2.89766 13 4.12164 13 7.00376V16.9959C13 19.878 9.3317 21.102 7.60106 18.7973L5.50037 15.9998H5C3.34315 15.9998 2 14.6566 2 12.9998V10.9998C2 9.34291 3.34315 7.99976 5 7.99976H5.50038L7.60108 5.20232Z",
  fill: "white"
}, null, -1));
const _hoisted_3$9$1 = [
  _hoisted_1$g$1,
  _hoisted_2$d$1
];
const _sfc_main$i$1 = {
  __name: "volume-mute",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_3$9$1, 2);
    };
  }
};
const VolumeMute = /* @__PURE__ */ _export_sfc(_sfc_main$i$1, [["__scopeId", "data-v-6c23127e"]]);
const _withScopeId$9 = (n) => (vue.pushScopeId("data-v-4373af40"), n = n(), vue.popScopeId(), n);
const _hoisted_1$f$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M16.3165 4.0511C15.7926 3.87645 15.2262 4.15961 15.0516 4.68356C14.8769 5.2075 15.1601 5.77382 15.684 5.94847C18.2922 6.81785 20.0003 8.94734 20.0003 11.9999C20.0003 15.0525 18.2922 17.1817 15.684 18.0511C15.1601 18.2257 14.8769 18.7921 15.0516 19.316C15.2262 19.84 15.7926 20.1231 16.3165 19.9485C19.7083 18.8179 22.0003 15.9477 22.0003 11.9999C22.0003 8.05223 19.7084 5.18172 16.3165 4.0511Z",
  fill: "white"
}, null, -1));
const _hoisted_2$c$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M16.7074 9.29314C16.3168 8.90261 15.6837 8.90261 15.2931 9.29314C14.9026 9.68366 14.9026 10.3168 15.2931 10.7074C15.7827 11.1969 16.0002 11.44 16.0002 12C16.0002 12.5602 15.7825 12.8038 15.2931 13.2931C14.9026 13.6837 14.9026 14.3168 15.2931 14.7074C15.6837 15.0979 16.3168 15.0979 16.7074 14.7074L16.733 14.6817C17.2438 14.1714 18.0002 13.4155 18.0002 12C18.0002 10.585 17.2441 9.82948 16.7336 9.31934L16.7074 9.29314Z",
  fill: "white"
}, null, -1));
const _hoisted_3$8$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ vue.createElementVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11 7.004C11 6.04329 9.77725 5.6353 9.20036 6.40352L6.49962 10H5C4.44772 10 4 10.4477 4 11V13C4 13.5523 4.44772 14 5 14H6.49963L9.20035 17.5966C9.77723 18.3648 11 17.9568 11 16.9961V7.004ZM7.60108 5.20256C9.33174 2.89789 13 4.12187 13 7.004V16.9961C13 19.8782 9.3317 21.1022 7.60106 18.7975L5.50037 16H5C3.34315 16 2 14.6569 2 13V11C2 9.34314 3.34315 8 5 8H5.50038L7.60108 5.20256Z",
  fill: "white"
}, null, -1));
const _hoisted_4$6$1 = [
  _hoisted_1$f$1,
  _hoisted_2$c$1,
  _hoisted_3$8$1
];
const _sfc_main$h$1 = {
  __name: "volume",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_4$6$1, 2);
    };
  }
};
const Volume = /* @__PURE__ */ _export_sfc(_sfc_main$h$1, [["__scopeId", "data-v-4373af40"]]);
const _hoisted_1$e$1 = { class: "vdb-p-mr-8 vdb-p-flex" };
const _hoisted_2$b$1 = /* @__PURE__ */ vue.createElementVNode("div", { class: "vdb-p-absolute vdb-p-h-4 vdb-p-w-32 vdb-p-rounded-full vdb-p-bg-white-40" }, null, -1);
const _sfc_main$g$1 = {
  __name: "VolumeControlButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const { volume, setVolume, showElements } = useVideoDBPlayer();
    const volumeDrag = vue.ref(false);
    const isPopperActive = vue.ref(true);
    const volumeRef = vue.ref(null);
    const onMouseMove = (e) => {
      if (volumeDrag.value) {
        updateVolume(e.pageX);
      }
    };
    const onMouseDown = (e) => {
      volumeDrag.value = true;
      updateVolume(e.pageX);
      window.addEventListener("mouseup", onMouseUp);
    };
    const onMouseUp = (e) => {
      if (volumeDrag.value) {
        volumeDrag.value = false;
        updateVolume(e.pageX);
      }
    };
    const updateVolume = (x, vol) => {
      const volume2 = volumeRef.value;
      let percentAsDecimal = 0;
      if (vol !== void 0) {
        percentAsDecimal = vol;
      } else {
        const position2 = x - volume2.getBoundingClientRect().left;
        percentAsDecimal = position2 / volume2.offsetWidth;
      }
      percentAsDecimal = Math.max(0, Math.min(1, percentAsDecimal));
      volume2.style.clip = `rect(0px, ${percentAsDecimal * 32}px, 10px, 0px)`;
      console.log("this is setVolume", setVolume);
      setVolume(percentAsDecimal);
    };
    vue.onMounted(() => {
      window.addEventListener("mousemove", onMouseMove);
    });
    vue.onUnmounted(() => {
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(TransparentButton, {
        class: vue.normalizeClass([
          "vdb-p-ml-8 vdb-p-hidden vdb-p-h-40 vdb-p-items-center vdb-p-rounded-8 vdb-p-px-8 vdb-p-font-semibold vdb-p-text-white vdb-p-transition-opacity sm:vdb-p-flex",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ]),
        "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
        "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
        "button-state": __props.isActive ? "default" : "hidden"
      }, {
        default: vue.withCtx(() => [
          vue.createElementVNode("div", _hoisted_1$e$1, [
            vue.createVNode(_sfc_main$k$1, {
              "popper-text": vue.unref(volume) === 0 ? "Unmute" : "Mute",
              "is-popper-active": isPopperActive.value
            }, {
              button: vue.withCtx(() => [
                vue.createElementVNode("button", {
                  id: "videoplay",
                  slot: "reference",
                  class: "vdb-p-flex vdb-p-h-20 vdb-p-w-20 focus:vdb-p-outline-none",
                  onClick: _cache[0] || (_cache[0] = ($event) => updateVolume(0, vue.unref(volume) === 0 ? 1 : 0))
                }, [
                  vue.unref(volume) == 0 ? (vue.openBlock(), vue.createBlock(VolumeMute, {
                    key: 0,
                    class: "vdb-p-h-20 vdb-p-w-20"
                  })) : (vue.openBlock(), vue.createBlock(Volume, {
                    key: 1,
                    class: "vdb-p-h-20 vdb-p-w-20"
                  }))
                ])
              ]),
              _: 1
            }, 8, ["popper-text", "is-popper-active"])
          ]),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(["volumeBar vdb-p-block vdb-p-h-4 vdb-p-w-32 vdb-p-cursor-pointer vdb-p-overflow-hidden vdb-p-rounded-full", {
              "vdb-p-opacity-50": !__props.isActive
            }]),
            onMousedown: onMouseDown
          }, [
            _hoisted_2$b$1,
            vue.createElementVNode("div", {
              ref_key: "volumeRef",
              ref: volumeRef,
              class: "vdb-p-absolute vdb-p-h-4 vdb-p-w-32 vdb-p-rounded-full vdb-p-bg-white"
            }, null, 512)
          ], 34)
        ]),
        _: 1
      }, 8, ["class", "button-state"]);
    };
  }
};
const _hoisted_1$d$1 = /* @__PURE__ */ vue.createElementVNode("span", null, "/", -1);
const _sfc_main$f$1 = {
  __name: "TimeCode",
  props: {
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const { playing, time, duration: duration2, showElements } = useVideoDBPlayer();
    const showHours = (duration3) => Math.floor(duration3 / 3600) > 0;
    const formaatPadded = (number) => String(number).padStart(2, "0");
    const formatDuration = (duration3) => {
      const hrs = formaatPadded(Math.floor(duration3 / 3600)) + ":";
      const mins = formaatPadded(Math.floor(duration3 % 3600 / 60)) + ":";
      const secs = formaatPadded(Math.floor(duration3 % 60));
      return `${showHours(duration3) ? hrs : ""}${mins}${secs}`;
    };
    const currentTime = vue.computed(() => formatDuration(time.value));
    const totalTime = vue.computed(() => formatDuration(duration2.value));
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("p", {
        class: vue.normalizeClass([
          "vdb-p-ml-12 vdb-p-inline vdb-p-hidden vdb-p-font-medium vdb-p-text-white vdb-p-transition sm:vdb-p-block",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ])
      }, [
        vue.createElementVNode("span", null, vue.toDisplayString(currentTime.value), 1),
        _hoisted_1$d$1,
        vue.createElementVNode("span", null, vue.toDisplayString(totalTime.value), 1)
      ], 2);
    };
  }
};
const _hoisted_1$c$1 = { class: "vdb-p-text-white" };
const _sfc_main$e$1 = {
  __name: "SpeedControlButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    speedOptions: {
      type: Array,
      default: () => [1, 1.2, 1.5, 1.8, 2]
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const props = __props;
    const isPopperActive = vue.ref(true);
    const { playBackRate, setPlayBackRate, showElements } = useVideoDBPlayer();
    const onClickPlaybackRate = () => {
      const newValue = props.speedOptions[(props.speedOptions.indexOf(playBackRate.value) + 1) % props.speedOptions.length];
      setPlayBackRate(newValue);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(_sfc_main$k$1, {
        "popper-text": "Change Speed",
        "is-popper-active": isPopperActive.value,
        class: vue.normalizeClass([
          "vdb-p-transition",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ])
      }, {
        button: vue.withCtx(() => [
          vue.createVNode(TransparentButton, {
            class: "vdb-p-pale vdb-p-group vdb-p-ml-8 vdb-p-h-40 vdb-p-w-48",
            "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
            "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
            "button-state": __props.isActive ? "default" : "hidden",
            onClickAction: onClickPlaybackRate
          }, {
            default: vue.withCtx(() => [
              vue.createElementVNode("div", _hoisted_1$c$1, vue.toDisplayString(vue.unref(playBackRate)) + "x", 1)
            ]),
            _: 1
          }, 8, ["button-state"])
        ]),
        _: 1
      }, 8, ["is-popper-active", "class"]);
    };
  }
};
const _sfc_main$d$1 = {
  __name: "CaptionButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const isPopperActive = vue.ref(true);
    const { showElements, showSubtitles, toggleSubtitles, subtitlesConfig } = useVideoDBPlayer();
    const captionButtonState = vue.computed(() => {
      if (!subtitlesConfig.src)
        return "disabled";
      return showSubtitles.value ? "active" : "default";
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(_sfc_main$k$1, {
        "popper-text": "Toggle subtitles",
        "is-popper-active": isPopperActive.value,
        class: vue.normalizeClass([
          "vdb-p-hidden vdb-p-transition sm:vdb-p-block",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ])
      }, {
        button: vue.withCtx(() => [
          vue.createVNode(TransparentButton, {
            class: "vdb-p-pale vdb-p-group vdb-p-ml-8 vdb-p-h-40 vdb-p-w-48",
            "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
            "active-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-56 vdb-p-backdrop-blur",
            "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
            "button-state": captionButtonState.value,
            onClickAction: _cache[0] || (_cache[0] = () => {
              vue.unref(toggleSubtitles)(!vue.unref(showSubtitles));
            })
          }, {
            default: vue.withCtx(() => [
              vue.createElementVNode("div", {
                class: vue.normalizeClass(["vdb-p-text-white", { "vdb-p-underline": captionButtonState.value === "active" }])
              }, " CC ", 2)
            ]),
            _: 1
          }, 8, ["button-state"])
        ]),
        _: 1
      }, 8, ["is-popper-active", "class"]);
    };
  }
};
const CaptionButton = /* @__PURE__ */ _export_sfc(_sfc_main$d$1, [["__scopeId", "data-v-e33a97dd"]]);
const _withScopeId$8 = (n) => (vue.pushScopeId("data-v-3476b19f"), n = n(), vue.popScopeId(), n);
const _hoisted_1$b$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M3.33333 8.33333C3.79357 8.33333 4.16667 7.96024 4.16667 7.5V7.33333C4.16667 6.61952 4.16732 6.13427 4.19796 5.7592C4.22781 5.39385 4.28192 5.20702 4.34832 5.07668C4.50811 4.76308 4.76308 4.50811 5.07668 4.34832C5.20702 4.28192 5.39385 4.22781 5.7592 4.19796C6.13427 4.16732 6.61952 4.16667 7.33333 4.16667H7.5C7.96024 4.16667 8.33333 3.79357 8.33333 3.33333C8.33333 2.8731 7.96024 2.5 7.5 2.5H7.29892C6.62812 2.49999 6.07447 2.49998 5.62348 2.53683C5.15507 2.5751 4.72448 2.65724 4.32003 2.86331C3.69283 3.18289 3.18289 3.69283 2.86331 4.32003C2.65724 4.72448 2.5751 5.15506 2.53683 5.62348C2.49998 6.07447 2.49999 6.6281 2.5 7.29891V7.5C2.5 7.96024 2.8731 8.33333 3.33333 8.33333Z",
  fill: "white"
}, null, -1));
const _hoisted_2$a$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M4.16667 12.5C4.16667 12.0398 3.79357 11.6667 3.33333 11.6667C2.8731 11.6667 2.5 12.0398 2.5 12.5V12.7011C2.49999 13.3719 2.49998 13.9255 2.53683 14.3765C2.5751 14.8449 2.65724 15.2755 2.86331 15.68C3.18289 16.3072 3.69283 16.8171 4.32003 17.1367C4.72448 17.3428 5.15507 17.4249 5.62348 17.4632C6.07448 17.5 6.62811 17.5 7.29892 17.5H7.5C7.96024 17.5 8.33333 17.1269 8.33333 16.6667C8.33333 16.2064 7.96024 15.8333 7.5 15.8333H7.33333C6.61952 15.8333 6.13427 15.8327 5.7592 15.802C5.39385 15.7722 5.20702 15.7181 5.07668 15.6517C4.76308 15.4919 4.50811 15.2369 4.34832 14.9233C4.28192 14.793 4.22781 14.6061 4.19796 14.2408C4.16732 13.8657 4.16667 13.3805 4.16667 12.6667V12.5Z",
  fill: "white"
}, null, -1));
const _hoisted_3$7$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M15.8333 12.5C15.8333 12.0398 16.2064 11.6667 16.6667 11.6667C17.1269 11.6667 17.5 12.0398 17.5 12.5V12.7011C17.5 13.3719 17.5 13.9255 17.4632 14.3765C17.4249 14.8449 17.3428 15.2755 17.1367 15.68C16.8171 16.3072 16.3072 16.8171 15.68 17.1367C15.2755 17.3428 14.8449 17.4249 14.3765 17.4632C13.9255 17.5 13.3719 17.5 12.7011 17.5H12.5C12.0398 17.5 11.6667 17.1269 11.6667 16.6667C11.6667 16.2064 12.0398 15.8333 12.5 15.8333H12.6667C13.3805 15.8333 13.8657 15.8327 14.2408 15.802C14.6061 15.7722 14.793 15.7181 14.9233 15.6517C15.2369 15.4919 15.4919 15.2369 15.6517 14.9233C15.7181 14.793 15.7722 14.6061 15.802 14.2408C15.8327 13.8657 15.8333 13.3805 15.8333 12.6667V12.5Z",
  fill: "white"
}, null, -1));
const _hoisted_4$5$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M15.8333 7.5C15.8333 7.96024 16.2064 8.33333 16.6667 8.33333C17.1269 8.33333 17.5 7.96024 17.5 7.5V7.29892C17.5 6.62815 17.5 6.07446 17.4632 5.62348C17.4249 5.15506 17.3428 4.72448 17.1367 4.32003C16.8171 3.69283 16.3072 3.18289 15.68 2.86331C15.2755 2.65724 14.8449 2.5751 14.3765 2.53683C13.9255 2.49998 13.3719 2.49999 12.7011 2.5H12.5C12.0398 2.5 11.6667 2.8731 11.6667 3.33333C11.6667 3.79357 12.0398 4.16667 12.5 4.16667H12.6667C13.3805 4.16667 13.8657 4.16732 14.2408 4.19796C14.6061 4.22781 14.793 4.28192 14.9233 4.34832C15.2369 4.50811 15.4919 4.76308 15.6517 5.07668C15.7181 5.20702 15.7722 5.39385 15.802 5.7592C15.8327 6.13427 15.8333 6.61952 15.8333 7.33333V7.5Z",
  fill: "white"
}, null, -1));
const _hoisted_5$5$1 = [
  _hoisted_1$b$1,
  _hoisted_2$a$1,
  _hoisted_3$7$1,
  _hoisted_4$5$1
];
const _sfc_main$c$1 = {
  __name: "full-screen",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_5$5$1, 2);
    };
  }
};
const FullScreen = /* @__PURE__ */ _export_sfc(_sfc_main$c$1, [["__scopeId", "data-v-3476b19f"]]);
const _withScopeId$7 = (n) => (vue.pushScopeId("data-v-3d3e30d5"), n = n(), vue.popScopeId(), n);
const _hoisted_1$a$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M9 3C8.44772 3 8 3.44772 8 4V4.2C8 5.05658 7.99922 5.63887 7.96245 6.08896C7.92663 6.52738 7.8617 6.75158 7.78201 6.90798C7.59027 7.28431 7.28431 7.59027 6.90798 7.78201C6.75158 7.8617 6.52738 7.92663 6.08896 7.96245C5.63887 7.99922 5.05658 8 4.2 8H4C3.44772 8 3 8.44771 3 9C3 9.55228 3.44772 10 4 10H4.2413C5.04626 10 5.71063 10 6.25183 9.95581C6.81392 9.90988 7.33063 9.81132 7.81596 9.56403C8.56861 9.18053 9.18053 8.56861 9.56403 7.81596C9.81132 7.33063 9.90988 6.81392 9.95581 6.25183C10 5.71063 10 5.04628 10 4.24131L10 4C10 3.44772 9.55229 3 9 3Z",
  fill: "white"
}, null, -1));
const _hoisted_2$9$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M8 20C8 20.5523 8.44772 21 9 21C9.55229 21 10 20.5523 10 20L10 19.7587C10 18.9537 10 18.2894 9.95581 17.7482C9.90988 17.1861 9.81132 16.6694 9.56403 16.184C9.18053 15.4314 8.56861 14.8195 7.81596 14.436C7.33063 14.1887 6.81392 14.0901 6.25183 14.0442C5.71065 14 5.04631 14 4.24137 14H4C3.44772 14 3 14.4477 3 15C3 15.5523 3.44772 16 4 16H4.2C5.05658 16 5.63887 16.0008 6.08896 16.0376C6.52738 16.0734 6.75158 16.1383 6.90798 16.218C7.28431 16.4097 7.59027 16.7157 7.78201 17.092C7.8617 17.2484 7.92663 17.4726 7.96245 17.911C7.99922 18.3611 8 18.9434 8 19.8V20Z",
  fill: "white"
}, null, -1));
const _hoisted_3$6$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M16 20C16 20.5523 15.5523 21 15 21C14.4477 21 14 20.5523 14 20V19.7587C14 18.9537 14 18.2894 14.0442 17.7482C14.0901 17.1861 14.1887 16.6694 14.436 16.184C14.8195 15.4314 15.4314 14.8195 16.184 14.436C16.6694 14.1887 17.1861 14.0901 17.7482 14.0442C18.2894 14 18.9537 14 19.7587 14H20C20.5523 14 21 14.4477 21 15C21 15.5523 20.5523 16 20 16H19.8C18.9434 16 18.3611 16.0008 17.911 16.0376C17.4726 16.0734 17.2484 16.1383 17.092 16.218C16.7157 16.4097 16.4097 16.7157 16.218 17.092C16.1383 17.2484 16.0734 17.4726 16.0376 17.911C16.0008 18.3611 16 18.9434 16 19.8V20Z",
  fill: "white"
}, null, -1));
const _hoisted_4$4$1 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M16 4C16 3.44772 15.5523 3 15 3C14.4477 3 14 3.44772 14 4L14 4.2413C14 5.04626 14 5.71063 14.0442 6.25183C14.0901 6.81392 14.1887 7.33063 14.436 7.81596C14.8195 8.56861 15.4314 9.18053 16.184 9.56403C16.6694 9.81132 17.1861 9.90988 17.7482 9.95581C18.2894 10 18.9537 10 19.7587 10H20C20.5523 10 21 9.55228 21 9C21 8.44772 20.5523 8 20 8H19.8C18.9434 8 18.3611 7.99922 17.911 7.96245C17.4726 7.92663 17.2484 7.8617 17.092 7.78201C16.7157 7.59027 16.4097 7.28431 16.218 6.90798C16.1383 6.75158 16.0734 6.52738 16.0376 6.08896C16.0008 5.63887 16 5.05658 16 4.2V4Z",
  fill: "white"
}, null, -1));
const _hoisted_5$4$1 = [
  _hoisted_1$a$1,
  _hoisted_2$9$1,
  _hoisted_3$6$1,
  _hoisted_4$4$1
];
const _sfc_main$b$1 = {
  __name: "full-screen-exit",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_5$4$1, 2);
    };
  }
};
const FullScreenExit = /* @__PURE__ */ _export_sfc(_sfc_main$b$1, [["__scopeId", "data-v-3d3e30d5"]]);
const _sfc_main$a$1 = {
  __name: "FullScreenButton",
  props: {
    isActive: {
      type: Boolean,
      default: true
    },
    autoHide: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    vue.ref(true);
    const { showElements, isFullScreen, toggleFullScreen } = useVideoDBPlayer();
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(_sfc_main$k$1, {
        "popper-text": vue.unref(isFullScreen) ? "Exit Full Screen" : "Full Screen",
        class: vue.normalizeClass([
          "vdb-p-transition-opacity",
          __props.autoHide && !vue.unref(showElements) ? "vdb-p-opacity-0" : "vdb-p-opacity-1"
        ])
      }, {
        button: vue.withCtx(() => [
          vue.createVNode(TransparentButton, {
            class: "vdb-p-flex vdb-p-h-40 vdb-p-w-48 vdb-p-rounded-8 vdb-p-font-semibold vdb-p-text-white sm:vdb-p-ml-8",
            "default-state-css": "vdb-p-bg-black-16 vdb-p-border vdb-p-border-white-16 vdb-p-backdrop-blur hover:vdb-p-bg-random-313131 hover:vdb-p-border-random-8e6200",
            "disabled-state-css": "vdb-p-bg-black-45 vdb-p-opacity-20 vdb-p-backdrop-blur vdb-p-cursor-not-allowed vdb-p-pointer-events-none",
            "button-state": __props.isActive ? "default" : "hidden",
            onClickAction: _cache[0] || (_cache[0] = ($event) => vue.unref(isFullScreen) ? vue.unref(toggleFullScreen)(false) : vue.unref(toggleFullScreen)(true))
          }, {
            default: vue.withCtx(() => [
              vue.createElementVNode("div", null, [
                vue.unref(isFullScreen) ? (vue.openBlock(), vue.createBlock(FullScreenExit, {
                  key: 0,
                  class: "vdb-p-h-20 vdb-p-w-20"
                })) : (vue.openBlock(), vue.createBlock(FullScreen, {
                  key: 1,
                  class: "vdb-p-flex vdb-p-h-20 vdb-p-w-20 group-hover:vdb-p-hidden"
                }))
              ])
            ]),
            _: 1
          }, 8, ["button-state"])
        ]),
        _: 1
      }, 8, ["popper-text", "class"]);
    };
  }
};
const _hoisted_1$9$1 = { class: "vdb-p-absolute vdb-p-inset-0 vdb-p-h-full vdb-p-w-full vdb-p-overflow-hidden vdb-p-bg-kilvish-200" };
const _hoisted_2$8$1 = ["kind", "src", "srclang", "label"];
const _hoisted_3$5$1 = { class: "vdb-p-absolute vdb-p-left-0 vdb-p-right-0 vdb-p-top-0 vdb-p-h-full vdb-p-w-full" };
const _hoisted_4$3$1 = {
  key: 1,
  class: "vdb-p-p-20 vdb-p-pt-0"
};
const _hoisted_5$3$1 = { class: "vdb-p-mb-12 sm:vdb-p-mx-8" };
const _hoisted_6$3$1 = { class: "vdb-p-flex vdb-p-w-full vdb-p-justify-between" };
const _hoisted_7$3$1 = { class: "vdb-p-z-10 vdb-p-ml-0 vdb-p-flex vdb-p-items-center" };
const _hoisted_8$2$1 = { class: "vdb-p-flex vdb-p-w-auto vdb-p-flex-row vdb-p-items-center" };
const _sfc_main$9$1 = {
  __name: "VideoDBPlayer",
  props: {
    streamUrl: {
      type: String,
      required: true
    },
    thumbnailUrl: {
      type: String,
      default: ""
    },
    subtitlesConfig: {
      type: Object,
      default: () => {
        return {
          src: "",
          kind: "captions",
          lang: "en",
          label: "English"
        };
      }
    },
    startAt: {
      type: Number,
      default: 0
    },
    autoPlay: {
      type: Boolean,
      default: false
    },
    autoHideDuration: {
      type: Number,
      default: 5e3
    },
    defaultControls: {
      type: Boolean,
      default: true
    },
    defaultOverlay: {
      type: Boolean,
      default: true
    },
    defaultPlayBackRate: {
      type: Number,
      default: 1
    },
    aspectRatio: {
      type: String,
      default: "16:9"
    },
    debug: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "play",
    "pause",
    "ended",
    "loadeddata",
    "waiting",
    "playing",
    "timeupdate",
    "canplay",
    "canplaythrough",
    "videoerrror",
    "toggleSubtitles",
    "fullScreenChange"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const aspectRatioPadding = vue.computed(() => {
      const [width, height] = props.aspectRatio.split(":").map(Number);
      return `${height / width * 100}%`;
    });
    const videoWrapper = vue.ref(null);
    const videoElement = vue.ref(null);
    const emit = __emit;
    const {
      events: events2,
      playing,
      volume,
      videoMuted,
      duration: duration2,
      time,
      percentagePlayed,
      playBackRate,
      play,
      pause,
      togglePlay,
      toggleMute,
      seekTo,
      seekToPercentage,
      setVolume,
      setPlayBackRate,
      convertTimeToDuration,
      togglePictureInPicture,
      initializePlayer
    } = usePlayer(emit, props);
    const showElements = vue.ref(true);
    const showElementsMouseMoveInterval = vue.ref(null);
    const isFullScreen = vue.ref(false);
    const showSubtitles = vue.ref(false);
    vue.onMounted(() => {
      window.addEventListener("keypress", (e) => {
        if (isFullScreen.value && e.code === "Escape") {
          toggleFullScreen(false);
        }
      });
      initializePlayer(videoElement);
      addVideoInteractions();
      addKeyboardKeyFunctions();
    });
    vue.onBeforeUnmount(() => {
      removeKeyboardKeyFunctions();
    });
    const addKeyboardKeyFunctions = () => {
      document.addEventListener("keydown", keyDown);
    };
    const removeKeyboardKeyFunctions = () => {
      document.removeEventListener("keydown", keyDown);
    };
    const toggleSubtitles = (value2) => {
      showSubtitles.value = value2;
      emit("toggleSubtitles", value2);
    };
    const toggleFullScreen = (value2) => {
      isFullScreen.value = value2;
      emit("fullScreenChange", value2);
    };
    const keyDown = (e) => {
      const currentElement = document.activeElement.tagName;
      if (currentElement === "TEXTAREA" || currentElement === "INPUT") {
        return;
      }
      switch (e.code) {
        case "Space":
          e.preventDefault();
          togglePlay();
          return;
      }
    };
    const addVideoInteractions = () => {
      if (window.matchMedia("(any-hover: none)").matches) {
        videoWrapper.value.addEventListener("touchend", onTouchEnd2);
      } else {
        videoWrapper.value.addEventListener("mouseenter", onMouseEnter);
        videoWrapper.value.addEventListener("mouseleave", onMouseLeave);
      }
    };
    const onMouseEnter = () => {
      showElements.value = true;
      window.addEventListener("mousemove", onMouseMove);
    };
    const onMouseLeave = () => {
      clearTimeout(showElementsMouseMoveInterval.value);
      if (playing.value) {
        showElements.value = false;
      }
      window.removeEventListener("mousemove", onMouseMove);
    };
    const onMouseMove = () => {
      clearTimeout(showElementsMouseMoveInterval.value);
      showElements.value = true;
      showElementsMouseMoveInterval.value = setTimeout(() => {
        if (!playing.value)
          return;
        showElements.value = false;
      }, props.autoHideDuration);
    };
    const onTouchEnd2 = () => {
      clearTimeout(showElementsMouseMoveInterval.value);
      showElements.value = true;
      showElementsMouseMoveInterval.value = setTimeout(() => {
        if (!playing.value)
          return;
        showElements.value = false;
      }, props.autoHideDuration);
    };
    __expose({
      showElements,
      playing,
      volume,
      videoMuted,
      duration: duration2,
      time,
      percentagePlayed,
      playBackRate,
      showSubtitles,
      subtitlesConfig: props.subtitlesConfig,
      isFullScreen,
      play,
      pause,
      togglePlay,
      toggleMute,
      seekTo,
      seekToPercentage,
      setPlayBackRate,
      setVolume,
      convertTimeToDuration,
      toggleFullScreen,
      toggleSubtitles,
      togglePictureInPicture
    });
    vue.provide("videodb-player", {
      showElements,
      playing,
      volume,
      videoMuted,
      duration: duration2,
      time,
      percentagePlayed,
      playBackRate,
      showSubtitles,
      subtitlesConfig: props.subtitlesConfig,
      isFullScreen,
      play,
      pause,
      togglePlay,
      toggleMute,
      seekTo,
      seekToPercentage,
      setPlayBackRate,
      setVolume,
      convertTimeToDuration,
      toggleFullScreen,
      togglePictureInPicture,
      toggleSubtitles
    });
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e;
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "vdb-p-relative vdb-p-w-full",
        style: vue.normalizeStyle({ paddingBottom: aspectRatioPadding.value })
      }, [
        vue.createElementVNode("div", _hoisted_1$9$1, [
          vue.createElementVNode("div", {
            ref_key: "videoWrapper",
            ref: videoWrapper,
            class: vue.normalizeClass(["video-container vdb-p-outline-16 vdb-p-relative vdb-p-h-full vdb-p-select-none vdb-p-outline-kilvish-200", {
              "show-elements": showElements.value,
              "hide-subtitles": !showSubtitles.value
            }])
          }, [
            vue.createElementVNode("video", {
              ref_key: "videoElement",
              ref: videoElement,
              class: "video-js vdb-p-pointer-events-none vdb-p-absolute vdb-p-bottom-0 vdb-p-left-0 vdb-p-right-0 vdb-p-top-0 vdb-p-h-full vdb-p-w-auto",
              playsinline: ""
            }, [
              ((_a = __props.subtitlesConfig) == null ? void 0 : _a.src) ? (vue.openBlock(), vue.createElementBlock("track", {
                key: 0,
                kind: ((_b = __props.subtitlesConfig) == null ? void 0 : _b.kind) || "captions",
                src: (_c = __props.subtitlesConfig) == null ? void 0 : _c.src,
                srclang: ((_d = __props.subtitlesConfig) == null ? void 0 : _d.lang) || "en",
                label: ((_e = __props.subtitlesConfig) == null ? void 0 : _e.label) || "English",
                default: ""
              }, null, 8, _hoisted_2$8$1)) : vue.createCommentVNode("", true)
            ], 512),
            vue.createElementVNode("div", _hoisted_3$5$1, [
              vue.createElementVNode("div", {
                class: vue.normalizeClass([
                  "vdb-p-duration-400 vdb-p-absolute vdb-p-bottom-0 vdb-p-left-0 vdb-p-right-0 vdb-p-top-0 vdb-p-block vdb-p-cursor-pointer vdb-p-bg-gradient-to-b vdb-p-from-black vdb-p-to-transparent vdb-p-transition-opacity vdb-p-ease-in-out",
                  !vue.unref(playing) || showElements.value ? "vdb-p-opacity-40" : "vdb-p-opacity-0"
                ]),
                onClick: _cache[0] || (_cache[0] = (...args) => vue.unref(togglePlay) && vue.unref(togglePlay)(...args))
              }, null, 2),
              !__props.defaultOverlay ? vue.renderSlot(_ctx.$slots, "overlay", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createBlock(_sfc_main$m$1, {
                key: 1,
                class: "vdb-p-absolute vdb-p-left-1/2 vdb-p-top-1/2"
              }))
            ]),
            vue.createElementVNode("div", {
              class: vue.normalizeClass([
                "vdb-p-absolute vdb-p-bottom-0 vdb-p-w-full",
                showElements.value ? "lg-black-40" : "lg-transparent"
              ])
            }, [
              !__props.defaultControls ? vue.renderSlot(_ctx.$slots, "controls", { key: 0 }, void 0, true) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$3$1, [
                vue.createElementVNode("div", _hoisted_5$3$1, [
                  vue.createVNode(ProgressBar, { "stream-url": __props.streamUrl }, null, 8, ["stream-url"])
                ]),
                vue.createElementVNode("div", _hoisted_6$3$1, [
                  vue.createElementVNode("div", _hoisted_7$3$1, [
                    vue.createVNode(_sfc_main$j$1),
                    vue.createVNode(_sfc_main$g$1),
                    vue.createVNode(_sfc_main$f$1)
                  ]),
                  vue.createElementVNode("div", _hoisted_8$2$1, [
                    vue.createVNode(CaptionButton),
                    vue.createVNode(_sfc_main$e$1, { "speed-options": [1, 1.2, 1.5, 1.8, 2] }),
                    vue.createVNode(_sfc_main$a$1)
                  ])
                ])
              ]))
            ], 2)
          ], 2)
        ])
      ], 4);
    };
  }
};
const VideoDBPlayer = /* @__PURE__ */ _export_sfc(_sfc_main$9$1, [["__scopeId", "data-v-d1d68f33"]]);
function isObject$2(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$2(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
      extend$2(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win2 = typeof window !== "undefined" ? window : {};
  extend$2(win2, ssrWindow);
  return win2;
}
function classesToTokens(classes2) {
  if (classes2 === void 0) {
    classes2 = "";
  }
  return classes2.trim().split(" ").filter((c) => !!c.trim());
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window2 = getWindow();
  let style2;
  if (window2.getComputedStyle) {
    style2 = window2.getComputedStyle(el, null);
  }
  if (!style2 && el.currentStyle) {
    style2 = el.currentStyle;
  }
  if (!style2) {
    style2 = el.style;
  }
  return style2;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$1(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$1() {
  const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper: swiper2,
    targetPosition,
    side
  } = _ref;
  const window2 = getWindow();
  const startPosition = -swiper2.translate;
  let startTime = null;
  let time;
  const duration2 = swiper2.params.speed;
  swiper2.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper2.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir === "next" && current >= target || dir === "prev" && current <= target;
  };
  const animate = () => {
    time = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration2, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper2.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper2.wrapperEl.style.overflow = "hidden";
      swiper2.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper2.wrapperEl.style.overflow = "";
        swiper2.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper2.cssModeFrameID);
      return;
    }
    swiper2.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = "";
  }
  const children = [...element.children];
  if (element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter((el) => el.matches(selector));
}
function elementIsChildOf(el, parent) {
  const isChild = parent.contains(el);
  if (!isChild && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    return children.includes(el);
  }
  return isChild;
}
function showWarning(text2) {
  try {
    console.warn(text2);
    return;
  } catch (err) {
  }
}
function createElement(tag, classes2) {
  if (classes2 === void 0) {
    classes2 = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
  return el;
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev2 = el.previousElementSibling;
    if (selector) {
      if (prev2.matches(selector))
        prevEls.push(prev2);
    } else
      prevEls.push(prev2);
    el = prev2;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling;
    if (selector) {
      if (next.matches(selector))
        nextEls.push(next);
    } else
      nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window2 = getWindow();
  return window2.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i += 1;
    }
    return i;
  }
  return void 0;
}
function elementParents(el, selector) {
  const parents = [];
  let parent = el.parentElement;
  while (parent) {
    if (selector) {
      if (parent.matches(selector))
        parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  const window2 = getWindow();
  if (includeMargins) {
    return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
  }
  return el.offsetWidth;
}
function makeElementsArray(el) {
  return (Array.isArray(el) ? el : [el]).filter((e) => !!e);
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  if (isSafari()) {
    const ua = String(window2.navigator.userAgent);
    if (ua.includes("Version/")) {
      const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize(_ref) {
  let {
    swiper: swiper2,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper2;
        let newWidth = width;
        let newHeight = height;
        entries.forEach((_ref2) => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper2.el)
            return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper2.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper2.el) {
      observer.unobserve(swiper2.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    emit("orientationchange");
  };
  on2("init", () => {
    if (swiper2.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on2("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const observers = [];
  const window2 = getWindow();
  const attach = function(target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper2.__preventObserver__)
        return;
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: swiper2.isElement || (typeof options.childList === "undefined" ? true : options).childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper2.params.observer)
      return;
    if (swiper2.params.observeParents) {
      const containerParents = elementParents(swiper2.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper2.hostEl, {
      childList: swiper2.params.observeSlideChildren
    });
    attach(swiper2.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on2("init", init);
  on2("destroy", destroy);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event2) => {
      if (!self2.eventsListeners[event2])
        self2.eventsListeners[event2] = [];
      self2.eventsListeners[event2][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    function onceHandler() {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsAnyListeners)
      return self2;
    const index = self2.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self2.eventsAnyListeners.splice(index, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    events2.split(" ").forEach((event2) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event2] = [];
      } else if (self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event2].splice(index, 1);
          }
        });
      }
    });
    return self2;
  },
  emit() {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self2;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event2) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event2, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event2]) {
        self2.eventsListeners[event2].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper2 = this;
  let width;
  let height;
  const el = swiper2.el;
  if (typeof swiper2.params.width !== "undefined" && swiper2.params.width !== null) {
    width = swiper2.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper2.params.height !== "undefined" && swiper2.params.height !== null) {
    height = swiper2.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper2.isHorizontal() || height === 0 && swiper2.isVertical()) {
    return;
  }
  width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
  height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper2, {
    width,
    height,
    size: swiper2.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper2 = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper2.getDirectionLabel(label)) || 0);
  }
  const params = swiper2.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper2;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper2.virtual.slides.length : swiper2.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper2.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper2.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper2);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper2);
  }
  const previousSnapGridLength = swiper2.snapGrid.length;
  const previousSlidesGridLength = swiper2.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper2.virtualSize = -spaceBetween;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = "";
    } else {
      slideEl.style.marginRight = "";
    }
    slideEl.style.marginBottom = "";
    slideEl.style.marginTop = "";
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper2.grid;
  if (gridEnabled) {
    swiper2.grid.initSlides(slides);
  } else if (swiper2.grid) {
    swiper2.grid.unsetSlides();
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide2;
    if (slides[i])
      slide2 = slides[i];
    if (gridEnabled) {
      swiper2.grid.updateSlide(i, slide2, slides);
    }
    if (slides[i] && elementStyle(slide2, "display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i].style[swiper2.getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper2.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper2.getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper2.params.slidesPerGroupSkip, index)) % swiper2.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper2.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper2.virtualSize = Math.max(swiper2.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    wrapperEl.style.width = `${swiper2.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper2.getDirectionLabel("width")] = `${swiper2.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper2.grid.updateWrapperSize(slideSize, snapGrid);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper2.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper2.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper2.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper2.virtualSize += size;
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper2.isHorizontal() && rtl ? "marginLeft" : swiper2.getDirectionLabel("marginRight");
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap <= 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper2, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper2.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper2.snapGrid[0];
    const addToSlidesGrid = -swiper2.slidesGrid[0];
    swiper2.snapGrid = swiper2.snapGrid.map((v) => v + addToSnapGrid);
    swiper2.slidesGrid = swiper2.slidesGrid.map((v) => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper2.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper2.params.watchOverflow)
      swiper2.checkOverflow();
    swiper2.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper2.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper2.updateSlidesOffset();
  }
  swiper2.emit("slidesUpdated");
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper2.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded)
        swiper2.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper2.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper2 = this;
  const activeSlides = [];
  const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === "number") {
    swiper2.setTransition(speed);
  } else if (speed === true) {
    swiper2.setTransition(swiper2.params.speed);
  }
  const getSlideByIndex = (index) => {
    if (isVirtual) {
      return swiper2.slides[swiper2.getSlideIndexByData(index)];
    }
    return swiper2.slides[index];
  };
  if (swiper2.params.slidesPerView !== "auto" && swiper2.params.slidesPerView > 1) {
    if (swiper2.params.centeredSlides) {
      (swiper2.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper2.params.slidesPerView); i += 1) {
        const index = swiper2.activeIndex + i;
        if (index > swiper2.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper2.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper2.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
  const swiper2 = this;
  const slides = swiper2.slides;
  const minusOffset = swiper2.isElement ? swiper2.isHorizontal() ? swiper2.wrapperEl.offsetLeft : swiper2.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper2.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper2.cssOverflowAdjustment();
  }
}
const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate2) {
  if (translate2 === void 0) {
    translate2 = this && this.translate || 0;
  }
  const swiper2 = this;
  const params = swiper2.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper2;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper2.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  swiper2.visibleSlidesIndexes = [];
  swiper2.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper2.size;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide2 = slides[i];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper2.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper2.size - swiper2.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper2.size - 1 || slideAfter > 1 && slideAfter <= swiper2.size || slideBefore <= 0 && slideAfter >= swiper2.size;
    if (isVisible) {
      swiper2.visibleSlides.push(slide2);
      swiper2.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide2, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper2 = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper2.rtlTranslate ? -1 : 1;
    translate2 = swiper2 && swiper2.translate && swiper2.translate * multiplier || 0;
  }
  const params = swiper2.params;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper2;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper2.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper2.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper2.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded)
      progress = 0;
    if (isEndRounded)
      progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper2.getSlideIndexByData(0);
    const lastSlideIndex = swiper2.getSlideIndexByData(swiper2.slides.length - 1);
    const firstSlideTranslate = swiper2.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper2.slidesGrid[lastSlideIndex];
    const translateMax = swiper2.slidesGrid[swiper2.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1)
      progressLoop -= 1;
  }
  Object.assign(swiper2, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper2.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper2.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper2.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper2.emit("fromEdge");
  }
  swiper2.emit("progress", progress);
}
const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper2 = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper2;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  const gridEnabled = swiper2.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = (selector) => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper2.virtual.slidesBefore;
      if (slideIndex < 0)
        slideIndex = swiper2.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper2.virtual.slides.length)
        slideIndex -= swiper2.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter((slideEl) => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter((slideEl) => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter((slideEl) => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach((slideEl) => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper2.emitSlidesClasses();
}
const processLazyPreloader = (swiper2, imageEl) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params)
    return;
  const slideSelector = () => swiper2.isElement ? `swiper-slide` : `.${swiper2.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper2.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
      } else {
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
            if (lazyEl)
              lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl)
      lazyEl.remove();
  }
};
const unlazy = (swiper2, index) => {
  if (!swiper2.slides[index])
    return;
  const imageEl = swiper2.slides[index].querySelector('[loading="lazy"]');
  if (imageEl)
    imageEl.removeAttribute("loading");
};
const preload = (swiper2) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params)
    return;
  let amount = swiper2.params.lazyPreloadPrevNext;
  const len = swiper2.slides.length;
  if (!len || !amount || amount < 0)
    return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper2.params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(swiper2.params.slidesPerView);
  const activeIndex = swiper2.activeIndex;
  if (swiper2.params.grid && swiper2.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper2.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column))
        unlazy(swiper2, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper2.params.rewind || swiper2.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView)
        unlazy(swiper2, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper2, i);
      }
    }
  }
};
function getActiveIndexByTranslate(swiper2) {
  const {
    slidesGrid,
    params
  } = swiper2;
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== "undefined") {
      if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate2 >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === "undefined")
      activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper2 = this;
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper2;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper2.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper2.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper2.virtual.slides.length) {
      realIndex2 -= swiper2.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === "undefined") {
    activeIndex = getActiveIndexByTranslate(swiper2);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper2.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper2.snapIndex = snapIndex;
      swiper2.emit("snapIndexChange");
    }
    return;
  }
  if (activeIndex === previousIndex && swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
    swiper2.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper2.grid && params.grid && params.grid.rows > 1;
  let realIndex;
  if (swiper2.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper2.slides.filter((slideEl) => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper2.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper2.slides[activeIndex]) {
    const slideIndex = swiper2.slides[activeIndex].getAttribute("data-swiper-slide-index");
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper2, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper2.initialized) {
    preload(swiper2);
  }
  swiper2.emit("activeIndexChange");
  swiper2.emit("snapIndexChange");
  if (swiper2.initialized || swiper2.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper2.emit("realIndexChange");
    }
    swiper2.emit("slideChange");
  }
}
function updateClickedSlide(el, path2) {
  const swiper2 = this;
  const params = swiper2.params;
  let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide2 && swiper2.isElement && path2 && path2.length > 1 && path2.includes(el)) {
    [...path2.slice(path2.indexOf(el) + 1, path2.length)].forEach((pathEl) => {
      if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide2 = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i = 0; i < swiper2.slides.length; i += 1) {
      if (swiper2.slides[i] === slide2) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper2.clickedSlide = slide2;
    if (swiper2.virtual && swiper2.params.virtual.enabled) {
      swiper2.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
    } else {
      swiper2.clickedIndex = slideIndex;
    }
  } else {
    swiper2.clickedSlide = void 0;
    swiper2.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper2.clickedIndex !== void 0 && swiper2.clickedIndex !== swiper2.activeIndex) {
    swiper2.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? "x" : "y";
  }
  const swiper2 = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl
  } = swiper2;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper2.cssOverflowAdjustment();
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper2 = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper2;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper2.isHorizontal()) {
    x = rtl ? -translate2 : translate2;
  } else {
    y = translate2;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper2.previousTranslate = swiper2.translate;
  swiper2.translate = swiper2.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper2.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper2.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper2.isHorizontal()) {
      x -= swiper2.cssOverflowAdjustment();
    } else {
      y -= swiper2.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }
  let newProgress;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper2.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper2.updateProgress(translate2);
  }
  swiper2.emit("setTranslate", swiper2.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
  if (translate2 === void 0) {
    translate2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper2 = this;
  const {
    params,
    wrapperEl
  } = swiper2;
  if (swiper2.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper2.minTranslate();
  const maxTranslate2 = swiper2.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper2.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper2.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper2.support.smoothScroll) {
        animateCSSModeScroll({
          swiper: swiper2,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper2.setTransition(0);
    swiper2.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper2.emit("beforeTransitionStart", speed, internal);
      swiper2.emit("transitionEnd");
    }
  } else {
    swiper2.setTransition(speed);
    swiper2.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper2.emit("beforeTransitionStart", speed, internal);
      swiper2.emit("transitionStart");
    }
    if (!swiper2.animating) {
      swiper2.animating = true;
      if (!swiper2.onTranslateToWrapperTransitionEnd) {
        swiper2.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
          if (!swiper2 || swiper2.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
          swiper2.onTranslateToWrapperTransitionEnd = null;
          delete swiper2.onTranslateToWrapperTransitionEnd;
          swiper2.animating = false;
          if (runCallbacks) {
            swiper2.emit("transitionEnd");
          }
        };
      }
      swiper2.wrapperEl.addEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration2, byController) {
  const swiper2 = this;
  if (!swiper2.params.cssMode) {
    swiper2.wrapperEl.style.transitionDuration = `${duration2}ms`;
    swiper2.wrapperEl.style.transitionDelay = duration2 === 0 ? `0ms` : "";
  }
  swiper2.emit("setTransition", duration2, byController);
}
function transitionEmit(_ref) {
  let {
    swiper: swiper2,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper2;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper2.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper2.emit(`slideResetTransition${step}`);
      return;
    }
    swiper2.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper2.emit(`slideNextTransition${step}`);
    } else {
      swiper2.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params
  } = swiper2;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper2.updateAutoHeight();
  }
  transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params
  } = swiper2;
  swiper2.animating = false;
  if (params.cssMode)
    return;
  swiper2.setTransition(0);
  transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === "string") {
    index = parseInt(index, 10);
  }
  const swiper2 = this;
  let slideIndex = index;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper2;
  if (!enabled && !internal && !initial || swiper2.destroyed || swiper2.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  const skip = Math.min(swiper2.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper2.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper2.initialized && slideIndex !== activeIndex) {
    if (!swiper2.allowSlideNext && (rtl ? translate2 > swiper2.translate && translate2 > swiper2.minTranslate() : translate2 < swiper2.translate && translate2 < swiper2.minTranslate())) {
      return false;
    }
    if (!swiper2.allowSlidePrev && translate2 > swiper2.translate && translate2 > swiper2.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper2.emit("beforeSlideChangeStart");
  }
  swiper2.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate2 === swiper2.translate || !rtl && translate2 === swiper2.translate) {
    swiper2.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper2.updateAutoHeight();
    }
    swiper2.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper2.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper2.transitionStart(runCallbacks, direction);
      swiper2.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper2.isHorizontal();
    const t = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      if (isVirtual) {
        swiper2.wrapperEl.style.scrollSnapType = "none";
        swiper2._immediateVirtual = true;
      }
      if (isVirtual && !swiper2._cssModeVirtualInitialSet && swiper2.params.initialSlide > 0) {
        swiper2._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
        });
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper2.wrapperEl.style.scrollSnapType = "";
          swiper2._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper2.support.smoothScroll) {
        animateCSSModeScroll({
          swiper: swiper2,
          targetPosition: t,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper2.setTransition(speed);
  swiper2.setTranslate(translate2);
  swiper2.updateActiveIndex(slideIndex);
  swiper2.updateSlidesClasses();
  swiper2.emit("beforeTransitionStart", speed, internal);
  swiper2.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper2.transitionEnd(runCallbacks, direction);
  } else if (!swiper2.animating) {
    swiper2.animating = true;
    if (!swiper2.onSlideToWrapperTransitionEnd) {
      swiper2.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
        if (!swiper2 || swiper2.destroyed)
          return;
        if (e.target !== this)
          return;
        swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
        swiper2.onSlideToWrapperTransitionEnd = null;
        delete swiper2.onSlideToWrapperTransitionEnd;
        swiper2.transitionEnd(runCallbacks, direction);
      };
    }
    swiper2.wrapperEl.addEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === "string") {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper2 = this;
  if (swiper2.destroyed)
    return;
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  const gridEnabled = swiper2.grid && swiper2.params.grid && swiper2.params.grid.rows > 1;
  let newIndex = index;
  if (swiper2.params.loop) {
    if (swiper2.virtual && swiper2.params.virtual.enabled) {
      newIndex = newIndex + swiper2.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper2.params.grid.rows;
        targetSlideIndex = swiper2.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper2.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper2.slides.length / swiper2.params.grid.rows) : swiper2.slides.length;
      const {
        centeredSlides
      } = swiper2.params;
      let slidesPerView = swiper2.params.slidesPerView;
      if (slidesPerView === "auto") {
        slidesPerView = swiper2.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper2.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper2.params.slidesPerView !== "auto" && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper2.activeIndex ? "prev" : "next" : targetSlideIndex - swiper2.activeIndex - 1 < swiper2.params.slidesPerView ? "next" : "prev";
        swiper2.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === "next" ? swiper2.realIndex : void 0
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper2.params.grid.rows;
        newIndex = swiper2.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper2.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper2.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper2;
}
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    enabled,
    params,
    animating
  } = swiper2;
  if (!enabled || swiper2.destroyed)
    return swiper2;
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper2.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper2.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper2.loopFix({
      direction: "next"
    });
    swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
    if (swiper2.activeIndex === swiper2.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper2.isEnd) {
    return swiper2.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper2;
  if (!enabled || swiper2.destroyed)
    return swiper2;
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper2.loopFix({
      direction: "prev"
    });
    swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper2.translate : -swiper2.translate;
  function normalize(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper2.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper2.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper2.isBeginning) {
    const lastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
    return swiper2.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper2.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  if (swiper2.destroyed)
    return;
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  return swiper2.slideTo(swiper2.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper2 = this;
  if (swiper2.destroyed)
    return;
  if (typeof speed === "undefined") {
    speed = swiper2.params.speed;
  }
  let index = swiper2.activeIndex;
  const skip = Math.min(swiper2.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper2.params.slidesPerGroup);
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  if (translate2 >= swiper2.snapGrid[snapIndex]) {
    const currentSnap = swiper2.snapGrid[snapIndex];
    const nextSnap = swiper2.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper2.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper2.snapGrid[snapIndex - 1];
    const currentSnap = swiper2.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper2.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper2.slidesGrid.length - 1);
  return swiper2.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper2 = this;
  if (swiper2.destroyed)
    return;
  const {
    params,
    slidesEl
  } = swiper2;
  const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper2.clickedIndex;
  let realIndex;
  const slideSelector = swiper2.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper2.animating)
      return;
    realIndex = parseInt(swiper2.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper2.loopedSlides - slidesPerView / 2 || slideToIndex > swiper2.slides.length - swiper2.loopedSlides + slidesPerView / 2) {
        swiper2.loopFix();
        slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper2.slideTo(slideToIndex);
        });
      } else {
        swiper2.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper2.slides.length - slidesPerView) {
      swiper2.loopFix();
      slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper2.slideTo(slideToIndex);
      });
    } else {
      swiper2.slideTo(slideToIndex);
    }
  } else {
    swiper2.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(slideRealIndex) {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
    return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute("data-swiper-slide-index", index);
    });
  };
  const gridEnabled = swiper2.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper2.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper2.slides.length % params.grid.rows !== 0;
  const addBlankSlides = (amountOfSlides) => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper2.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
      swiper2.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper2.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper2.recalcSlides();
      swiper2.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper2.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper2.recalcSlides();
      swiper2.updateSlides();
    } else {
      showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper2.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? void 0 : "next"
  });
}
function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo: slideTo2 = true,
    direction,
    setTranslate: setTranslate2,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper2 = this;
  if (!swiper2.params.loop)
    return;
  swiper2.emit("beforeLoopFix");
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper2;
  const {
    centeredSlides
  } = params;
  swiper2.allowSlidePrev = true;
  swiper2.allowSlideNext = true;
  if (swiper2.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!params.centeredSlides && swiper2.snapIndex === 0) {
        swiper2.slideTo(swiper2.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper2.snapIndex < params.slidesPerView) {
        swiper2.slideTo(swiper2.virtual.slides.length + swiper2.snapIndex, 0, false, true);
      } else if (swiper2.snapIndex === swiper2.snapGrid.length - 1) {
        swiper2.slideTo(swiper2.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    swiper2.emit("loopFix");
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === "auto") {
    slidesPerView = swiper2.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper2.loopedSlides = loopedSlides;
  const gridEnabled = swiper2.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
  } else if (gridEnabled && params.grid.fill === "row") {
    showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper2.activeIndex;
  if (typeof activeSlideIndex === "undefined") {
    activeSlideIndex = swiper2.getSlideIndex(slides.filter((el) => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === "next" || !direction;
  const isPrev = direction === "prev" || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i2 = slides.length - 1; i2 >= 0; i2 -= 1) {
          if (slides[i2].column === colIndexToPrepend)
            prependSlidesIndexes.push(i2);
        }
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide2, slideIndex) => {
          if (slide2.column === index)
            appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper2.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper2.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index) => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper2.recalcSlides();
  if (params.slidesPerView === "auto") {
    swiper2.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper2.slides.forEach((slide2, slideIndex) => {
      swiper2.grid.updateSlide(slideIndex, slide2, swiper2.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper2.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
        const newSlideTranslate = swiper2.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper2.setTranslate(swiper2.translate - diff);
        } else {
          swiper2.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate2) {
            swiper2.touchEventsData.startTranslate = swiper2.touchEventsData.startTranslate - diff;
            swiper2.touchEventsData.currentTranslate = swiper2.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate2) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper2.slideTo(swiper2.activeIndex + shift, 0, false, true);
          swiper2.touchEventsData.currentTranslate = swiper2.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
        const newSlideTranslate = swiper2.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper2.setTranslate(swiper2.translate - diff);
        } else {
          swiper2.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper2.touchEventsData.startTranslate = swiper2.touchEventsData.startTranslate - diff;
            swiper2.touchEventsData.currentTranslate = swiper2.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper2.slideTo(swiper2.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper2.allowSlidePrev = allowSlidePrev;
  swiper2.allowSlideNext = allowSlideNext;
  if (swiper2.controller && swiper2.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper2.controller.control)) {
      swiper2.controller.control.forEach((c) => {
        if (!c.destroyed && c.params.loop)
          c.loopFix({
            ...loopParams,
            slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false
          });
      });
    } else if (swiper2.controller.control instanceof swiper2.constructor && swiper2.controller.control.params.loop) {
      swiper2.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper2.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
      });
    }
  }
  swiper2.emit("loopFix");
}
function loopDestroy() {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
    return;
  swiper2.recalcSlides();
  const newSlidesOrder = [];
  swiper2.slides.forEach((slideEl) => {
    const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper2.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper2.recalcSlides();
  swiper2.slideTo(swiper2.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper2 = this;
  if (!swiper2.params.simulateTouch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode)
    return;
  const el = swiper2.params.touchEventsTarget === "container" ? swiper2.el : swiper2.wrapperEl;
  if (swiper2.isElement) {
    swiper2.__preventObserver__ = true;
  }
  el.style.cursor = "move";
  el.style.cursor = moving ? "grabbing" : "grab";
  if (swiper2.isElement) {
    requestAnimationFrame(() => {
      swiper2.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper2 = this;
  if (swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) {
    return;
  }
  if (swiper2.isElement) {
    swiper2.__preventObserver__ = true;
  }
  swiper2[swiper2.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  if (swiper2.isElement) {
    requestAnimationFrame(() => {
      swiper2.__preventObserver__ = false;
    });
  }
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow())
      return null;
    if (el.assignedSlot)
      el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper2, event2, startX) {
  const window2 = getWindow();
  const {
    params
  } = swiper2;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event2.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event2) {
  const swiper2 = this;
  const document2 = getDocument();
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  const data = swiper2.touchEventsData;
  if (e.type === "pointerdown") {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === "touchstart") {
    preventEdgeSwipe(swiper2, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && e.pointerType === "mouse")
    return;
  if (swiper2.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper2.animating && params.cssMode && params.loop) {
    swiper2.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === "wrapper") {
    if (!elementIsChildOf(targetEl, swiper2.wrapperEl))
      return;
  }
  if ("which" in e && e.which === 3)
    return;
  if ("button" in e && e.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper2.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler))
      return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  if (!preventEdgeSwipe(swiper2, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper2.allowClick = true;
  swiper2.updateSize();
  swiper2.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === "SELECT") {
      data.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper2.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode && swiper2.animating && !params.cssMode) {
    swiper2.freeMode.onTouchStart();
  }
  swiper2.emit("touchStart", e);
}
function onTouchMove(event2) {
  const document2 = getDocument();
  const swiper2 = this;
  const data = swiper2.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && event2.pointerType === "mouse")
    return;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (e.type === "pointermove") {
    if (data.touchId !== null)
      return;
    const id = e.pointerId;
    if (id !== data.pointerId)
      return;
  }
  let targetTouch;
  if (e.type === "touchmove") {
    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId)
      return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper2.emit("touchMoveOpposite", e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper2.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper2.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper2.isVertical()) {
      if (pageY < touches.startY && swiper2.translate <= swiper2.maxTranslate() || pageY > touches.startY && swiper2.translate >= swiper2.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper2.translate <= swiper2.maxTranslate() || pageX > touches.startX && swiper2.translate >= swiper2.minTranslate()) {
      return;
    }
  }
  if (document2.activeElement) {
    if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper2.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper2.emit("touchMove", e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper2.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper2.params.threshold)
    return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper2.isHorizontal() && touches.currentY === touches.startY || swiper2.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper2.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper2.emit("touchMoveOpposite", e);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper2.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper2.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper2.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper2.touchesDirection;
  swiper2.swipeDirection = diff > 0 ? "prev" : "next";
  swiper2.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  const isLoop = swiper2.params.loop && !params.cssMode;
  const allowLoopFix = swiper2.touchesDirection === "next" && swiper2.allowSlideNext || swiper2.touchesDirection === "prev" && swiper2.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper2.loopFix({
        direction: swiper2.swipeDirection
      });
    }
    data.startTranslate = swiper2.getTranslate();
    swiper2.setTransition(0);
    if (swiper2.animating) {
      const evt = new window.CustomEvent("transitionend", {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper2.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
      swiper2.setGrabCursor(true);
    }
    swiper2.emit("sliderFirstMove", e);
  }
  let loopFixed;
  (/* @__PURE__ */ new Date()).getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper2.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper2.emit("sliderMove", e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper2.minTranslate() - swiper2.slidesSizesGrid[swiper2.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper2.slides.length - params.slidesPerView >= 2 ? swiper2.slidesSizesGrid[swiper2.activeIndex + 1] + swiper2.params.spaceBetween : 0) - swiper2.params.spaceBetween : swiper2.minTranslate())) {
      swiper2.loopFix({
        direction: "prev",
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper2.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper2.minTranslate() - 1 + (-swiper2.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper2.maxTranslate() + swiper2.slidesSizesGrid[swiper2.slidesSizesGrid.length - 1] + swiper2.params.spaceBetween + (params.slidesPerView !== "auto" && swiper2.slides.length - params.slidesPerView >= 2 ? swiper2.slidesSizesGrid[swiper2.slidesSizesGrid.length - 1] + swiper2.params.spaceBetween : 0) : swiper2.maxTranslate())) {
      swiper2.loopFix({
        direction: "next",
        setTranslate: true,
        activeSlideIndex: swiper2.slides.length - (params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper2.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper2.maxTranslate() + 1 - (swiper2.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }
  if (!swiper2.allowSlideNext && swiper2.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper2.allowSlidePrev && swiper2.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper2.allowSlidePrev && !swiper2.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper2.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode || params.watchSlidesProgress) {
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode) {
    swiper2.freeMode.onTouchMove();
  }
  swiper2.updateProgress(data.currentTranslate);
  swiper2.setTranslate(data.currentTranslate);
}
function onTouchEnd(event2) {
  const swiper2 = this;
  const data = swiper2.touchEventsData;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
  if (!isTouchEvent) {
    if (data.touchId !== null)
      return;
    if (e.pointerId !== data.pointerId)
      return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter((t) => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId)
      return;
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
    const proceed = ["pointercancel", "contextmenu"].includes(e.type) && (swiper2.browser.isSafari || swiper2.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && e.pointerType === "mouse")
    return;
  if (data.allowTouchCallbacks) {
    swiper2.emit("touchEnd", e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper2.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
    swiper2.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper2.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper2.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper2.emit("tap click", e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper2.emit("doubleTap doubleClick", e);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper2.destroyed)
      swiper2.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper2.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper2.translate : -swiper2.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper2.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  const swipeToLast = currentPos >= -swiper2.maxTranslate() && !swiper2.params.loop;
  let stopIndex = 0;
  let groupSize = swiper2.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== "undefined") {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper2.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
    } else if (swiper2.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper2.slideTo(swiper2.activeIndex);
      return;
    }
    if (swiper2.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper2.slideTo(params.rewind && swiper2.isEnd ? rewindFirstIndex : stopIndex + increment);
      else
        swiper2.slideTo(stopIndex);
    }
    if (swiper2.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper2.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper2.slideTo(rewindLastIndex);
      } else {
        swiper2.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper2.slideTo(swiper2.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper2.navigation && (e.target === swiper2.navigation.nextEl || e.target === swiper2.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper2.swipeDirection === "next") {
        swiper2.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper2.swipeDirection === "prev") {
        swiper2.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper2.navigation.nextEl) {
      swiper2.slideTo(stopIndex + increment);
    } else {
      swiper2.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper2 = this;
  const {
    params,
    el
  } = swiper2;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper2.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper2;
  const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
  swiper2.allowSlideNext = true;
  swiper2.allowSlidePrev = true;
  swiper2.updateSize();
  swiper2.updateSlides();
  swiper2.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !swiper2.isBeginning && !swiper2.params.centeredSlides && !isVirtualLoop) {
    swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
  } else {
    if (swiper2.params.loop && !isVirtual) {
      swiper2.slideToLoop(swiper2.realIndex, 0, false, true);
    } else {
      swiper2.slideTo(swiper2.activeIndex, 0, false, true);
    }
  }
  if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
    clearTimeout(swiper2.autoplay.resizeTimeout);
    swiper2.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
        swiper2.autoplay.resume();
      }
    }, 500);
  }
  swiper2.allowSlidePrev = allowSlidePrev;
  swiper2.allowSlideNext = allowSlideNext;
  if (swiper2.params.watchOverflow && snapGrid !== swiper2.snapGrid) {
    swiper2.checkOverflow();
  }
}
function onClick(e) {
  const swiper2 = this;
  if (!swiper2.enabled)
    return;
  if (!swiper2.allowClick) {
    if (swiper2.params.preventClicks)
      e.preventDefault();
    if (swiper2.params.preventClicksPropagation && swiper2.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper2 = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  swiper2.previousTranslate = swiper2.translate;
  if (swiper2.isHorizontal()) {
    swiper2.translate = -wrapperEl.scrollLeft;
  } else {
    swiper2.translate = -wrapperEl.scrollTop;
  }
  if (swiper2.translate === 0)
    swiper2.translate = 0;
  swiper2.updateActiveIndex();
  swiper2.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper2.translate - swiper2.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper2.progress) {
    swiper2.updateProgress(rtlTranslate ? -swiper2.translate : swiper2.translate);
  }
  swiper2.emit("setTranslate", swiper2.translate, false);
}
function onLoad(e) {
  const swiper2 = this;
  processLazyPreloader(swiper2, e.target);
  if (swiper2.params.cssMode || swiper2.params.slidesPerView !== "auto" && !swiper2.params.autoHeight) {
    return;
  }
  swiper2.update();
}
function onDocumentTouchStart() {
  const swiper2 = this;
  if (swiper2.documentTouchHandlerProceeded)
    return;
  swiper2.documentTouchHandlerProceeded = true;
  if (swiper2.params.touchReleaseOnEdges) {
    swiper2.el.style.touchAction = "auto";
  }
}
const events = (swiper2, method) => {
  const document2 = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper2;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!el || typeof el === "string")
    return;
  document2[domMethod]("touchstart", swiper2.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]("touchstart", swiper2.onTouchStart, {
    passive: false
  });
  el[domMethod]("pointerdown", swiper2.onTouchStart, {
    passive: false
  });
  document2[domMethod]("touchmove", swiper2.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("pointermove", swiper2.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("touchend", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerup", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointercancel", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("touchcancel", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerout", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerleave", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("contextmenu", swiper2.onTouchEnd, {
    passive: true
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper2.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper2.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper2[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper2[swiperMethod]("observerUpdate", onResize, true);
  }
  el[domMethod]("load", swiper2.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper2 = this;
  const {
    params
  } = swiper2;
  swiper2.onTouchStart = onTouchStart.bind(swiper2);
  swiper2.onTouchMove = onTouchMove.bind(swiper2);
  swiper2.onTouchEnd = onTouchEnd.bind(swiper2);
  swiper2.onDocumentTouchStart = onDocumentTouchStart.bind(swiper2);
  if (params.cssMode) {
    swiper2.onScroll = onScroll.bind(swiper2);
  }
  swiper2.onClick = onClick.bind(swiper2);
  swiper2.onLoad = onLoad.bind(swiper2);
  events(swiper2, "on");
}
function detachEvents() {
  const swiper2 = this;
  events(swiper2, "off");
}
var events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper2, params) => {
  return swiper2.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper2 = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper2;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper2.getBreakpoint(breakpoints2, swiper2.params.breakpointsBase, swiper2.el);
  if (!breakpoint || swiper2.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper2.originalParams;
  const wasMultiRow = isGridEnabled(swiper2, params);
  const isMultiRow = isGridEnabled(swiper2, breakpointParams);
  const wasGrabCursor = swiper2.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper2.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper2.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper2.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper2.setGrabCursor();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    if (typeof breakpointParams[prop] === "undefined")
      return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper2[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper2[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper2.changeDirection();
  }
  extend$1(swiper2.params, breakpointParams);
  const isEnabled2 = swiper2.params.enabled;
  const hasLoop = swiper2.params.loop;
  Object.assign(swiper2, {
    allowTouchMove: swiper2.params.allowTouchMove,
    allowSlideNext: swiper2.params.allowSlideNext,
    allowSlidePrev: swiper2.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled2) {
    swiper2.disable();
  } else if (!wasEnabled && isEnabled2) {
    swiper2.enable();
  }
  swiper2.currentBreakpoint = breakpoint;
  swiper2.emit("_beforeBreakpoint", breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper2.loopDestroy();
      swiper2.loopCreate(realIndex);
      swiper2.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper2.loopCreate(realIndex);
      swiper2.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper2.loopDestroy();
    }
  }
  swiper2.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
  if (base === void 0) {
    base = "window";
  }
  if (!breakpoints2 || base === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value2 = currentHeight * minRatio;
      return {
        value: value2,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value: value2
    } = points[i];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value2}px)`).matches) {
        breakpoint = point;
      }
    } else if (value2 <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper2 = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper2;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper2.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper2.emitContainerClasses();
}
function removeClasses() {
  const swiper2 = this;
  const {
    el,
    classNames
  } = swiper2;
  if (!el || typeof el === "string")
    return;
  el.classList.remove(...classNames);
  swiper2.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const swiper2 = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper2;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper2.slides.length - 1;
    const lastSlideRightEdge = swiper2.slidesGrid[lastSlideIndex] + swiper2.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper2.isLocked = swiper2.size > lastSlideRightEdge;
  } else {
    swiper2.isLocked = swiper2.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper2.allowSlideNext = !swiper2.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper2.allowSlidePrev = !swiper2.isLocked;
  }
  if (wasLocked && wasLocked !== swiper2.isLocked) {
    swiper2.isEnd = false;
  }
  if (wasLocked !== swiper2.isLocked) {
    swiper2.emit(swiper2.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults = {
  init: true,
  direction: "horizontal",
  oneWayMovement: false,
  swiperElementNodeName: "SWIPER-CONTAINER",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: "swiper",
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-blank",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideFullyVisibleClass: "swiper-slide-fully-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend$1(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
let Swiper$1 = class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params)
      params = {};
    params = extend$1({}, params);
    if (el && !params.el)
      params.el = el;
    const document2 = getDocument();
    if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper2 = this;
    swiper2.__swiper__ = true;
    swiper2.support = getSupport();
    swiper2.device = getDevice({
      userAgent: params.userAgent
    });
    swiper2.browser = getBrowser();
    swiper2.eventsListeners = {};
    swiper2.eventsAnyListeners = [];
    swiper2.modules = [...swiper2.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper2.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper2.modules.forEach((mod) => {
      mod({
        params,
        swiper: swiper2,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper2.on.bind(swiper2),
        once: swiper2.once.bind(swiper2),
        off: swiper2.off.bind(swiper2),
        emit: swiper2.emit.bind(swiper2)
      });
    });
    const swiperParams = extend$1({}, defaults, allModulesParams);
    swiper2.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper2.originalParams = extend$1({}, swiper2.params);
    swiper2.passedParams = extend$1({}, params);
    if (swiper2.params && swiper2.params.on) {
      Object.keys(swiper2.params.on).forEach((eventName) => {
        swiper2.on(eventName, swiper2.params.on[eventName]);
      });
    }
    if (swiper2.params && swiper2.params.onAny) {
      swiper2.onAny(swiper2.params.onAny);
    }
    Object.assign(swiper2, {
      enabled: swiper2.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper2.params.direction === "horizontal";
      },
      isVertical() {
        return swiper2.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper2.params.allowSlideNext,
      allowSlidePrev: swiper2.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper2.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper2.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper2.emit("_swiper");
    if (swiper2.params.init) {
      swiper2.init();
    }
    return swiper2;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper2 = this;
    const {
      slidesEl,
      params
    } = swiper2;
    swiper2.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper2 = this;
    if (swiper2.enabled)
      return;
    swiper2.enabled = true;
    if (swiper2.params.grabCursor) {
      swiper2.setGrabCursor();
    }
    swiper2.emit("enable");
  }
  disable() {
    const swiper2 = this;
    if (!swiper2.enabled)
      return;
    swiper2.enabled = false;
    if (swiper2.params.grabCursor) {
      swiper2.unsetGrabCursor();
    }
    swiper2.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper2 = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min2 = swiper2.minTranslate();
    const max2 = swiper2.maxTranslate();
    const current = (max2 - min2) * progress + min2;
    swiper2.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper2 = this;
    if (!swiper2.params._emitClasses || !swiper2.el)
      return;
    const cls = swiper2.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper2.params.containerModifierClass) === 0;
    });
    swiper2.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper2 = this;
    if (swiper2.destroyed)
      return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper2.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper2 = this;
    if (!swiper2.params._emitClasses || !swiper2.el)
      return;
    const updates = [];
    swiper2.slides.forEach((slideEl) => {
      const classNames = swiper2.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper2.emit("_slideClass", slideEl, classNames);
    });
    swiper2.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = "current";
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper2 = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper2;
    let spv = 1;
    if (typeof params.slidesPerView === "number")
      return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view === "current") {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper2 = this;
    if (!swiper2 || swiper2.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper2;
    if (params.breakpoints) {
      swiper2.setBreakpoint();
    }
    [...swiper2.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper2, imageEl);
      }
    });
    swiper2.updateSize();
    swiper2.updateSlides();
    swiper2.updateProgress();
    swiper2.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper2.rtlTranslate ? swiper2.translate * -1 : swiper2.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper2.maxTranslate()), swiper2.minTranslate());
      swiper2.setTranslate(newTranslate);
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate2();
      if (params.autoHeight) {
        swiper2.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !params.centeredSlides) {
        const slides = swiper2.virtual && params.virtual.enabled ? swiper2.virtual.slides : swiper2.slides;
        translated = swiper2.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper2.slideTo(swiper2.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper2.snapGrid) {
      swiper2.checkOverflow();
    }
    swiper2.emit("update");
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper2 = this;
    const currentDirection = swiper2.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper2;
    }
    swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}${currentDirection}`);
    swiper2.el.classList.add(`${swiper2.params.containerModifierClass}${newDirection}`);
    swiper2.emitContainerClasses();
    swiper2.params.direction = newDirection;
    swiper2.slides.forEach((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper2.emit("changeDirection");
    if (needUpdate)
      swiper2.update();
    return swiper2;
  }
  changeLanguageDirection(direction) {
    const swiper2 = this;
    if (swiper2.rtl && direction === "rtl" || !swiper2.rtl && direction === "ltr")
      return;
    swiper2.rtl = direction === "rtl";
    swiper2.rtlTranslate = swiper2.params.direction === "horizontal" && swiper2.rtl;
    if (swiper2.rtl) {
      swiper2.el.classList.add(`${swiper2.params.containerModifierClass}rtl`);
      swiper2.el.dir = "rtl";
    } else {
      swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}rtl`);
      swiper2.el.dir = "ltr";
    }
    swiper2.update();
  }
  mount(element) {
    const swiper2 = this;
    if (swiper2.mounted)
      return true;
    let el = element || swiper2.params.el;
    if (typeof el === "string") {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper2;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper2.params.swiperElementNodeName.toUpperCase()) {
      swiper2.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper2.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper2.params.createElements) {
      wrapperEl = createElement("div", swiper2.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper2.params.slideClass}`).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper2, {
      el,
      wrapperEl,
      slidesEl: swiper2.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper2.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
      rtlTranslate: swiper2.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper2 = this;
    if (swiper2.initialized)
      return swiper2;
    const mounted = swiper2.mount(el);
    if (mounted === false)
      return swiper2;
    swiper2.emit("beforeInit");
    if (swiper2.params.breakpoints) {
      swiper2.setBreakpoint();
    }
    swiper2.addClasses();
    swiper2.updateSize();
    swiper2.updateSlides();
    if (swiper2.params.watchOverflow) {
      swiper2.checkOverflow();
    }
    if (swiper2.params.grabCursor && swiper2.enabled) {
      swiper2.setGrabCursor();
    }
    if (swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
      swiper2.slideTo(swiper2.params.initialSlide + swiper2.virtual.slidesBefore, 0, swiper2.params.runCallbacksOnInit, false, true);
    } else {
      swiper2.slideTo(swiper2.params.initialSlide, 0, swiper2.params.runCallbacksOnInit, false, true);
    }
    if (swiper2.params.loop) {
      swiper2.loopCreate();
    }
    swiper2.attachEvents();
    const lazyElements = [...swiper2.el.querySelectorAll('[loading="lazy"]')];
    if (swiper2.isElement) {
      lazyElements.push(...swiper2.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper2, imageEl);
      } else {
        imageEl.addEventListener("load", (e) => {
          processLazyPreloader(swiper2, e.target);
        });
      }
    });
    preload(swiper2);
    swiper2.initialized = true;
    preload(swiper2);
    swiper2.emit("init");
    swiper2.emit("afterInit");
    return swiper2;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper2 = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper2;
    if (typeof swiper2.params === "undefined" || swiper2.destroyed) {
      return null;
    }
    swiper2.emit("beforeDestroy");
    swiper2.initialized = false;
    swiper2.detachEvents();
    if (params.loop) {
      swiper2.loopDestroy();
    }
    if (cleanStyles) {
      swiper2.removeClasses();
      if (el && typeof el !== "string") {
        el.removeAttribute("style");
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute("style");
      }
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute("style");
          slideEl.removeAttribute("data-swiper-slide-index");
        });
      }
    }
    swiper2.emit("destroy");
    Object.keys(swiper2.eventsListeners).forEach((eventName) => {
      swiper2.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper2.el && typeof swiper2.el !== "string") {
        swiper2.el.swiper = null;
      }
      deleteProps(swiper2);
    }
    swiper2.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module2) {
    if (Array.isArray(module2)) {
      module2.forEach((m) => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module2);
    return Swiper;
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "swiperElementNodeName",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "breakpointsBase",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopAdditionalSlides",
  "loopAddBlankSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideFullyVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "slideBlankClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control"
];
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object" && !o.__swiper__;
}
function extend(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__)
        target[key] = src[key];
      else
        extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params) {
  if (params === void 0) {
    params = {};
  }
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params) {
  if (params === void 0) {
    params = {};
  }
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params) {
  if (params === void 0) {
    params = {};
  }
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames) {
  if (classNames === void 0) {
    classNames = "";
  }
  const classes2 = classNames.split(" ").map((c) => c.trim()).filter((c) => !!c);
  const unique = [];
  classes2.forEach((c) => {
    if (unique.indexOf(c) < 0)
      unique.push(c);
  });
  return unique.join(" ");
}
function wrapperClass(className) {
  if (className === void 0) {
    className = "";
  }
  if (!className)
    return "swiper-wrapper";
  if (!className.includes("swiper-wrapper"))
    return `swiper-wrapper ${className}`;
  return className;
}
function updateSwiper(_ref) {
  let {
    swiper: swiper2,
    slides,
    passedParams,
    changedParams,
    nextEl,
    prevEl,
    scrollbarEl,
    paginationEl
  } = _ref;
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction" && key !== "wrapperClass");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper2;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper2[mod])
      return;
    swiper2[mod].destroy();
    if (mod === "navigation") {
      if (swiper2.isElement) {
        swiper2[mod].prevEl.remove();
        swiper2[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper2[mod].prevEl = void 0;
      swiper2[mod].nextEl = void 0;
    } else {
      if (swiper2.isElement) {
        swiper2[mod].el.remove();
      }
      currentParams[mod].el = void 0;
      swiper2[mod].el = void 0;
    }
  };
  if (changedParams.includes("loop") && swiper2.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach((key) => {
    if (isObject(currentParams[key]) && isObject(passedParams[key])) {
      Object.assign(currentParams[key], passedParams[key]);
      if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper2.controller && swiper2.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper2.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes("virtual") && virtual && currentParams.virtual.enabled) {
    if (slides)
      virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes("children") && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper2.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper2.isElement && (!paginationEl || typeof paginationEl === "string")) {
      paginationEl = document.createElement("div");
      paginationEl.classList.add("swiper-pagination");
      paginationEl.part.add("pagination");
      swiper2.el.appendChild(paginationEl);
    }
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper2.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
      scrollbarEl = document.createElement("div");
      scrollbarEl.classList.add("swiper-scrollbar");
      scrollbarEl.part.add("scrollbar");
      swiper2.el.appendChild(scrollbarEl);
    }
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper2.isElement) {
      if (!nextEl || typeof nextEl === "string") {
        nextEl = document.createElement("div");
        nextEl.classList.add("swiper-button-next");
        nextEl.innerHTML = swiper2.hostEl.constructor.nextButtonSvg;
        nextEl.part.add("button-next");
        swiper2.el.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === "string") {
        prevEl = document.createElement("div");
        prevEl.classList.add("swiper-button-prev");
        prevEl.innerHTML = swiper2.hostEl.constructor.prevButtonSvg;
        prevEl.part.add("button-prev");
        swiper2.el.appendChild(prevEl);
      }
    }
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper2.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper2.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper2.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper2.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper2.loopCreate();
  }
  swiper2.update();
}
function getParams(obj, splitEvents) {
  if (obj === void 0) {
    obj = {};
  }
  if (splitEvents === void 0) {
    splitEvents = true;
  }
  const params = {
    on: {}
  };
  const events2 = {};
  const passedParams = {};
  extend(params, defaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined")
      return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events2[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true)
      params[key] = {};
    if (params[key] === false)
      delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events: events2
  };
}
function mountSwiper(_ref, swiperParams) {
  let {
    el,
    nextEl,
    prevEl,
    paginationEl,
    scrollbarEl,
    swiper: swiper2
  } = _ref;
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper2.params.navigation.nextEl = nextEl;
    swiper2.originalParams.navigation.nextEl = nextEl;
    swiper2.params.navigation.prevEl = prevEl;
    swiper2.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper2.params.pagination.el = paginationEl;
    swiper2.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper2.params.scrollbar.el = scrollbarEl;
    swiper2.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper2.init(el);
}
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys2 = [];
  if (!oldParams)
    return keys2;
  const addKey = (key) => {
    if (keys2.indexOf(key) < 0)
      keys2.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join(""))
      addKey("children");
    if (oldChildren.length !== children.length)
      addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject(swiperParams[key]) && isObject(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
              addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys2;
}
const updateOnVirtualData = (swiper2) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params.virtual || swiper2.params.virtual && !swiper2.params.virtual.enabled)
    return;
  swiper2.updateSlides();
  swiper2.updateProgress();
  swiper2.updateSlidesClasses();
  if (swiper2.parallax && swiper2.params.parallax && swiper2.params.parallax.enabled) {
    swiper2.parallax.setTranslate();
  }
};
function getChildren(originalSlots, slidesRef, oldSlidesRef) {
  if (originalSlots === void 0) {
    originalSlots = {};
  }
  const slides = [];
  const slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  const getSlidesFromElements = (els, slotName) => {
    if (!Array.isArray(els)) {
      return;
    }
    els.forEach((vnode) => {
      const isFragment = typeof vnode.type === "symbol";
      if (slotName === "default")
        slotName = "container-end";
      if (isFragment && vnode.children) {
        getSlidesFromElements(vnode.children, slotName);
      } else if (vnode.type && (vnode.type.name === "SwiperSlide" || vnode.type.name === "AsyncComponentWrapper") || vnode.componentOptions && vnode.componentOptions.tag === "SwiperSlide") {
        slides.push(vnode);
      } else if (slots[slotName]) {
        slots[slotName].push(vnode);
      }
    });
  };
  Object.keys(originalSlots).forEach((slotName) => {
    if (typeof originalSlots[slotName] !== "function")
      return;
    const els = originalSlots[slotName]();
    getSlidesFromElements(els, slotName);
  });
  oldSlidesRef.value = slidesRef.value;
  slidesRef.value = slides;
  return {
    slides,
    slots
  };
}
function renderVirtual(swiperRef, slides, virtualData) {
  if (!virtualData)
    return null;
  const getSlideIndex = (index) => {
    let slideIndex = index;
    if (index < 0) {
      slideIndex = slides.length + index;
    } else if (slideIndex >= slides.length) {
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style2 = swiperRef.value.isHorizontal() ? {
    [swiperRef.value.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  const {
    from: from2,
    to
  } = virtualData;
  const loopFrom = swiperRef.value.params.loop ? -slides.length : 0;
  const loopTo = swiperRef.value.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i = loopFrom; i < loopTo; i += 1) {
    if (i >= from2 && i <= to && slidesToRender.length < slides.length) {
      slidesToRender.push(slides[getSlideIndex(i)]);
    }
  }
  return slidesToRender.map((slide2) => {
    if (!slide2.props)
      slide2.props = {};
    if (!slide2.props.style)
      slide2.props.style = {};
    slide2.props.swiperRef = swiperRef;
    slide2.props.style = style2;
    if (slide2.type) {
      return vue.h(slide2.type, {
        ...slide2.props
      }, slide2.children);
    } else if (slide2.componentOptions) {
      return vue.h(slide2.componentOptions.Ctor, {
        ...slide2.props
      }, slide2.componentOptions.children);
    }
  });
}
const Swiper2 = {
  name: "Swiper",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    wrapperTag: {
      type: String,
      default: "div"
    },
    modules: {
      type: Array,
      default: void 0
    },
    init: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String,
      default: void 0
    },
    oneWayMovement: {
      type: Boolean,
      default: void 0
    },
    swiperElementNodeName: {
      type: String,
      default: "SWIPER-CONTAINER"
    },
    touchEventsTarget: {
      type: String,
      default: void 0
    },
    initialSlide: {
      type: Number,
      default: void 0
    },
    speed: {
      type: Number,
      default: void 0
    },
    cssMode: {
      type: Boolean,
      default: void 0
    },
    updateOnWindowResize: {
      type: Boolean,
      default: void 0
    },
    resizeObserver: {
      type: Boolean,
      default: void 0
    },
    nested: {
      type: Boolean,
      default: void 0
    },
    focusableElements: {
      type: String,
      default: void 0
    },
    width: {
      type: Number,
      default: void 0
    },
    height: {
      type: Number,
      default: void 0
    },
    preventInteractionOnTransition: {
      type: Boolean,
      default: void 0
    },
    userAgent: {
      type: String,
      default: void 0
    },
    url: {
      type: String,
      default: void 0
    },
    edgeSwipeDetection: {
      type: [Boolean, String],
      default: void 0
    },
    edgeSwipeThreshold: {
      type: Number,
      default: void 0
    },
    autoHeight: {
      type: Boolean,
      default: void 0
    },
    setWrapperSize: {
      type: Boolean,
      default: void 0
    },
    virtualTranslate: {
      type: Boolean,
      default: void 0
    },
    effect: {
      type: String,
      default: void 0
    },
    breakpoints: {
      type: Object,
      default: void 0
    },
    breakpointsBase: {
      type: String,
      default: void 0
    },
    spaceBetween: {
      type: [Number, String],
      default: void 0
    },
    slidesPerView: {
      type: [Number, String],
      default: void 0
    },
    maxBackfaceHiddenSlides: {
      type: Number,
      default: void 0
    },
    slidesPerGroup: {
      type: Number,
      default: void 0
    },
    slidesPerGroupSkip: {
      type: Number,
      default: void 0
    },
    slidesPerGroupAuto: {
      type: Boolean,
      default: void 0
    },
    centeredSlides: {
      type: Boolean,
      default: void 0
    },
    centeredSlidesBounds: {
      type: Boolean,
      default: void 0
    },
    slidesOffsetBefore: {
      type: Number,
      default: void 0
    },
    slidesOffsetAfter: {
      type: Number,
      default: void 0
    },
    normalizeSlideIndex: {
      type: Boolean,
      default: void 0
    },
    centerInsufficientSlides: {
      type: Boolean,
      default: void 0
    },
    watchOverflow: {
      type: Boolean,
      default: void 0
    },
    roundLengths: {
      type: Boolean,
      default: void 0
    },
    touchRatio: {
      type: Number,
      default: void 0
    },
    touchAngle: {
      type: Number,
      default: void 0
    },
    simulateTouch: {
      type: Boolean,
      default: void 0
    },
    shortSwipes: {
      type: Boolean,
      default: void 0
    },
    longSwipes: {
      type: Boolean,
      default: void 0
    },
    longSwipesRatio: {
      type: Number,
      default: void 0
    },
    longSwipesMs: {
      type: Number,
      default: void 0
    },
    followFinger: {
      type: Boolean,
      default: void 0
    },
    allowTouchMove: {
      type: Boolean,
      default: void 0
    },
    threshold: {
      type: Number,
      default: void 0
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: void 0
    },
    touchStartPreventDefault: {
      type: Boolean,
      default: void 0
    },
    touchStartForcePreventDefault: {
      type: Boolean,
      default: void 0
    },
    touchReleaseOnEdges: {
      type: Boolean,
      default: void 0
    },
    uniqueNavElements: {
      type: Boolean,
      default: void 0
    },
    resistance: {
      type: Boolean,
      default: void 0
    },
    resistanceRatio: {
      type: Number,
      default: void 0
    },
    watchSlidesProgress: {
      type: Boolean,
      default: void 0
    },
    grabCursor: {
      type: Boolean,
      default: void 0
    },
    preventClicks: {
      type: Boolean,
      default: void 0
    },
    preventClicksPropagation: {
      type: Boolean,
      default: void 0
    },
    slideToClickedSlide: {
      type: Boolean,
      default: void 0
    },
    loop: {
      type: Boolean,
      default: void 0
    },
    loopedSlides: {
      type: Number,
      default: void 0
    },
    loopPreventsSliding: {
      type: Boolean,
      default: void 0
    },
    rewind: {
      type: Boolean,
      default: void 0
    },
    allowSlidePrev: {
      type: Boolean,
      default: void 0
    },
    allowSlideNext: {
      type: Boolean,
      default: void 0
    },
    swipeHandler: {
      type: Boolean,
      default: void 0
    },
    noSwiping: {
      type: Boolean,
      default: void 0
    },
    noSwipingClass: {
      type: String,
      default: void 0
    },
    noSwipingSelector: {
      type: String,
      default: void 0
    },
    passiveListeners: {
      type: Boolean,
      default: void 0
    },
    containerModifierClass: {
      type: String,
      default: void 0
    },
    slideClass: {
      type: String,
      default: void 0
    },
    slideActiveClass: {
      type: String,
      default: void 0
    },
    slideVisibleClass: {
      type: String,
      default: void 0
    },
    slideFullyVisibleClass: {
      type: String,
      default: void 0
    },
    slideBlankClass: {
      type: String,
      default: void 0
    },
    slideNextClass: {
      type: String,
      default: void 0
    },
    slidePrevClass: {
      type: String,
      default: void 0
    },
    wrapperClass: {
      type: String,
      default: void 0
    },
    lazyPreloaderClass: {
      type: String,
      default: void 0
    },
    lazyPreloadPrevNext: {
      type: Number,
      default: void 0
    },
    runCallbacksOnInit: {
      type: Boolean,
      default: void 0
    },
    observer: {
      type: Boolean,
      default: void 0
    },
    observeParents: {
      type: Boolean,
      default: void 0
    },
    observeSlideChildren: {
      type: Boolean,
      default: void 0
    },
    a11y: {
      type: [Boolean, Object],
      default: void 0
    },
    autoplay: {
      type: [Boolean, Object],
      default: void 0
    },
    controller: {
      type: Object,
      default: void 0
    },
    coverflowEffect: {
      type: Object,
      default: void 0
    },
    cubeEffect: {
      type: Object,
      default: void 0
    },
    fadeEffect: {
      type: Object,
      default: void 0
    },
    flipEffect: {
      type: Object,
      default: void 0
    },
    creativeEffect: {
      type: Object,
      default: void 0
    },
    cardsEffect: {
      type: Object,
      default: void 0
    },
    hashNavigation: {
      type: [Boolean, Object],
      default: void 0
    },
    history: {
      type: [Boolean, Object],
      default: void 0
    },
    keyboard: {
      type: [Boolean, Object],
      default: void 0
    },
    mousewheel: {
      type: [Boolean, Object],
      default: void 0
    },
    navigation: {
      type: [Boolean, Object],
      default: void 0
    },
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    parallax: {
      type: [Boolean, Object],
      default: void 0
    },
    scrollbar: {
      type: [Boolean, Object],
      default: void 0
    },
    thumbs: {
      type: Object,
      default: void 0
    },
    virtual: {
      type: [Boolean, Object],
      default: void 0
    },
    zoom: {
      type: [Boolean, Object],
      default: void 0
    },
    grid: {
      type: [Object],
      default: void 0
    },
    freeMode: {
      type: [Boolean, Object],
      default: void 0
    },
    enabled: {
      type: Boolean,
      default: void 0
    }
  },
  emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "autoplayTimeLeft", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "init", "keyPress", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slidesUpdated", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
  setup(props, _ref) {
    let {
      slots: originalSlots,
      emit
    } = _ref;
    const {
      tag: Tag,
      wrapperTag: WrapperTag
    } = props;
    const containerClasses = vue.ref("swiper");
    const virtualData = vue.ref(null);
    const breakpointChanged = vue.ref(false);
    const initializedRef = vue.ref(false);
    const swiperElRef = vue.ref(null);
    const swiperRef = vue.ref(null);
    const oldPassedParamsRef = vue.ref(null);
    const slidesRef = {
      value: []
    };
    const oldSlidesRef = {
      value: []
    };
    const nextElRef = vue.ref(null);
    const prevElRef = vue.ref(null);
    const paginationElRef = vue.ref(null);
    const scrollbarElRef = vue.ref(null);
    const {
      params: swiperParams,
      passedParams
    } = getParams(props, false);
    getChildren(originalSlots, slidesRef, oldSlidesRef);
    oldPassedParamsRef.value = passedParams;
    oldSlidesRef.value = slidesRef.value;
    const onBeforeBreakpoint = () => {
      getChildren(originalSlots, slidesRef, oldSlidesRef);
      breakpointChanged.value = true;
    };
    swiperParams.onAny = function(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      emit(event2, ...args);
    };
    Object.assign(swiperParams.on, {
      _beforeBreakpoint: onBeforeBreakpoint,
      _containerClasses(swiper2, classes2) {
        containerClasses.value = classes2;
      }
    });
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.value = new Swiper$1(passParams);
    if (swiperRef.value.virtual && swiperRef.value.params.virtual.enabled) {
      swiperRef.value.virtual.slides = slidesRef.value;
      const extendWith = {
        cache: false,
        slides: slidesRef.value,
        renderExternal: (data) => {
          virtualData.value = data;
        },
        renderExternalUpdate: false
      };
      extend(swiperRef.value.params.virtual, extendWith);
      extend(swiperRef.value.originalParams.virtual, extendWith);
    }
    vue.onUpdated(() => {
      if (!initializedRef.value && swiperRef.value) {
        swiperRef.value.emitSlidesClasses();
        initializedRef.value = true;
      }
      const {
        passedParams: newPassedParams
      } = getParams(props, false);
      const changedParams = getChangedParams(newPassedParams, oldPassedParamsRef.value, slidesRef.value, oldSlidesRef.value, (c) => c.props && c.props.key);
      oldPassedParamsRef.value = newPassedParams;
      if ((changedParams.length || breakpointChanged.value) && swiperRef.value && !swiperRef.value.destroyed) {
        updateSwiper({
          swiper: swiperRef.value,
          slides: slidesRef.value,
          passedParams: newPassedParams,
          changedParams,
          nextEl: nextElRef.value,
          prevEl: prevElRef.value,
          scrollbarEl: scrollbarElRef.value,
          paginationEl: paginationElRef.value
        });
      }
      breakpointChanged.value = false;
    });
    vue.provide("swiper", swiperRef);
    vue.watch(virtualData, () => {
      vue.nextTick(() => {
        updateOnVirtualData(swiperRef.value);
      });
    });
    vue.onMounted(() => {
      if (!swiperElRef.value)
        return;
      mountSwiper({
        el: swiperElRef.value,
        nextEl: nextElRef.value,
        prevEl: prevElRef.value,
        paginationEl: paginationElRef.value,
        scrollbarEl: scrollbarElRef.value,
        swiper: swiperRef.value
      }, swiperParams);
      emit("swiper", swiperRef.value);
    });
    vue.onBeforeUnmount(() => {
      if (swiperRef.value && !swiperRef.value.destroyed) {
        swiperRef.value.destroy(true, false);
      }
    });
    function renderSlides(slides) {
      if (swiperParams.virtual) {
        return renderVirtual(swiperRef, slides, virtualData.value);
      }
      slides.forEach((slide2, index) => {
        if (!slide2.props)
          slide2.props = {};
        slide2.props.swiperRef = swiperRef;
        slide2.props.swiperSlideIndex = index;
      });
      return slides;
    }
    return () => {
      const {
        slides,
        slots
      } = getChildren(originalSlots, slidesRef, oldSlidesRef);
      return vue.h(Tag, {
        ref: swiperElRef,
        class: uniqueClasses(containerClasses.value)
      }, [slots["container-start"], vue.h(WrapperTag, {
        class: wrapperClass(swiperParams.wrapperClass)
      }, [slots["wrapper-start"], renderSlides(slides), slots["wrapper-end"]]), needsNavigation(props) && [vue.h("div", {
        ref: prevElRef,
        class: "swiper-button-prev"
      }), vue.h("div", {
        ref: nextElRef,
        class: "swiper-button-next"
      })], needsScrollbar(props) && vue.h("div", {
        ref: scrollbarElRef,
        class: "swiper-scrollbar"
      }), needsPagination(props) && vue.h("div", {
        ref: paginationElRef,
        class: "swiper-pagination"
      }), slots["container-end"]]);
    };
  }
};
const SwiperSlide = {
  name: "SwiperSlide",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    swiperRef: {
      type: Object,
      required: false
    },
    swiperSlideIndex: {
      type: Number,
      default: void 0,
      required: false
    },
    zoom: {
      type: Boolean,
      default: void 0,
      required: false
    },
    lazy: {
      type: Boolean,
      default: false,
      required: false
    },
    virtualIndex: {
      type: [String, Number],
      default: void 0
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    let eventAttached = false;
    const {
      swiperRef
    } = props;
    const slideElRef = vue.ref(null);
    const slideClasses = vue.ref("swiper-slide");
    const lazyLoaded = vue.ref(false);
    function updateClasses(swiper2, el, classNames) {
      if (el === slideElRef.value) {
        slideClasses.value = classNames;
      }
    }
    vue.onMounted(() => {
      if (!swiperRef || !swiperRef.value)
        return;
      swiperRef.value.on("_slideClass", updateClasses);
      eventAttached = true;
    });
    vue.onBeforeUpdate(() => {
      if (eventAttached || !swiperRef || !swiperRef.value)
        return;
      swiperRef.value.on("_slideClass", updateClasses);
      eventAttached = true;
    });
    vue.onUpdated(() => {
      if (!slideElRef.value || !swiperRef || !swiperRef.value)
        return;
      if (typeof props.swiperSlideIndex !== "undefined") {
        slideElRef.value.swiperSlideIndex = props.swiperSlideIndex;
      }
      if (swiperRef.value.destroyed) {
        if (slideClasses.value !== "swiper-slide") {
          slideClasses.value = "swiper-slide";
        }
      }
    });
    vue.onBeforeUnmount(() => {
      if (!swiperRef || !swiperRef.value)
        return;
      swiperRef.value.off("_slideClass", updateClasses);
    });
    const slideData = vue.computed(() => ({
      isActive: slideClasses.value.indexOf("swiper-slide-active") >= 0,
      isVisible: slideClasses.value.indexOf("swiper-slide-visible") >= 0,
      isPrev: slideClasses.value.indexOf("swiper-slide-prev") >= 0,
      isNext: slideClasses.value.indexOf("swiper-slide-next") >= 0
    }));
    vue.provide("swiperSlide", slideData);
    const onLoad2 = () => {
      lazyLoaded.value = true;
    };
    return () => {
      return vue.h(props.tag, {
        class: uniqueClasses(`${slideClasses.value}`),
        ref: slideElRef,
        "data-swiper-slide-index": typeof props.virtualIndex === "undefined" && swiperRef && swiperRef.value && swiperRef.value.params.loop ? props.swiperSlideIndex : props.virtualIndex,
        onLoadCapture: onLoad2
      }, props.zoom ? vue.h("div", {
        class: "swiper-zoom-container",
        "data-swiper-zoom": typeof props.zoom === "number" ? props.zoom : void 0
      }, [slots.default && slots.default(slideData.value), props.lazy && !lazyLoaded.value && vue.h("div", {
        class: "swiper-lazy-preloader"
      })]) : [slots.default && slots.default(slideData.value), props.lazy && !lazyLoaded.value && vue.h("div", {
        class: "swiper-lazy-preloader"
      })]);
    };
  }
};
function Virtual(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document2 = getDocument();
  swiper2.virtual = {
    cache: {},
    from: void 0,
    to: void 0,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document2.createElement("div");
  function renderSlide(slide2, index) {
    const params = swiper2.params.virtual;
    if (params.cache && swiper2.virtual.cache[index]) {
      return swiper2.virtual.cache[index];
    }
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper2, slide2, index);
      if (typeof slideEl === "string") {
        tempDOM.innerHTML = slideEl;
        slideEl = tempDOM.children[0];
      }
    } else if (swiper2.isElement) {
      slideEl = createElement("swiper-slide");
    } else {
      slideEl = createElement("div", swiper2.params.slideClass);
    }
    slideEl.setAttribute("data-swiper-slide-index", index);
    if (!params.renderSlide) {
      slideEl.innerHTML = slide2;
    }
    if (params.cache) {
      swiper2.virtual.cache[index] = slideEl;
    }
    return slideEl;
  }
  function update2(force, beforeInit) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides,
      loop: isLoop,
      initialSlide
    } = swiper2.params;
    if (beforeInit && !isLoop && initialSlide > 0) {
      return;
    }
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper2.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper2.virtual;
    if (!swiper2.params.cssMode) {
      swiper2.updateActiveIndex();
    }
    const activeIndex = swiper2.activeIndex || 0;
    let offsetProp;
    if (swiper2.rtlTranslate)
      offsetProp = "right";
    else
      offsetProp = swiper2.isHorizontal() ? "left" : "top";
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
    }
    let from2 = activeIndex - slidesBefore;
    let to = activeIndex + slidesAfter;
    if (!isLoop) {
      from2 = Math.max(from2, 0);
      to = Math.min(to, slides.length - 1);
    }
    let offset2 = (swiper2.slidesGrid[from2] || 0) - (swiper2.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from2 -= slidesBefore;
      if (!centeredSlides)
        offset2 += swiper2.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from2 = -slidesBefore;
      if (centeredSlides)
        offset2 += swiper2.slidesGrid[0];
    }
    Object.assign(swiper2.virtual, {
      from: from2,
      to,
      offset: offset2,
      slidesGrid: swiper2.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper2.updateSlides();
      swiper2.updateProgress();
      swiper2.updateSlidesClasses();
      emit("virtualUpdate");
    }
    if (previousFrom === from2 && previousTo === to && !force) {
      if (swiper2.slidesGrid !== previousSlidesGrid && offset2 !== previousOffset) {
        swiper2.slides.forEach((slideEl) => {
          slideEl.style[offsetProp] = `${offset2 - Math.abs(swiper2.cssOverflowAdjustment())}px`;
        });
      }
      swiper2.updateProgress();
      emit("virtualUpdate");
      return;
    }
    if (swiper2.params.virtual.renderExternal) {
      swiper2.params.virtual.renderExternal.call(swiper2, {
        offset: offset2,
        from: from2,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from2; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper2.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit("virtualUpdate");
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = (index) => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper2.slides.filter((el) => el.matches(`.${swiper2.params.slideClass}, swiper-slide`)).forEach((slideEl) => {
        slideEl.remove();
      });
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from2 || i > to) {
          const slideIndex = getSlideIndex(i);
          swiper2.slides.filter((el) => el.matches(`.${swiper2.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach((slideEl) => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i = loopFrom; i < loopTo; i += 1) {
      if (i >= from2 && i <= to) {
        const slideIndex = getSlideIndex(i);
        if (typeof previousTo === "undefined" || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i > previousTo)
            appendIndexes.push(slideIndex);
          if (i < previousFrom)
            prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper2.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
        const index = prependIndexes[i];
        swiper2.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a, b) => b - a);
      prependIndexes.forEach((index) => {
        swiper2.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    elementChildren(swiper2.slidesEl, ".swiper-slide, swiper-slide").forEach((slideEl) => {
      slideEl.style[offsetProp] = `${offset2 - Math.abs(swiper2.cssOverflowAdjustment())}px`;
    });
    onRendered();
  }
  function appendSlide2(slides) {
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          swiper2.virtual.slides.push(slides[i]);
      }
    } else {
      swiper2.virtual.slides.push(slides);
    }
    update2(true);
  }
  function prependSlide2(slides) {
    const activeIndex = swiper2.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          swiper2.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper2.virtual.slides.unshift(slides);
    }
    if (swiper2.params.virtual.cache) {
      const cache2 = swiper2.virtual.cache;
      const newCache = {};
      Object.keys(cache2).forEach((cachedIndex) => {
        const cachedEl = cache2[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute("data-swiper-slide-index");
        if (cachedElIndex) {
          cachedEl.setAttribute("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper2.virtual.cache = newCache;
    }
    update2(true);
    swiper2.slideTo(newActiveIndex, 0);
  }
  function removeSlide2(slidesIndexes) {
    if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
      return;
    let activeIndex = swiper2.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        if (swiper2.params.virtual.cache) {
          delete swiper2.virtual.cache[slidesIndexes[i]];
          Object.keys(swiper2.virtual.cache).forEach((key) => {
            if (key > slidesIndexes) {
              swiper2.virtual.cache[key - 1] = swiper2.virtual.cache[key];
              swiper2.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
              delete swiper2.virtual.cache[key];
            }
          });
        }
        swiper2.virtual.slides.splice(slidesIndexes[i], 1);
        if (slidesIndexes[i] < activeIndex)
          activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      if (swiper2.params.virtual.cache) {
        delete swiper2.virtual.cache[slidesIndexes];
        Object.keys(swiper2.virtual.cache).forEach((key) => {
          if (key > slidesIndexes) {
            swiper2.virtual.cache[key - 1] = swiper2.virtual.cache[key];
            swiper2.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
            delete swiper2.virtual.cache[key];
          }
        });
      }
      swiper2.virtual.slides.splice(slidesIndexes, 1);
      if (slidesIndexes < activeIndex)
        activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update2(true);
    swiper2.slideTo(activeIndex, 0);
  }
  function removeAllSlides2() {
    swiper2.virtual.slides = [];
    if (swiper2.params.virtual.cache) {
      swiper2.virtual.cache = {};
    }
    update2(true);
    swiper2.slideTo(0, 0);
  }
  on2("beforeInit", () => {
    if (!swiper2.params.virtual.enabled)
      return;
    let domSlidesAssigned;
    if (typeof swiper2.passedParams.virtual.slides === "undefined") {
      const slides = [...swiper2.slidesEl.children].filter((el) => el.matches(`.${swiper2.params.slideClass}, swiper-slide`));
      if (slides && slides.length) {
        swiper2.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute("data-swiper-slide-index", slideIndex);
          swiper2.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper2.virtual.slides = swiper2.params.virtual.slides;
    }
    swiper2.classNames.push(`${swiper2.params.containerModifierClass}virtual`);
    swiper2.params.watchSlidesProgress = true;
    swiper2.originalParams.watchSlidesProgress = true;
    update2(false, true);
  });
  on2("setTranslate", () => {
    if (!swiper2.params.virtual.enabled)
      return;
    if (swiper2.params.cssMode && !swiper2._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update2();
      }, 100);
    } else {
      update2();
    }
  });
  on2("init update resize", () => {
    if (!swiper2.params.virtual.enabled)
      return;
    if (swiper2.params.cssMode) {
      setCSSProperty(swiper2.wrapperEl, "--swiper-virtual-size", `${swiper2.virtualSize}px`);
    }
  });
  Object.assign(swiper2.virtual, {
    appendSlide: appendSlide2,
    prependSlide: prependSlide2,
    removeSlide: removeSlide2,
    removeAllSlides: removeAllSlides2,
    update: update2
  });
}
function Mousewheel(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: "swiper-no-mousewheel"
    }
  });
  swiper2.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = now();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0;
    let pX = 0;
    let pY = 0;
    if ("detail" in e) {
      sY = e.detail;
    }
    if ("wheelDelta" in e) {
      sY = -e.wheelDelta / 120;
    }
    if ("wheelDeltaY" in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in e) {
      sX = -e.wheelDeltaX / 120;
    }
    if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in e) {
      pY = e.deltaY;
    }
    if ("deltaX" in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper2.enabled)
      return;
    swiper2.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper2.enabled)
      return;
    swiper2.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper2.params.mousewheel.thresholdDelta && newEvent.delta < swiper2.params.mousewheel.thresholdDelta) {
      return false;
    }
    if (swiper2.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper2.params.mousewheel.thresholdTime) {
      return false;
    }
    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
      return true;
    }
    if (newEvent.direction < 0) {
      if ((!swiper2.isEnd || swiper2.params.loop) && !swiper2.animating) {
        swiper2.slideNext();
        emit("scroll", newEvent.raw);
      }
    } else if ((!swiper2.isBeginning || swiper2.params.loop) && !swiper2.animating) {
      swiper2.slidePrev();
      emit("scroll", newEvent.raw);
    }
    lastScrollTime = new window2.Date().getTime();
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper2.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper2.isEnd && !swiper2.params.loop && params.releaseOnEdges) {
        return true;
      }
    } else if (swiper2.isBeginning && !swiper2.params.loop && params.releaseOnEdges) {
      return true;
    }
    return false;
  }
  function handle(event2) {
    let e = event2;
    let disableParentSwiper = true;
    if (!swiper2.enabled)
      return;
    if (event2.target.closest(`.${swiper2.params.mousewheel.noMousewheelClass}`))
      return;
    const params = swiper2.params.mousewheel;
    if (swiper2.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper2.el;
    if (swiper2.params.mousewheel.eventsTarget !== "container") {
      targetEl = document.querySelector(swiper2.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper2.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges)
      return true;
    if (e.originalEvent)
      e = e.originalEvent;
    let delta = 0;
    const rtlFactor = swiper2.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper2.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
          delta = -data.pixelX * rtlFactor;
        else
          return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
        delta = -data.pixelY;
      else
        return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0)
      return true;
    if (params.invert)
      delta = -delta;
    let positions = swiper2.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper2.minTranslate())
      positions = swiper2.minTranslate();
    if (positions <= swiper2.maxTranslate())
      positions = swiper2.maxTranslate();
    disableParentSwiper = swiper2.params.loop ? true : !(positions === swiper2.minTranslate() || positions === swiper2.maxTranslate());
    if (disableParentSwiper && swiper2.params.nested)
      e.stopPropagation();
    if (!swiper2.params.freeMode || !swiper2.params.freeMode.enabled) {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event2
      };
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift();
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
      recentWheelEvents.push(newEvent);
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = void 0;
        let position2 = swiper2.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper2.isBeginning;
        const wasEnd = swiper2.isEnd;
        if (position2 >= swiper2.minTranslate())
          position2 = swiper2.minTranslate();
        if (position2 <= swiper2.maxTranslate())
          position2 = swiper2.maxTranslate();
        swiper2.setTransition(0);
        swiper2.setTranslate(position2);
        swiper2.updateProgress();
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
        if (!wasBeginning && swiper2.isBeginning || !wasEnd && swiper2.isEnd) {
          swiper2.updateSlidesClasses();
        }
        if (swiper2.params.loop) {
          swiper2.loopFix({
            direction: newEvent.direction < 0 ? "next" : "prev",
            byMousewheel: true
          });
        }
        if (swiper2.params.freeMode.sticky) {
          clearTimeout(timeout);
          timeout = void 0;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift();
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick(() => {
              if (swiper2.destroyed || !swiper2.params)
                return;
              swiper2.slideToClosest(swiper2.params.speed, true, void 0, snapToThreshold);
            }, 0);
          }
          if (!timeout) {
            timeout = nextTick(() => {
              if (swiper2.destroyed || !swiper2.params)
                return;
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper2.slideToClosest(swiper2.params.speed, true, void 0, snapToThreshold);
            }, 500);
          }
        }
        if (!ignoreWheelEvents)
          emit("scroll", e);
        if (swiper2.params.autoplay && swiper2.params.autoplayDisableOnInteraction)
          swiper2.autoplay.stop();
        if (params.releaseOnEdges && (position2 === swiper2.minTranslate() || position2 === swiper2.maxTranslate())) {
          return true;
        }
      }
    }
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
    return false;
  }
  function events2(method) {
    let targetEl = swiper2.el;
    if (swiper2.params.mousewheel.eventsTarget !== "container") {
      targetEl = document.querySelector(swiper2.params.mousewheel.eventsTarget);
    }
    targetEl[method]("mouseenter", handleMouseEnter);
    targetEl[method]("mouseleave", handleMouseLeave);
    targetEl[method]("wheel", handle);
  }
  function enable() {
    if (swiper2.params.cssMode) {
      swiper2.wrapperEl.removeEventListener("wheel", handle);
      return true;
    }
    if (swiper2.mousewheel.enabled)
      return false;
    events2("addEventListener");
    swiper2.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper2.params.cssMode) {
      swiper2.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper2.mousewheel.enabled)
      return false;
    events2("removeEventListener");
    swiper2.mousewheel.enabled = false;
    return true;
  }
  on2("init", () => {
    if (!swiper2.params.mousewheel.enabled && swiper2.params.cssMode) {
      disable();
    }
    if (swiper2.params.mousewheel.enabled)
      enable();
  });
  on2("destroy", () => {
    if (swiper2.params.cssMode) {
      enable();
    }
    if (swiper2.mousewheel.enabled)
      disable();
  });
  Object.assign(swiper2.mousewheel, {
    enable,
    disable
  });
}
function createElementIfNotDefined(swiper2, originalParams, params, checkProps) {
  if (swiper2.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = elementChildren(swiper2.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = createElement("div", checkProps[key]);
          element.className = checkProps[key];
          swiper2.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
function Navigation(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  });
  swiper2.navigation = {
    nextEl: null,
    prevEl: null
  };
  function getEl(el) {
    let res;
    if (el && typeof el === "string" && swiper2.isElement) {
      res = swiper2.el.querySelector(el);
      if (res)
        return res;
    }
    if (el) {
      if (typeof el === "string")
        res = [...document.querySelectorAll(el)];
      if (swiper2.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper2.el.querySelectorAll(el).length === 1) {
        res = swiper2.el.querySelector(el);
      } else if (res && res.length === 1) {
        res = res[0];
      }
    }
    if (el && !res)
      return el;
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper2.params.navigation;
    el = makeElementsArray(el);
    el.forEach((subEl) => {
      if (subEl) {
        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
        if (subEl.tagName === "BUTTON")
          subEl.disabled = disabled;
        if (swiper2.params.watchOverflow && swiper2.enabled) {
          subEl.classList[swiper2.isLocked ? "add" : "remove"](params.lockClass);
        }
      }
    });
  }
  function update2() {
    const {
      nextEl,
      prevEl
    } = swiper2.navigation;
    if (swiper2.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper2.isBeginning && !swiper2.params.rewind);
    toggleEl(nextEl, swiper2.isEnd && !swiper2.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper2.isBeginning && !swiper2.params.loop && !swiper2.params.rewind)
      return;
    swiper2.slidePrev();
    emit("navigationPrev");
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper2.isEnd && !swiper2.params.loop && !swiper2.params.rewind)
      return;
    swiper2.slideNext();
    emit("navigationNext");
  }
  function init() {
    const params = swiper2.params.navigation;
    swiper2.params.navigation = createElementIfNotDefined(swiper2, swiper2.originalParams.navigation, swiper2.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl))
      return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper2.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      }
      if (!swiper2.enabled && el) {
        el.classList.add(...params.lockClass.split(" "));
      }
    };
    nextEl.forEach((el) => initButton(el, "next"));
    prevEl.forEach((el) => initButton(el, "prev"));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper2.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
      el.classList.remove(...swiper2.params.navigation.disabledClass.split(" "));
    };
    nextEl.forEach((el) => destroyButton(el, "next"));
    prevEl.forEach((el) => destroyButton(el, "prev"));
  }
  on2("init", () => {
    if (swiper2.params.navigation.enabled === false) {
      disable();
    } else {
      init();
      update2();
    }
  });
  on2("toEdge fromEdge lock unlock", () => {
    update2();
  });
  on2("destroy", () => {
    destroy();
  });
  on2("enable disable", () => {
    let {
      nextEl,
      prevEl
    } = swiper2.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (swiper2.enabled) {
      update2();
      return;
    }
    [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.add(swiper2.params.navigation.lockClass));
  });
  on2("click", (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper2.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
    if (swiper2.isElement && !targetIsButton) {
      const path2 = e.path || e.composedPath && e.composedPath();
      if (path2) {
        targetIsButton = path2.find((pathEl) => nextEl.includes(pathEl) || prevEl.includes(pathEl));
      }
    }
    if (swiper2.params.navigation.hideOnClick && !targetIsButton) {
      if (swiper2.pagination && swiper2.params.pagination && swiper2.params.pagination.clickable && (swiper2.pagination.el === targetEl || swiper2.pagination.el.contains(targetEl)))
        return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper2.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper2.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      [...nextEl, ...prevEl].filter((el) => !!el).forEach((el) => el.classList.toggle(swiper2.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper2.el.classList.remove(...swiper2.params.navigation.navigationDisabledClass.split(" "));
    init();
    update2();
  };
  const disable = () => {
    swiper2.el.classList.add(...swiper2.params.navigation.navigationDisabledClass.split(" "));
    destroy();
  };
  Object.assign(swiper2.navigation, {
    enable,
    disable,
    update: update2,
    init,
    destroy
  });
}
function appendSlide(slides) {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  if (params.loop) {
    swiper2.loopDestroy();
  }
  const appendElement2 = (slideEl) => {
    if (typeof slideEl === "string") {
      const tempDOM = document.createElement("div");
      tempDOM.innerHTML = slideEl;
      slidesEl.append(tempDOM.children[0]);
      tempDOM.innerHTML = "";
    } else {
      slidesEl.append(slideEl);
    }
  };
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        appendElement2(slides[i]);
    }
  } else {
    appendElement2(slides);
  }
  swiper2.recalcSlides();
  if (params.loop) {
    swiper2.loopCreate();
  }
  if (!params.observer || swiper2.isElement) {
    swiper2.update();
  }
}
function prependSlide(slides) {
  const swiper2 = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper2;
  if (params.loop) {
    swiper2.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  const prependElement = (slideEl) => {
    if (typeof slideEl === "string") {
      const tempDOM = document.createElement("div");
      tempDOM.innerHTML = slideEl;
      slidesEl.prepend(tempDOM.children[0]);
      tempDOM.innerHTML = "";
    } else {
      slidesEl.prepend(slideEl);
    }
  };
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        prependElement(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    prependElement(slides);
  }
  swiper2.recalcSlides();
  if (params.loop) {
    swiper2.loopCreate();
  }
  if (!params.observer || swiper2.isElement) {
    swiper2.update();
  }
  swiper2.slideTo(newActiveIndex, 0, false);
}
function addSlide(index, slides) {
  const swiper2 = this;
  const {
    params,
    activeIndex,
    slidesEl
  } = swiper2;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper2.loopedSlides;
    swiper2.loopDestroy();
    swiper2.recalcSlides();
  }
  const baseLength = swiper2.slides.length;
  if (index <= 0) {
    swiper2.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper2.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper2.slides[i];
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        slidesEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    slidesEl.append(slides);
  }
  for (let i = 0; i < slidesBuffer.length; i += 1) {
    slidesEl.append(slidesBuffer[i]);
  }
  swiper2.recalcSlides();
  if (params.loop) {
    swiper2.loopCreate();
  }
  if (!params.observer || swiper2.isElement) {
    swiper2.update();
  }
  if (params.loop) {
    swiper2.slideTo(newActiveIndex + swiper2.loopedSlides, 0, false);
  } else {
    swiper2.slideTo(newActiveIndex, 0, false);
  }
}
function removeSlide(slidesIndexes) {
  const swiper2 = this;
  const {
    params,
    activeIndex
  } = swiper2;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper2.loopedSlides;
    swiper2.loopDestroy();
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper2.slides[indexToRemove])
        swiper2.slides[indexToRemove].remove();
      if (indexToRemove < newActiveIndex)
        newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper2.slides[indexToRemove])
      swiper2.slides[indexToRemove].remove();
    if (indexToRemove < newActiveIndex)
      newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  swiper2.recalcSlides();
  if (params.loop) {
    swiper2.loopCreate();
  }
  if (!params.observer || swiper2.isElement) {
    swiper2.update();
  }
  if (params.loop) {
    swiper2.slideTo(newActiveIndex + swiper2.loopedSlides, 0, false);
  } else {
    swiper2.slideTo(newActiveIndex, 0, false);
  }
}
function removeAllSlides() {
  const swiper2 = this;
  const slidesIndexes = [];
  for (let i = 0; i < swiper2.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper2.removeSlide(slidesIndexes);
}
function Manipulation(_ref) {
  let {
    swiper: swiper2
  } = _ref;
  Object.assign(swiper2, {
    appendSlide: appendSlide.bind(swiper2),
    prependSlide: prependSlide.bind(swiper2),
    addSlide: addSlide.bind(swiper2),
    removeSlide: removeSlide.bind(swiper2),
    removeAllSlides: removeAllSlides.bind(swiper2)
  });
}
const _hoisted_1$8$1 = ["data-seconds", "data-index", "data-id"];
const _hoisted_2$7$1 = ["data-seconds"];
const _hoisted_3$4$1 = ["data-seconds"];
const _hoisted_4$2$1 = ["innerHTML"];
const _hoisted_5$2$1 = { class: "vdb-p-flex vdb-p-w-full vdb-p-items-center vdb-p-justify-between" };
const _hoisted_6$2$1 = ["data-seconds"];
const _hoisted_7$2$1 = ["data-seconds"];
const _sfc_main$8$1 = {
  __name: "SearchResultSlide",
  props: {
    searchContent: {
      type: String,
      default: ""
    },
    searchResultItem: {
      type: Object,
      default: () => {
      }
    },
    searchResultItemIndex: {
      type: Number,
      default: 0
    },
    isLight: {
      type: Boolean,
      default: true
    }
  },
  setup(__props) {
    const props = __props;
    const i = vue.computed(() => props.searchResultItemIndex);
    const start2 = vue.computed(
      () => new Date(parseFloat(props.searchResultItem.start) * 1e3).toISOString()
    );
    const end2 = vue.computed(
      () => props.searchResultItem.type === "relevant" ? new Date(parseFloat(props.searchResultItem.end) * 1e3).toISOString() : null
    );
    const wrapSpan = (strReplace, type) => {
      const searchMask = props.searchContent.trim();
      const regEx = new RegExp(searchMask, "ig");
      const replaceMask = `<span class="text-${props.searchResultItem.type === "relevant" ? "lime" : "yellow"} ${props.isLight ? "light" : ""}">${props.searchContent}</span>`;
      return strReplace.replace(regEx, replaceMask);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass([
          "swiper-slide sr vdb-p-h-full vdb-p-rounded-8 vdb-p-text-left",
          __props.isLight ? "light" : ""
        ]),
        "data-seconds": __props.searchResultItem.start,
        "data-index": i.value,
        "data-id": __props.searchResultItem.id,
        style: { "min-width": "204px" }
      }, [
        vue.createElementVNode("div", {
          class: "vdb-p-flex vdb-p-h-full vdb-p-cursor-pointer vdb-p-flex-col vdb-p-justify-between vdb-p-transition",
          "data-seconds": __props.searchResultItem.start
        }, [
          vue.createElementVNode("p", {
            class: "vdb-p-mb-8 vdb-p-leading-normal swiper-truncate-overflow {{ isLight ? 'vdb-p-text-gray-950' : 'vdb-p-text-white' }}",
            "data-seconds": __props.searchResultItem.start
          }, [
            vue.createElementVNode("span", {
              innerHTML: wrapSpan(__props.searchResultItem.text, __props.searchResultItem.type)
            }, null, 8, _hoisted_4$2$1)
          ], 8, _hoisted_3$4$1),
          vue.createElementVNode("div", _hoisted_5$2$1, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(`swiper-time ${__props.searchResultItem.type} ${__props.isLight ? "light" : ""}`),
              "data-seconds": __props.searchResultItem.start
            }, [
              vue.createVNode(PlayIcon, {
                class: vue.normalizeClass(`${__props.searchResultItem.type === "relevant" ? __props.isLight ? "vdb-p-text-[#53B745]" : "vdb-p-text-[#B4C236]" : "vdb-p-text-[#F8C450]"}`)
              }, null, 8, ["class"]),
              vue.createElementVNode("p", {
                class: vue.normalizeClass(`vdb-p-text-overline vdb-p-font-medium vdb-p-tracking-wider vdb-p-opacity-80 ${__props.isLight ? "swiper-time-light-text" : "vdb-p-text-white-80"}`)
              }, vue.toDisplayString(__props.searchResultItem.start < 3600 ? start2.value.substring(14, 19) : start2.value.substring(11, 19)) + " " + vue.toDisplayString(end2.value ? " - " : "") + " " + vue.toDisplayString(end2.value ? __props.searchResultItem.end < 3600 ? end2.value.substring(14, 19) : end2.value.substring(11, 19) : ""), 3)
            ], 10, _hoisted_6$2$1),
            vue.createElementVNode("p", {
              "data-seconds": __props.searchResultItem.start,
              class: vue.normalizeClass(`vdb-p-hidden md:vdb-p-block vdb-p-text-caption3 vdb-p-font-medium vdb-p-capitalize vdb-p-text-kilvish-600 ${__props.searchResultItem.type}-text-br`)
            }, vue.toDisplayString(__props.searchResultItem.type), 11, _hoisted_7$2$1)
          ])
        ], 8, _hoisted_2$7$1)
      ], 10, _hoisted_1$8$1);
    };
  }
};
const _withScopeId$6 = (n) => (vue.pushScopeId("data-v-7b4f1d8e"), n = n(), vue.popScopeId(), n);
const _hoisted_1$7$1 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M10.83 12L15.78 7.04999L14.366 5.63599L8.00203 12L14.366 18.364L15.78 16.95L10.83 12Z",
  fill: "black"
}, null, -1));
const _hoisted_2$6$1 = [
  _hoisted_1$7$1
];
const _sfc_main$7$1 = {
  __name: "arrow-left",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_2$6$1, 2);
    };
  }
};
const ArrowLeftIcon = /* @__PURE__ */ _export_sfc(_sfc_main$7$1, [["__scopeId", "data-v-7b4f1d8e"]]);
const _withScopeId$5 = (n) => (vue.pushScopeId("data-v-00b90b0f"), n = n(), vue.popScopeId(), n);
const _hoisted_1$6$1 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ vue.createElementVNode("path", {
  d: "M13.1719 12L8.22192 7.04999L9.63592 5.63599L15.9999 12L9.63592 18.364L8.22192 16.95L13.1719 12Z",
  fill: "black"
}, null, -1));
const _hoisted_2$5$1 = [
  _hoisted_1$6$1
];
const _sfc_main$6$1 = {
  __name: "arrow-right",
  props: {
    className: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("svg", {
        class: vue.normalizeClass(__props.className),
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }, _hoisted_2$5$1, 2);
    };
  }
};
const ArrowRightIcon = /* @__PURE__ */ _export_sfc(_sfc_main$6$1, [["__scopeId", "data-v-00b90b0f"]]);
const _hoisted_1$5$1 = { class: "vdb-p-relative vdb-p-h-12" };
const _hoisted_2$4$1 = ["onClick"];
const _sfc_main$5$1 = {
  __name: "SearchResults",
  props: {
    bg: {
      type: String,
      default: "255,255,255"
    },
    duration: {
      type: Number,
      default: 0.01
    },
    searchResults: {
      type: Object,
      default: () => ({})
    },
    onSlideClick: {
      type: Function,
      default: () => {
      }
    },
    highlights: {
      type: Array,
      default: () => []
    },
    theme: {
      type: String,
      default: "yellow"
    },
    searchContent: {
      type: String,
      default: ""
    },
    isLight: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    vue.ref(false);
    const hoveredSlide = vue.ref(null);
    const activeBullets = vue.ref([]);
    const swiperRef = vue.ref({});
    const isBeginning = vue.ref(true);
    const isEnd = vue.ref(false);
    const swiperModules = [Navigation, Mousewheel, Virtual, Manipulation];
    vue.onMounted(() => {
      onSwiperSlideChangeTransitionStart();
      setUpSlideMouseEvents();
    });
    const getSwiperRef = (instance) => {
      swiperRef.value = instance;
    };
    const reachBeginning = (instance) => {
      isBeginning.value = instance.isBeginning;
    };
    const reachEnd = (instance) => {
      isEnd.value = instance.isEnd;
    };
    const setUpSlideMouseEvents = () => {
      const slides = document.getElementsByClassName("swiper-slide");
      if (slides && slides.length) {
        for (let i = 0; i < slides.length; i++) {
          slides[i].addEventListener("mouseenter", (e) => {
            const a = e.target.getAttribute("data-id");
            hoveredSlide.value = a || null;
          });
          slides[i].addEventListener("mouseleave", () => {
            hoveredSlide.value = null;
          });
        }
      }
    };
    const onSwiperSlideChangeTransitionStart = () => {
      isBeginning.value = swiperRef.value.isBeginning;
      isEnd.value = swiperRef.value.isEnd;
      if (!swiperRef.value)
        return;
      const newActiveBullets = [];
      const activeSlideCount = Math.round(
        swiperRef.value.params.breakpoints[swiperRef.value.currentBreakpoint].slidesPerView
      );
      for (let i = swiperRef.value.activeIndex; i < swiperRef.value.activeIndex + activeSlideCount; i++) {
        newActiveBullets.push(i);
      }
      activeBullets.value = newActiveBullets;
    };
    const getLeftValue = (startTime, duration2) => {
      const val = parseFloat(startTime) * 100 / duration2;
      if (val < 0.5)
        return 0.5;
      return val;
    };
    const changeSlide = (type) => {
      if (type === "next") {
        const slideToMove = activeBullets.value[activeBullets.value.length - 1] + 1;
        goToSlide(Math.min(props.searchResults.hits.length - 1, slideToMove));
      } else if (type === "prev") {
        const slideToMove = activeBullets.value[0] - 3;
        goToSlide(Math.max(0, slideToMove));
      }
    };
    const goToSlide = (slide2) => {
      swiperRef.value.slideTo(slide2);
    };
    const getSearchResultsItemWidth = (srItem) => {
      const duration2 = srItem.end - srItem.start;
      const width = `${duration2 / props.duration * 100}%`;
      return width;
    };
    const isRelevant = (searchResult) => {
      return searchResult.type === "relevant";
    };
    const swiperClick = (e) => {
      if (!e.target)
        return;
      let value2 = e.target.getAttribute("data-seconds");
      if (!value2) {
        const parentElement = e.target.parentElement;
        if (!parentElement)
          return;
        value2 = parentElement.getAttribute("data-seconds");
      }
      if (value2) {
        props.onSlideClick(value2);
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", null, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass(["vdb-p-relative vdb-p-z-10", {
            "vdb-p-px-16 vdb-p-pt-16 md:vdb-p-px-24 md:vdb-p-pt-24 xl:vdb-p-px-32 xl:vdb-p-pt-32": __props.isLight,
            "vdb-p-px-32 vdb-p-pt-40": !__props.isLight
          }])
        }, [
          vue.createElementVNode("div", _hoisted_1$5$1, [
            vue.createElementVNode("div", {
              class: vue.normalizeClass(["sr-timeline-bg vdb-p-absolute vdb-p-bottom-0 vdb-p-left-0 vdb-p-right-0 vdb-p-top-0 vdb-p-py-3", __props.isLight ? "light" : ""])
            }, null, 2),
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.highlights, (item, index) => {
              return vue.withDirectives((vue.openBlock(), vue.createElementBlock("button", {
                key: `highligt-marker-${item.time}-${index}`,
                class: "vdb-p-pointer-events-none vdb-p-absolute vdb-p-top-1/2 vdb-p-flex vdb-p-h-16 vdb-p-w-6 vdb-p--translate-x-1/2 vdb-p--translate-y-1/2 vdb-p-transform vdb-p-items-center vdb-p-justify-center vdb-p-rounded-full vdb-p-border vdb-p-border-black-64 vdb-p-bg-primary vdb-p-shadow-1",
                style: vue.normalizeStyle({
                  left: `${Math.max(Math.min(100 * item.time / __props.duration, 95), 5)}%`
                })
              }, null, 4)), [
                [vue.vShow, !__props.isLight]
              ]);
            }), 128)),
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.searchResults.hits, (searchResultsItem, index) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: `searchResults-${searchResultsItem.id}-${index}`,
                class: vue.normalizeClass(["sr-dot vdb-p-absolute vdb-p-top-1/2 vdb-p-h-6 vdb-p--translate-y-1/2 vdb-p-transform vdb-p-cursor-pointer vdb-p-rounded-full", `${activeBullets.value.includes(index) ? "active vdb-p-opacity-100" : "vdb-p-opacity-20 hover:vdb-p-opacity-100"} ${isRelevant(searchResultsItem) ? "relevant bg-lime vdb-p-z-10 vdb-p-min-w-12" : "exact vdb-p-z-20 vdb-p-w-8 vdb-p--translate-x-1/2 vdb-p-bg-yellow"} ${__props.isLight ? "light" : ""} ${hoveredSlide.value && hoveredSlide.value == searchResultsItem.id ? "forced-hover" : ""} `]),
                style: vue.normalizeStyle({
                  left: `${getLeftValue(searchResultsItem.start, __props.duration)}%`,
                  width: isRelevant(searchResultsItem) ? getSearchResultsItemWidth(searchResultsItem) : ""
                }),
                onClick: ($event) => goToSlide(index)
              }, null, 14, _hoisted_2$4$1);
            }), 128))
          ])
        ], 2),
        vue.createElementVNode("div", {
          class: vue.normalizeClass(["sr-swiper vdb-p-relative vdb-p-z-0 vdb-p-overflow-hidden vdb-p-rounded-b-16", {
            "light vdb-p-px-16 vdb-p-pb-16 xl:vdb-p-px-24 xl:vdb-p-pb-24": __props.isLight
          }]),
          onClick: swiperClick
        }, [
          vue.createVNode(vue.unref(Swiper2), {
            modules: swiperModules,
            "slides-per-view": 1.3,
            "space-between": 24,
            mousewheel: {
              forceToAxis: true,
              invert: false
            },
            breakpoints: {
              320: {
                slidesPerView: 1.3,
                spaceBetween: 24
              },
              460: {
                slidesPerView: 2.2,
                spaceBetween: 24
              },
              680: {
                slidesPerView: 3.2,
                spaceBetween: 10
              }
            },
            navigation: "",
            onSwiper: getSwiperRef,
            onReachBeginning: reachBeginning,
            onReachEnd: reachEnd,
            onSlideChangeTransitionStart: onSwiperSlideChangeTransitionStart
          }, {
            default: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.searchResults.hits, (slideContent, index) => {
                return vue.openBlock(), vue.createBlock(vue.unref(SwiperSlide), {
                  key: index,
                  virtualIndex: index
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_sfc_main$8$1, {
                      searchResultItem: slideContent,
                      searchResultItemIndex: index,
                      searchContent: __props.searchContent,
                      isLight: __props.isLight
                    }, null, 8, ["searchResultItem", "searchResultItemIndex", "searchContent", "isLight"])
                  ]),
                  _: 2
                }, 1032, ["virtualIndex"]);
              }), 128))
            ]),
            _: 1
          }),
          !isBeginning.value ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: "vdb-p-pointer-events-none vdb-p-absolute vdb-p-bottom-0 vdb-p-left-0 vdb-p-top-0 vdb-p-z-10 vdb-p-block vdb-p-w-40 sm:vdb-p-w-60",
            style: vue.normalizeStyle({
              background: `linear-gradient(90deg, rgba(${__props.bg},1) 3.12%, rgba(${__props.bg}, 0.838542) 32.92%, rgba(${__props.bg}, 0) 95.39%)`
            })
          }, null, 4)) : vue.createCommentVNode("", true),
          !isBeginning.value ? (vue.openBlock(), vue.createElementBlock("button", {
            key: 1,
            class: vue.normalizeClass(["vdb-p-absolute vdb-p-left-24 vdb-p-top-1/2 vdb-p-z-10 vdb-p-hidden vdb-p-h-40 vdb-p-w-40 vdb-p--translate-y-1/2 vdb-p-transform vdb-p-items-center vdb-p-justify-center vdb-p-rounded-full vdb-p-border vdb-p-bg-white vdb-p-shadow-3 vdb-p-transition hover:vdb-p-shadow-4 sm:vdb-p-flex", `vdb-p-border-${__props.theme}-8`]),
            onClick: _cache[0] || (_cache[0] = ($event) => changeSlide("prev"))
          }, [
            vue.createVNode(ArrowLeftIcon, { class: "vdb-p-text-black" })
          ], 2)) : vue.createCommentVNode("", true),
          !isEnd.value ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 2,
            class: "sm:vdb-p-w-600 vdb-p-pointer-events-none vdb-p-absolute vdb-p-bottom-0 vdb-p-right-0 vdb-p-top-0 vdb-p-z-10 vdb-p-block vdb-p-w-40",
            style: vue.normalizeStyle({
              background: `linear-gradient(270deg, rgba(${__props.bg},1) 3.12%, rgba(${__props.bg}, 0.838542) 32.92%, rgba(${__props.bg}, 0) 95.39%)`
            })
          }, null, 4)) : vue.createCommentVNode("", true),
          !isEnd.value ? (vue.openBlock(), vue.createElementBlock("button", {
            key: 3,
            class: vue.normalizeClass(["vdb-p-absolute vdb-p-right-24 vdb-p-top-1/2 vdb-p-z-10 vdb-p-hidden vdb-p-h-40 vdb-p-w-40 vdb-p--translate-y-1/2 vdb-p-transform vdb-p-items-center vdb-p-justify-center vdb-p-rounded-full vdb-p-border vdb-p-bg-white vdb-p-shadow-3 vdb-p-transition hover:vdb-p-shadow-4 sm:vdb-p-flex", `vdb-p-border-${__props.theme}-8`]),
            onClick: _cache[1] || (_cache[1] = ($event) => changeSlide("next"))
          }, [
            vue.createVNode(ArrowRightIcon, { class: "vdb-p-text-black" })
          ], 2)) : vue.createCommentVNode("", true)
        ], 2)
      ]);
    };
  }
};
const style$1 = "";
const ExternalLink_vue_vue_type_style_index_0_scoped_917c817b_lang = "";
const _sfc_main$z = {
  name: "ExternalLinkIcon",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "black"
    }
  }
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", null, _cache[0] || (_cache[0] = [
    vue.createStaticVNode('<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-917c817b><g clip-path="url(#clip0_1351_16008)" data-v-917c817b><path d="M5.5 2.5H2.5C1.67157 2.5 1 3.17157 1 4V11.5C1 12.3284 1.67157 13 2.5 13H10C10.8284 13 11.5 12.3284 11.5 11.5V8.5M8.5 1H13M13 1V5.5M13 1L5.5 8.5" stroke="#111827" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" data-v-917c817b></path></g><defs data-v-917c817b><clipPath id="clip0_1351_16008" data-v-917c817b><rect width="14" height="14" fill="white" data-v-917c817b></rect></clipPath></defs></svg>', 1)
  ]));
}
const ExternalLink = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$i], ["__scopeId", "data-v-917c817b"]]);
const VideoCard_vue_vue_type_style_index_0_scoped_9b5a1ba5_lang = "";
const _hoisted_1$v = { class: "video-card vdb-c-flex vdb-c-h-full vdb-c-cursor-pointer vdb-c-flex-col vdb-c-rounded-lg vdb-c-bg-kilvish-200 vdb-c-p-6" };
const _hoisted_2$i = { key: 0 };
const _hoisted_3$f = {
  key: 1,
  class: "vid-pb vdb-c-relative vdb-c-overflow-hidden vdb-c-rounded-[7px]"
};
const _hoisted_4$c = { class: "text-elip vdb-c-mb-8 vdb-c-line-clamp-2 vdb-c-h-[2.5em] vdb-c-whitespace-normal vdb-c-text-xs vdb-c-font-medium" };
const _sfc_main$y = {
  __name: "VideoCard",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    index: {
      type: Number,
      default: 0
    },
    variant: {
      type: String,
      default: "default"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$v, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass([
            "vdb-c-flex vdb-c-flex-col sm:vdb-c-block sm:vdb-c-flex-row",
            {
              "vdb-c-mb-14": __props.variant === "default"
            }
          ])
        }, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass([
              "sm:vdb-c-min-w-auto sm:vdb-c-min-w-0 vdb-c-w-auto vdb-c-min-w-96 sm:vdb-c-mr-24 sm:vdb-c-w-full",
              {
                "vdb-c-mb-8 sm:vdb-c-mb-16": __props.variant === "default"
              }
            ])
          }, [
            __props.item.stream_url ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$i, [
              vue.createElementVNode("div", null, [
                vue.createVNode(vue.unref(VideoDBPlayer), {
                  "stream-url": __props.item.stream_url,
                  "default-controls": false,
                  "default-overlay": false,
                  class: "vdb-c-overflow-hidden vdb-c-rounded-12"
                }, {
                  overlay: vue.withCtx(() => [
                    vue.createVNode(vue.unref(_sfc_main$m$1), {
                      class: "vdb-c-absolute vdb-c-left-1/2 vdb-c-top-1/2",
                      style: { height: "48px", width: "48px" }
                    }),
                    vue.createElementVNode("div", {
                      class: "vdb-c-absolute vdb-c-bottom-4 vdb-c-right-4 vdb-c-rounded-full vdb-c-border vdb-c-bg-black-45 vdb-c-p-6 vdb-c-backdrop-blur vdb-c-transition-transform vdb-c-duration-300 hover:vdb-c-scale-110 hover:vdb-c-bg-random-313131",
                      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("video-click", __props.item))
                    }, [
                      __props.item.stream_url ? (vue.openBlock(), vue.createBlock(ExternalLink, { key: 0 })) : vue.createCommentVNode("", true)
                    ])
                  ]),
                  _: 1
                }, 8, ["stream-url"])
              ])
            ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$f, [
              __props.item.thumbnail_url ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: "thumbnail vdb-c-absolute vdb-c-bottom-0 vdb-c-left-0 vdb-c-right-0 vdb-c-top-0 vdb-c-h-106 vdb-c-rounded-lg vdb-c-bg-cover vdb-c-bg-center vdb-c-bg-no-repeat vdb-c-shadow-1",
                style: vue.normalizeStyle({
                  backgroundImage: `url('${__props.item.thumbnail_url}')`,
                  backgroundColor: "transparent"
                }),
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("video-click", __props.item))
              }, null, 4)) : (vue.openBlock(), vue.createBlock(DefaultThumbnail, {
                key: 1,
                class: "thumbnail vdb-c-absolute vdb-c-bottom-0 vdb-c-left-0 vdb-c-right-0 vdb-c-top-0 vdb-c-h-106 vdb-c-rounded-lg vdb-c-bg-cover vdb-c-bg-center vdb-c-bg-no-repeat vdb-c-shadow-1 vdb-c-animate-pulse",
                onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("video-click", __props.item))
              })),
              vue.createElementVNode("div", {
                class: "center-button transparent-button vdb-c-absolute vdb-c-left-1/2 vdb-c-top-1/2 vdb-c-flex vdb-c-h-48 vdb-c-w-48 -vdb-c-translate-x-1/2 -vdb-c-translate-y-1/2 vdb-c-transform vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full lg:vdb-c-h-56 lg:vdb-c-w-56",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("video-click", __props.item))
              }, [
                vue.createVNode(PlayIcon$1, { class: "vdb-c-h-20 vdb-c-w-20" })
              ])
            ]))
          ], 2),
          __props.variant === "default" ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: "fade-on-hover vdb-c-flex vdb-c-flex-col vdb-c-justify-center vdb-c-text-kilvish-900",
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("video-click", __props.item))
          }, [
            vue.createElementVNode("p", _hoisted_4$c, vue.toDisplayString(__props.item.name), 1)
          ])) : vue.createCommentVNode("", true)
        ], 2)
      ]);
    };
  }
};
const VideoCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["__scopeId", "data-v-9b5a1ba5"]]);
const _hoisted_1$u = ["disabled"];
const _sfc_main$x = {
  __name: "PaginationButton",
  props: {
    label: {
      type: [String, Number],
      required: true
    },
    targetPage: {
      type: Number,
      required: true
    },
    state: {
      type: String,
      default: "default",
      validator: (value2) => ["default", "active", "disabled"].includes(value2)
    },
    isFirst: {
      type: Boolean,
      default: false
    },
    isLast: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("button", {
        class: vue.normalizeClass(["vdb-c-w-[80px] vdb-c-border-[1px] vdb-c-border-[#DADADA] vdb-c-px-4 vdb-c-py-6 vdb-c-text-center vdb-c-text-sm vdb-c-font-normal vdb-c-text-black", {
          "vdb-c-text-orange vdb-c-bg-orange-50": __props.state === "active",
          "vdb-c-cursor-not-allowed": __props.state === "disabled",
          "vdb-c-border-l-0": !__props.isFirst,
          "vdb-c-rounded-l-lg vdb-c-border-l": __props.isFirst,
          "vdb-c-rounded-r-lg": __props.isLast
        }]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", __props.targetPage)),
        disabled: __props.state === "disabled"
      }, vue.toDisplayString(__props.label), 11, _hoisted_1$u);
    };
  }
};
const _hoisted_1$t = { class: "vdb-c-mb-24 vdb-c-grid vdb-c-grid-cols-12 vdb-c-gap-24 sm:vdb-c-mb-32 sm:vdb-c-gap-32" };
const _hoisted_2$h = {
  key: 0,
  class: "vdb-c-mt-24 vdb-c-flex vdb-c-justify-center"
};
const _sfc_main$w = {
  __name: "VideoList",
  props: {
    videoResults: {
      type: Array,
      default: () => []
    },
    itemsPerPage: {
      type: Number,
      default: 8
    },
    showPagination: {
      type: Boolean,
      default: true
    },
    columns: {
      type: Number,
      default: 4,
      validator: (value2) => value2 >= 1 && value2 <= 4
    }
  },
  emits: ["video-click"],
  setup(__props) {
    const props = __props;
    const currentPage = vue.ref(1);
    const totalPages = vue.computed(
      () => Math.ceil(props.videoResults.length / props.itemsPerPage)
    );
    const paginatedVideos = vue.computed(() => {
      if (!props.showPagination) {
        return props.videoResults;
      }
      const start2 = (currentPage.value - 1) * props.itemsPerPage;
      const end2 = start2 + props.itemsPerPage;
      return props.videoResults.slice(start2, end2);
    });
    const displayedPageNumbers = vue.computed(() => {
      const maxDisplayed = 5;
      const halfDisplay = Math.floor(maxDisplayed / 2);
      let start2 = Math.max(1, currentPage.value - halfDisplay);
      let end2 = Math.min(totalPages.value, start2 + maxDisplayed - 1);
      if (end2 === totalPages.value) {
        start2 = Math.max(1, end2 - maxDisplayed + 1);
      }
      if (start2 === 1) {
        end2 = Math.min(totalPages.value, maxDisplayed);
      }
      return Array.from({ length: end2 - start2 + 1 }, (_, i) => start2 + i);
    });
    const goToPage = (page) => {
      if (page < 1) {
        currentPage.value--;
      } else if (page > totalPages.value) {
        currentPage.value++;
      } else {
        currentPage.value = page;
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", null, [
        vue.createElementVNode("div", _hoisted_1$t, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(paginatedVideos.value, (item, index) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              key: `post-${item.id}`,
              class: vue.normalizeClass(["vdb-c-col-span-12 sm:vdb-c-col-span-6", [
                __props.columns >= 4 ? "md:vdb-c-col-span-4 lg:vdb-c-col-span-3" : __props.columns >= 3 ? "md:vdb-c-col-span-4 lg:vdb-c-col-span-4" : __props.columns >= 2 ? "md:vdb-c-col-span-6 lg:vdb-c-col-span-6" : ""
              ]])
            }, [
              vue.createVNode(VideoCard, {
                item,
                "border-b": true,
                index,
                "border-class": "sm:vdb-c-hidden",
                onVideoClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("video-click", $event))
              }, null, 8, ["item", "index"])
            ], 2);
          }), 128))
        ]),
        __props.showPagination ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$h, [
          vue.createVNode(_sfc_main$x, {
            "target-page": -1,
            state: currentPage.value === 1 ? "disabled" : "default",
            "is-first": true,
            label: "Previous",
            onClick: goToPage
          }, null, 8, ["state"]),
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(displayedPageNumbers.value, (pageNumber) => {
            return vue.openBlock(), vue.createBlock(_sfc_main$x, {
              key: pageNumber,
              "target-page": pageNumber,
              state: currentPage.value === pageNumber ? "active" : "default",
              label: pageNumber,
              onClick: goToPage
            }, null, 8, ["target-page", "state", "label"]);
          }), 128)),
          vue.createVNode(_sfc_main$x, {
            "target-page": totalPages.value + 1,
            state: currentPage.value === totalPages.value ? "disabled" : "default",
            "is-last": true,
            label: "Next",
            onClick: goToPage
          }, null, 8, ["target-page", "state"])
        ])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const _sfc_main$v = {
  name: "VideoCardLoading",
  props: {
    index: {
      type: Number,
      default: 0
    },
    borderB: {
      type: Boolean,
      default: false
    }
  }
};
const _hoisted_1$s = { class: "vdb-c-flex vdb-c-flex-col vdb-c-h-full" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$s, [
    vue.createElementVNode("div", {
      class: vue.normalizeClass(["vdb-c-flex sm:vdb-c-block vdb-c-mb-30", { "vdb-c-flex-grow": $props.borderB }])
    }, _cache[0] || (_cache[0] = [
      vue.createStaticVNode('<div class="vdb-c-w-96 vdb-c-min-w-96 sm:vdb-c-w-full sm:vdb-c-min-w-auto vdb-c-mr-24 sm:vdb-c-min-w-0 sm:vdb-c-mb-16"><div class="vdb-c-relative vdb-c-rounded-12 vdb-c-bg-roy vdb-c-animate-pulse vdb-c-custom-duration" style="padding-bottom:75%;"></div></div><div class="vdb-c-flex vdb-c-flex-col vdb-c-justify-center"><div class="vdb-c-animate-pulse vdb-c-custom-duration vdb-c-h-20 vdb-c-bg-roy vdb-c-mb-8 vdb-c-rounded-full"></div><div class="vdb-c-flex vdb-c-items-center"><div class="vdb-c-animate-pulse vdb-c-custom-duration vdb-c-w-48 vdb-c-h-20 vdb-c-bg-roy vdb-c-rounded-full vdb-c-mr-12"></div><div class="vdb-c-animate-pulse vdb-c-custom-duration vdb-c-w-48 vdb-c-h-20 vdb-c-bg-roy vdb-c-rounded-full"></div></div></div>', 2)
    ]), 2),
    $props.borderB ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(["vdb-c-border-b vdb-c-border-outline-xlight lg:vdb-c-mb-16", `${$props.index % 2 === 0 ? "sm:vdb-c--mr-32" : "sm:vdb-c-mr-0"} ${$props.index % 3 !== 2 ? "md:vdb-c--mr-32" : "md:vdb-c-mr-0"} ${$props.index % 4 !== 3 ? "lg:vdb-c--mr-32" : "lg:vdb-c-mr-0"}`])
    }, null, 2)) : vue.createCommentVNode("", true)
  ]);
}
const VideoCardLoader = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$h]]);
const _sfc_main$u = {
  name: "AllVideoLoader",
  components: {
    VideoCardLoader
  }
};
const _hoisted_1$r = { class: "vdb-c-grid vdb-c-grid-cols-12 vdb-c-gap-24 sm:vdb-c-gap-32" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_video_card_loader = vue.resolveComponent("video-card-loader");
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$r, [
    (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList([1, 2, 3, 4], (item, index) => {
      return vue.createElementVNode("div", {
        key: `post-loading-${index}`,
        class: "vdb-c-col-span-12 sm:vdb-c-col-span-6 md:vdb-c-col-span-4 lg:vdb-c-col-span-3"
      }, [
        vue.createVNode(_component_video_card_loader, { index }, null, 8, ["index"])
      ]);
    }), 64))
  ]);
}
const VideoListLoader = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$g]]);
const FileUpload_vue_vue_type_style_index_0_scoped_6e9786d3_lang = "";
const _sfc_main$t = {
  name: "FileUpload",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#FFF5EC"
    }
  }
};
const _hoisted_1$q = ["fill"];
const _hoisted_2$g = ["fill"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "30",
    height: "30",
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M18.364 2.63823C17.7856 2.49938 17.1858 2.49966 16.3921 2.50004L12.1984 2.50008C11.1921 2.50006 10.3617 2.50005 9.68519 2.55532C8.98256 2.61273 8.33668 2.73593 7.73001 3.04505C6.78919 3.52442 6.02428 4.28933 5.54491 5.23015C5.2358 5.83682 5.11259 6.4827 5.05518 7.18533C4.99991 7.86182 4.99992 8.69227 4.99994 9.69848V20.3018C4.99992 21.308 4.99991 22.1385 5.05518 22.815C5.11259 23.5176 5.2358 24.1635 5.54491 24.7702C6.02428 25.711 6.78919 26.4759 7.73001 26.9553C8.33668 27.2644 8.98256 27.3876 9.68519 27.445C10.3617 27.5003 11.1921 27.5003 12.1983 27.5003H17.8017C18.8079 27.5003 19.6383 27.5003 20.3148 27.445C21.0175 27.3876 21.6633 27.2644 22.27 26.9553C23.2108 26.4759 23.9757 25.711 24.4551 24.7702C24.7642 24.1635 24.8874 23.5176 24.9448 22.815C25.0001 22.1385 25.0001 21.308 25.0001 20.3018L25.0001 11.1081C25.0005 10.3143 25.0008 9.71456 24.8619 9.1362C24.7394 8.62601 24.5374 8.13829 24.2633 7.69092C23.9525 7.18377 23.5282 6.75989 22.9667 6.19889L21.3013 4.53349C20.7403 3.97195 20.3164 3.54767 19.8092 3.23688C19.3619 2.96274 18.8741 2.76071 18.364 2.63823ZM16.25 5.0001H12.25C11.1793 5.0001 10.4514 5.00107 9.88877 5.04704C9.34075 5.09181 9.06049 5.17297 8.86499 5.27258C8.39458 5.51227 8.01213 5.89472 7.77244 6.36513C7.67283 6.56063 7.59167 6.84089 7.5469 7.38891C7.50093 7.95153 7.49996 8.6794 7.49996 9.75013V20.2502C7.49996 21.3209 7.50093 22.0488 7.5469 22.6114C7.59167 23.1594 7.67283 23.4397 7.77244 23.6352C8.01213 24.1056 8.39458 24.4881 8.86499 24.7277C9.06049 24.8274 9.34075 24.9085 9.88877 24.9533C10.4514 24.9993 11.1793 25.0002 12.25 25.0002H17.75C18.8208 25.0002 19.5486 24.9993 20.1112 24.9533C20.6593 24.9085 20.9395 24.8274 21.135 24.7277C21.6054 24.4881 21.9879 24.1056 22.2276 23.6352C22.3272 23.4397 22.4083 23.1594 22.4531 22.6114C22.4991 22.0488 22.5001 21.3209 22.5001 20.2502V11.2501H20C17.929 11.2501 16.25 9.57119 16.25 7.50011V5.0001ZM21.95 8.75012C21.7998 8.57249 21.5599 8.32774 21.1088 7.87664L19.6235 6.39135C19.1724 5.94024 18.9277 5.70035 18.75 5.55013V7.50011C18.75 8.19047 19.3097 8.75012 20 8.75012H21.95Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$q),
    vue.createElementVNode("path", {
      d: "M15.8839 12.8661C15.3957 12.378 14.6042 12.378 14.1161 12.8661L11.6161 15.3661C11.1279 15.8543 11.1279 16.6458 11.6161 17.1339C12.1042 17.6221 12.8957 17.6221 13.3838 17.1339L13.75 16.7678V21.2501C13.75 21.9404 14.3096 22.5001 15 22.5001C15.6903 22.5001 16.25 21.9404 16.25 21.2501V16.7678L16.6161 17.1339C17.1043 17.6221 17.8957 17.6221 18.3839 17.1339C18.872 16.6458 18.872 15.8543 18.3839 15.3661L15.8839 12.8661Z",
      fill: $props.fill
    }, null, 8, _hoisted_2$g)
  ], 2);
}
const FileUpload = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$f], ["__scopeId", "data-v-6e9786d3"]]);
const _hoisted_1$p = { class: "vdb-c-mx-auto vdb-c-w-11/12 vdb-c-py-28" };
const _hoisted_2$f = { key: 0 };
const _hoisted_3$e = {
  key: 1,
  class: "vdb-c-flex vdb-c-flex-col vdb-c-items-center vdb-c-justify-center vdb-c-gap-32 vdb-c-py-32 vdb-c-text-center vdb-c-text-black"
};
const _hoisted_4$b = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-6" };
const _sfc_main$s = {
  __name: "CollectionView",
  props: {
    collectionId: {
      type: String,
      required: true
    },
    collectionData: {
      type: Object,
      default: null
    },
    collectionVideos: {
      type: Array,
      default: null
    }
  },
  emits: ["video-click"],
  setup(__props, { emit: __emit }) {
    const { chatInput, loadSession, addMessage } = useVideoDBChat();
    const props = __props;
    const emit = __emit;
    const videos = vue.computed(() => {
      if (props.collectionVideos === null) {
        return [];
      }
      return props.collectionVideos;
    });
    const handleVideoClick = (video) => {
      emit("video-click", video);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$p, [
        __props.collectionVideos !== null ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$f, [
          videos.value.length > 0 ? (vue.openBlock(), vue.createBlock(_sfc_main$w, {
            key: 0,
            "video-results": videos.value,
            onVideoClick: handleVideoClick
          }, null, 8, ["video-results"])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$e, [
            _cache[2] || (_cache[2] = vue.createElementVNode("div", { class: "vdb-c-text-2xl vdb-c-font-bold" }, " Your Collection is empty ", -1)),
            vue.createVNode(_sfc_main$C, {
              onClick: _cache[0] || (_cache[0] = ($event) => {
                vue.unref(loadSession)();
                vue.unref(addMessage)({
                  content: [
                    { type: "text", text: "Upload a video to this collection" }
                  ]
                });
                chatInput.value = "";
              }),
              variant: "tertiary",
              class: "vdb-c-mt-12"
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_4$b, [
                  vue.createVNode(FileUpload),
                  _cache[1] || (_cache[1] = vue.createElementVNode("span", null, "Upload a video", -1))
                ])
              ]),
              _: 1
            })
          ]))
        ])) : (vue.openBlock(), vue.createBlock(VideoListLoader, { key: 1 }))
      ]);
    };
  }
};
const _sfc_main$r = {
  name: "QuestionMark",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#C14103"
    }
  }
};
const _hoisted_1$o = ["fill"];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    class: vue.normalizeClass($props.className),
    width: "30",
    height: "30",
    viewBox: "0 0 30 30",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M0.789307 14.9996C0.789307 7.15133 7.15158 0.789062 14.9998 0.789062C22.8481 0.789062 29.2104 7.15133 29.2104 14.9996C29.2104 22.8478 22.8481 29.2101 14.9998 29.2101C7.15158 29.2101 0.789307 22.8478 0.789307 14.9996ZM11.8265 11.9665C12.5058 12.3595 13.3751 12.1273 13.7681 11.448C15.1281 9.47936 17.7568 12.1006 15.6015 13.3819C15.2141 13.6122 14.7075 13.9956 14.3221 14.4652C13.9573 14.9098 13.6221 15.5213 13.5827 16.2729C13.5777 16.3215 13.5751 16.3707 13.5751 16.4206C13.5751 17.2055 14.2114 17.8417 14.9962 17.8417C16.0794 17.8417 16.2856 17.2662 16.4937 16.6855C16.6275 16.312 16.7621 15.9362 17.1315 15.7101C18.3062 14.991 19.2631 13.7174 19.2631 12.1575C19.2631 9.80301 17.3544 7.89433 14.9999 7.89433C13.4202 7.89433 12.0429 8.75432 11.308 10.0249C10.915 10.7042 11.1471 11.5735 11.8265 11.9665ZM13.5751 20.6838C13.5751 19.899 14.2114 19.2627 14.9962 19.2627C15.781 19.2627 16.4172 19.899 16.4172 20.6838C16.4172 21.4686 15.781 22.1049 14.9962 22.1049C14.2114 22.1049 13.5751 21.4686 13.5751 20.6838Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$o)
  ], 2);
}
const QuestionMarkIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$e]]);
const ChevronRightCircled_vue_vue_type_style_index_0_scoped_1cd4866c_lang = "";
const _sfc_main$q = {
  name: "ChevronRightCircledIcon",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "black"
    }
  }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", null, [
    (vue.openBlock(), vue.createElementBlock("svg", {
      class: vue.normalizeClass($props.className),
      width: "20",
      height: "20",
      viewBox: "0 0 20 20",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, _cache[0] || (_cache[0] = [
      vue.createElementVNode("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M10 3.33464C6.31812 3.33464 3.33335 6.3194 3.33335 10.0013C3.33335 13.6832 6.31812 16.668 10 16.668C13.6819 16.668 16.6667 13.6832 16.6667 10.0013C16.6667 6.3194 13.6819 3.33464 10 3.33464ZM1.66669 10.0013C1.66669 5.39893 5.39765 1.66797 10 1.66797C14.6024 1.66797 18.3334 5.39893 18.3334 10.0013C18.3334 14.6037 14.6024 18.3346 10 18.3346C5.39765 18.3346 1.66669 14.6037 1.66669 10.0013Z",
        fill: "#12131A"
      }, null, -1),
      vue.createElementVNode("path", {
        "fill-rule": "evenodd",
        "clip-rule": "evenodd",
        d: "M8.57739 6.91205C8.90283 6.58661 9.43047 6.58661 9.7559 6.91205L12.2559 9.41205C12.5813 9.73748 12.5813 10.2651 12.2559 10.5906L9.7559 13.0906C9.43047 13.416 8.90283 13.416 8.57739 13.0906C8.25195 12.7651 8.25195 12.2375 8.57739 11.912L10.4881 10.0013L8.57739 8.09056C8.25195 7.76512 8.25195 7.23748 8.57739 6.91205Z",
        fill: "#12131A"
      }, null, -1)
    ]), 2))
  ]);
}
const ChevronRightCircled = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$d], ["__scopeId", "data-v-1cd4866c"]]);
const Star_vue_vue_type_style_index_0_scoped_5fe74808_lang = "";
const _sfc_main$p = {
  props: {
    className: {
      type: String,
      default: () => {
      }
    }
  }
};
const _hoisted_1$n = {
  width: "12",
  height: "12",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 47.94 47.94",
  "xml:space": "preserve"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$n, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      style: { "fill": "#fff" },
      d: "M26.285,2.486l5.407,10.956c0.376,0.762,1.103,1.29,1.944,1.412l12.091,1.757\n	c2.118,0.308,2.963,2.91,1.431,4.403l-8.749,8.528c-0.608,0.593-0.886,1.448-0.742,2.285l2.065,12.042\n	c0.362,2.109-1.852,3.717-3.746,2.722l-10.814-5.685c-0.752-0.395-1.651-0.395-2.403,0l-10.814,5.685\n	c-1.894,0.996-4.108-0.613-3.746-2.722l2.065-12.042c0.144-0.837-0.134-1.692-0.742-2.285l-8.749-8.528\n	c-1.532-1.494-0.687-4.096,1.431-4.403l12.091-1.757c0.841-0.122,1.568-0.65,1.944-1.412l5.407-10.956\n	C22.602,0.567,25.338,0.567,26.285,2.486z"
    }, null, -1)
  ]));
}
const StarIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$c], ["__scopeId", "data-v-5fe74808"]]);
const DefaultScreen_vue_vue_type_style_index_0_scoped_21c9e4e8_lang = "";
const _hoisted_1$m = { class: "vdb-c-flex vdb-c-h-full vdb-c-w-5/6 vdb-c-flex-col vdb-c-gap-32 vdb-c-p-16 md:vdb-c-p-32" };
const _hoisted_2$e = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-8" };
const _hoisted_3$d = {
  class: "vdb-c-flex vdb-c-items-center vdb-c-gap-4 vdb-c-text-xl vdb-c-leading-tight sm:vdb-c-text-3xl md:vdb-c-text-5xl",
  style: { lineHeight: "1.2" }
};
const _hoisted_4$a = {
  key: 0,
  class: "vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-between"
};
const _hoisted_5$9 = ["title"];
const _hoisted_6$7 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-6 vdb-c-text-sm vdb-c-font-medium" };
const _hoisted_7$6 = {
  key: 1,
  class: "vdb-c-inline-block vdb-c-h-[3rem] vdb-c-w-4/6 vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-roy"
};
const _hoisted_8$5 = { class: "fade-in-anim vdb-c-flex vdb-c-grow vdb-c-items-start vdb-c-justify-center vdb-c-pt-4" };
const _hoisted_9$4 = { class: "vdb-c-grid vdb-c-grid-cols-1 vdb-c-gap-12 md:vdb-c-grid-cols-3 md:vdb-c-gap-16 2xl:vdb-c-grid-cols-3" };
const _hoisted_10$3 = ["onClick"];
const _hoisted_11$2 = {
  key: 0,
  class: "vdb-c-absolute vdb-c-right-4 vdb-c-flex vdb-c-flex-row vdb-c-items-center vdb-c-rounded-4 vdb-c-bg-orange-900 vdb-c-px-6 vdb-c-py-3 vdb-c-text-[10px] vdb-c-font-semibold vdb-c-uppercase vdb-c-text-white md:vdb-c-right-12 md:vdb-c-text-xs"
};
const _hoisted_12$2 = {
  key: 0,
  class: "vdb-c-flex vdb-c-h-30 vdb-c-w-30 vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full vdb-c-bg-orange vdb-c-p-4"
};
const _hoisted_13$1 = {
  key: 1,
  class: "vdb-c-break-words"
};
const _hoisted_14$1 = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-12" };
const _hoisted_15$1 = { class: "vdb-c-text-base vdb-c-font-normal vdb-c-text-vdb-darkishgrey md:vdb-c-text-xl" };
const _hoisted_16$1 = { key: 0 };
const _hoisted_17$1 = { class: "vdb-c-mb-12 vdb-c-flex vdb-c-items-center vdb-c-justify-between vdb-c-gap-4 md:vdb-c-mb-16" };
const _hoisted_18$1 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-16" };
const _hoisted_19$1 = { key: 1 };
const _hoisted_20$1 = {
  key: 0,
  class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between vdb-c-gap-4"
};
const _hoisted_21$1 = { class: "vdb-c-w-4/6 vdb-c-text-sm md:vdb-c-text-xl" };
const _hoisted_22$1 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-16" };
const _hoisted_23 = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between vdb-c-gap-6" };
const _hoisted_24 = { key: 1 };
const _hoisted_25 = {
  key: 0,
  class: "vdb-c-mb-24 vdb-c-grid vdb-c-grid-cols-12 vdb-c-gap-12 sm:vdb-c-mb-32 sm:vdb-c-gap-18"
};
const _hoisted_26 = {
  key: 1,
  class: "vdb-c-mb-24 vdb-c-grid vdb-c-grid-cols-12 vdb-c-gap-24 sm:vdb-c-mb-32 sm:vdb-c-gap-32"
};
const _sfc_main$o = {
  __name: "DefaultScreen",
  props: {
    actionCardQueries: {
      type: Array,
      default: () => []
    },
    headerConfig: {
      type: Object,
      default: () => ({})
    },
    showDemoVideos: {
      type: Boolean,
      default: true
    },
    previewVideos: {
      type: Array,
      default: null
    },
    collectionData: {
      type: Object,
      default: () => null
    }
  },
  emits: [
    "query-card-click",
    "video-click",
    "view-all-videos-click",
    "upload-button-click"
  ],
  setup(__props) {
    const props = __props;
    const collectionName = vue.computed(() => {
      var _a;
      return (_a = props.collectionData) == null ? void 0 : _a.name;
    });
    const headerText = vue.computed(
      () => {
        var _a;
        return props.headerConfig.headerText || ((_a = props.collectionData) == null ? void 0 : _a.name);
      }
    );
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$m, [
        vue.renderSlot(_ctx.$slots, "header", {}, () => [
          vue.createElementVNode("div", _hoisted_2$e, [
            vue.createElementVNode("h1", _hoisted_3$d, [
              headerText.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$a, [
                vue.createElementVNode("span", {
                  class: "vdb-c-line-clamp-2 vdb-c-inline-block vdb-c-max-w-[60%] vdb-c-font-bold md:vdb-c-line-clamp-none md:vdb-c-max-w-[80%] md:vdb-c-font-extrabold vdb-c-text-orange",
                  title: headerText.value
                }, vue.toDisplayString(headerText.value), 9, _hoisted_5$9),
                __props.headerConfig.uploadButton ? (vue.openBlock(), vue.createBlock(_sfc_main$C, {
                  key: 0,
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("upload-button-click")),
                  variant: "tertiary",
                  class: "!vdb-c-px-8 !vdb-c-py-10"
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode("div", _hoisted_6$7, [
                      vue.createVNode(FileUpload, { class: "vdb-c-hidden vdb-c-h-20 vdb-c-w-20 md:vdb-c-block" }),
                      _cache[3] || (_cache[3] = vue.createElementVNode("span", { class: "vdb-c-flex vdb-c-flex-row vdb-c-gap-4" }, " Upload Video ", -1))
                    ])
                  ]),
                  _: 1
                })) : vue.createCommentVNode("", true)
              ])) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_7$6))
            ])
          ])
        ], true),
        vue.createElementVNode("div", _hoisted_8$5, [
          vue.createElementVNode("div", _hoisted_9$4, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.actionCardQueries, (query, index) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: index,
                class: vue.normalizeClass([
                  "action-card-shadow vdb-c-w-160 vdb-c-h-120 vdb-c-relative vdb-c-flex vdb-c-cursor-pointer vdb-c-flex-col vdb-c-gap-24 vdb-c-rounded-lg vdb-c-border vdb-c-px-12 vdb-c-py-12 vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in-out md:vdb-c-h-220 md:vdb-c-px-16 md:vdb-c-py-20",
                  {
                    "vdb-c-border-orange-100 vdb-c-bg-orange-50 hover:vdb-c-border hover:vdb-c-border-[#FFCFA5] hover:vdb-c-bg-[#FFE9D3]": query.type === "primary",
                    "vdb-c-border-roy vdb-c-bg-vdb-lightgrey hover:vdb-c-bg-roy": query.type === "muted",
                    "vdb-c-bg-orange hover:vdb-c-bg-orange-600": query.type === "cta"
                  }
                ]),
                onClick: ($event) => _ctx.$emit("query-card-click", query)
              }, [
                query.isDemo ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_11$2, [
                  vue.createElementVNode("span", null, [
                    vue.createVNode(StarIcon)
                  ]),
                  _cache[4] || (_cache[4] = vue.createElementVNode("span", { class: "vdb-c-ml-4 vdb-c-hidden md:vdb-c-block" }, " DEMO ", -1))
                ])) : vue.createCommentVNode("", true),
                vue.createElementVNode("div", {
                  class: vue.normalizeClass([
                    "vdb-c-hidden vdb-c-h-48 vdb-c-w-48 vdb-c-items-center vdb-c-justify-center vdb-c-self-start vdb-c-rounded-full vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in-out md:vdb-c-flex",
                    {
                      "vdb-c-bg-[#B92600A6]": query.type === "cta",
                      "vdb-c-bg-roy": query.type === "muted",
                      "vdb-c-bg-orange-100": query.type === "primary"
                    }
                  ])
                }, [
                  query.icon ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_12$2, [
                    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(query.icon)))
                  ])) : (vue.openBlock(), vue.createBlock(QuestionMarkIcon, {
                    key: 1,
                    class: "query-card-icon",
                    fill: query.type === "cta" ? "#FFFFFF" : query.type === "muted" ? "#2D2D2D" : "#EC5B16"
                  }, null, 8, ["fill"]))
                ], 2),
                vue.createElementVNode("p", {
                  class: vue.normalizeClass(["vdb-c-flex-grow vdb-c-text-left vdb-c-text-xs vdb-c-font-medium md:vdb-c-text-sm md:vdb-c-font-semibold lg:vdb-c-text-base", [
                    {
                      "vdb-c-text-pam": query.type === "muted",
                      "vdb-c-text-kilvish-900": query.type === "primary",
                      "vdb-c-text-orange-50": query.type === "cta"
                    }
                  ]])
                }, [
                  query.component ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(query.component), { key: 0 })) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_13$1, vue.toDisplayString(query.content), 1))
                ], 2)
              ], 10, _hoisted_10$3);
            }), 128))
          ])
        ]),
        vue.createElementVNode("div", _hoisted_14$1, [
          _cache[10] || (_cache[10] = vue.createElementVNode("div", { class: "vdb-c-mt-12 vdb-c-h-1 vdb-c-w-full vdb-c-bg-[#EFEFEF]" }, null, -1)),
          vue.createElementVNode("div", _hoisted_15$1, [
            __props.showDemoVideos ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_16$1, [
              vue.createElementVNode("div", _hoisted_17$1, [
                _cache[6] || (_cache[6] = vue.createElementVNode("span", { class: "vdb-c-w-1/2 vdb-c-text-sm vdb-c-font-semibold md:vdb-c-text-lg" }, " See agents in action: ", -1)),
                vue.createElementVNode("div", _hoisted_18$1, [
                  vue.createVNode(_sfc_main$C, { variant: "secondary" }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode("div", {
                        class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between vdb-c-gap-6",
                        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit(
                          "view-all-videos-click",
                          "https://www.youtube.com/playlist?list=PLhxAMFLSSK039xl1UgcZmoFLnb-qNRYQw"
                        ))
                      }, [
                        _cache[5] || (_cache[5] = vue.createElementVNode("div", { class: "vdb-c-text-sm vdb-c-font-medium" }, [
                          vue.createElementVNode("span", { class: "vdb-c-hidden md:vdb-c-block" }, " Watch more demos"),
                          vue.createElementVNode("span", { class: "vdb-c-block md:vdb-c-hidden" }, " More Demos ")
                        ], -1)),
                        vue.createVNode(ExternalLink)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ])
            ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_19$1, [
              collectionName.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_20$1, [
                vue.createElementVNode("span", _hoisted_21$1, [
                  _cache[7] || (_cache[7] = vue.createElementVNode("b", null, " Videos ", -1)),
                  vue.createTextVNode(" in " + vue.toDisplayString(collectionName.value), 1)
                ]),
                vue.createElementVNode("div", _hoisted_22$1, [
                  vue.createVNode(_sfc_main$C, {
                    variant: "secondary",
                    onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("view-all-videos-click")),
                    class: "!vdb-c-px-8 !vdb-c-py-10"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createElementVNode("div", _hoisted_23, [
                        _cache[8] || (_cache[8] = vue.createElementVNode("div", { class: "vdb-c-text-sm vdb-c-font-medium" }, "View all", -1)),
                        vue.createVNode(ChevronRightCircled, { class: "vdb-c-hidden md:vdb-c-block" })
                      ])
                    ]),
                    _: 1
                  })
                ])
              ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_24, _cache[9] || (_cache[9] = [
                vue.createElementVNode("div", { class: "vdb-c-inline-block vdb-c-h-[3rem] vdb-c-w-full vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-roy" }, null, -1)
              ])))
            ]))
          ]),
          __props.previewVideos ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_25, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.previewVideos, (item, index) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: `post-${item.id}`,
                class: "vdb-c-col-span-12 sm:vdb-c-col-span-6 md:vdb-c-col-span-4 lg:vdb-c-col-span-3"
              }, [
                vue.createVNode(VideoCard, {
                  "border-class": "sm:vdb-c-hidden",
                  item,
                  "border-b": true,
                  index,
                  variant: __props.showDemoVideos ? "hide-title" : "default",
                  onVideoClick: ($event) => _ctx.$emit("video-click", item)
                }, null, 8, ["item", "index", "variant", "onVideoClick"])
              ]);
            }), 128))
          ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_26, [
            (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList([1, 2, 3, 4], (item, index) => {
              return vue.createElementVNode("div", {
                key: `post-loading-${index}`,
                class: "vdb-c-col-span-12 sm:vdb-c-col-span-6 md:vdb-c-col-span-4 lg:vdb-c-col-span-3"
              }, [
                vue.createVNode(VideoCardLoader, { index }, null, 8, ["index"])
              ]);
            }), 64))
          ]))
        ])
      ]);
    };
  }
};
const DefaultScreen = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__scopeId", "data-v-21c9e4e8"]]);
const SetupCard_vue_vue_type_style_index_0_scoped_e4a604fb_lang = "";
const _hoisted_1$l = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-16" };
const _hoisted_2$d = { class: "vdb-c-flex vdb-c-flex-1 vdb-c-flex-col vdb-c-justify-between" };
const _hoisted_3$c = { class: "vdb-c-font-semibold vdb-c-text-nan" };
const _hoisted_4$9 = {
  class: /* @__PURE__ */ vue.normalizeClass([
    "vdb-c-mt-12 vdb-c-text-sm vdb-c-font-medium vdb-c-text-nan"
  ])
};
const _hoisted_5$8 = ["innerHTML"];
const _sfc_main$n = {
  __name: "SetupCard",
  props: {
    title: String,
    status: {
      type: String,
      validator: (value2) => ["incomplete", "complete"].includes(value2)
    },
    message: Object
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["vdb-c-flex vdb-c-flex-col vdb-c-justify-between vdb-c-gap-14 vdb-c-rounded-lg vdb-c-border vdb-c-border-roy vdb-c-px-16 vdb-c-py-16", [
          __props.status === "complete" ? "" : "vdb-c-bg-red-200 vdb-c-bg-opacity-20 hover:vdb-c-border-red-200 hover:vdb-c-bg-opacity-100"
        ]]),
        style: { "box-shadow": "0px 1px 2px rgba(0, 0, 0, 0.05)" }
      }, [
        vue.createElementVNode("div", _hoisted_1$l, [
          vue.createElementVNode("div", {
            class: vue.normalizeClass(["vdb-c-flex vdb-c-h-54 vdb-c-w-54 vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full", [
              __props.status === "complete" ? "vdb-c-bg-green-100" : "vdb-c-bg-red-100"
            ]])
          }, [
            __props.status === "incomplete" ? (vue.openBlock(), vue.createBlock(QuestionMarkIcon, {
              key: 0,
              fill: "#E2462C"
            })) : (vue.openBlock(), vue.createBlock(CheckIcon, {
              key: 1,
              class: "vdb-c-h-1/2 vdb-c-w-1/2"
            }))
          ], 2),
          vue.createElementVNode("div", _hoisted_2$d, [
            vue.createElementVNode("h3", _hoisted_3$c, vue.toDisplayString(__props.title), 1),
            vue.createElementVNode("p", _hoisted_4$9, [
              __props.message.html ? (vue.openBlock(), vue.createElementBlock("span", {
                key: 0,
                innerHTML: __props.message.html
              }, null, 8, _hoisted_5$8)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                vue.createTextVNode(vue.toDisplayString(__props.message.text), 1)
              ], 64))
            ])
          ])
        ])
      ], 2);
    };
  }
};
const SetupCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__scopeId", "data-v-e4a604fb"]]);
const SetupScreen_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$k = { class: "vdb-c-flex vdb-c-h-full vdb-c-w-full vdb-c-items-center vdb-c-justify-center" };
const _hoisted_2$c = { class: "vdb-c-flex vdb-c-w-4/6 vdb-c-flex-col vdb-c-gap-8" };
const _hoisted_3$b = { class: "vdb-c-relative vdb-c-mb-12 vdb-c-gap-10 vdb-c-rounded-lg vdb-c-border vdb-c-border-primary vdb-c-bg-red-100 vdb-c-px-24 vdb-c-py-20" };
const _hoisted_4$8 = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between" };
const _hoisted_5$7 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8" };
const _hoisted_6$6 = { class: "vdb-c-font-medium vdb-c-text-red" };
const _hoisted_7$5 = { class: "vdb-c-grid vdb-c-grid-cols-1 vdb-c-gap-16 sm:vdb-c-grid-cols-2 md:vdb-c-grid-cols-3 2xl:vdb-c-grid-cols-4" };
const _sfc_main$m = {
  __name: "SetupScreen",
  props: {
    configStatus: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const setupMapping = {
      db_configured: {
        title: "Database Config",
        complete: {
          text: "Database Configured"
        },
        incomplete: {
          text: "Unable to locate"
        }
      },
      llm_configured: {
        title: "LLM Connection",
        complete: {
          text: "LLM Configured"
        },
        incomplete: {
          html: "<span>Please set your OpenAI LLM key as <code style='background-color: #f3f4f6; color: #1f2937; padding: 2px 4px; border-radius: 4px;'>OPENAI_API_KEY</code> in the backend <code style='background-color: #f3f4f6; color: #1f2937; padding: 2px 4px; border-radius: 4px;'>.env</code> file</span>"
        }
      },
      videodb_configured: {
        title: "VideoDB Setup",
        complete: {
          text: "VideoDB Configured"
        },
        incomplete: {
          html: "<span>Please generate VideoDB key from <a href='https://console.videodb.ai/keys' target='_blank' style='color: #3b82f6; text-decoration: none;'> console </a> and set it to <code style='background-color: #f3f4f6; color: #1f2937; padding: 2px 4px; border-radius: 4px;'>VIDEO_DB_API_KEY</code> in the backend <code style='background-color: #f3f4f6; color: #1f2937; padding: 2px 4px; border-radius: 4px;'>.env</code> file</span>"
        }
      }
    };
    const incompleteCount = vue.computed(() => {
      return Object.values(props.configStatus).filter((status) => !status).length;
    });
    const totalCount = vue.computed(() => Object.keys(props.configStatus).length);
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$k, [
        vue.createElementVNode("div", _hoisted_2$c, [
          _cache[2] || (_cache[2] = vue.createElementVNode("h1", { class: "vdb-c-mb-24 vdb-c-text-5xl vdb-c-font-extrabold vdb-c-text-vdb-darkishgrey" }, " Welcome! ", -1)),
          vue.createElementVNode("div", _hoisted_3$b, [
            vue.createElementVNode("div", _hoisted_4$8, [
              vue.createElementVNode("div", _hoisted_5$7, [
                vue.createVNode(RedExclamation),
                _cache[0] || (_cache[0] = vue.createElementVNode("strong", { class: "vdb-c-ml-2 vdb-c-font-bold vdb-c-text-red" }, "Your setup is incomplete", -1))
              ]),
              vue.createElementVNode("span", _hoisted_6$6, vue.toDisplayString(incompleteCount.value) + " of " + vue.toDisplayString(totalCount.value) + " missing", 1)
            ]),
            _cache[1] || (_cache[1] = vue.createElementVNode("p", { class: "vdb-c-text-pam" }, " Please provide the missing information so we can get started. ", -1))
          ]),
          vue.createElementVNode("div", _hoisted_7$5, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.configStatus, (status, key) => {
              return vue.openBlock(), vue.createBlock(SetupCard, {
                key,
                title: setupMapping[key].title,
                status: status ? "complete" : "incomplete",
                message: status ? setupMapping[key].complete : setupMapping[key].incomplete
              }, null, 8, ["title", "status", "message"]);
            }), 128))
          ])
        ])
      ]);
    };
  }
};
const _sfc_main$l = {
  props: {
    fill: {
      type: String,
      default: "black"
    }
  }
};
const _hoisted_1$j = {
  width: "12",
  height: "14",
  viewBox: "0 0 12 14",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$b = ["fill"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$j, [
    vue.createElementVNode("path", {
      d: "M2.48081 13.2942C2.10681 13.2942 1.78731 13.1618 1.52231 12.8969C1.25744 12.6319 1.125 12.3124 1.125 11.9384V2.41923H0.375V1.29423H3.75V0.630859H8.25V1.29423H11.625V2.41923H10.875V11.9384C10.875 12.3173 10.7438 12.638 10.4813 12.9005C10.2188 13.163 9.89806 13.2942 9.51919 13.2942H2.48081ZM9.75 2.41923H2.25V11.9384C2.25 12.0058 2.27162 12.0611 2.31487 12.1044C2.35812 12.1476 2.41344 12.1692 2.48081 12.1692H9.51919C9.57694 12.1692 9.62981 12.1452 9.67781 12.097C9.72594 12.049 9.75 11.9962 9.75 11.9384V2.41923ZM4.053 10.6692H5.17781V3.91923H4.053V10.6692ZM6.82219 10.6692H7.947V3.91923H6.82219V10.6692Z",
      fill: $props.fill
    }, null, 8, _hoisted_2$b)
  ]);
}
const DeleteIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$b]]);
const _sfc_main$k = {
  name: "Compose",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "white"
    }
  }
};
const _hoisted_1$i = ["fill"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    class: vue.normalizeClass($props.className),
    width: "18",
    height: "18",
    viewBox: "0 0 18 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    vue.createElementVNode("path", {
      d: "M2.28504 17.4251C1.86822 17.4251 1.51591 17.2812 1.2281 16.9934C0.940291 16.7056 0.796387 16.3532 0.796387 15.9364V4.28411C0.796387 3.86096 0.939134 3.50324 1.22463 3.21096C1.51012 2.91852 1.86359 2.78002 2.28504 2.79545H10.045L8.84129 3.99915H2.28504C2.21375 3.99915 2.14847 4.02886 2.08921 4.08827C2.0298 4.14753 2.00009 4.21281 2.00009 4.28411V15.9364C2.00009 16.0077 2.0298 16.073 2.08921 16.1323C2.14847 16.1917 2.21375 16.2214 2.28504 16.2214H13.9374C14.0087 16.2214 14.0739 16.1917 14.1332 16.1323C14.1926 16.073 14.2223 16.0077 14.2223 15.9364V9.34452L15.426 8.14082V15.9364C15.426 16.3532 15.2821 16.7056 14.9943 16.9934C14.7065 17.2812 14.3542 17.4251 13.9374 17.4251H2.28504ZM6.35194 11.8695V9.08457L14.4397 0.99707C14.5678 0.868829 14.7025 0.779477 14.8438 0.729014C14.985 0.678551 15.1331 0.65332 15.2881 0.65332C15.445 0.65332 15.5959 0.678551 15.7408 0.729014C15.8859 0.779477 16.0191 0.8642 16.1404 0.983181L17.1887 2.00841C17.3229 2.13665 17.4181 2.27724 17.4746 2.43017C17.531 2.5831 17.5591 2.73812 17.5591 2.89522C17.5591 3.05263 17.5323 3.20502 17.4786 3.35239C17.4249 3.49977 17.3342 3.63696 17.2066 3.76397L9.09222 11.8695H6.35194ZM7.55565 10.6658H8.59384L14.3415 4.9179L13.8341 4.38735L13.2857 3.86212L7.55565 9.59221V10.6658Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$i)
  ], 2);
}
const ComposeIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$a]]);
const Agent_vue_vue_type_style_index_0_scoped_ead29eb8_lang = "";
const _sfc_main$j = {
  name: "FileUpload",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#FFF5EC"
    }
  }
};
const _hoisted_1$h = {
  width: "20",
  height: "20",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$h, _cache[0] || (_cache[0] = [
    vue.createStaticVNode('<g clip-path="url(#clip0_2117_5081)" data-v-ead29eb8><path d="M5.99533 8.4445C5.07249 8.4445 4.287 8.11913 3.63885 7.46839C2.9907 6.81765 2.66663 6.03061 2.66663 5.10728C2.66663 4.18394 2.99181 3.3982 3.64218 2.75005C4.29268 2.10191 5.07928 1.77783 6.002 1.77783H10.0046C10.9274 1.77783 11.7129 2.1032 12.3611 2.75394C13.0092 3.40468 13.3333 4.19172 13.3333 5.11505C13.3333 6.03839 13.0081 6.82413 12.3577 7.47228C11.7072 8.12042 10.9206 8.4445 9.99792 8.4445H5.99533ZM5.99996 7.11117H9.99996C10.5555 7.11117 11.0277 6.91672 11.4166 6.52783C11.8055 6.13894 12 5.66672 12 5.11117C12 4.55561 11.8055 4.08339 11.4166 3.6945C11.0277 3.30561 10.5555 3.11117 9.99996 3.11117H5.99996C5.4444 3.11117 4.97218 3.30561 4.58329 3.6945C4.1944 4.08339 3.99996 4.55561 3.99996 5.11117C3.99996 5.66672 4.1944 6.13894 4.58329 6.52783C4.97218 6.91672 5.4444 7.11117 5.99996 7.11117ZM5.99607 5.77783C6.18385 5.77783 6.34255 5.71431 6.47218 5.58728C6.60181 5.46024 6.66663 5.30283 6.66663 5.11505C6.66663 4.92728 6.60311 4.76857 6.47607 4.63894C6.34903 4.50931 6.19163 4.4445 6.00385 4.4445C5.81607 4.4445 5.65737 4.50802 5.52774 4.63505C5.39811 4.76209 5.33329 4.9195 5.33329 5.10728C5.33329 5.29505 5.39681 5.45376 5.52385 5.58339C5.65089 5.71302 5.80829 5.77783 5.99607 5.77783ZM9.99607 5.77783C10.1838 5.77783 10.3426 5.71431 10.4722 5.58728C10.6018 5.46024 10.6666 5.30283 10.6666 5.11505C10.6666 4.92728 10.6031 4.76857 10.4761 4.63894C10.349 4.50931 10.1916 4.4445 10.0038 4.4445C9.81607 4.4445 9.65737 4.50802 9.52774 4.63505C9.39811 4.76209 9.33329 4.9195 9.33329 5.10728C9.33329 5.29505 9.39681 5.45376 9.52385 5.58339C9.65089 5.71302 9.80829 5.77783 9.99607 5.77783Z" fill="black" data-v-ead29eb8></path><rect x="3.33329" y="10.4445" width="9.33333" height="3.11111" rx="1.11111" stroke="black" stroke-width="1.33333" data-v-ead29eb8></rect></g><defs data-v-ead29eb8><clipPath id="clip0_2117_5081" data-v-ead29eb8><rect width="16" height="16" fill="white" data-v-ead29eb8></rect></clipPath></defs>', 2)
  ]));
}
const AgentIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$9], ["__scopeId", "data-v-ead29eb8"]]);
const Chat_vue_vue_type_style_index_0_scoped_cc9ab357_lang = "";
const _sfc_main$i = {
  name: "MenuIcon",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "black"
    }
  }
};
const _hoisted_1$g = ["fill"];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.63099 2.5H11.6963C12.4477 2.49999 13.0539 2.49999 13.5472 2.53365C14.0545 2.56826 14.5031 2.64123 14.9278 2.81717C15.9488 3.24006 16.7599 4.0512 17.1828 5.07215C17.3588 5.4969 17.4317 5.94547 17.4663 6.45276C17.5 6.94609 17.5 7.55227 17.5 8.30373V8.36294C17.5 9.1144 17.5 9.72057 17.4663 10.2139C17.4317 10.7212 17.3588 11.1698 17.1828 11.5945C16.7599 12.6155 15.9488 13.4266 14.9278 13.8495C14.5031 14.0254 14.0545 14.0984 13.5472 14.133C13.0539 14.1667 12.4477 14.1667 11.6963 14.1667H9.52381C9.14082 14.1667 9.06446 14.1705 9.00217 14.1831C8.85702 14.2123 8.72229 14.2797 8.61182 14.3782C8.56441 14.4205 8.51551 14.4793 8.28571 14.7857L8.26776 14.8097C7.76299 15.4827 7.36075 16.019 7.0316 16.4068C6.7222 16.7713 6.37247 17.1378 5.95507 17.3104C4.80656 17.7852 3.48366 17.3442 2.84972 16.2753C2.61933 15.8868 2.55949 15.3837 2.53066 14.9065C2.49999 14.3988 2.5 13.7284 2.5 12.8871V8.63099C2.49999 7.72784 2.49999 6.99938 2.54818 6.40948C2.59781 5.80211 2.70265 5.26862 2.95414 4.77504C3.35361 3.99103 3.99103 3.35361 4.77504 2.95414C5.26862 2.70265 5.80211 2.59781 6.40948 2.54818C6.99938 2.49999 7.72784 2.49999 8.63099 2.5ZM6.5452 4.20931C6.04089 4.25052 5.75115 4.32733 5.53169 4.43915C5.06129 4.67883 4.67883 5.06129 4.43915 5.53169C4.32733 5.75115 4.25052 6.04089 4.20931 6.5452C4.16732 7.05924 4.16667 7.7195 4.16667 8.66667V12.8571C4.16667 13.7351 4.16704 14.3548 4.19429 14.806C4.20778 15.0292 4.22663 15.1861 4.24878 15.2967C4.26756 15.3904 4.28393 15.4255 4.28484 15.4278C4.49624 15.7812 4.93427 15.9272 5.31547 15.7713C5.31754 15.7701 5.3517 15.7518 5.42297 15.6881C5.50703 15.6129 5.61626 15.4987 5.76098 15.3282C6.05352 14.9836 6.42561 14.4881 6.95238 13.7857C6.96446 13.7696 6.97642 13.7536 6.98829 13.7378C7.1619 13.5059 7.31445 13.3022 7.50212 13.1347C7.83352 12.839 8.23773 12.6369 8.67316 12.5492C8.91976 12.4995 9.17428 12.4997 9.46394 12.5C9.48373 12.5 9.50368 12.5 9.52381 12.5H11.6667C12.4546 12.5 13.0039 12.4995 13.4338 12.4702C13.8562 12.4414 14.1022 12.3875 14.29 12.3097C14.9026 12.056 15.3893 11.5693 15.643 10.9567C15.7208 10.7689 15.7747 10.5229 15.8035 10.1005C15.8329 9.67055 15.8333 9.1213 15.8333 8.33333C15.8333 7.54536 15.8329 6.99612 15.8035 6.56621C15.7747 6.14378 15.7208 5.89778 15.643 5.70996C15.3893 5.09739 14.9026 4.6107 14.29 4.35697C14.1022 4.27917 13.8562 4.22527 13.4338 4.19645C13.0039 4.16712 12.4546 4.16667 11.6667 4.16667H8.66667C7.7195 4.16667 7.05924 4.16732 6.5452 4.20931Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$g)
  ], 2);
}
const ChatIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$8], ["__scopeId", "data-v-cc9ab357"]]);
const Collection_vue_vue_type_style_index_0_scoped_6cdd1706_lang = "";
const _sfc_main$h = {
  name: "CollectionIcon",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "white"
    }
  }
};
const _hoisted_1$f = ["fill"];
const _hoisted_2$a = ["fill"];
const _hoisted_3$a = ["fill"];
const _hoisted_4$7 = ["fill"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M14.1933 2.5H14.14C13.7745 2.49999 13.4591 2.49998 13.198 2.51779C12.9232 2.53655 12.6482 2.5778 12.3766 2.6903C11.7641 2.94404 11.2774 3.43072 11.0236 4.04329C10.9111 4.3149 10.8699 4.58983 10.8511 4.86468C10.8333 5.12572 10.8333 5.44112 10.8333 5.80664V5.85999C10.8333 6.22551 10.8333 6.54095 10.8511 6.80199C10.8699 7.07684 10.9111 7.35177 11.0236 7.62338C11.2774 8.23595 11.7641 8.72263 12.3766 8.97637C12.6482 9.08887 12.9232 9.13012 13.198 9.14888C13.4591 9.16669 13.7744 9.16668 14.14 9.16667H14.1933C14.5589 9.16668 14.8743 9.16669 15.1353 9.14888C15.4102 9.13012 15.6851 9.08887 15.9567 8.97637C16.5693 8.72263 17.056 8.23595 17.3097 7.62338C17.4222 7.35177 17.4635 7.07684 17.4822 6.80199C17.5 6.54094 17.5 6.22553 17.5 5.85999V5.80668C17.5 5.44114 17.5 5.12573 17.4822 4.86468C17.4635 4.58983 17.4222 4.3149 17.3097 4.04329C17.056 3.43072 16.5693 2.94404 15.9567 2.6903C15.6851 2.5778 15.4102 2.53655 15.1353 2.51779C14.8743 2.49998 14.5588 2.49999 14.1933 2.5ZM13.0144 4.2301C13.0491 4.21574 13.1215 4.19356 13.3115 4.18059C13.509 4.16712 13.767 4.16667 14.1667 4.16667C14.5664 4.16667 14.8244 4.16712 15.0219 4.18059C15.2119 4.19356 15.2842 4.21574 15.3189 4.2301C15.5231 4.31468 15.6853 4.47691 15.7699 4.6811C15.7843 4.71578 15.8064 4.78814 15.8194 4.97813C15.8329 5.17562 15.8333 5.43365 15.8333 5.83334C15.8333 6.23302 15.8329 6.49105 15.8194 6.68854C15.8064 6.87853 15.7843 6.95089 15.7699 6.98557C15.6853 7.18976 15.5231 7.35199 15.3189 7.43657C15.2842 7.45093 15.2119 7.47311 15.0219 7.48608C14.8244 7.49955 14.5664 7.5 14.1667 7.5C13.767 7.5 13.509 7.49955 13.3115 7.48608C13.1215 7.47311 13.0491 7.45093 13.0144 7.43657C12.8102 7.35199 12.648 7.18976 12.5634 6.98557C12.5491 6.95089 12.5269 6.87853 12.5139 6.68854C12.5005 6.49105 12.5 6.23302 12.5 5.83334C12.5 5.43365 12.5005 5.17562 12.5139 4.97813C12.5269 4.78814 12.5491 4.71578 12.5634 4.6811C12.648 4.47691 12.8102 4.31468 13.0144 4.2301Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$f),
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.80668 10.8333H5.85999C6.22551 10.8333 6.54095 10.8333 6.80199 10.8511C7.07684 10.8699 7.35177 10.9111 7.62338 11.0236C8.23595 11.2774 8.72263 11.7641 8.97637 12.3766C9.08887 12.6482 9.13012 12.9232 9.14888 13.198C9.16669 13.4591 9.16668 13.7744 9.16667 14.14V14.1933C9.16668 14.5589 9.16669 14.8743 9.14888 15.1353C9.13012 15.4102 9.08887 15.6851 8.97637 15.9567C8.72263 16.5693 8.23595 17.056 7.62338 17.3097C7.35177 17.4222 7.07684 17.4635 6.80199 17.4822C6.54094 17.5 6.22553 17.5 5.85999 17.5H5.80668C5.44114 17.5 5.12573 17.5 4.86468 17.4822C4.58983 17.4635 4.3149 17.4222 4.04329 17.3097C3.43072 17.056 2.94404 16.5693 2.6903 15.9567C2.5778 15.6851 2.53655 15.4102 2.51779 15.1353C2.49998 14.8743 2.49999 14.5589 2.5 14.1934V14.14C2.49999 13.7745 2.49998 13.4591 2.51779 13.198C2.53655 12.9232 2.5778 12.6482 2.6903 12.3766C2.94404 11.7641 3.43072 11.2774 4.04329 11.0236C4.3149 10.9111 4.58983 10.8699 4.86468 10.8511C5.12572 10.8333 5.44116 10.8333 5.80668 10.8333ZM4.97813 12.5139C4.78814 12.5269 4.71578 12.5491 4.6811 12.5634C4.47691 12.648 4.31468 12.8102 4.2301 13.0144C4.21574 13.0491 4.19356 13.1215 4.18059 13.3115C4.16712 13.509 4.16667 13.767 4.16667 14.1667C4.16667 14.5664 4.16712 14.8244 4.18059 15.0219C4.19356 15.2119 4.21574 15.2842 4.2301 15.3189C4.31468 15.5231 4.47691 15.6853 4.6811 15.7699C4.71578 15.7843 4.78814 15.8064 4.97813 15.8194C5.17562 15.8329 5.43365 15.8333 5.83334 15.8333C6.23302 15.8333 6.49105 15.8329 6.68854 15.8194C6.87853 15.8064 6.95089 15.7843 6.98557 15.7699C7.18976 15.6853 7.35199 15.5231 7.43657 15.3189C7.45093 15.2842 7.47311 15.2119 7.48608 15.0219C7.49955 14.8244 7.5 14.5664 7.5 14.1667C7.5 13.767 7.49955 13.509 7.48608 13.3115C7.47311 13.1215 7.45093 13.0491 7.43657 13.0144C7.35199 12.8102 7.18976 12.648 6.98557 12.5634C6.95089 12.5491 6.87853 12.5269 6.68854 12.5139C6.49105 12.5005 6.23302 12.5 5.83334 12.5C5.43365 12.5 5.17562 12.5005 4.97813 12.5139Z",
      fill: $props.fill
    }, null, 8, _hoisted_2$a),
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M14.14 10.8333H14.1933C14.5588 10.8333 14.8743 10.8333 15.1353 10.8511C15.4102 10.8699 15.6851 10.9111 15.9567 11.0236C16.5693 11.2774 17.056 11.7641 17.3097 12.3766C17.4222 12.6482 17.4635 12.9232 17.4822 13.198C17.5 13.4591 17.5 13.7745 17.5 14.14V14.1933C17.5 14.5589 17.5 14.8743 17.4822 15.1353C17.4635 15.4102 17.4222 15.6851 17.3097 15.9567C17.056 16.5693 16.5693 17.056 15.9567 17.3097C15.6851 17.4222 15.4102 17.4635 15.1353 17.4822C14.8743 17.5 14.5589 17.5 14.1933 17.5H14.14C13.7745 17.5 13.4591 17.5 13.198 17.4822C12.9232 17.4635 12.6482 17.4222 12.3766 17.3097C11.7641 17.056 11.2774 16.5693 11.0236 15.9567C10.9111 15.6851 10.8699 15.4102 10.8511 15.1353C10.8333 14.8743 10.8333 14.5589 10.8333 14.1934V14.14C10.8333 13.7745 10.8333 13.4591 10.8511 13.198C10.8699 12.9232 10.9111 12.6482 11.0236 12.3766C11.2774 11.7641 11.7641 11.2774 12.3766 11.0236C12.6482 10.9111 12.9232 10.8699 13.198 10.8511C13.4591 10.8333 13.7745 10.8333 14.14 10.8333ZM13.3115 12.5139C13.1215 12.5269 13.0491 12.5491 13.0144 12.5634C12.8102 12.648 12.648 12.8102 12.5634 13.0144C12.5491 13.0491 12.5269 13.1215 12.5139 13.3115C12.5005 13.509 12.5 13.767 12.5 14.1667C12.5 14.5664 12.5005 14.8244 12.5139 15.0219C12.5269 15.2119 12.5491 15.2842 12.5634 15.3189C12.648 15.5231 12.8102 15.6853 13.0144 15.7699C13.0491 15.7843 13.1215 15.8064 13.3115 15.8194C13.509 15.8329 13.767 15.8333 14.1667 15.8333C14.5664 15.8333 14.8244 15.8329 15.0219 15.8194C15.2119 15.8064 15.2842 15.7843 15.3189 15.7699C15.5231 15.6853 15.6853 15.5231 15.7699 15.3189C15.7843 15.2842 15.8064 15.2119 15.8194 15.0219C15.8329 14.8244 15.8333 14.5664 15.8333 14.1667C15.8333 13.767 15.8329 13.509 15.8194 13.3115C15.8064 13.1215 15.7843 13.0491 15.7699 13.0144C15.6853 12.8102 15.5231 12.648 15.3189 12.5634C15.2842 12.5491 15.2119 12.5269 15.0219 12.5139C14.8244 12.5005 14.5664 12.5 14.1667 12.5C13.767 12.5 13.509 12.5005 13.3115 12.5139Z",
      fill: $props.fill
    }, null, 8, _hoisted_3$a),
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M5.80668 2.5H5.85999C6.22553 2.49999 6.54094 2.49998 6.80199 2.51779C7.07684 2.53655 7.35177 2.5778 7.62338 2.6903C8.23595 2.94404 8.72263 3.43072 8.97637 4.04329C9.08887 4.3149 9.13012 4.58982 9.14888 4.86468C9.16669 5.12573 9.16668 5.44114 9.16667 5.80668V5.85999C9.16668 6.22553 9.16669 6.54094 9.14888 6.80199C9.13012 7.07684 9.08887 7.35177 8.97637 7.62338C8.72263 8.23595 8.23595 8.72263 7.62338 8.97637C7.35177 9.08887 7.07684 9.13012 6.80199 9.14888C6.54094 9.16669 6.22553 9.16668 5.85999 9.16667H5.80668C5.44114 9.16668 5.12573 9.16669 4.86468 9.14888C4.58982 9.13012 4.3149 9.08887 4.04329 8.97637C3.43072 8.72263 2.94404 8.23595 2.6903 7.62338C2.5778 7.35177 2.53655 7.07684 2.51779 6.80199C2.49998 6.54094 2.49999 6.22553 2.5 5.85999V5.80668C2.49999 5.44114 2.49998 5.12573 2.51779 4.86468C2.53655 4.58982 2.5778 4.3149 2.6903 4.04329C2.94404 3.43072 3.43072 2.94404 4.04329 2.6903C4.3149 2.5778 4.58982 2.53655 4.86468 2.51779C5.12573 2.49998 5.44114 2.49999 5.80668 2.5ZM4.97813 4.18059C4.78814 4.19356 4.71578 4.21574 4.6811 4.2301C4.47691 4.31468 4.31468 4.47691 4.2301 4.6811C4.21574 4.71578 4.19356 4.78814 4.18059 4.97813C4.16712 5.17562 4.16667 5.43365 4.16667 5.83333C4.16667 6.23302 4.16712 6.49105 4.18059 6.68854C4.19356 6.87853 4.21574 6.95089 4.2301 6.98557C4.31468 7.18976 4.47691 7.35199 4.6811 7.43657C4.71578 7.45093 4.78814 7.47311 4.97813 7.48608C5.17562 7.49955 5.43365 7.5 5.83333 7.5C6.23302 7.5 6.49105 7.49955 6.68854 7.48608C6.87853 7.47311 6.95089 7.45093 6.98557 7.43657C7.18976 7.35199 7.35199 7.18976 7.43657 6.98557C7.45093 6.95089 7.47311 6.87853 7.48608 6.68854C7.49955 6.49105 7.5 6.23302 7.5 5.83333C7.5 5.43365 7.49955 5.17562 7.48608 4.97813C7.47311 4.78814 7.45093 4.71578 7.43657 4.6811C7.35199 4.47691 7.18976 4.31468 6.98557 4.2301C6.95089 4.21574 6.87853 4.19356 6.68854 4.18059C6.49105 4.16712 6.23302 4.16667 5.83333 4.16667C5.43365 4.16667 5.17562 4.16712 4.97813 4.18059Z",
      fill: $props.fill
    }, null, 8, _hoisted_4$7)
  ], 2);
}
const CollectionIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$7], ["__scopeId", "data-v-6cdd1706"]]);
const Sidebar_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$e = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between" };
const _hoisted_2$9 = { class: "vdb-c-text-2xl vdb-c-font-bold" };
const _hoisted_3$9 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-6" };
const _hoisted_4$6 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8" };
const _hoisted_5$6 = { class: "vdb-c-p-4" };
const _hoisted_6$5 = {
  key: 0,
  class: "vdb-c-mt-4 vdb-c-overflow-y-auto"
};
const _hoisted_7$4 = ["onClick"];
const _hoisted_8$4 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8" };
const _hoisted_9$3 = { class: "vdb-c-p-4" };
const _hoisted_10$2 = {
  key: 0,
  class: "vdb-c-overflow-y-scroll vdb-c-rounded-lg vdb-c-px-8 vdb-c-py-4",
  style: { "scrollbar-gutter": "stable" }
};
const _hoisted_11$1 = ["onClick"];
const _hoisted_12$1 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8" };
const _hoisted_13 = { class: "vdb-c-p-4" };
const _hoisted_14 = {
  key: 0,
  class: "vdb-c-mt-4 vdb-c-overflow-y-auto"
};
const _hoisted_15 = { key: 0 };
const _hoisted_16 = ["onClick", "onMouseenter"];
const _hoisted_17 = ["onClick"];
const _hoisted_18 = { class: "vdb-c-mt-auto vdb-c-flex vdb-c-flex-col" };
const _hoisted_19 = ["href", "target"];
const _hoisted_20 = { class: "vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-center vdb-c-gap-6" };
const _hoisted_21 = ["href", "target"];
const _hoisted_22 = ["src"];
const _sfc_main$g = {
  __name: "Sidebar",
  props: {
    sessions: {
      type: Array,
      required: true
    },
    collections: {
      type: Array,
      required: true
    },
    agents: {
      type: Array,
      required: true
    },
    status: {
      type: String,
      default: "active"
    },
    newSessionButtonStatus: {
      type: String,
      default: "active"
    },
    config: {
      type: Object,
      required: true
    },
    selectedCollection: {
      type: String,
      default: "default"
    },
    selectedSession: {
      type: String,
      default: ""
    },
    addDummySession: {
      type: Boolean,
      default: false
    },
    showSelectedCollection: {
      type: Boolean,
      default: false
    },
    initialExploreAgentsOpen: {
      type: Boolean,
      default: true
    },
    initialSessionsOpen: {
      type: Boolean,
      default: true
    },
    initialCollectionsOpen: {
      type: Boolean,
      default: false
    },
    sidebarSections: {
      type: Array,
      default: () => ["collections", "agents", "sessions"],
      validator: (value2) => {
        return value2.every(
          (item) => ["collections", "agents", "sessions"].includes(item)
        );
      }
    }
  },
  emits: [
    "create-new-session",
    "session-click",
    "delete-session",
    "collection-click",
    "agent-click"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const showExploreAgents = vue.ref(true);
    const showSessions = vue.ref(true);
    const showCollections = vue.ref(true);
    const isExploreAgentsFocused = vue.ref(false);
    const exploreAgentsTimeout = vue.ref(null);
    const userClickedSessions = vue.ref(false);
    const userClickedExploreAgents = vue.ref(false);
    const userClickedCollections = vue.ref(false);
    const hoveredSession = vue.ref(null);
    const isMobile = vue.ref((window == null ? void 0 : window.innerWidth) < 1024);
    const isOpen = vue.ref(false);
    const visibleSections = vue.computed(() => {
      return props.sidebarSections;
    });
    const closeSidebar = () => {
      if (isMobile.value) {
        isOpen.value = false;
      }
    };
    const toggleExploreAgents = (value2) => {
      userClickedExploreAgents.value = true;
      showExploreAgents.value = value2 !== void 0 ? value2 : !showExploreAgents.value;
    };
    const toggleSessions = (value2) => {
      userClickedSessions.value = true;
      showSessions.value = value2 !== void 0 ? value2 : !showSessions.value;
    };
    const toggleCollections = (value2) => {
      userClickedCollections.value = true;
      showCollections.value = value2 !== void 0 ? value2 : !showCollections.value;
    };
    const toggleSidebar = () => {
      isOpen.value = !isOpen.value;
    };
    const triggerExploreAgentsFocusAnimation = () => {
      if (exploreAgentsTimeout.value) {
        clearTimeout(exploreAgentsTimeout.value);
      }
      isExploreAgentsFocused.value = false;
      vue.nextTick(() => {
        isExploreAgentsFocused.value = true;
        exploreAgentsTimeout.value = setTimeout(() => {
          isExploreAgentsFocused.value = false;
        }, 1e3);
      });
    };
    const computedSelectedCollection = vue.computed(() => {
      if (props.selectedCollection !== "default") {
        return props.selectedCollection;
      }
      return props.collections.length > 0 ? props.collections[0].id : null;
    });
    vue.watch(
      () => props.initialSessionsOpen,
      (newValue) => {
        if (!userClickedSessions.value) {
          showSessions.value = newValue;
        }
      },
      { immediate: true }
    );
    vue.watch(
      () => props.initialExploreAgentsOpen,
      (newValue) => {
        if (!userClickedExploreAgents.value) {
          showExploreAgents.value = newValue;
        }
      },
      { immediate: true }
    );
    vue.watch(
      () => props.initialCollectionsOpen,
      (newValue) => {
        if (!userClickedCollections.value) {
          showCollections.value = newValue;
        }
      },
      { immediate: true }
    );
    vue.watch(showExploreAgents, (newValue) => {
    });
    __expose({
      toggleExploreAgents,
      toggleSessions,
      toggleCollections,
      triggerExploreAgentsFocusAnimation,
      toggleSidebar
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
        vue.createElementVNode("div", {
          class: vue.normalizeClass([
            "vdb-c-flex vdb-c-h-full vdb-c-flex-col vdb-c-gap-16 vdb-c-border-l vdb-c-bg-white vdb-c-p-16 vdb-c-pl-12 vdb-c-pr-20 vdb-c-text-black",
            {
              "vdb-c-w-1/5": !isMobile.value,
              "vdb-c-fixed vdb-c-left-0 vdb-c-top-0 vdb-c-z-50 vdb-c-h-full vdb-c-w-4/5 vdb-c-transform vdb-c-transition-transform vdb-c-duration-300 vdb-c-ease-in-out md:vdb-c-w-2/5": isMobile.value,
              "vdb-c--translate-x-full": isMobile.value && !isOpen.value
            }
          ])
        }, [
          vue.createElementVNode("div", _hoisted_1$e, [
            vue.createElementVNode("div", _hoisted_2$9, [
              __props.config.icon ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(__props.config.icon), { key: 0 })) : vue.createCommentVNode("", true)
            ]),
            isMobile.value ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 0,
              onClick: closeSidebar,
              class: "vdb-c-text-2xl vdb-c-font-bold"
            }, " × ")) : vue.createCommentVNode("", true)
          ]),
          vue.createVNode(_sfc_main$C, {
            variant: "primary",
            class: vue.normalizeClass(["vdb-c-px-10 vdb-c-py-12", {
              "vdb-c-pointer-events-none vdb-c-opacity-20": __props.newSessionButtonStatus !== "active"
            }]),
            onClick: _cache[0] || (_cache[0] = ($event) => {
              _ctx.$emit("create-new-session");
              closeSidebar();
            })
          }, {
            default: vue.withCtx(() => [
              vue.createElementVNode("div", _hoisted_3$9, [
                vue.createVNode(ComposeIcon),
                _cache[5] || (_cache[5] = vue.createElementVNode("span", { class: "vdb-c-block vdb-c-text-sm vdb-c-font-medium" }, "New Chat", -1))
              ])
            ]),
            _: 1
          }, 8, ["class"]),
          vue.createElementVNode("div", {
            class: vue.normalizeClass(["vdb-c-flex vdb-c-flex-grow vdb-c-flex-col vdb-c-gap-16 vdb-c-overflow-hidden", {
              "vdb-c-pointer-events-none vdb-c-opacity-20": __props.status === "inactive"
            }])
          }, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(visibleSections.value, (section) => {
              return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: section }, [
                section === "collections" ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 0,
                  class: "sidebar-section vdb-c-flex vdb-c-flex-col vdb-c-overflow-hidden",
                  style: vue.normalizeStyle({
                    "max-height": `calc(100% / ${visibleSections.value.length})`
                  })
                }, [
                  vue.createElementVNode("button", {
                    onClick: _cache[1] || (_cache[1] = ($event) => toggleCollections()),
                    class: "vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-between vdb-c-rounded-lg vdb-c-px-12 vdb-c-py-6 vdb-c-text-pam hover:vdb-c-bg-roy"
                  }, [
                    vue.createElementVNode("div", _hoisted_4$6, [
                      vue.createVNode(CollectionIcon, {
                        class: "vdb-c-mr-8",
                        fill: "#464646"
                      }),
                      _cache[6] || (_cache[6] = vue.createElementVNode("span", { class: "vdb-c-font-semibold vdb-c-leading-5" }, "Collections", -1))
                    ]),
                    vue.createElementVNode("div", _hoisted_5$6, [
                      vue.createVNode(ChevronDown, {
                        class: vue.normalizeClass([
                          "vdb-c-h-16 vdb-c-w-16 vdb-c-transition-transform",
                          { "vdb-c-rotate-180": showCollections.value }
                        ]),
                        "stroke-color": "#464646",
                        "stroke-width": 2
                      }, null, 8, ["class"])
                    ])
                  ]),
                  __props.status !== "inactive" && showCollections.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6$5, [
                    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.collections, (collection) => {
                      return vue.openBlock(), vue.createElementBlock("div", {
                        key: collection.id,
                        onClick: ($event) => {
                          _ctx.$emit("collection-click", collection.id);
                          closeSidebar();
                        },
                        class: vue.normalizeClass([
                          "vdb-c-ml-24 vdb-c-cursor-pointer vdb-c-truncate vdb-c-rounded-lg vdb-c-p-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-vdb-darkishgrey",
                          {
                            "vdb-c-bg-[#FFF5EC]": __props.showSelectedCollection && collection.id === computedSelectedCollection.value,
                            "hover:vdb-c-bg-[#FFF5EC]": collection.id !== computedSelectedCollection.value
                          }
                        ])
                      }, vue.toDisplayString(collection.name), 11, _hoisted_7$4);
                    }), 128))
                  ])) : vue.createCommentVNode("", true)
                ], 4)) : vue.createCommentVNode("", true),
                section === "agents" ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 1,
                  class: "sidebar-section vdb-c-flex vdb-c-flex-col vdb-c-gap-4 vdb-c-rounded-lg vdb-c-border vdb-c-border-transparent",
                  style: vue.normalizeStyle({
                    "max-height": `calc(100% / ${visibleSections.value.length})`
                  })
                }, [
                  vue.createElementVNode("button", {
                    onClick: _cache[2] || (_cache[2] = ($event) => toggleExploreAgents()),
                    class: vue.normalizeClass([
                      "vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-between vdb-c-rounded-lg vdb-c-px-12 vdb-c-py-6 vdb-c-font-medium vdb-c-text-pam vdb-c-transition-all vdb-c-duration-300 hover:vdb-c-bg-roy"
                    ])
                  }, [
                    vue.createElementVNode("div", _hoisted_8$4, [
                      vue.createVNode(AgentIcon, { class: "vdb-c-mr-8" }),
                      _cache[7] || (_cache[7] = vue.createElementVNode("span", { class: "vdb-c-font-semibold vdb-c-leading-5" }, "Explore Agents", -1))
                    ]),
                    vue.createElementVNode("div", _hoisted_9$3, [
                      vue.createVNode(ChevronDown, {
                        class: vue.normalizeClass([
                          "vdb-c-h-16 vdb-c-w-16 vdb-c-transition-transform vdb-c-duration-300",
                          { "vdb-c-rotate-180": showExploreAgents.value }
                        ]),
                        "stroke-color": "#464646",
                        "stroke-width": 2
                      }, null, 8, ["class"])
                    ])
                  ]),
                  __props.status !== "inactive" && showExploreAgents.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_10$2, [
                    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.agents, (agent, index) => {
                      return vue.openBlock(), vue.createElementBlock("div", {
                        key: index,
                        onClick: ($event) => {
                          _ctx.$emit("agent-click", agent);
                          closeSidebar();
                        },
                        class: vue.normalizeClass([
                          "vdb-c-ml-18 vdb-c-cursor-pointer vdb-c-truncate vdb-c-rounded-lg vdb-c-border vdb-c-border-transparent vdb-c-bg-white vdb-c-p-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-black vdb-c-transition-all vdb-c-duration-75 hover:vdb-c-bg-[#FFF5EC]"
                        ])
                      }, [
                        _cache[8] || (_cache[8] = vue.createElementVNode("span", { class: "vdb-c-text-orange" }, " @ ", -1)),
                        vue.createElementVNode("span", null, vue.toDisplayString(agent.name), 1)
                      ], 8, _hoisted_11$1);
                    }), 128))
                  ])) : vue.createCommentVNode("", true)
                ], 4)) : vue.createCommentVNode("", true),
                section === "sessions" ? (vue.openBlock(), vue.createElementBlock("div", {
                  key: 2,
                  class: "sidebar-section vdb-c-flex vdb-c-flex-col vdb-c-overflow-hidden",
                  style: vue.normalizeStyle({
                    "max-height": `calc(100% / ${visibleSections.value.length})`
                  })
                }, [
                  vue.createElementVNode("button", {
                    onClick: _cache[3] || (_cache[3] = ($event) => toggleSessions()),
                    class: "vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-between vdb-c-rounded vdb-c-px-12 vdb-c-py-6 vdb-c-text-pam hover:vdb-c-bg-roy"
                  }, [
                    vue.createElementVNode("div", _hoisted_12$1, [
                      vue.createVNode(ChatIcon, {
                        class: "vdb-c-mr-8",
                        fill: "#464646"
                      }),
                      _cache[9] || (_cache[9] = vue.createElementVNode("span", { class: "vdb-c-font-semibold vdb-c-leading-5" }, "Chats", -1))
                    ]),
                    vue.createElementVNode("div", _hoisted_13, [
                      vue.createVNode(ChevronDown, {
                        class: vue.normalizeClass([
                          "vdb-c-h-16 vdb-c-w-16 vdb-c-transition-transform",
                          { "vdb-c-rotate-180": showSessions.value }
                        ]),
                        "stroke-color": "#464646",
                        "stroke-width": 2
                      }, null, 8, ["class"])
                    ])
                  ]),
                  __props.status !== "inactive" && showSessions.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_14, [
                    vue.createVNode(vue.Transition, {
                      name: "fade",
                      mode: "out-in"
                    }, {
                      default: vue.withCtx(() => [
                        __props.addDummySession ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_15, _cache[10] || (_cache[10] = [
                          vue.createElementVNode("div", { class: "vdb-c-ml-24 vdb-c-cursor-pointer vdb-c-truncate vdb-c-rounded-lg vdb-c-bg-[#FFF5EC] vdb-c-p-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-vdb-darkishgrey" }, " (new chat) ", -1)
                        ]))) : vue.createCommentVNode("", true)
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.TransitionGroup, {
                      name: "fade",
                      tag: "div"
                    }, {
                      default: vue.withCtx(() => [
                        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.sessions, (session) => {
                          return vue.openBlock(), vue.createElementBlock("div", {
                            key: session.session_id,
                            onClick: ($event) => {
                              _ctx.$emit("session-click", session.session_id);
                              closeSidebar();
                            },
                            onMouseenter: ($event) => hoveredSession.value = session.session_id,
                            onMouseleave: _cache[4] || (_cache[4] = ($event) => hoveredSession.value = null),
                            class: vue.normalizeClass([
                              "vdb-c-ml-24 vdb-c-flex vdb-c-cursor-pointer vdb-c-items-center vdb-c-justify-between vdb-c-truncate vdb-c-rounded-lg vdb-c-p-8 vdb-c-px-12 vdb-c-text-sm vdb-c-font-medium vdb-c-text-vdb-darkishgrey",
                              {
                                "vdb-c-bg-[#FFF5EC]": session.session_id === __props.selectedSession,
                                "hover:vdb-c-bg-[#FFF5EC]": session.session_id !== __props.selectedSession
                              }
                            ])
                          }, [
                            vue.createElementVNode("span", null, vue.toDisplayString(new Date(session.created_at * 1e3).toLocaleString("en-US", {
                              year: "numeric",
                              month: "2-digit",
                              day: "2-digit",
                              hour: "2-digit",
                              minute: "2-digit",
                              second: "2-digit",
                              hour12: false
                            }).replace(/\//g, ".").replace(",", " -")), 1),
                            vue.createElementVNode("span", {
                              onClick: vue.withModifiers(($event) => {
                                _ctx.$emit("delete-session", session.session_id);
                                closeSidebar();
                              }, ["stop"]),
                              class: "vdb-c-transition-all vdb-c-duration-300 hover:vdb-c-scale-110"
                            }, [
                              vue.createVNode(DeleteIcon, {
                                fill: hoveredSession.value === session.session_id ? "black" : "#CCCCCC"
                              }, null, 8, ["fill"])
                            ], 8, _hoisted_17)
                          ], 42, _hoisted_16);
                        }), 128))
                      ]),
                      _: 1
                    })
                  ])) : vue.createCommentVNode("", true)
                ], 4)) : vue.createCommentVNode("", true)
              ], 64);
            }), 128))
          ], 2),
          vue.createElementVNode("div", _hoisted_18, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.config.links, (link, index) => {
              return vue.openBlock(), vue.createElementBlock("a", {
                key: index,
                class: "vdb-c-mx-8 vdb-c-my-10 vdb-c-flex vdb-c-items-center vdb-c-gap-12 vdb-c-pl-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-vdb-darkishgrey hover:vdb-c-text-black hover:vdb-c-no-underline",
                href: link.href,
                target: link.target || "_blank",
                rel: "noopener noreferrer"
              }, [
                vue.createElementVNode("span", null, vue.toDisplayString(link.text), 1),
                link.icon ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(link.icon), { key: 0 })) : vue.createCommentVNode("", true)
              ], 8, _hoisted_19);
            }), 128)),
            __props.config.primaryLink ? (vue.openBlock(), vue.createBlock(_sfc_main$C, {
              key: 0,
              class: vue.normalizeClass(["vdb-c-mt-16 vdb-c-w-full", {
                "vdb-c-pointer-events-none vdb-c-opacity-20": __props.status === "inactive"
              }]),
              variant: "tertiary"
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_20, [
                  vue.createElementVNode("a", {
                    href: __props.config.primaryLink.href,
                    target: __props.config.primaryLink.target || "_blank",
                    rel: "noopener noreferrer",
                    class: "vdb-c-flex vdb-c-items-center vdb-c-text-white hover:vdb-c-text-white hover:vdb-c-no-underline"
                  }, [
                    __props.config.primaryLink.icon ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                      typeof __props.config.primaryLink.icon === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
                        key: 0,
                        src: __props.config.primaryLink.icon,
                        alt: "Primary Link Icon",
                        class: "vdb-c-mr-8 vdb-c-h-20 vdb-c-w-20"
                      }, null, 8, _hoisted_22)) : typeof __props.config.primaryLink.icon === "object" ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(__props.config.primaryLink.icon), {
                        key: 1,
                        class: "vdb-c-mr-8 vdb-c-h-20 vdb-c-w-20"
                      })) : vue.createCommentVNode("", true)
                    ], 64)) : vue.createCommentVNode("", true),
                    vue.createTextVNode(" " + vue.toDisplayString(__props.config.primaryLink.text), 1)
                  ], 8, _hoisted_21)
                ])
              ]),
              _: 1
            }, 8, ["class"])) : vue.createCommentVNode("", true)
          ])
        ], 2),
        vue.createVNode(vue.Transition, { name: "fade" }, {
          default: vue.withCtx(() => [
            isMobile.value && !isOpen.value ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 0,
              onClick: toggleSidebar,
              class: "vdb-c-shadow-md vdb-c-fixed vdb-c-left-16 vdb-c-top-16 vdb-c-z-50 vdb-c-rounded-full vdb-c-bg-white vdb-c-p-8"
            }, _cache[11] || (_cache[11] = [
              vue.createElementVNode("div", { class: "vdb-c-flex vdb-c-h-24 vdb-c-w-24 vdb-c-flex-col vdb-c-items-center vdb-c-justify-center" }, [
                vue.createElementVNode("div", { class: "vdb-c-mb-2 vdb-c-h-2 vdb-c-w-20 vdb-c-bg-gray-600" }),
                vue.createElementVNode("div", { class: "vdb-c-mb-2 vdb-c-h-2 vdb-c-w-20 vdb-c-bg-gray-600" }),
                vue.createElementVNode("div", { class: "vdb-c-mb-2 vdb-c-h-2 vdb-c-w-20 vdb-c-bg-gray-600" })
              ], -1)
            ]))) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ], 64);
    };
  }
};
const UploadNotifications_vue_vue_type_style_index_0_scoped_5c6dc672_lang = "";
const _hoisted_1$d = { class: "vdb-c-absolute vdb-c-bottom-4 vdb-c-right-24 vdb-c-z-50 vdb-c-flex vdb-c-flex-col vdb-c-gap-2" };
const _hoisted_2$8 = { class: "flex items-center justify-center vdb-c-rounded-full vdb-c-px-20 vdb-c-py-14" };
const _hoisted_3$8 = {
  key: 0,
  class: "vdb-c-p-12"
};
const _hoisted_4$5 = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  width: "30",
  height: "30",
  viewBox: "0 0 30 30",
  class: "vdb-c-text-success-700",
  fill: "currentColor"
};
const _hoisted_5$5 = {
  key: 2,
  xmlns: "http://www.w3.org/2000/svg",
  width: "30",
  height: "30",
  viewBox: "0 0 30 30",
  class: "vdb-c-text-danger-700",
  fill: "currentColor"
};
const _hoisted_6$4 = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-4 vdb-c-border-l vdb-c-border-roy vdb-c-p-16" };
const _hoisted_7$3 = { class: "vdb-c-font-semibold vdb-c-text-kilvish-900" };
const _hoisted_8$3 = ["title"];
const _hoisted_9$2 = { class: "vdb-c-text-sm vdb-c-text-vdb-darkishgrey" };
const _sfc_main$f = {
  __name: "UploadNotifications",
  setup(__props, { expose: __expose }) {
    const uploads = vue.ref([]);
    let uploadCounter = 0;
    const addUpload = (name, description = null) => {
      const id = uploadCounter++;
      const upload = {
        id,
        name,
        description,
        status: "loading"
      };
      uploads.value.push(upload);
      return id;
    };
    const updateUploadStatus = (id, status) => {
      const upload = uploads.value.find((u) => u.id === id);
      if (upload) {
        upload.status = status;
        if (status === "success") {
          setTimeout(() => {
            uploads.value = uploads.value.filter((u) => u.id !== id);
          }, 3e3);
        }
        if (status === "error") {
          setTimeout(() => {
            uploads.value = uploads.value.filter((u) => u.id !== id);
          }, 5e3);
        }
      }
    };
    __expose({
      addUpload,
      updateUploadStatus
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$d, [
        vue.createVNode(vue.TransitionGroup, { name: "notification" }, {
          default: vue.withCtx(() => [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(uploads.value, (upload) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: upload.id,
                class: "vdb-c-flex vdb-c-h-[80px] vdb-c-w-[400px] vdb-c-cursor-pointer vdb-c-items-center vdb-c-rounded-lg vdb-c-border-2 vdb-c-border-roy vdb-c-bg-white hover:vdb-c-bg-gray-100"
              }, [
                vue.createElementVNode("div", _hoisted_2$8, [
                  vue.createElementVNode("div", {
                    class: vue.normalizeClass(["vdb-c-flex vdb-c-h-54 vdb-c-w-54 vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full", {
                      "vdb-c-bg-orange-100": upload.status === "loading",
                      "vdb-c-bg-green-100": upload.status === "success",
                      "vdb-c-bg-red-100": upload.status === "error"
                    }])
                  }, [
                    upload.status === "loading" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$8, [
                      vue.createVNode(FileUpload, {
                        class: "vdb-c-text-orange",
                        fill: "#EC5B16"
                      })
                    ])) : upload.status === "success" ? (vue.openBlock(), vue.createElementBlock("svg", _hoisted_4$5, _cache[0] || (_cache[0] = [
                      vue.createElementVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M25.0605 7.93945C25.6462 8.52513 25.6462 9.47487 25.0605 10.0605L13.0605 22.0605C12.4748 22.6462 11.5252 22.6462 10.9395 22.0605L4.93945 16.0605C4.35376 15.4748 4.35376 14.5252 4.93945 13.9395C5.52513 13.3538 6.47487 13.3538 7.06055 13.9395L12 18.8789L22.9395 7.93945C23.5252 7.35376 24.4748 7.35376 25.0605 7.93945Z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ]))) : (vue.openBlock(), vue.createElementBlock("svg", _hoisted_5$5, _cache[1] || (_cache[1] = [
                      vue.createElementVNode("path", {
                        "fill-rule": "evenodd",
                        d: "M6.43945 6.43945C7.02513 5.85376 7.97487 5.85376 8.56055 6.43945L15 12.8789L21.4395 6.43945C22.0252 5.85376 22.9748 5.85376 23.5605 6.43945C24.1462 7.02513 24.1462 7.97487 23.5605 8.56055L17.1211 15L23.5605 21.4395C24.1462 22.0252 24.1462 22.9748 23.5605 23.5605C22.9748 24.1462 22.0252 24.1462 21.4395 23.5605L15 17.1211L8.56055 23.5605C7.97487 24.1462 7.02513 24.1462 6.43945 23.5605C5.85376 22.9748 5.85376 22.0252 6.43945 21.4395L12.8789 15L6.43945 8.56055C5.85376 7.97487 5.85376 7.02513 6.43945 6.43945Z",
                        "clip-rule": "evenodd"
                      }, null, -1)
                    ])))
                  ], 2)
                ]),
                vue.createElementVNode("div", _hoisted_6$4, [
                  vue.createElementVNode("h4", _hoisted_7$3, [
                    vue.createElementVNode("span", {
                      class: "vdb-c-block vdb-c-max-w-[200px] vdb-c-truncate vdb-c-text-base vdb-c-font-semibold vdb-c-text-kilvish-900 sm:vdb-c-text-lg",
                      title: upload.name
                    }, vue.toDisplayString(upload.name), 9, _hoisted_8$3)
                  ]),
                  vue.createElementVNode("p", _hoisted_9$2, [
                    vue.createElementVNode("span", {
                      class: vue.normalizeClass(["vdb-c-line-clamp-2 vdb-c-text-xs vdb-c-font-normal sm:vdb-c-text-sm", {
                        "vdb-c-text-orange": upload.status === "loading",
                        "vdb-c-text-success-700": upload.status === "success",
                        "vdb-c-text-danger-700": upload.status === "error"
                      }])
                    }, [
                      upload.description ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                        vue.createTextVNode(vue.toDisplayString(upload.description), 1)
                      ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                        upload.status === "loading" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                          _cache[2] || (_cache[2] = vue.createTextVNode(" Uploading")),
                          _cache[3] || (_cache[3] = vue.createElementVNode("span", { class: "loading-dots" }, null, -1))
                        ], 64)) : upload.status === "success" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                          vue.createTextVNode(" Upload complete ")
                        ], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 2 }, [
                          vue.createTextVNode(" Upload failed ")
                        ], 64))
                      ], 64))
                    ], 2)
                  ])
                ])
              ]);
            }), 128))
          ]),
          _: 1
        })
      ]);
    };
  }
};
const UploadNotifications = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__scopeId", "data-v-5c6dc672"]]);
const _sfc_main$e = {
  props: {
    ytLink: {
      type: String,
      default: "https://www.youtube.com/watch?v=FgrO9ADPZSA"
    }
  }
};
const _hoisted_1$c = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-4 vdb-c-break-words vdb-c-text-kilvish-900" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$c, _cache[0] || (_cache[0] = [
    vue.createElementVNode("div", { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-4" }, " Click here to see an example query → ", -1)
  ]));
}
const UploadVideoQueryCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$6]]);
const _sfc_main$d = {
  name: "Cross",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#969696"
    }
  }
};
const _hoisted_1$b = ["fill"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "10",
    height: "10",
    viewBox: "0 0 10 10",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, [
    vue.createElementVNode("path", {
      d: "M3.64897 4.85103L0 8.5L1.20208 9.70208L4.85105 6.05311L8.50002 9.70208L9.70211 8.5L6.05313 4.85103L9.70208 1.20208L8.5 0L4.85105 3.64895L1.20211 0L2.43187e-05 1.20208L3.64897 4.85103Z",
      fill: $props.fill
    }, null, 8, _hoisted_1$b)
  ], 2);
}
const CrossIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$5]]);
const _hoisted_1$a = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between vdb-c-p-24" };
const _hoisted_2$7 = { class: "vdb-c-space-y-24 vdb-c-p-24" };
const _hoisted_3$7 = ["disabled"];
const _hoisted_4$4 = {
  key: 0,
  class: "vdb-c-mt-2 vdb-c-text-xs vdb-c-text-gray-400"
};
const _hoisted_5$4 = {
  key: 0,
  class: "vdb-c-flex vdb-c-flex-col vdb-c-items-center vdb-c-gap-8"
};
const _hoisted_6$3 = { class: "vdb-c-text-gray-300" };
const _hoisted_7$2 = {
  key: 1,
  class: "vdb-c-text-gray-300"
};
const _hoisted_8$2 = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-between" };
const _hoisted_9$1 = { class: "vdb-c-relative vdb-c-w-[70%]" };
const _hoisted_10$1 = {
  key: 0,
  class: "vdb-c-absolute vdb-c-z-10 vdb-c-mt-4 vdb-c-max-h-[200px] vdb-c-w-full vdb-c-overflow-y-auto vdb-c-rounded-lg vdb-c-bg-[#141414]"
};
const _hoisted_11 = ["onClick"];
const _hoisted_12 = { class: "vdb-c-flex vdb-c-justify-center vdb-c-gap-12 vdb-c-border-t vdb-c-border-gray-800 vdb-c-p-16" };
const _sfc_main$c = {
  __name: "UploadModal",
  props: {
    showUploadDialog: {
      type: Boolean,
      required: true
    },
    defaultSelectedCollectionId: {
      type: String,
      default: null
    },
    collections: {
      type: Array,
      default: () => [],
      required: true
    }
  },
  emits: ["cancel-upload", "upload"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    let dragCounter = 0;
    const isDragging = vue.ref(false);
    const hasUrl = vue.ref(false);
    const hasUploadedFile = vue.ref(false);
    const url2 = vue.ref("");
    const fileInput = vue.ref(null);
    const fileInputEl = vue.ref(null);
    const selectedCollection = vue.ref(null);
    const isDropdownOpen = vue.ref(false);
    const clearState = () => {
      dragCounter = 0;
      isDragging.value = false;
      hasUrl.value = false;
      hasUploadedFile.value = false;
      url2.value = "";
      fileInput.value = null;
      selectedCollection.value = props.defaultSelectedCollectionId || null;
      isDropdownOpen.value = false;
    };
    const handleUrlInput = (e) => {
      if (e.target.value) {
        hasUrl.value = true;
      } else {
        hasUrl.value = false;
      }
    };
    const clearSelectedFile = () => {
      fileInput.value = null;
      hasUploadedFile.value = false;
    };
    const handleDragEnter = (e) => {
      e.preventDefault();
      dragCounter++;
      if (!hasUrl.value && !hasUploadedFile.value) {
        isDragging.value = true;
      }
    };
    const handleDragLeave = (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        isDragging.value = false;
      }
    };
    const handleDragOver = (e) => {
      e.preventDefault();
      if (!hasUrl.value && !hasUploadedFile.value) {
        isDragging.value = true;
      }
    };
    const handleDrop = (e) => {
      e.preventDefault();
      isDragging.value = false;
      dragCounter = 0;
      if (!hasUrl.value && !hasUploadedFile.value) {
        const files = Array.from(e.dataTransfer.files);
        const validFiles = files.filter(
          (file) => file.type.startsWith("audio/") || file.type.startsWith("video/") || file.type.startsWith("image/")
        );
        if (validFiles.length > 0) {
          hasUploadedFile.value = true;
          url2.value = "";
          hasUrl.value = false;
          fileInput.value = files[0];
        }
      }
    };
    const handleFileSelect = (e) => {
      const files = e.target.files;
      if (files.length > 0) {
        hasUploadedFile.value = true;
        url2.value = "";
        hasUrl.value = false;
        fileInput.value = files[0];
      }
    };
    const triggerFileInput = () => {
      var _a;
      (_a = fileInputEl.value) == null ? void 0 : _a.click();
    };
    const handleCancel = () => {
      emit("cancel-upload");
      clearState();
    };
    const handleUpload = () => {
      if (hasUrl.value) {
        emit("upload", {
          source: { url: url2.value },
          sourceType: "url",
          collectionId: selectedCollection.value
        });
      } else if (hasUploadedFile.value) {
        emit("upload", {
          source: fileInput.value,
          sourceType: "file",
          collectionId: selectedCollection.value
        });
      }
      clearState();
    };
    vue.watch(
      () => props.collections,
      (newCollections) => {
        if (newCollections.length > 0 && !selectedCollection.value) {
          selectedCollection.value = props.defaultSelectedCollectionId || newCollections[0].id;
        }
      },
      { immediate: true }
    );
    vue.watch(
      () => props.defaultSelectedCollectionId,
      (newDefaultId) => {
        if (newDefaultId) {
          selectedCollection.value = newDefaultId;
        }
      }
    );
    return (_ctx, _cache) => {
      var _a;
      return __props.showUploadDialog ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "vdb-c-fixed vdb-c-inset-0 vdb-c-flex vdb-c-items-center vdb-c-justify-center vdb-c-bg-black/50",
        onClick: handleCancel
      }, [
        vue.createElementVNode("div", {
          class: "vdb-c-shadow-xl vdb-c-w-[480px] vdb-c-rounded-lg vdb-c-bg-[#1F1F1F]",
          onClick: _cache[3] || (_cache[3] = vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          vue.createElementVNode("div", _hoisted_1$a, [
            _cache[4] || (_cache[4] = vue.createElementVNode("h2", { class: "vdb-c-text-base vdb-c-font-semibold vdb-c-text-white" }, " Upload Media ", -1)),
            vue.createElementVNode("button", {
              onClick: handleCancel,
              class: "vdb-c-text-gray-400 hover:vdb-c-text-white"
            }, [
              vue.createVNode(CrossIcon, {
                class: "vdb-c-h-20 vdb-c-w-20",
                fill: "#848484"
              })
            ])
          ]),
          vue.createElementVNode("div", _hoisted_2$7, [
            vue.createElementVNode("div", null, [
              vue.withDirectives(vue.createElementVNode("input", {
                type: "text",
                placeholder: "Upload a URL",
                class: "vdb-c-w-full vdb-c-rounded-lg vdb-c-border vdb-c-border-[#424242] vdb-c-bg-[#0C0C0C] vdb-c-px-16 vdb-c-py-8 vdb-c-text-white placeholder:vdb-c-text-[#424242] focus:vdb-c-outline-none focus:vdb-c-ring-1 focus:vdb-c-ring-[#FF5B0A]",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => url2.value = $event),
                disabled: hasUploadedFile.value,
                onInput: handleUrlInput
              }, null, 40, _hoisted_3$7), [
                [vue.vModelText, url2.value]
              ]),
              hasUploadedFile.value ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_4$4, " URL input disabled - file already selected ")) : vue.createCommentVNode("", true)
            ]),
            _cache[6] || (_cache[6] = vue.createElementVNode("div", { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-16" }, [
              vue.createElementVNode("div", { class: "vdb-c-h-px vdb-c-flex-1 vdb-c-bg-gray-800" }),
              vue.createElementVNode("span", { class: "vdb-c-text-gray-500" }, "Or"),
              vue.createElementVNode("div", { class: "vdb-c-h-px vdb-c-flex-1 vdb-c-bg-gray-800" })
            ], -1)),
            vue.createElementVNode("div", {
              class: vue.normalizeClass([
                "vdb-c-rounded-lg vdb-c-border-2 vdb-c-border-dashed vdb-c-p-32 vdb-c-text-center vdb-c-transition-colors",
                isDragging.value ? "vdb-c-border-[#FF5B0A] vdb-c-bg-black/40" : hasUrl.value || hasUploadedFile.value ? "vdb-c-border-[#2C2C2C] vdb-c-bg-[#1A1A1A]" : "vdb-c-cursor-pointer vdb-c-border-white/20 vdb-c-bg-black/20 hover:vdb-c-border-white/40 hover:vdb-c-bg-black/20"
              ]),
              onDragenter: vue.withModifiers(handleDragEnter, ["prevent"]),
              onDragleave: vue.withModifiers(handleDragLeave, ["prevent"]),
              onDragover: vue.withModifiers(handleDragOver, ["prevent"]),
              onDrop: vue.withModifiers(handleDrop, ["prevent"]),
              onClick: _cache[1] || (_cache[1] = ($event) => !hasUrl.value && !hasUploadedFile.value && triggerFileInput())
            }, [
              vue.createElementVNode("input", {
                type: "file",
                ref_key: "fileInputEl",
                ref: fileInputEl,
                class: "vdb-c-hidden",
                accept: "audio/*,video/*,image/*",
                onChange: handleFileSelect
              }, null, 544),
              hasUploadedFile.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5$4, [
                vue.createElementVNode("p", _hoisted_6$3, " Selected file: " + vue.toDisplayString(fileInput.value.name), 1),
                vue.createElementVNode("button", {
                  onClick: vue.withModifiers(clearSelectedFile, ["stop"]),
                  class: "vdb-c-text-[#FF5B0A] hover:vdb-c-text-[#FF7B3A]"
                }, " Remove file ")
              ])) : (vue.openBlock(), vue.createElementBlock("p", _hoisted_7$2, vue.toDisplayString(hasUrl.value ? "File upload disabled - URL already entered" : isDragging.value ? "Drop your files here" : "Click or drop audio, video or image files here to upload"), 1))
            ], 34),
            vue.createElementVNode("div", _hoisted_8$2, [
              _cache[5] || (_cache[5] = vue.createElementVNode("label", { class: "vdb-c-text-gray-300" }, "Add files to*", -1)),
              vue.createElementVNode("div", _hoisted_9$1, [
                vue.createElementVNode("button", {
                  onClick: _cache[2] || (_cache[2] = vue.withModifiers(($event) => isDropdownOpen.value = !isDropdownOpen.value, ["stop"])),
                  class: vue.normalizeClass(["vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-between vdb-c-rounded-lg vdb-c-border vdb-c-border-[#424242] vdb-c-bg-[#0C0C0C] vdb-c-px-16 vdb-c-py-8 vdb-c-text-white", {
                    "vdb-c-border-[#FF5B0A]": isDropdownOpen.value
                  }])
                }, [
                  vue.createTextVNode(vue.toDisplayString(selectedCollection.value ? (_a = __props.collections.find((c) => c.id === selectedCollection.value)) == null ? void 0 : _a.name : "Select Collection") + " ", 1),
                  vue.createVNode(ChevronDown, {
                    class: vue.normalizeClass(["vdb-c-h-16 vdb-c-w-16", { "vdb-c-rotate-180": isDropdownOpen.value }]),
                    "stroke-color": "#ffffff",
                    "stroke-width": 2
                  }, null, 8, ["class"])
                ], 2),
                isDropdownOpen.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_10$1, [
                  (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.collections, (collection) => {
                    return vue.openBlock(), vue.createElementBlock("div", {
                      key: collection.id,
                      onClick: vue.withModifiers(($event) => {
                        selectedCollection.value = collection.id;
                        isDropdownOpen.value = false;
                      }, ["stop"]),
                      class: "vdb-c-cursor-pointer vdb-c-px-16 vdb-c-py-8 vdb-c-text-white vdb-c-transition-colors hover:vdb-c-bg-[#1F1F1F] hover:vdb-c-text-gray-300"
                    }, vue.toDisplayString(collection.name), 9, _hoisted_11);
                  }), 128))
                ])) : vue.createCommentVNode("", true)
              ])
            ])
          ]),
          vue.createElementVNode("div", _hoisted_12, [
            vue.createVNode(_sfc_main$C, {
              onClick: handleUpload,
              variant: "tertiary",
              class: "!vdb-c-px-12 !vdb-c-py-8"
            }, {
              default: vue.withCtx(() => _cache[7] || (_cache[7] = [
                vue.createTextVNode(" Upload ")
              ])),
              _: 1
            }),
            vue.createElementVNode("button", {
              onClick: handleCancel,
              class: "vdb-c-px-16 vdb-c-py-8 vdb-c-text-gray-300 vdb-c-transition-colors hover:vdb-c-text-white"
            }, " Cancel ")
          ])
        ])
      ])) : vue.createCommentVNode("", true);
    };
  }
};
const WarningExclamation_vue_vue_type_style_index_0_scoped_9cd20102_lang = "";
const _sfc_main$b = {
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
const _hoisted_1$9 = {
  width: "20",
  height: "18",
  viewBox: "0 0 20 18",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$9, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      d: "M10 7V9M10 13H10.01M3.07183 17H16.9282C18.4678 17 19.4301 15.3333 18.6603 14L11.7321 2C10.9623 0.666667 9.03778 0.666667 8.26798 2L1.33978 14C0.56998 15.3333 1.53223 17 3.07183 17Z",
      stroke: "#DC2626",
      "stroke-width": "2",
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, -1)
  ]));
}
const WarningExclamation = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$4], ["__scopeId", "data-v-9cd20102"]]);
const _hoisted_1$8 = { class: "vdb-c-flex vdb-c-gap-16 vdb-c-px-24 vdb-c-py-16 vdb-c-pt-24" };
const _hoisted_2$6 = { class: "vdb-c-flex vdb-c-h-40 vdb-c-w-40 vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full vdb-c-bg-red-100" };
const _hoisted_3$6 = { class: "vdb-c-flex vdb-c-w-full vdb-c-justify-end vdb-c-gap-12 vdb-c-bg-gray-50 vdb-c-px-24 vdb-c-py-12" };
const _sfc_main$a = {
  __name: "DeleteSessionModal",
  props: {
    showDialog: {
      type: Boolean,
      default: false
    }
  },
  emits: ["cancel-delete", "confirm-delete"],
  setup(__props) {
    return (_ctx, _cache) => {
      return __props.showDialog ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "vdb-c-fixed vdb-c-inset-0 vdb-c-z-50 vdb-c-flex vdb-c-items-center vdb-c-justify-center vdb-c-bg-black vdb-c-bg-opacity-50",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("cancel-delete"))
      }, [
        vue.createElementVNode("div", {
          class: "vdb-c-shadow-xl vdb-c-overflow-hidden vdb-c-rounded-lg vdb-c-bg-white",
          onClick: _cache[2] || (_cache[2] = vue.withModifiers(() => {
          }, ["stop"]))
        }, [
          vue.createElementVNode("div", _hoisted_1$8, [
            vue.createElementVNode("div", _hoisted_2$6, [
              vue.createVNode(WarningExclamation)
            ]),
            _cache[4] || (_cache[4] = vue.createElementVNode("div", { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-8" }, [
              vue.createElementVNode("h2", { class: "vdb-c-text-lg vdb-c-font-medium vdb-c-text-gray-950" }, " Delete Session "),
              vue.createElementVNode("p", { class: "vdb-c-text-sm vdb-c-font-normal vdb-c-text-[#6B7280]" }, " Are you sure you want to delete this session? ")
            ], -1))
          ]),
          vue.createElementVNode("div", _hoisted_3$6, [
            vue.createElementVNode("button", {
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("cancel-delete")),
              class: "vdb-c-shadow-sm vdb-c-rounded-md vdb-c-border vdb-c-border-gray-300 vdb-c-bg-white vdb-c-px-16 vdb-c-py-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-gray-700 hover:vdb-c-bg-gray-300"
            }, " Cancel "),
            vue.createElementVNode("button", {
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("confirm-delete")),
              class: "vdb-c-shadow-sm vdb-c-rounded-md vdb-c-bg-[#DC2626] vdb-c-px-16 vdb-c-py-8 vdb-c-text-sm vdb-c-font-medium vdb-c-text-white hover:vdb-c-bg-[#B91C1C]"
            }, " Delete ")
          ])
        ])
      ])) : vue.createCommentVNode("", true);
    };
  }
};
const _hoisted_1$7 = { class: "vdb-c-mt-8" };
const _hoisted_2$5 = { class: "vdb-c-space-between vdb-c-col-span-12 vdb-c-flex vdb-c-flex-col vdb-c-gap-12 md:vdb-c-col-span-3" };
const _hoisted_3$5 = { class: "text-elip vdb-c-mb-8 vdb-c-line-clamp-2 vdb-c-whitespace-normal vdb-c-px-8 vdb-c-text-base vdb-c-font-medium vdb-c-text-black" };
const _hoisted_4$3 = { class: "vdb-c-col-span-12 vdb-c--mt-20 md:vdb-c-col-span-9 md:vdb-c-mt-0 md:vdb-c-pl-16" };
const _hoisted_5$3 = { class: "vdb-c-relative vdb-c-rounded-16 vdb-c-border vdb-c-bg-white vdb-c-text-gray-900" };
const _hoisted_6$2 = { class: "vdb-c-mt-24 vdb-c-flex vdb-c-w-full vdb-c-items-center vdb-c-justify-center" };
const _sfc_main$9 = {
  __name: "SearchListItem",
  props: {
    searchResults: {
      type: Object,
      default: () => ({})
    },
    isContractable: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const isExpanded = vue.ref(!props.isContractable);
    const videoPlayerRefs = vue.ref({});
    const playerInfo = vue.ref({});
    const getFormattedSearchResult = (videoData) => {
      const shots = videoData.shots;
      return {
        hits: shots.map((shot, index) => ({
          id: `sr-${index}`,
          start: shot.start,
          text: shot.text,
          end: shot.end,
          type: "relevant"
        }))
      };
    };
    const onSlideClick = (index, duration2) => {
      const player = videoPlayerRefs.value[index];
      if (player) {
        player.seekTo(duration2);
        if (!playerInfo.value[index].playing) {
          player.togglePlay();
        }
      }
    };
    const onPlayPause = (index) => {
      const player = videoPlayerRefs.value[index];
      if (player) {
        playerInfo.value[index] = {
          playing: player.playing
        };
      }
    };
    const onVideoLoaded = (index) => {
      const player = videoPlayerRefs.value[index];
      if (player) {
        playerInfo.value[index] = {
          duration: player.duration,
          playing: player.playing
        };
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", null, [
        vue.createElementVNode("div", _hoisted_1$7, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.searchResults, (videoData, index) => {
            var _a;
            return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
              key: `search-results-${index}`,
              class: vue.normalizeClass(["vdb-c-grid vdb-c-grid-cols-12 vdb-c-gap-18 vdb-c-rounded-20 vdb-c-bg-kilvish-200 vdb-c-p-8 sm:vdb-c-gap-20 sm:vdb-c-p-20", `${__props.searchResults.length === index + 1 || !isExpanded.value ? "vdb-c-mb-0" : "vdb-c-mb-20 vdb-c-border-b vdb-c-border-outline-xlight"}`])
            }, [
              vue.createElementVNode("div", _hoisted_2$5, [
                vue.createVNode(vue.unref(VideoDBPlayer), {
                  ref_for: true,
                  ref: (el) => {
                    if (el)
                      videoPlayerRefs.value[index] = el;
                  },
                  "stream-url": videoData.stream_url,
                  "default-controls": false,
                  "default-overlay": false,
                  class: "vdb-c-overflow-hidden vdb-c-rounded-12",
                  onPlay: ($event) => onPlayPause(index),
                  onPause: ($event) => onPlayPause(index),
                  onLoadeddata: ($event) => onVideoLoaded(index)
                }, {
                  overlay: vue.withCtx(() => [
                    vue.createVNode(vue.unref(_sfc_main$m$1), {
                      class: "vdb-c-absolute vdb-c-left-1/2 vdb-c-top-1/2 vdb-c-w-48 vdb-c-h-48",
                      style: { height: "48px", width: "48px" }
                    })
                  ]),
                  _: 2
                }, 1032, ["stream-url", "onPlay", "onPause", "onLoadeddata"]),
                vue.createElementVNode("div", _hoisted_3$5, vue.toDisplayString(videoData.video_title), 1)
              ]),
              vue.createElementVNode("div", _hoisted_4$3, [
                vue.createElementVNode("div", _hoisted_5$3, [
                  (vue.openBlock(), vue.createBlock(vue.unref(_sfc_main$5$1), {
                    key: 0,
                    "is-light": true,
                    "on-slide-click": (duration2) => {
                      onSlideClick(index, duration2);
                    },
                    "search-results": getFormattedSearchResult(videoData),
                    duration: ((_a = playerInfo.value[index]) == null ? void 0 : _a.duration) || 0
                  }, null, 8, ["on-slide-click", "search-results", "duration"]))
                ])
              ])
            ], 2)), [
              [vue.vShow, isExpanded.value ? true : index === 0]
            ]);
          }), 128)),
          vue.withDirectives(vue.createElementVNode("div", _hoisted_6$2, [
            vue.createElementVNode("button", {
              class: "vdb-c-flex vdb-c-cursor-pointer vdb-c-items-center vdb-c-justify-center vdb-c-rounded-full vdb-c-border vdb-c-border-steelblue vdb-c-bg-white vdb-c-px-12 vdb-c-py-8 vdb-c-font-semibold vdb-c-text-steelblue hover:vdb-c-bg-steelblue-200",
              onClick: _cache[0] || (_cache[0] = ($event) => isExpanded.value = !isExpanded.value)
            }, [
              vue.createTextVNode(vue.toDisplayString(isExpanded.value ? "See less" : "See more results") + " ", 1),
              vue.createVNode(ChevronDown, {
                "class-name": `vdb-c-ml-8 ${isExpanded.value ? "vdb-c-transform vdb-c-rotate-180" : ""}`
              }, null, 8, ["class-name"])
            ])
          ], 512), [
            [vue.vShow, __props.isContractable]
          ])
        ])
      ]);
    };
  }
};
const _sfc_main$8 = {
  name: "SearchListItemLoader",
  props: {
    limit: {
      type: Number,
      default: 1
    }
  },
  methods: {
    getArr() {
      const arr = [];
      for (let i = 0; i < this.limit; i++) {
        arr.push(i + 1);
      }
      return arr;
    }
  }
};
const _hoisted_1$6 = { class: "vdb-c-flex vdb-c-flex-col vdb-c-gap-24" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$6, [
    (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($options.getArr(), (searchItem, index) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: `search-results-${index}`,
        class: "vdb-c-flex vdb-c-flex-col md:vdb-c-grid md:vdb-c-grid-cols-12 vdb-c-gap-24 vdb-c-border-b vdb-c-border-outline-xlight vdb-c-py-24"
      }, _cache[0] || (_cache[0] = [
        vue.createStaticVNode('<div class="vdb-c-w-full md:vdb-c-col-span-3"><div class="vdb-c-flex vdb-c-h-full vdb-c-flex-col"><div class="vdb-c-flex vdb-c-flex-col vdb-c-gap-24"><div class="vdb-c-mr-24 vdb-c-w-full vdb-c-min-w-96"><div class="vdb-c-custom-duration vdb-c-relative vdb-c-animate-pulse vdb-c-rounded-12 vdb-c-bg-gray-400" style="padding-bottom:56.25%;"></div></div><div class="vdb-c-flex vdb-c-flex-col vdb-c-justify-center"><div class="vdb-c-custom-duration vdb-c-mb-8 vdb-c-h-20 vdb-c-animate-pulse vdb-c-rounded-full vdb-c-bg-gray-400"></div><div class="vdb-c-flex vdb-c-items-center"><div class="vdb-c-custom-duration vdb-c-mr-12 vdb-c-h-20 vdb-c-w-48 vdb-c-animate-pulse vdb-c-rounded-full vdb-c-bg-gray-400"></div><div class="vdb-c-custom-duration vdb-c-h-20 vdb-c-w-48 vdb-c-animate-pulse vdb-c-rounded-full vdb-c-bg-gray-400"></div></div></div></div></div></div><div class="vdb-c-w-full md:vdb-c-col-span-9"><div class="vdb-c-custom-duration vdb-c-relative vdb-c-animate-pulse vdb-c-rounded-16 vdb-c-bg-gray-400"><div class="vdb-c-h-152 vdb-c-rounded-16 vdb-c-bg-gray-400"></div></div></div>', 2)
      ]));
    }), 128))
  ]);
}
const SearchListItemLoader = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$3]]);
const _hoisted_1$5 = { class: "vdb-c-relative vdb-c-rounded-20 vdb-c-bg-white" };
const _hoisted_2$4 = { key: 0 };
const _hoisted_3$4 = { key: 1 };
const _sfc_main$7 = {
  __name: "ChatSearchResults",
  props: {
    content: {
      type: Object,
      required: true
    },
    isLastConv: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
        vue.createVNode(LoadingMessage, {
          status: __props.content.status,
          message: __props.content.status_message,
          "is-last-conv": __props.isLastConv
        }, null, 8, ["status", "message", "is-last-conv"]),
        __props.content.status === "success" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$4, [
          vue.createVNode(_sfc_main$9, {
            "search-results": __props.content.search_results,
            "is-contractable": __props.content.search_results.length > 1
          }, null, 8, ["search-results", "is-contractable"])
        ])) : __props.content.status === "progress" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$4, [
          vue.createVNode(SearchListItemLoader)
        ])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const ChatVideo_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$4 = { class: "vdb-c-relative vdb-c-flex vdb-c-w-full vdb-c-flex-col vdb-c-gap-8 vdb-c-py-14 vdb-c-text-left" };
const _hoisted_2$3 = {
  key: 0,
  class: "vdb-c-w-full vdb-c-py-6"
};
const _hoisted_3$3 = { class: "vdb-p-pt-0 vdb-c-p-20" };
const _hoisted_4$2 = { class: "sm:vdb-p-mx-8 vdb-c-mb-8 md:vdb-c-mb-12" };
const _hoisted_5$2 = { class: "vdb-c-flex vdb-c-w-full vdb-c-justify-between" };
const _hoisted_6$1 = { class: "vdb-c-z-10 vdb-c-ml-0 vdb-c-flex vdb-c-items-center" };
const _hoisted_7$1 = { key: 1 };
const _hoisted_8$1 = {
  key: 2,
  class: "vdb-c-flex vdb-c-flex-col"
};
const _sfc_main$6 = {
  __name: "ChatVideo",
  props: {
    content: {
      type: Object,
      required: true
    },
    isLastConv: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const isFullScreen = vue.ref(false);
    const handleFullScreenChange = () => {
      isFullScreen.value = !isFullScreen.value;
      if (isFullScreen.value) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [
        vue.createVNode(LoadingMessage, {
          status: __props.content.status,
          message: __props.content.status_message,
          "is-last-conv": __props.isLastConv
        }, null, 8, ["status", "message", "is-last-conv"]),
        vue.createVNode(vue.Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: vue.withCtx(() => [
            __props.content.status === "success" && __props.content.video.stream_url ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$3, [
              vue.createElementVNode("div", {
                class: vue.normalizeClass(
                  isFullScreen.value ? "vdb-c-fixed vdb-c-inset-0 vdb-c-z-50 vdb-c-flex vdb-c-h-full vdb-c-w-full vdb-c-flex-col vdb-c-items-center vdb-c-justify-center vdb-c-overflow-y-hidden vdb-c-bg-black-64" : "vdb-c-full xl:vdb-c-1/2 vdb-c-overflow-hidden vdb-c-rounded-20 sm:vdb-c-w-3/4 lg:vdb-c-w-3/5 xl:vdb-c-w-1/2"
                )
              }, [
                vue.createVNode(vue.unref(VideoDBPlayer), {
                  class: vue.normalizeClass(isFullScreen.value ? "vdb-c-h-screen vdb-c-w-screen" : ""),
                  "stream-url": __props.content.video.stream_url,
                  "default-controls": false,
                  "default-overlay": false,
                  onFullScreenChange: handleFullScreenChange
                }, {
                  overlay: vue.withCtx(() => [
                    vue.createVNode(vue.unref(_sfc_main$m$1), { class: "vdb-c-absolute vdb-c-left-1/2 vdb-c-top-1/2 vdb-c-h-32 vdb-c-w-32 md:vdb-c-h-48 md:vdb-c-w-48" })
                  ]),
                  controls: vue.withCtx(() => [
                    vue.createElementVNode("div", _hoisted_3$3, [
                      vue.createElementVNode("div", _hoisted_4$2, [
                        vue.createVNode(vue.unref(ProgressBar), {
                          "stream-url": __props.content.video.stream_url
                        }, null, 8, ["stream-url"])
                      ]),
                      vue.createElementVNode("div", _hoisted_5$2, [
                        vue.createElementVNode("div", _hoisted_6$1, [
                          vue.createVNode(vue.unref(_sfc_main$j$1)),
                          vue.createVNode(vue.unref(_sfc_main$g$1)),
                          vue.createVNode(vue.unref(_sfc_main$f$1))
                        ]),
                        vue.createVNode(vue.unref(_sfc_main$a$1), { class: "" })
                      ])
                    ])
                  ]),
                  _: 1
                }, 8, ["class", "stream-url"])
              ], 2)
            ])) : __props.content.status === "progress" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_7$1, _cache[0] || (_cache[0] = [
              vue.createElementVNode("div", { class: "vdb-c-full xl:vdb-c-1/2 vdb-c-animate-pulse vdb-c-overflow-hidden vdb-c-rounded-20 sm:vdb-c-w-3/4 lg:vdb-c-w-3/5 xl:vdb-c-w-1/2" }, [
                vue.createElementVNode("div", {
                  class: "vdb-c-relative vdb-c-w-full",
                  style: { "padding-top": "56.25%" }
                }, [
                  vue.createElementVNode("div", { class: "vdb-c-absolute vdb-c-inset-0 vdb-c-flex vdb-c-items-center vdb-c-justify-center vdb-c-bg-gray-200" })
                ])
              ], -1)
            ]))) : __props.content.status === "not_generated" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_8$1)) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const ChatVideos_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$3 = { class: "vdb-c-relative vdb-c-flex vdb-c-w-full vdb-c-flex-col vdb-c-gap-8 vdb-c-py-14 vdb-c-text-left" };
const _hoisted_2$2 = { key: 0 };
const _hoisted_3$2 = {
  key: 1,
  class: "vdb-c-flex vdb-c-flex-col"
};
const _sfc_main$5 = {
  __name: "ChatVideos",
  props: {
    content: {
      type: Object,
      required: true
    },
    isLastConv: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const { addMessage, loadSession } = useVideoDBChat();
    vue.ref(false);
    const handleVideoClick = (video) => {
      if (video.external_url) {
        window.open(video.external_url, "_blank");
      } else {
        if (video.stream_url) {
          handleAddMessage(`@stream_video ${video.name}`);
        }
      }
    };
    const handleAddMessage = (content) => {
      addMessage({
        content: [{ type: "text", text: content }]
      });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [
        vue.createVNode(LoadingMessage, {
          status: __props.content.status,
          message: __props.content.status_message,
          "is-last-conv": __props.isLastConv
        }, null, 8, ["status", "message", "is-last-conv"]),
        vue.createVNode(vue.Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: vue.withCtx(() => [
            __props.content.status === "success" || __props.content.status === "progress" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$2, [
              vue.createVNode(_sfc_main$w, {
                columns: 3,
                "show-pagination": false,
                "video-results": __props.content.videos,
                onVideoClick: handleVideoClick
              }, null, 8, ["video-results"])
            ])) : __props.content.status === "not_generated" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2)) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const ImageHandler_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$2 = { class: "vdb-c-relative vdb-c-flex vdb-c-w-full vdb-c-flex-col vdb-c-gap-8 vdb-c-bg-white vdb-c-py-14 vdb-c-text-left" };
const _hoisted_2$1 = {
  key: 0,
  class: "vdb-c-shadow-md vdb-c-overflow-hidden"
};
const _hoisted_3$1 = ["src"];
const _hoisted_4$1 = {
  key: 1,
  class: "vdb-c-animate-pulse vdb-c-rounded-lg vdb-c-bg-gray-200"
};
const _hoisted_5$1 = {
  key: 2,
  class: "vdb-c-flex vdb-c-flex-col"
};
const _sfc_main$4 = {
  __name: "ImageHandler",
  props: {
    content: {
      type: Object,
      required: true
    },
    isUser: {
      type: Boolean,
      default: false
    },
    isLastConv: {
      type: Boolean,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const image = vue.computed(() => props.content.image || {});
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2, [
        !__props.isUser ? (vue.openBlock(), vue.createBlock(LoadingMessage, {
          key: 0,
          status: __props.content.status,
          message: __props.content.status_message,
          isLastConv: __props.isLastConv
        }, null, 8, ["status", "message", "isLastConv"])) : vue.createCommentVNode("", true),
        vue.createVNode(vue.Transition, {
          name: "fade",
          mode: "out-in"
        }, {
          default: vue.withCtx(() => [
            __props.content.status === "success" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1, [
              vue.createElementVNode("img", {
                src: image.value.url,
                alt: "Generated image",
                class: "vdb-c-h-auto vdb-c-w-4/5 vdb-c-max-w-[400px] vdb-c-rounded-lg sm:vdb-c-w-3/4 md:vdb-c-w-1/2"
              }, null, 8, _hoisted_3$1)
            ])) : __props.content.status === "progress" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$1)) : __props.content.status === "error" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5$1, _cache[0] || (_cache[0] = [
              vue.createElementVNode("p", { class: "vdb-c-text-red-500" }, "Error loading image.", -1)
            ]))) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const _sfc_main$3 = {
  name: "DirectorIcon",
  props: {
    className: {
      type: String,
      default: ""
    }
  }
};
const _hoisted_1$1 = {
  width: "150",
  height: "39",
  viewBox: "0 0 550 550",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1$1, _cache[0] || (_cache[0] = [
    vue.createStaticVNode('<path d="M0 0 C3.16216216 5.35135135 3.16216216 5.35135135 2.5 8 C1.23880017 9.68159977 -0.12071253 11.28881941 -1.5 12.875 C-5.68222903 17.78296877 -6.08919191 22.62434336 -7 29 C5.21 29 17.42 29 30 29 C30.3334429 19.28216671 30.3334429 19.28216671 26 12 C23.41139607 9.6090093 23.41139607 9.6090093 21 8 C22.33333333 5.33333333 23.66666667 2.66666667 25 0 C31.61107127 3.03007433 35.77291636 7.61397461 38.4375 14.375 C41.41394192 23.76618743 40.18580054 31.39088382 35.94555664 40.1875 C34.77208273 42.37778443 33.55499586 44.53565159 32.3125 46.6875 C31.87695801 47.45626465 31.44141602 48.2250293 30.99267578 49.01708984 C29.66926616 51.34908706 28.33529278 53.67479163 27 56 C26.18815929 57.42541534 25.37693111 58.85117978 24.56640625 60.27734375 C22.719497 63.52317145 20.86291064 66.76332286 19 70 C18.01 70 17.02 70 16 70 C20.36575298 73.94996698 23.98546477 77.0711797 30.203125 76.9609375 C34.43941353 76.58219647 38.13546869 75.86993451 42 74 C45 79.625 45 79.625 45 83 C36.80778728 86.47548419 28.05799368 87.6995313 19.5 84.6875 C16.66362539 83.31996224 14.35791281 82.06317371 12 80 C11.45730469 80.34933594 10.91460937 80.69867188 10.35546875 81.05859375 C9.64003906 81.51363281 8.92460938 81.96867187 8.1875 82.4375 C7.47980469 82.88996094 6.77210937 83.34242187 6.04296875 83.80859375 C0.27916676 87.16989319 -6.54816267 86.5477304 -13 86 C-16.08267113 84.97839119 -18.24358598 83.76410497 -21 82 C-19.79618552 79.50638429 -18.54571278 77.31856917 -17 75 C-16.360625 75.144375 -15.72125 75.28875 -15.0625 75.4375 C-13.5465625 75.7159375 -13.5465625 75.7159375 -12 76 C-11.00033203 76.21269531 -11.00033203 76.21269531 -9.98046875 76.4296875 C-3.64377239 77.5172466 0.43145092 76.06730954 6 73 C4.8361351 70.64441172 3.66952428 68.29027917 2.5 65.9375 C2.14486328 65.22247314 1.78972656 64.50744629 1.42382812 63.77075195 C-1.44120072 58.03754727 -4.43747792 52.38380166 -7.56054688 46.78686523 C-9.10388385 43.96453043 -10 42.27251888 -10 39 C-15.75759524 41.78037719 -20.16763553 43.99538733 -23 50 C-23.85853316 53.31006717 -24.49224007 56.61938783 -25 60 C-27.97 59.67 -30.94 59.34 -34 59 C-33.4851232 49.73221757 -31.4953044 42.87738113 -25 36 C-21.7881686 33.6580396 -18.56109847 31.74217533 -15 30 C-15.04640625 29.23816406 -15.0928125 28.47632812 -15.140625 27.69140625 C-15.49737502 17.48580757 -13.23957106 11.01150811 -6.46484375 3.41015625 C-4.44054 1.4614265 -2.89817598 0 0 0 Z M28 33 C29 35 29 35 29 35 Z M25 38 C15.1 38.33 5.2 38.66 -5 39 C-3.02 39.99 -3.02 39.99 -1 41 C0.70751953 43.59790039 0.70751953 43.59790039 2.3828125 46.84765625 C2.99253906 48.00974609 3.60226563 49.17183594 4.23046875 50.36914062 C4.86277087 51.59985399 5.49427227 52.83097904 6.125 54.0625 C7.37037854 56.47395976 8.62489716 58.880161 9.8828125 61.28515625 C10.43340332 62.35644775 10.98399414 63.42773926 11.55126953 64.53149414 C12.7619573 67.10807557 12.7619573 67.10807557 15 68 C14.71125 67.06800781 14.4225 66.13601562 14.125 65.17578125 C13.29616197 59.38121118 17.05076883 54.89392727 20 50.1875 C21.15257993 48.31011485 22.29878616 46.42879649 23.4375 44.54296875 C23.95183594 43.71821045 24.46617188 42.89345215 24.99609375 42.04370117 C25.32738281 41.36927979 25.65867187 40.6948584 26 40 C25.67 39.34 25.34 38.68 25 38 Z M9 76 C10 78 10 78 10 78 Z " fill="#1990A0" transform="translate(54,21)"></path><path d="M0 0 C8.25 0 16.5 0 25 0 C25 2.31 25 4.62 25 7 C23.35 7 21.7 7 20 7 C23.96 17.56 27.92 28.12 32 39 C35.3 39.33 38.6 39.66 42 40 C42 29.11 42 18.22 42 7 C40.35 7 38.7 7 37 7 C37 4.69 37 2.38 37 0 C42.94 0 48.88 0 55 0 C55 2.31 55 4.62 55 7 C53.35 7 51.7 7 50 7 C50 17.89 50 28.78 50 40 C51.65 40 53.3 40 55 40 C55 42.31 55 44.62 55 47 C42.79 47 30.58 47 18 47 C18 44.69 18 42.38 18 40 C19.65 40 21.3 40 23 40 C22.505 38.88625 22.505 38.88625 22 37.75 C21 35 21 35 21 31 C15.72 31.33 10.44 31.66 5 32 C4.01 34.64 3.02 37.28 2 40 C3.65 40 5.3 40 7 40 C7 42.31 7 44.62 7 47 C0.73 47 -5.54 47 -12 47 C-12 44.69 -12 42.38 -12 40 C-10.02 40 -8.04 40 -6 40 C-5.88213135 39.31139893 -5.7642627 38.62279785 -5.64282227 37.91333008 C-4.91540358 34.61660121 -3.86050499 31.56266572 -2.71484375 28.38671875 C-2.49429825 27.77230423 -2.27375275 27.15788971 -2.04652405 26.52485657 C-1.34680121 24.57786976 -0.64223285 22.63267824 0.0625 20.6875 C0.54003559 19.36144406 1.01725248 18.0352733 1.49414062 16.70898438 C2.6596303 13.47151306 3.82835965 10.23524939 5 7 C3.35 7 1.7 7 0 7 C0 4.69 0 2.38 0 0 Z M12 8 C10.35 13.28 8.7 18.56 7 24 C10.63 24 14.26 24 18 24 C17.54625 22.288125 17.0925 20.57625 16.625 18.8125 C16.36976563 17.84957031 16.11453125 16.88664062 15.8515625 15.89453125 C15.05233704 13.17789793 14.0968638 10.60862825 13 8 C12.67 8 12.34 8 12 8 Z " fill="#000000" transform="translate(419,8)"></path><path d="M0 0 C7.92 0 15.84 0 24 0 C24 2.31 24 4.62 24 7 C22.68 7.33 21.36 7.66 20 8 C20.33322266 8.89831543 20.66644531 9.79663086 21.00976562 10.72216797 C22.24301143 14.04941642 23.47200485 17.37822201 24.69970703 20.70751953 C25.23207236 22.14935584 25.76559627 23.59076492 26.30029297 25.03173828 C27.06781766 27.1007798 27.8311884 29.17131251 28.59375 31.2421875 C28.83436157 31.88807831 29.07497314 32.53396912 29.32287598 33.19943237 C31 37.77225659 31 37.77225659 31 40 C32.65 40 34.3 40 36 40 C36 42.31 36 44.62 36 47 C29.73 47 23.46 47 17 47 C17 44.69 17 42.38 17 40 C19.475 39.505 19.475 39.505 22 39 C21.34 36.36 20.68 33.72 20 31 C14.72 31 9.44 31 4 31 C3.34 33.97 2.68 36.94 2 40 C3.65 40 5.3 40 7 40 C7 42.31 7 44.62 7 47 C0.73 47 -5.54 47 -12 47 C-12 44.69 -12 42.38 -12 40 C-11.23469971 39.97687744 -10.46939941 39.95375488 -9.6809082 39.92993164 C-6.6944298 39.23418649 -6.6944298 39.23418649 -5.42260742 36.04077148 C-4.96232487 34.74154147 -4.52461723 33.43417151 -4.10546875 32.12109375 C-3.86838699 31.4344313 -3.63130524 30.74776886 -3.38703918 30.04029846 C-2.63423531 27.84547685 -1.91072611 25.64222349 -1.1875 23.4375 C-0.68223755 21.94792222 -0.17509822 20.45897965 0.33398438 18.97070312 C1.57788842 15.32081621 2.79560898 11.66310583 4 8 C2.68 7.67 1.36 7.34 0 7 C0 4.69 0 2.38 0 0 Z M12 8 C9.91864693 13.29798964 8.28708387 18.45563871 7 24 C10.3 24 13.6 24 17 24 C15.83672541 18.59908226 14.57704144 13.29435341 13 8 C12.67 8 12.34 8 12 8 Z " fill="#000000" transform="translate(154,8)"></path><path d="M0 0 C4.71174885 3.44170955 6.95748823 7.98141576 7.8671875 13.671875 C8.16473267 18.88766687 7.70154902 23.04596306 4.18359375 27.0859375 C0.14008861 30.73477271 -2.73434225 32.82900696 -8.3125 33.25 C-12.27584099 32.98129892 -14.60215531 31.98898226 -18 30 C-18.33 32.97 -18.66 35.94 -19 39 C-17.02 39 -15.04 39 -13 39 C-13 41.31 -13 43.62 -13 46 C-19.27 46 -25.54 46 -32 46 C-32 43.69 -32 41.38 -32 39 C-30.35 39 -28.7 39 -27 39 C-27 28.11 -27 17.22 -27 6 C-28.65 6 -30.3 6 -32 6 C-32 3.69 -32 1.38 -32 -1 C-27.71 -1 -23.42 -1 -19 -1 C-18.67 -0.34 -18.34 0.32 -18 1 C-16.88625 0.46375 -15.7725 -0.0725 -14.625 -0.625 C-9.43290771 -2.53981418 -5.08100398 -2.13266221 0 0 Z M-17.8125 9.75 C-19.52868326 13.00171564 -19.38162088 15.37460162 -19 19 C-17.74360091 21.82689795 -16.67448232 23.47004961 -14.25 25.375 C-10.85887913 26.31697802 -8.39008797 25.84752199 -5 25 C-2.4450617 23.31911954 -1.32438473 22.06935105 -0.43359375 19.1328125 C0.19176467 15.64397079 0.20691007 13.51727517 -1.125 10.1875 C-3.22898053 7.73285605 -5.0844076 6.38490639 -8 5 C-12.31268909 5 -14.75552054 6.79843363 -17.8125 9.75 Z " fill="#000000" transform="translate(263,23)"></path><path d="M0 0 C4.12513998 4.61045056 5.75152905 10.19992362 5.47265625 16.359375 C4.54269345 21.75106943 2.31512828 25.42775504 -1.9375 28.8125 C-6.48002987 31.22873929 -9.74914176 31.72251581 -14.875 31.375 C-18.3125 29.875 -18.3125 29.875 -20.875 28.375 C-21.205 31.345 -21.535 34.315 -21.875 37.375 C-19.895 37.375 -17.915 37.375 -15.875 37.375 C-15.875 39.685 -15.875 41.995 -15.875 44.375 C-22.145 44.375 -28.415 44.375 -34.875 44.375 C-34.875 42.065 -34.875 39.755 -34.875 37.375 C-32.895 37.375 -30.915 37.375 -28.875 37.375 C-28.875 26.485 -28.875 15.595 -28.875 4.375 C-30.855 4.375 -32.835 4.375 -34.875 4.375 C-34.875 2.065 -34.875 -0.245 -34.875 -2.625 C-30.585 -2.625 -26.295 -2.625 -21.875 -2.625 C-21.545 -1.635 -21.215 -0.645 -20.875 0.375 C-20.318125 -0.099375 -19.76125 -0.57375 -19.1875 -1.0625 C-13.06715792 -5.19786627 -6.10531141 -3.45082819 0 0 Z M-19.875 7.375 C-22.02971967 9.99813699 -21.98616084 12.10508066 -21.75 15.375 C-21.29556705 18.14807382 -20.84662791 19.41755814 -19.25 21.8125 C-16.04101302 23.92367565 -13.70398112 24.30782489 -9.875 24.375 C-6.99947001 23.16088734 -5.4291689 22.11389186 -3.5625 19.625 C-2.24874285 15.32543115 -2.31411065 11.70342214 -4.0625 7.5625 C-6.18346911 5.0027097 -7.69399928 4.2497752 -10.875 3.375 C-14.95046013 3.375 -16.68036362 4.92804448 -19.875 7.375 Z " fill="#000000" transform="translate(223.875,24.625)"></path><path d="M0 0 C4.29 0 8.58 0 13 0 C13 13.2 13 26.4 13 40 C14.98 40 16.96 40 19 40 C19 42.31 19 44.62 19 47 C14.71 47 10.42 47 6 47 C5.67 46.34 5.34 45.68 5 45 C4.44957031 45.32226562 3.89914062 45.64453125 3.33203125 45.9765625 C-1.42704389 48.06513484 -7.18266959 47.81527144 -12.1328125 46.3828125 C-16.36692543 44.31157977 -18.54176645 41.40254494 -20.33984375 37.20703125 C-21.97862021 31.72828156 -21.68375603 26.91615336 -19.375 21.6875 C-16.73643834 16.97377063 -13.0753212 14.69177373 -8 13 C-2.73428531 12.60258757 0.4443154 13.3332578 5 16 C5.33 13.03 5.66 10.06 6 7 C4.02 7 2.04 7 0 7 C0 4.69 0 2.38 0 0 Z M-12 25 C-13.57455739 28.14911479 -13.34799118 30.52008816 -13 34 C-11.23010062 37.30479138 -9.04649383 39.54383602 -5.5625 41.0625 C-1.99436584 40.97547234 0.0216491 39.94240276 3 38 C5.26803219 35.2027603 5.94655567 33.52375446 6.3125 29.9375 C5.99753546 26.97683328 5.73571674 25.39694216 4 23 C1.52172505 21.12454869 -0.39271246 20.1245718 -3.4375 19.5 C-7.32747126 20.25901878 -9.14347376 22.27331586 -12 25 Z " fill="#000000" transform="translate(373,8)"></path><path d="M0 0 C2.97 0 5.94 0 9 0 C9.79620796 1.38848254 10.59218046 2.77710044 11.38720703 4.16625977 C12.09643383 5.40452162 12.8070815 6.64197058 13.51904297 7.87866211 C15.5018898 11.33380497 17.44345132 14.80453077 19.32421875 18.31640625 C19.70843994 19.02474609 20.09266113 19.73308594 20.48852539 20.46289062 C21.22840541 21.82980109 21.95860667 23.20200952 22.67749023 24.58007812 C25.664785 30.05829147 29.10938892 33.58681236 34.8125 36.375 C40.76638472 37.54242838 46.53190237 36.64585369 52 34 C55 39.625 55 39.625 55 43 C46.80778728 46.47548419 38.05799368 47.6995313 29.5 44.6875 C26.66362539 43.31996224 24.35791281 42.06317371 22 40 C21.18595703 40.52400391 21.18595703 40.52400391 20.35546875 41.05859375 C19.64003906 41.51363281 18.92460938 41.96867187 18.1875 42.4375 C17.12595703 43.11619141 17.12595703 43.11619141 16.04296875 43.80859375 C10.27916676 47.16989319 3.45183733 46.5477304 -3 46 C-6.08267113 44.97839119 -8.24358598 43.76410497 -11 42 C-9.79618552 39.50638429 -8.54571278 37.31856917 -7 35 C-6.360625 35.144375 -5.72125 35.28875 -5.0625 35.4375 C-3.5465625 35.7159375 -3.5465625 35.7159375 -2 36 C-1.33355469 36.14179687 -0.66710937 36.28359375 0.01953125 36.4296875 C6.35622761 37.5172466 10.43145092 36.06730954 16 33 C11.62738818 24.15011278 7.20155231 15.34727123 2.43945312 6.69897461 C0 2.21335041 0 2.21335041 0 0 Z M19 36 C20 38 20 38 20 38 Z " fill="#64A866" transform="translate(44,61)"></path><path d="M0 0 C4.51444192 2.59162406 6.4557673 4.55865095 9.375 8.9375 C9.87 13.8875 9.87 13.8875 10.375 18.9375 C1.795 18.9375 -6.785 18.9375 -15.625 18.9375 C-12.49324314 24.71010299 -12.49324314 24.71010299 -9.625 25.9375 C-3.38794839 26.44873374 -1.47562664 26.00153854 3.375 21.9375 C6.14787249 22.13095622 7.90585554 22.70292777 10.375 23.9375 C9.71069507 26.59471974 9.03803927 28.42978228 6.82421875 30.125 C0.85444469 33.60204185 -4.71953696 35.12189887 -11.6796875 33.44140625 C-16.38343663 31.87053154 -19.48899428 29.90362489 -22.625 25.9375 C-24.87136794 21.0168845 -25.69447879 16.12163003 -23.9375 10.890625 C-21.70315964 5.93783721 -19.05718883 3.04946237 -14.625 -0.0625 C-9.47314305 -1.77978565 -5.11937784 -1.5005073 0 0 Z M-13.625 7.9375 C-14.285 9.5875 -14.945 11.2375 -15.625 12.9375 C-9.685 12.9375 -3.745 12.9375 2.375 12.9375 C-0.38893862 8.33093563 -1.1307377 7.1270124 -5.625 4.9375 C-8.84569545 4.9375 -10.90553977 6.29449278 -13.625 7.9375 Z " fill="#000000" transform="translate(337.625,22.0625)"></path><path d="M0 0 C6.61107127 3.03007433 10.77291636 7.61397461 13.4375 14.375 C16.41394192 23.76618743 15.18580054 31.39088382 10.94555664 40.1875 C9.77208273 42.37778443 8.55499586 44.53565159 7.3125 46.6875 C6.65918701 47.84064697 6.65918701 47.84064697 5.99267578 49.01708984 C4.66926616 51.34908706 3.33529278 53.67479163 2 56 C1.18815929 57.42541534 0.37693111 58.85117978 -0.43359375 60.27734375 C-2.280503 63.52317145 -4.13708936 66.76332286 -6 70 C-9.8359375 68.234375 -9.8359375 68.234375 -11.3125 66.125 C-12.38047837 62.82397594 -11.34644375 60.70596085 -9.84838867 57.65332031 C-9.3763501 56.80350586 -8.90431152 55.95369141 -8.41796875 55.078125 C-7.89783203 54.13453125 -7.37769531 53.1909375 -6.84179688 52.21875 C-6.29587891 51.2390625 -5.74996094 50.259375 -5.1875 49.25 C-3.11302719 45.5064399 -1.04827834 41.75796088 1 38 C1.41620605 37.24404541 1.83241211 36.48809082 2.26123047 35.70922852 C5.32940075 29.91995675 5.9491335 25.42342877 5 19 C3.30823036 14.09658212 0.2273732 10.93567583 -4 8 C-2.66666667 5.33333333 -1.33333333 2.66666667 0 0 Z " fill="#DB7147" transform="translate(79,21)"></path><path d="M0 0 C4.29 0 8.58 0 13 0 C13 13.2 13 26.4 13 40 C14.65 40 16.3 40 18 40 C18 42.31 18 44.62 18 47 C12.06 47 6.12 47 0 47 C0 44.69 0 42.38 0 40 C1.98 40 3.96 40 6 40 C6 29.11 6 18.22 6 7 C4.02 7 2.04 7 0 7 C0 4.69 0 2.38 0 0 Z " fill="#000000" transform="translate(273,8)"></path><path d="M0 0 C2.375 2.25 2.375 2.25 4 5 C4 6.65 4 8.3 4 10 C0.04 10 -3.92 10 -8 10 C-8 10.66 -8 11.32 -8 12 C-4.16774573 12.08912219 -0.73437848 11.87867729 3 11 C3 12.32 3 13.64 3 15 C-1.43592972 17.60699287 -5.11752195 17.24836086 -10 16 C-12.0625 14.4375 -12.0625 14.4375 -13 12 C-13.21844466 9.27984385 -13.13697992 6.73959834 -13 4 C-16.05383204 5.52691602 -16.38086503 7.95216256 -17.625 11.0625 C-18.07101562 12.16722656 -18.51703125 13.27195312 -18.9765625 14.41015625 C-19.48316406 15.69212891 -19.48316406 15.69212891 -20 17 C-21.32 17 -22.64 17 -24 17 C-24.67057887 15.2097939 -25.3363469 13.41778511 -26 11.625 C-26.37125 10.62726563 -26.7425 9.62953125 -27.125 8.6015625 C-28 6 -28 6 -28 4 C-28.99 4 -29.98 4 -31 4 C-31 2.68 -31 1.36 -31 0 C-28.03 0 -25.06 0 -22 0 C-22.185625 0.763125 -22.37125 1.52625 -22.5625 2.3125 C-23.22819173 5.08967375 -23.22819173 5.08967375 -22 8 C-21.17361624 5.10765685 -21 3.11257569 -21 0 C-17 0 -13 0 -9 0 C-5.39297148 -1.20234284 -3.64185324 -1.0405295 0 0 Z M-6 3 C-6.99 4.485 -6.99 4.485 -8 6 C-5.69 6 -3.38 6 -1 6 C-1.66 5.01 -2.32 4.02 -3 3 C-3.99 3 -4.98 3 -6 3 Z " fill="#000000" transform="translate(418,87)"></path><path d="M0 0 C3.51038651 2.59463351 4.77811815 4.23728114 6 8.4375 C6 12.61810309 5.40415469 14.58765141 3 18 C-0.39331233 20.39074278 -2.40827516 20.98961886 -6.5625 21.0625 C-10.09043838 19.97204632 -11.9356523 18.82544183 -14.11328125 15.80859375 C-15.73392649 12.50304861 -15.89720624 9.55350186 -15 6 C-11.30565338 -0.50373569 -7.1060999 -1.71526549 0 0 Z " fill="#DE7046" transform="translate(71,9)"></path><path d="M0 0 C3.49890004 2.11391877 4.70578686 3.11736059 6 7 C6.3686858 11.97725826 6.16456308 15.04429615 3 19 C-0.42919572 21.57189679 -3.83939486 21.502142 -8 21 C-11.18999609 19.10963195 -13.38427071 17.67519645 -14.69921875 14.09765625 C-15.55709514 9.29170354 -14.75215854 6.12823781 -12 2 C-7.97685134 -0.68209911 -4.72780081 -0.68843415 0 0 Z " fill="#62A864" transform="translate(113,83)"></path><path d="M0 0 C3.18637361 0.64073817 4.95955678 2.09960721 7.15625 4.43359375 C8.75314041 7.62737457 8.52973957 10.9588069 8.15625 14.43359375 C6.90636855 17.3083211 5.90156416 18.87460813 3.40625 20.74609375 C0.1351882 21.74558486 -2.44117588 21.79175945 -5.84375 21.43359375 C-8.84707418 19.63159924 -10.4341452 18.12247455 -12.21875 15.12109375 C-13.06469728 11.48352046 -12.81060978 9.0432036 -11.84375 5.43359375 C-8.5358309 0.57508758 -5.60954437 -0.30852494 0 0 Z " fill="#1A91A1" transform="translate(25.84375,82.56640625)"></path><path d="M0 0 C3.96 0 7.92 0 12 0 C12 8.58 12 17.16 12 26 C13.65 26 15.3 26 17 26 C17 28.31 17 30.62 17 33 C11.39 33 5.78 33 0 33 C0 30.69 0 28.38 0 26 C1.65 26 3.3 26 5 26 C5 19.73 5 13.46 5 7 C3.35 7 1.7 7 0 7 C0 4.69 0 2.38 0 0 Z " fill="#000000" transform="translate(294,22)"></path><path d="M0 0 C2.75357293 2.08378492 3.8111953 3.37549215 4.8125 6.6875 C4.874375 7.450625 4.93625 8.21375 5 9 C3.26043342 10.73956658 0.8063378 10.37190386 -1.5625 10.5625 C-2.57441406 10.64628906 -3.58632813 10.73007813 -4.62890625 10.81640625 C-5.41136719 10.87699219 -6.19382812 10.93757813 -7 11 C-5.96976543 12.25249952 -5.96976543 12.25249952 -3.75 12.125 C-1.06474086 12.00294277 1.38358203 11.59803839 4 11 C3.75 12.875 3.75 12.875 3 15 C-0.16857001 17.3470889 -3.15724779 17.47054109 -7 17 C-9.69990662 15.20006226 -11.5418865 13.916227 -13 11 C-13.039992 9.00039988 -13.04346799 6.99952758 -13 5 C-14.32 5.33 -15.64 5.66 -17 6 C-17.33 8.31 -17.66 10.62 -18 13 C-17.01 13 -16.02 13 -15 13 C-15 13.99 -15 14.98 -15 16 C-18.3 16 -21.6 16 -25 16 C-25 15.01 -25 14.02 -25 13 C-24.01 13 -23.02 13 -22 13 C-22 10.03 -22 7.06 -22 4 C-22.99 4 -23.98 4 -25 4 C-25 2.68 -25 1.36 -25 0 C-20.71 0 -16.42 0 -12 0 C-11.67 0.66 -11.34 1.32 -11 2 C-10.29875 1.484375 -9.5975 0.96875 -8.875 0.4375 C-5.29773881 -1.3511306 -3.77634696 -1.20521711 0 0 Z M-6 3 C-6.99 4.485 -6.99 4.485 -8 6 C-5.36 6 -2.72 6 0 6 C-1.31201173 4.43750191 -1.31201173 4.43750191 -3 3 C-3.99 3 -4.98 3 -6 3 Z " fill="#000000" transform="translate(448,87)"></path><path d="M0 0 C0.72960937 0.04189453 1.45921875 0.08378906 2.2109375 0.12695312 C2.95601562 0.14951172 3.70109375 0.17207031 4.46875 0.1953125 C6.3003465 0.25401752 8.13090403 0.34369556 9.9609375 0.43945312 C9.9609375 1.75945312 9.9609375 3.07945313 9.9609375 4.43945312 C9.3009375 4.43945312 8.6409375 4.43945312 7.9609375 4.43945312 C7.98414063 5.24769531 8.00734375 6.0559375 8.03125 6.88867188 C8.05832031 8.49162109 8.05832031 8.49162109 8.0859375 10.12695312 C8.10914063 11.18269531 8.13234375 12.2384375 8.15625 13.32617188 C7.88581769 17.63686292 7.10417747 20.43071197 3.8359375 23.31445312 C-0.18994824 24.88979972 -2.81620943 24.22676471 -7.0390625 23.43945312 C-7.0390625 22.11945313 -7.0390625 20.79945312 -7.0390625 19.43945312 C-5.0390625 18.43945312 -5.0390625 18.43945312 -2.6015625 19.06445312 C-1.7559375 19.18820313 -0.9103125 19.31195313 -0.0390625 19.43945312 C1.7964174 18.10566738 1.7964174 18.10566738 2.9609375 16.43945312 C2.3009375 16.76945312 1.6409375 17.09945312 0.9609375 17.43945312 C-1.9140625 17.75195312 -1.9140625 17.75195312 -5.0390625 17.43945312 C-8.31115407 14.7864059 -9.88358792 12.83872434 -10.3515625 8.62695312 C-9.70604704 2.04269548 -6.46366332 -0.14690144 0 0 Z M-3.0390625 4.43945312 C-5.2882533 6.2664854 -5.2882533 6.2664854 -5.2890625 8.93945312 C-5.2882533 11.61242085 -5.2882533 11.61242085 -3.0390625 13.43945312 C0.26777216 13.14962044 0.26777216 13.14962044 2.9609375 11.43945312 C3.2110148 8.98135314 3.2110148 8.98135314 2.9609375 6.43945312 C2.3009375 5.77945313 1.6409375 5.11945313 0.9609375 4.43945312 C-0.3590625 4.43945312 -1.6790625 4.43945312 -3.0390625 4.43945312 Z " fill="#010101" transform="translate(237.0390625,86.560546875)"></path><path d="M0 0 C2.37625177 -0.10883596 4.74743976 -0.18766696 7.125 -0.25 C7.79015625 -0.28351563 8.4553125 -0.31703125 9.140625 -0.3515625 C14.26783619 -0.45209605 17.13628758 0.66342076 21 4 C22.93456673 7.56120935 23.30577564 11.32252057 22.58203125 15.29296875 C21.60724202 18.24964989 20.92971579 20.29477656 18.3984375 22.21484375 C14.87462316 23.36840512 11.41243418 23.20911951 7.75 23.125 C7.00492187 23.11597656 6.25984375 23.10695313 5.4921875 23.09765625 C3.66131941 23.07418358 1.83061762 23.03831525 0 23 C0 22.01 0 21.02 0 20 C0.99 20 1.98 20 3 20 C3 14.72 3 9.44 3 4 C2.01 4 1.02 4 0 4 C0 2.68 0 1.36 0 0 Z M7 4 C7 9.28 7 14.56 7 20 C8.44375 19.7525 9.8875 19.505 11.375 19.25 C12.18710937 19.11078125 12.99921875 18.9715625 13.8359375 18.828125 C16.13113741 18.18168629 16.13113741 18.18168629 17.296875 16.14453125 C18.3893011 12.81263163 17.85397726 10.35491068 17 7 C15.42304368 4.9214392 15.42304368 4.9214392 13 4 C11.02 4 9.04 4 7 4 Z " fill="#000000" transform="translate(327,80)"></path><path d="M0 0 C5.87761454 0.79731119 9.01691029 3.79192405 13 8 C17.5900988 14.30810721 18.1256918 19.45849173 18 27 C15.36 27 12.72 27 10 27 C9.77957031 26.03900391 9.77957031 26.03900391 9.5546875 25.05859375 C7.94948841 18.86842944 5.91487305 14.2299152 1 10 C-1.1030134 8.825293 -1.1030134 8.825293 -3 8 C-1.125 2.25 -1.125 2.25 0 0 Z " fill="#67A868" transform="translate(94,53)"></path><path d="M0 0 C2.72426311 2.35277269 3.8141763 4.62496331 5 8 C-2.79088989 13.02638057 -9.80782797 14.2307055 -19 13 C-22.05965489 11.95774914 -24.25654936 10.75580841 -27 9 C-25.79618552 6.50638429 -24.54571278 4.31856917 -23 2 C-22.360625 2.144375 -21.72125 2.28875 -21.0625 2.4375 C-20.051875 2.623125 -19.04125 2.80875 -18 3 C-17.33355469 3.14179687 -16.66710937 3.28359375 -15.98046875 3.4296875 C-9.64377239 4.5172466 -5.56854908 3.06730954 0 0 Z " fill="#2494A2" transform="translate(60,94)"></path><path d="M0 0 C3.16216216 5.35135135 3.16216216 5.35135135 2.5 8 C1.23880017 9.68159977 -0.12071253 11.28881941 -1.5 12.875 C-5.56687649 17.64759917 -6.26684586 22.89038215 -7 29 C-10.28696233 29.79953138 -11.71023192 30.09658936 -15 29 C-15.65086102 19.32748199 -14.1676811 12.59775644 -7.9375 5.0625 C-3.42553191 0 -3.42553191 0 0 0 Z " fill="#DD6F44" transform="translate(54,21)"></path><path d="M0 0 C2.31 0 4.62 0 7 0 C7 6.6 7 13.2 7 20 C8.65 20 10.3 20 12 20 C12 14.72 12 9.44 12 4 C11.34 4 10.68 4 10 4 C10 2.68 10 1.36 10 0 C12.31 0 14.62 0 17 0 C17 6.6 17 13.2 17 20 C17.66 20 18.32 20 19 20 C19 20.99 19 21.98 19 23 C12.73 23 6.46 23 0 23 C0 22.01 0 21.02 0 20 C0.99 20 1.98 20 3 20 C3 14.72 3 9.44 3 4 C2.01 4 1.02 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(198,80)"></path><path d="M0 0 C2.31 0 4.62 0 7 0 C7 6.6 7 13.2 7 20 C7.99 20 8.98 20 10 20 C10 20.99 10 21.98 10 23 C8.80375 22.979375 7.6075 22.95875 6.375 22.9375 C3.64218122 22.91822086 1.51706842 23.10416171 -1.1875 23.6875 C-4.7809319 24.08677021 -6.18230651 23.17364926 -9 21 C-10.60135272 17.79729456 -10.48861584 14.47536616 -10 11 C-7.88407536 7.82611304 -6.56498557 7.14689625 -2.875 6.1875 C0 6 0 6 2 7 C2.33 6.01 2.66 5.02 3 4 C2.01 4 1.02 4 0 4 C0 2.68 0 1.36 0 0 Z M-4 11 C-5.29042763 13.26601865 -5.29042763 13.26601865 -6 16 C-4.73647948 18.32511472 -4.73647948 18.32511472 -3 20 C-0.13275314 19.42655063 0.8614515 19.1385485 3 17 C2.71016731 13.69316534 2.71016731 13.69316534 1 11 C-0.66617115 10.95936168 -2.33388095 10.957279 -4 11 Z " fill="#000000" transform="translate(464,80)"></path><path d="M0 0 C2.44936524 2.72151693 2.41841365 5.30960581 2.6875 8.875 C-3.2525 9.37 -3.2525 9.37 -9.3125 9.875 C-8.28226543 11.12749952 -8.28226543 11.12749952 -6.0625 11 C-3.37724086 10.87794277 -0.92891797 10.47303839 1.6875 9.875 C1.6875 10.865 1.6875 11.855 1.6875 12.875 C-0.98401256 14.99649527 -2.93144879 15.81943003 -6.3125 16.3125 C-10.17595665 15.74907924 -11.70693424 14.7783447 -14.3125 11.875 C-15.45259771 7.95591414 -15.72138632 5.84341496 -14.125 2.0625 C-9.94520348 -2.982082 -5.77056039 -2.80729965 0 0 Z M-9 3.375 C-9.433125 3.87 -9.86625 4.365 -10.3125 4.875 C-7.6725 4.875 -5.0325 4.875 -2.3125 4.875 C-2.9725 3.885 -3.6325 2.895 -4.3125 1.875 C-7.31509517 1.54281808 -7.31509517 1.54281808 -9 3.375 Z " fill="#000000" transform="translate(195.3125,88.125)"></path><path d="M0 0 C2.375 1.6875 2.375 1.6875 4 4 C4.25 7.25 4.25 7.25 4 10 C-1.445 10.495 -1.445 10.495 -7 11 C-2.65055731 11.86988854 -1.02871475 12.03595522 3 11 C3 12.32 3 13.64 3 15 C-0.41748222 17.10306598 -3.02085525 17.40603518 -7 17 C-11.63235294 14.73529412 -11.63235294 14.73529412 -13 12 C-13.58203713 4.78273959 -13.58203713 4.78273959 -11.1875 1.5625 C-7.23814633 -1.25846691 -4.58583056 -1.21664892 0 0 Z M-6 3 C-6.99 4.485 -6.99 4.485 -8 6 C-5.69 6 -3.38 6 -1 6 C-1.66 5.01 -2.32 4.02 -3 3 C-3.99 3 -4.98 3 -6 3 Z " fill="#000000" transform="translate(314,87)"></path><path d="M0 0 C2.375 1.6875 2.375 1.6875 4 4 C4.25 7.25 4.25 7.25 4 10 C-1.445 10.495 -1.445 10.495 -7 11 C-2.65055731 11.86988854 -1.02871475 12.03595522 3 11 C3 12.32 3 13.64 3 15 C-0.41748222 17.10306598 -3.02085525 17.40603518 -7 17 C-11.63235294 14.73529412 -11.63235294 14.73529412 -13 12 C-13.58203713 4.78273959 -13.58203713 4.78273959 -11.1875 1.5625 C-7.23814633 -1.25846691 -4.58583056 -1.21664892 0 0 Z M-6 3 C-6.99 4.485 -6.99 4.485 -8 6 C-5.69 6 -3.38 6 -1 6 C-1.66 5.01 -2.32 4.02 -3 3 C-3.99 3 -4.98 3 -6 3 Z " fill="#000000" transform="translate(260,87)"></path><path d="M0 0 C2.75357293 2.08378492 3.8111953 3.37549215 4.8125 6.6875 C4.874375 7.450625 4.93625 8.21375 5 9 C3.26043342 10.73956658 0.8063378 10.37190386 -1.5625 10.5625 C-2.57441406 10.64628906 -3.58632813 10.73007813 -4.62890625 10.81640625 C-5.41136719 10.87699219 -6.19382812 10.93757813 -7 11 C-5.96976543 12.25249952 -5.96976543 12.25249952 -3.75 12.125 C-1.06474086 12.00294277 1.38358203 11.59803839 4 11 C3.75 12.875 3.75 12.875 3 15 C-0.16857001 17.3470889 -3.15724779 17.47054109 -7 17 C-9.69990662 15.20006226 -11.5418865 13.916227 -13 11 C-13.42576871 7.16808162 -13.30321315 5.47050317 -11.1875 2.1875 C-7.53637316 -1.46362684 -4.79503135 -1.27215117 0 0 Z M-6 3 C-6.99 4.485 -6.99 4.485 -8 6 C-5.36 6 -2.72 6 0 6 C-1.31201173 4.43750191 -1.31201173 4.43750191 -3 3 C-3.99 3 -4.98 3 -6 3 Z " fill="#000000" transform="translate(364,87)"></path><path d="M0 0 C2.29141286 -0.05384521 4.58318188 -0.09272087 6.875 -0.125 C8.78925781 -0.15980469 8.78925781 -0.15980469 10.7421875 -0.1953125 C14 0 14 0 16 2 C16.1953125 4.6015625 16.1953125 4.6015625 16.125 7.625 C16.10695312 8.62789062 16.08890625 9.63078125 16.0703125 10.6640625 C16.04710937 11.43492188 16.02390625 12.20578125 16 13 C16.66 13 17.32 13 18 13 C18 13.99 18 14.98 18 16 C16.02 16 14.04 16 12 16 C11.67 12.37 11.34 8.74 11 5 C10.01 5 9.02 5 8 5 C7.67 7.64 7.34 10.28 7 13 C7.66 13 8.32 13 9 13 C9 13.99 9 14.98 9 16 C6.03 16 3.06 16 0 16 C0 15.01 0 14.02 0 13 C0.66 13 1.32 13 2 13 C2 10.03 2 7.06 2 4 C1.34 4 0.68 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(152,87)"></path><path d="M0 0 C2.47923801 -0.02685095 4.9581884 -0.04676547 7.4375 -0.0625 C8.14455078 -0.07087891 8.85160156 -0.07925781 9.58007812 -0.08789062 C11.38693559 -0.09653588 13.19387603 -0.05220011 15 0 C16 1 16 1 16.09765625 3.72265625 C16.08605469 4.82480469 16.07445312 5.92695312 16.0625 7.0625 C16.05347656 8.16722656 16.04445313 9.27195312 16.03515625 10.41015625 C16.02355469 11.26480469 16.01195312 12.11945313 16 13 C16.99 13 17.98 13 19 13 C19 13.99 19 14.98 19 16 C16.69 16 14.38 16 12 16 C12 12.04 12 8.08 12 4 C10.68 4.33 9.36 4.66 8 5 C7.67 7.64 7.34 10.28 7 13 C7.99 13 8.98 13 10 13 C10 13.99 10 14.98 10 16 C6.7 16 3.4 16 0 16 C0 15.01 0 14.02 0 13 C0.99 13 1.98 13 3 13 C3 10.03 3 7.06 3 4 C2.01 4 1.02 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(265,87)"></path><path d="M0 0 C0.91007812 0.10183594 1.82015625 0.20367187 2.7578125 0.30859375 C3.45648438 0.39238281 4.15515625 0.47617188 4.875 0.5625 C4.875 2.8725 4.875 5.1825 4.875 7.5625 C3.225 7.2325 1.575 6.9025 -0.125 6.5625 C-0.125 5.9025 -0.125 5.2425 -0.125 4.5625 C-1.775 4.8925 -3.425 5.2225 -5.125 5.5625 C-5.81659401 7.40975052 -5.81659401 7.40975052 -6.125 9.5625 C-5.135 11.0475 -5.135 11.0475 -4.125 12.5625 C-3.5475 12.418125 -2.97 12.27375 -2.375 12.125 C-0.29166667 11.60416667 1.79166667 11.08333333 3.875 10.5625 C4.205 11.5525 4.535 12.5425 4.875 13.5625 C2.30102018 16.2534789 0.84661926 17.43295077 -2.9375 17.9375 C-6.125 17.5625 -6.125 17.5625 -9 15.5 C-11.125 12.5625 -11.125 12.5625 -11.6875 9.0625 C-11.04377781 5.05711748 -9.96554174 3.40304174 -7.125 0.5625 C-4.50184968 -0.74907516 -2.89466564 -0.33399988 0 0 Z " fill="#000000" transform="translate(295.125,86.4375)"></path><path d="M0 0 C2.97 0 5.94 0 9 0 C9 1.32 9 2.64 9 4 C8.34 4 7.68 4 7 4 C7 9.28 7 14.56 7 20 C7.66 20 8.32 20 9 20 C9 20.99 9 21.98 9 23 C6.03 23 3.06 23 0 23 C0 22.01 0 21.02 0 20 C0.66 20 1.32 20 2 20 C2 14.72 2 9.44 2 4 C1.34 4 0.68 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(142,80)"></path><path d="M0 0 C0 1.65 0 3.3 0 5 C0.66 5 1.32 5 2 5 C2 6.32 2 7.64 2 9 C1.34 9 0.68 9 0 9 C0.66264086 15.06264222 0.66264086 15.06264222 2 21 C0.1875 21.6875 0.1875 21.6875 -2 22 C-3.625 20.84375 -3.625 20.84375 -5 19 C-5.29296875 16.51953125 -5.29296875 16.51953125 -5.1875 13.8125 C-5.16042969 12.91144531 -5.13335937 12.01039062 -5.10546875 11.08203125 C-5.07066406 10.39496094 -5.03585938 9.70789063 -5 9 C-5.66 9 -6.32 9 -7 9 C-7 7.68 -7 6.36 -7 5 C-6.34 5 -5.68 5 -5 5 C-5 4.01 -5 3.02 -5 2 C-2 0 -2 0 0 0 Z " fill="#000000" transform="translate(177,82)"></path><path d="M0 0 C2.31 0 4.62 0 7 0 C7 6.6 7 13.2 7 20 C7.66 20 8.32 20 9 20 C9 20.99 9 21.98 9 23 C6.03 23 3.06 23 0 23 C0 22.01 0 21.02 0 20 C0.99 20 1.98 20 3 20 C3 14.72 3 9.44 3 4 C2.01 4 1.02 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(369,80)"></path><path d="M0 0 C2.31 0 4.62 0 7 0 C7 4.29 7 8.58 7 13 C7.66 13 8.32 13 9 13 C9 13.99 9 14.98 9 16 C6.03 16 3.06 16 0 16 C0 15.01 0 14.02 0 13 C0.66 13 1.32 13 2 13 C2 10.03 2 7.06 2 4 C1.34 4 0.68 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(379,87)"></path><path d="M0 0 C1.98 0 3.96 0 6 0 C6 4.29 6 8.58 6 13 C6.99 13 7.98 13 9 13 C9 13.99 9 14.98 9 16 C6.03 16 3.06 16 0 16 C0 15.01 0 14.02 0 13 C0.66 13 1.32 13 2 13 C2 10.03 2 7.06 2 4 C1.34 4 0.68 4 0 4 C0 2.68 0 1.36 0 0 Z " fill="#000000" transform="translate(218,87)"></path><path d="M0 0 C1.4540625 0.0309375 1.4540625 0.0309375 2.9375 0.0625 C4.0625 1.8125 4.0625 1.8125 4.9375 4.0625 C4.0625 6.3125 4.0625 6.3125 2.9375 8.0625 C0.93795254 8.10504356 -1.06291636 8.10330783 -3.0625 8.0625 C-4.0625 7.0625 -4.0625 7.0625 -4.1875 4.0625 C-4.02164894 0.08207447 -4.02164894 0.08207447 0 0 Z " fill="#000000" transform="translate(302.0625,7.9375)"></path><path d="M0 0 C0.66 0.33 1.32 0.66 2 1 C-1.3 4.3 -4.6 7.6 -8 11 C-8.66 10.67 -9.32 10.34 -10 10 C-8.90033225 8.70450101 -7.79508199 7.41373929 -6.6875 6.125 C-6.07261719 5.40570312 -5.45773438 4.68640625 -4.82421875 3.9453125 C-3 2 -3 2 0 0 Z " fill="#D48465" transform="translate(52,21)"></path><path d="M0 0 C0 3.75832067 -0.93607224 4.3698162 -3.4375 7.0625 C-6.02679823 9.8184536 -6.02679823 9.8184536 -8 13 C-8.66 12.67 -9.32 12.34 -10 12 C-9.09232898 10.55680308 -8.17343894 9.12065894 -7.25 7.6875 C-6.48429687 6.48673828 -6.48429687 6.48673828 -5.703125 5.26171875 C-3.99722239 2.99631139 -2.34191855 1.57315833 0 0 Z " fill="#2D7B84" transform="translate(32,55)"></path><path d="M0 0 C1.98 0.495 1.98 0.495 4 1 C3.67 2.32 3.34 3.64 3 5 C1.68 4.67 0.36 4.34 -1 4 C-0.67 2.68 -0.34 1.36 0 0 Z " fill="#000000" transform="translate(382,80)"></path><path d="M0 0 C1.32 0 2.64 0 4 0 C4.33 0.99 4.66 1.98 5 3 C3.02 3.99 3.02 3.99 1 5 C0.67 3.35 0.34 1.7 0 0 Z " fill="#000000" transform="translate(220,80)"></path>', 40)
  ]));
}
const DirectorIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$2]]);
const SearchIcon_vue_vue_type_style_index_0_scoped_6d74faa9_lang = "";
const _sfc_main$2 = {
  name: "SearchIcon",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#FFF5EC"
    }
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M11.4941 11.4941C11.8195 11.1686 12.3472 11.1686 12.6726 11.4941L17.2559 16.0774C17.5814 16.4028 17.5814 16.9305 17.2559 17.2559C16.9305 17.5814 16.4028 17.5814 16.0774 17.2559L11.4941 12.6726C11.1686 12.3472 11.1686 11.8195 11.4941 11.4941Z",
      fill: "white"
    }, null, -1),
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.33333 4.16667C6.03215 4.16667 4.16667 6.03215 4.16667 8.33333C4.16667 10.6345 6.03215 12.5 8.33333 12.5C10.6345 12.5 12.5 10.6345 12.5 8.33333C12.5 6.03215 10.6345 4.16667 8.33333 4.16667ZM2.5 8.33333C2.5 5.11167 5.11167 2.5 8.33333 2.5C11.555 2.5 14.1667 5.11167 14.1667 8.33333C14.1667 11.555 11.555 14.1667 8.33333 14.1667C5.11167 14.1667 2.5 11.555 2.5 8.33333Z",
      fill: "white"
    }, null, -1)
  ]), 2);
}
const SearchIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$1], ["__scopeId", "data-v-6d74faa9"]]);
const Query_vue_vue_type_style_index_0_scoped_efe42b3d_lang = "";
const _sfc_main$1 = {
  name: "FileUpload",
  props: {
    className: {
      type: String,
      default: ""
    },
    fill: {
      type: String,
      default: "#FFF5EC"
    }
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("svg", {
    width: "20",
    height: "20",
    viewBox: "0 0 20 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    class: vue.normalizeClass($props.className)
  }, _cache[0] || (_cache[0] = [
    vue.createElementVNode("path", {
      "fill-rule": "evenodd",
      "clip-rule": "evenodd",
      d: "M8.63099 2.5H11.6963C12.4477 2.49999 13.0539 2.49999 13.5472 2.53365C14.0545 2.56826 14.5031 2.64123 14.9278 2.81717C15.9488 3.24006 16.7599 4.0512 17.1828 5.07215C17.3588 5.4969 17.4317 5.94547 17.4663 6.45276C17.5 6.94609 17.5 7.55227 17.5 8.30373V8.36294C17.5 9.1144 17.5 9.72057 17.4663 10.2139C17.4317 10.7212 17.3588 11.1698 17.1828 11.5945C16.7599 12.6155 15.9488 13.4266 14.9278 13.8495C14.5031 14.0254 14.0545 14.0984 13.5472 14.133C13.0539 14.1667 12.4477 14.1667 11.6963 14.1667H9.52381C9.14082 14.1667 9.06446 14.1705 9.00217 14.1831C8.85702 14.2123 8.72229 14.2797 8.61182 14.3782C8.56441 14.4205 8.51551 14.4793 8.28571 14.7857L8.26776 14.8097C7.76299 15.4827 7.36075 16.019 7.0316 16.4068C6.7222 16.7713 6.37247 17.1378 5.95507 17.3104C4.80656 17.7852 3.48366 17.3442 2.84972 16.2753C2.61933 15.8868 2.55949 15.3837 2.53066 14.9065C2.49999 14.3988 2.5 13.7284 2.5 12.8871V8.63099C2.49999 7.72784 2.49999 6.99938 2.54818 6.40948C2.59781 5.80211 2.70265 5.26862 2.95414 4.77504C3.35361 3.99103 3.99103 3.35361 4.77504 2.95414C5.26862 2.70265 5.80211 2.59781 6.40948 2.54818C6.99938 2.49999 7.72784 2.49999 8.63099 2.5ZM6.5452 4.20931C6.04089 4.25052 5.75115 4.32733 5.53169 4.43915C5.06129 4.67883 4.67883 5.06129 4.43915 5.53169C4.32733 5.75115 4.25052 6.04089 4.20931 6.5452C4.16732 7.05924 4.16667 7.7195 4.16667 8.66667V12.8571C4.16667 13.7351 4.16704 14.3548 4.19429 14.806C4.20778 15.0292 4.22663 15.1861 4.24878 15.2967C4.26756 15.3904 4.28393 15.4255 4.28484 15.4278C4.49624 15.7812 4.93427 15.9272 5.31547 15.7713C5.31754 15.7701 5.3517 15.7518 5.42297 15.6881C5.50703 15.6129 5.61626 15.4987 5.76098 15.3282C6.05352 14.9836 6.42561 14.4881 6.95238 13.7857C6.96446 13.7696 6.97642 13.7536 6.98829 13.7378C7.1619 13.5059 7.31445 13.3022 7.50212 13.1347C7.83352 12.839 8.23773 12.6369 8.67316 12.5492C8.91976 12.4995 9.17428 12.4997 9.46394 12.5C9.48373 12.5 9.50368 12.5 9.52381 12.5H11.6667C12.4546 12.5 13.0039 12.4995 13.4338 12.4702C13.8562 12.4414 14.1022 12.3875 14.29 12.3097C14.9026 12.056 15.3893 11.5693 15.643 10.9567C15.7208 10.7689 15.7747 10.5229 15.8035 10.1005C15.8329 9.67055 15.8333 9.1213 15.8333 8.33333C15.8333 7.54536 15.8329 6.99612 15.8035 6.56621C15.7747 6.14378 15.7208 5.89778 15.643 5.70996C15.3893 5.09739 14.9026 4.6107 14.29 4.35697C14.1022 4.27917 13.8562 4.22527 13.4338 4.19645C13.0039 4.16712 12.4546 4.16667 11.6667 4.16667H8.66667C7.7195 4.16667 7.05924 4.16732 6.5452 4.20931Z",
      fill: "white"
    }, null, -1),
    vue.createElementVNode("path", {
      d: "M6.66665 5.83334C6.20641 5.83334 5.83331 6.20644 5.83331 6.66668C5.83331 7.12691 6.20641 7.50001 6.66665 7.50001H13.3333C13.7936 7.50001 14.1666 7.12691 14.1666 6.66668C14.1666 6.20644 13.7936 5.83334 13.3333 5.83334H6.66665Z",
      fill: "white"
    }, null, -1),
    vue.createElementVNode("path", {
      d: "M6.66665 9.16668C6.20641 9.16668 5.83331 9.53977 5.83331 10C5.83331 10.4602 6.20641 10.8333 6.66665 10.8333H9.16665C9.62688 10.8333 9.99998 10.4602 9.99998 10C9.99998 9.53977 9.62688 9.16668 9.16665 9.16668H6.66665Z",
      fill: "white"
    }, null, -1)
  ]), 2);
}
const QueryIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-efe42b3d"]]);
const ChatInterface_vue_vue_type_style_index_0_lang = "";
const _hoisted_1 = { class: "vdb-c-flex vdb-c-h-full vdb-c-w-full" };
const _hoisted_2 = { class: "vdb-c-flex vdb-c-flex-1 vdb-c-flex-col" };
const _hoisted_3 = { class: "vdb-c-relative vdb-c-flex-1 vdb-c-bg-white vdb-c-shadow-2 vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in-out md:vdb-c-w-full" };
const _hoisted_4 = { class: "vdb-c-flex vdb-c-items-center vdb-c-justify-center vdb-c-pt-24 lg:vdb-c-hidden" };
const _hoisted_5 = { class: "vdb-c-chat-parent vdb-c-relative vdb-c-overflow-hidden" };
const _hoisted_6 = { key: 0 };
const _hoisted_7 = {
  key: 0,
  class: "vdb-c-w-full vdb-c-p-16 vdb-c-px-30"
};
const _hoisted_8 = { class: "vdb-c-flex vdb-c-items-center vdb-c-gap-8 vdb-c-border-b vdb-c-border-roy vdb-c-py-12 vdb-c-text-lg vdb-c-text-black" };
const _hoisted_9 = { class: "vdb-c-flex vdb-c-font-bold" };
const _hoisted_10 = {
  key: 1,
  class: "vdb-c-inline-block vdb-c-h-20 vdb-c-w-100 vdb-c-animate-pulse vdb-c-rounded vdb-c-bg-roy"
};
const _sfc_main = {
  __name: "ChatInterface",
  props: {
    chatInputPlaceholder: {
      type: String,
      default: "Ask Agent"
    },
    customChatHook: {
      type: Function,
      default: null
    },
    chatHookConfig: {
      type: Object,
      default: () => ({
        socketUrl: "http://127.0.0.1:8000/chat",
        httpUrl: "http://127.0.0.1:8000",
        debug: false
      })
    },
    size: {
      type: String,
      default: "full",
      validator: (value2) => ["full", "embedded"].includes(value2)
    },
    headerConfig: {
      type: Object,
      default: () => ({
        uploadButton: true
      })
    },
    sidebarConfig: {
      type: Object,
      default: () => ({
        icon: DirectorIcon,
        links: [
          {
            href: "https://www.youtube.com/playlist?list=PLhxAMFLSSK039xl1UgcZmoFLnb-qNRYQw",
            text: "Watch Demos",
            icon: ExternalLink
          },
          {
            href: "https://console.videodb.io",
            text: "VideoDB Console"
          }
        ]
      })
    },
    defaultScreenConfig: {
      type: Object,
      default: () => ({
        actionCardQueries: null,
        demoVideos: [
          {
            id: 1,
            external_url: "https://www.youtube.com/watch?v=Dncn_0RWrro",
            thumbnail_url: "https://raw.githubusercontent.com/video-db/videodb-cookbook-assets/main/images/thumbnail_automated.png"
          },
          {
            id: 2,
            external_url: "https://www.youtube.com/watch?v=bct8Vvl2acU",
            thumbnail_url: "https://raw.githubusercontent.com/video-db/videodb-cookbook-assets/main/images/thumbnail_gen_ai.png"
          },
          {
            id: 3,
            external_url: "https://www.youtube.com/watch?v=KcoA0eio1Zo",
            thumbnail_url: "https://raw.githubusercontent.com/video-db/videodb-cookbook-assets/main/images/thumbnail_profanity.png"
          },
          {
            id: 4,
            external_url: "https://www.youtube.com/watch?v=7J7oBIv4eOY",
            thumbnail_url: "https://raw.githubusercontent.com/video-db/videodb-cookbook-assets/main/images/thumbnail_keyword.png"
          }
        ]
      })
    }
  },
  emits: [],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const sidebarRef = vue.ref(null);
    const chatInputRef = vue.ref(null);
    const uploadNotificationsRef = vue.ref(null);
    const showCollectionView = vue.ref(false);
    const taggedAgent = vue.ref([]);
    const useChatHook = props.customChatHook || useVideoDBAgent;
    const {
      configStatus,
      sessionId,
      collectionId,
      videoId,
      collections,
      sessions,
      agents,
      activeCollectionData,
      activeCollectionVideos,
      activeVideoData,
      addMessage,
      deleteSession,
      conversations,
      loadSession,
      uploadMedia,
      refetchCollectionVideos
    } = useChatHook(props.chatHookConfig);
    const { chatInput, setChatInput, messageHandlers, registerMessageHandler } = useChatInterface();
    registerMessageHandler("video", _sfc_main$6);
    registerMessageHandler("videos", _sfc_main$5);
    registerMessageHandler("text", _sfc_main$H);
    registerMessageHandler("search_results", _sfc_main$7);
    registerMessageHandler("image", _sfc_main$4);
    const isStaticPage = vue.ref(false);
    const chatWindow = vue.ref(null);
    const isSetupComplete = vue.computed(() => {
      return typeof configStatus.value === "object" && configStatus.value !== null && Object.values(configStatus.value).every((value2) => value2 === true);
    });
    const collectionName = vue.computed(() => {
      var _a;
      return (_a = activeCollectionData.value) == null ? void 0 : _a.name;
    });
    const isFreshUser = vue.computed(() => {
      if (collections.value && activeCollectionVideos.value) {
        return collections.value.length < 2 && activeCollectionVideos.value.length < 1;
      }
      return false;
    });
    const chatLoading = vue.computed(
      () => Object.values(conversations).some(
        (conv) => Object.values(conv).some(
          (content) => content.status === "progress" || content.clientLoading
        )
      )
    );
    const dynamicActionCards = vue.computed(() => {
      var _a;
      return props.defaultScreenConfig.actionCardQueries || (!isFreshUser.value && activeCollectionData.value && ((_a = activeCollectionVideos == null ? void 0 : activeCollectionVideos.value) == null ? void 0 : _a.length) > 0 ? [
        {
          component: UploadVideoQueryCard,
          content: "Upload <a href='https://www.youtube.com/watch?v=FgrO9ADPZSA' target='_blank'>https://youtu.be/FgrO9ADPZSA</a> and generate a bullet point summary.",
          type: "primary",
          action: "chat",
          icon: QueryIcon
        },
        {
          content: "What are the pre-built agents I can use right now?",
          type: "primary",
          action: "chat"
        },
        {
          content: "Categorize all videos in this collection",
          type: "primary",
          action: "chat",
          icon: CollectionIcon
        }
      ] : [
        {
          component: UploadVideoQueryCard,
          content: "Upload <a href='https://www.youtube.com/watch?v=FgrO9ADPZSA' target='_blank'>https://youtu.be/FgrO9ADPZSA</a> and generate a bullet point summary.",
          type: "primary",
          action: "chat",
          icon: QueryIcon
        },
        {
          content: "What are the pre-built agents I can use right now?",
          type: "primary",
          action: "chat"
        },
        {
          content: "Show me how the search agent works? ",
          type: "primary",
          action: "chat",
          icon: SearchIcon
        }
      ]);
    });
    const scrollToBottom = () => {
      const element = chatWindow.value;
      if (!element)
        return;
      vue.nextTick(() => {
        element.scroll({ top: element.scrollHeight - 50, behavior: "smooth" });
      });
    };
    vue.watch(chatLoading, (val) => {
      if (val) {
        scrollToBottom();
      }
    });
    const createNewSession = () => {
      videoId.value = null;
      showCollectionView.value = false;
      taggedAgent.value = [];
      loadSession();
    };
    const handleSessionClick = (sessionId2) => {
      showCollectionView.value = false;
      loadSession(sessionId2);
    };
    const handleCollectionClick = (_collectionId) => {
      collectionId.value = _collectionId;
      videoId.value = null;
      showCollectionView.value = false;
      loadSession();
    };
    const showDeleteDialog = vue.ref(false);
    const sessionToDelete = vue.ref(null);
    const showDeleteSessionDialog = (_sessionId) => {
      sessionToDelete.value = _sessionId;
      showDeleteDialog.value = true;
    };
    const confirmDeleteSession = () => {
      if (sessionToDelete.value === sessionId.value) {
        createNewSession();
      }
      deleteSession(sessionToDelete.value);
      showDeleteDialog.value = false;
      sessionToDelete.value = null;
    };
    const showUploadDialog = vue.ref(false);
    const handleUpload = async (uploadData) => {
      showUploadDialog.value = false;
      let name = "Media";
      if (uploadData.sourceType === "file") {
        name = uploadData.source.name;
      } else {
        name = uploadData.source.url;
      }
      const uploadId = uploadNotificationsRef.value.addUpload(name);
      try {
        const res = await uploadMedia(uploadData);
        if (res.ok) {
          uploadNotificationsRef.value.updateUploadStatus(uploadId, "success");
          refetchCollectionVideos();
        } else {
          uploadNotificationsRef.value.updateUploadStatus(uploadId, "error");
        }
      } catch (e) {
        uploadNotificationsRef.value.updateUploadStatus(uploadId, "error");
      }
    };
    const handleQueryCardClick = (query) => {
      if (query.action === "show-collection") {
        showCollectionView.value = true;
        chatInput.value = "";
      } else if (query.action === "chat") {
        chatInput.value = "";
        handleAddMessage(query.content);
      }
    };
    const handleViewAllVideosClick = (redirectTo = "") => {
      if (redirectTo.includes("youtube.com")) {
        window.open(redirectTo, "_blank");
      } else {
        showCollectionView.value = true;
        chatInput.value = "";
      }
    };
    const handleTagAgent = (agent, addToInput = true) => {
      const agentName = agent.name || agent;
      if (agentName) {
        taggedAgent.value.push(agentName);
        if (addToInput) {
          chatInput.value = chatInput.value.trim() === "" ? `@${agentName}` : `${chatInput.value} @${agentName}`;
          chatInputRef.value.focus();
        }
      }
    };
    const handleVideoClick = (video) => {
      if (video.external_url) {
        window.open(video.external_url, "_blank");
      } else {
        videoId.value = video.id;
        handleAddMessage(`@stream_video ${video.name}`);
      }
    };
    const handleAddMessage = (content) => {
      if (!sessionId.value) {
        loadSession();
      }
      addMessage({
        content: [{ type: "text", text: content }],
        agents: taggedAgent.value
      });
      taggedAgent.value = [];
    };
    __expose({
      chatInput,
      chatInputRef,
      conversations,
      messageHandlers,
      addMessage,
      loadSession,
      activeCollectionData,
      activeCollectionVideos,
      createNewSession,
      setChatInput,
      registerMessageHandler,
      uploadMedia
    });
    vue.provide("videodb-chat", {
      chatInput,
      chatLoading,
      conversations,
      messageHandlers,
      addMessage,
      loadSession,
      activeCollectionData,
      activeCollectionVideos,
      setChatInput,
      registerMessageHandler,
      uploadMedia
    });
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e;
      return vue.openBlock(), vue.createElementBlock("section", {
        class: vue.normalizeClass([{
          "vdb-c-fixed": __props.size === "full"
        }, "vdb-c-inset-0 vdb-c-z-50 vdb-c-flex vdb-c-h-full vdb-c-w-full vdb-c-flex-col vdb-c-items-center vdb-c-justify-center vdb-c-overflow-y-hidden vdb-c-bg-black-64"]),
        tabindex: "0"
      }, [
        vue.createElementVNode("div", _hoisted_1, [
          vue.createVNode(_sfc_main$g, {
            ref_key: "sidebarRef",
            ref: sidebarRef,
            status: vue.unref(configStatus) !== null && isSetupComplete.value ? "active" : "inactive",
            "new-session-button-status": Object.keys(vue.unref(conversations)).length === 0 && !showCollectionView.value ? "inactive" : "active",
            config: __props.sidebarConfig,
            "show-selected-collection": Object.keys(vue.unref(conversations)).length === 0 && !showCollectionView.value,
            "initial-sessions-open": !isFreshUser.value,
            "initial-explore-agents-open": !isFreshUser.value,
            "initial-collections-open": !isFreshUser.value,
            "selected-session": vue.unref(sessionId),
            "add-dummy-session": Object.keys(vue.unref(conversations)).length === 0,
            "selected-collection": vue.unref(collectionId),
            agents: vue.unref(agents),
            sessions: vue.unref(sessions),
            collections: vue.unref(collections),
            onCreateNewSession: createNewSession,
            onDeleteSession: showDeleteSessionDialog,
            onAgentClick: _cache[0] || (_cache[0] = ($event) => {
              if (!chatLoading.value) {
                handleTagAgent($event, false);
                handleAddMessage(`@${$event.name} `);
              }
            }),
            onSessionClick: handleSessionClick,
            onCollectionClick: handleCollectionClick
          }, null, 8, ["status", "new-session-button-status", "config", "show-selected-collection", "initial-sessions-open", "initial-explore-agents-open", "initial-collections-open", "selected-session", "add-dummy-session", "selected-collection", "agents", "sessions", "collections"]),
          vue.createElementVNode("div", _hoisted_2, [
            vue.createElementVNode("div", _hoisted_3, [
              vue.createElementVNode("div", _hoisted_4, [
                vue.createVNode(DirectorIcon)
              ]),
              vue.createElementVNode("div", _hoisted_5, [
                vue.unref(configStatus) === null ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_6)) : !isSetupComplete.value ? (vue.openBlock(), vue.createBlock(_sfc_main$m, {
                  key: 1,
                  "config-status": vue.unref(configStatus)
                }, null, 8, ["config-status"])) : isSetupComplete.value ? (vue.openBlock(), vue.createElementBlock("section", {
                  key: 2,
                  ref_key: "chatWindow",
                  ref: chatWindow,
                  class: "vdb-c-absolute vdb-c-left-0 vdb-c-top-0 vdb-c-flex vdb-c-h-full vdb-c-max-h-full vdb-c-w-full vdb-c-flex-col vdb-c-items-center vdb-c-overflow-x-auto vdb-c-overflow-y-auto"
                }, [
                  Object.keys(vue.unref(conversations)).length === 0 ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                    showCollectionView.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_7, [
                      vue.createElementVNode("div", _hoisted_8, [
                        vue.createElementVNode("span", _hoisted_9, [
                          collectionName.value ? (vue.openBlock(), vue.createElementBlock("span", {
                            key: 0,
                            class: "vdb-c-cursor-pointer",
                            onClick: _cache[1] || (_cache[1] = ($event) => videoId.value = null)
                          }, vue.toDisplayString(collectionName.value), 1)) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_10))
                        ])
                      ]),
                      showCollectionView.value ? (vue.openBlock(), vue.createBlock(_sfc_main$s, {
                        key: 0,
                        "collection-id": vue.unref(collectionId),
                        "collection-data": vue.unref(activeCollectionData),
                        "collection-videos": vue.unref(activeCollectionVideos),
                        onVideoClick: handleVideoClick,
                        class: "vdb-c-transition-opacity vdb-c-duration-300 vdb-c-ease-in-out"
                      }, null, 8, ["collection-id", "collection-data", "collection-videos"])) : vue.createCommentVNode("", true)
                    ])) : (vue.openBlock(), vue.createBlock(DefaultScreen, {
                      key: 1,
                      class: "vdb-c-transition-opacity vdb-c-duration-300 vdb-c-ease-in-out",
                      "header-config": __props.headerConfig,
                      "collection-data": vue.unref(activeCollectionData),
                      "action-card-queries": dynamicActionCards.value,
                      "show-demo-videos": isFreshUser.value || vue.unref(activeCollectionData) && ((_a = vue.unref(activeCollectionVideos)) == null ? void 0 : _a.length) === 0,
                      "preview-videos": isFreshUser.value || vue.unref(activeCollectionData) && ((_b = vue.unref(activeCollectionVideos)) == null ? void 0 : _b.length) === 0 ? (_c = __props.defaultScreenConfig.demoVideos) == null ? void 0 : _c.slice(0, 4) : (_d = vue.unref(activeCollectionVideos)) == null ? void 0 : _d.slice(0, 4),
                      onQueryCardClick: handleQueryCardClick,
                      onVideoClick: handleVideoClick,
                      onUploadButtonClick: _cache[2] || (_cache[2] = ($event) => showUploadDialog.value = true),
                      onViewAllVideosClick: handleViewAllVideosClick
                    }, null, 8, ["header-config", "collection-data", "action-card-queries", "show-demo-videos", "preview-videos"]))
                  ], 64)) : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(Object.keys(vue.unref(conversations)), (key, i) => {
                    return vue.openBlock(), vue.createBlock(_sfc_main$D, {
                      key,
                      conversation: vue.unref(conversations)[key],
                      "search-term": vue.unref(chatInput),
                      "is-static-page": isStaticPage.value,
                      "is-last-conv": i === Object.keys(vue.unref(conversations)).length - 1,
                      class: "vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in-out"
                    }, null, 8, ["conversation", "search-term", "is-static-page", "is-last-conv"]);
                  }), 128))
                ], 512)) : vue.createCommentVNode("", true),
                vue.createVNode(UploadNotifications, {
                  ref_key: "uploadNotificationsRef",
                  ref: uploadNotificationsRef
                }, null, 512)
              ]),
              vue.createElementVNode("div", {
                class: vue.normalizeClass(["vdb-c-chat-input-container vdb-c-relative vdb-c-transition-all vdb-c-duration-300 vdb-c-ease-in-out", {
                  "vdb-c-pointer-events-none vdb-c-opacity-20": !(vue.unref(configStatus) !== null && isSetupComplete.value)
                }])
              }, [
                vue.createVNode(_sfc_main$M, {
                  ref_key: "chatInputRef",
                  ref: chatInputRef,
                  agents: vue.unref(agents),
                  "input-disabled": chatLoading.value,
                  placeholder: __props.chatInputPlaceholder,
                  "context-data": vue.unref(activeVideoData) || vue.unref(activeCollectionData),
                  onOnSubmit: handleAddMessage,
                  onTagAgent: _cache[3] || (_cache[3] = ($event) => handleTagAgent($event, false))
                }, null, 8, ["agents", "input-disabled", "placeholder", "context-data"])
              ], 2)
            ])
          ])
        ]),
        vue.createVNode(_sfc_main$a, {
          "show-dialog": showDeleteDialog.value,
          onCancelDelete: _cache[4] || (_cache[4] = ($event) => {
            showDeleteDialog.value = false;
            sessionToDelete.value = null;
          }),
          onConfirmDelete: confirmDeleteSession
        }, null, 8, ["show-dialog"]),
        vue.createVNode(_sfc_main$c, {
          "show-upload-dialog": showUploadDialog.value,
          "default-selected-collection-id": (_e = vue.unref(activeCollectionData)) == null ? void 0 : _e.id,
          collections: vue.unref(collections),
          onUpload: handleUpload,
          onCancelUpload: _cache[5] || (_cache[5] = ($event) => showUploadDialog.value = false)
        }, null, 8, ["show-upload-dialog", "default-selected-collection-id", "collections"])
      ], 2);
    };
  }
};
const style = "";
function install(app) {
  app.component("ChatInterface", _sfc_main);
}
exports.ChatInterface = _sfc_main;
exports.ChatMessageContainer = _sfc_main$D;
exports.ChatSearchResults = _sfc_main$7;
exports.ChatVideo = _sfc_main$6;
exports.ChatVideos = _sfc_main$5;
exports.DefaultScreen = DefaultScreen;
exports.ImageHandler = _sfc_main$4;
exports.Sidebar = _sfc_main$g;
exports.TextResponse = _sfc_main$H;
exports.install = install;
exports.useChatInterface = useChatInterface;
exports.useVideoDBChat = useVideoDBChat;
